<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=strawman" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html#syntactic_support_for_private_names" class="toc">Syntactic Support for Private Names</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html#at-names_and_their_declaration" class="toc">&quot;At-Names&quot; and Their Declaration</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html#private_name_declarations" class="toc">Private Name Declarations</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html#backwards_compatibility_considerations" class="toc">Backwards Compatibility Considerations</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html#referencing_and_using_at-names" class="toc">Referencing and Using At-Names</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html#at-names_in_expressions" class="toc">At-Names in Expressions</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html#at-names_in_dot_notation_property_accessors" class="toc">At-Names in Dot Notation Property Accessors</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html#at-names_in_object_literals" class="toc">At-Names in Object Literals</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html#at-names_in_class_definitions" class="toc">At-Names in Class Definitions</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html#other_possible_at-name_features" class="toc">Other Possible At-Name Features</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html#name_declarations_with_explicit_initializers" class="toc">Name Declarations with Explicit Initializers</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html#exportimport_of_name_declarations" class="toc">Export/Import of Name Declarations</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html#class_local_name_declarations" class="toc">Class Local Name Declarations</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html#class_protected_name_declarations" class="toc">Class &quot;Protected&quot; Name Declarations</a></span><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html#scoping_issues_with_protected_properties" class="toc">Scoping Issues with Protected Properties</a></span></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names&amp;do=export_html.html#other_syntactic_approaches_to_private_names" class="toc">Other Syntactic Approaches to Private Names</a></span></li>
</ul>
</li>
</ul>
</div>
</div>

<a name="syntactic_support_for_private_names"></a><h1>Syntactic Support for Private Names</h1>
<div class="level1">

<p>
 This is a proposal for syntactic extensions that make it easier to use <a href="doku.php%3Fid=harmony:private_name_objects.html" class="wikilink1" title="harmony:private_name_objects" onclick="return svchk()" onkeypress="return svchk()">unique and private names</a>.
</p>

</div>
<!-- SECTION [1-182] -->
<a name="at-names_and_their_declaration"></a><h2>&quot;At-Names&quot; and Their Declaration</h2>
<div class="level2">

<p>
 An &ldquo;At-Name&rdquo; is a new form of lexical token that consists of an @ character immediately followed by an <em>IdentifierName</em>:
</p>
<pre class="code ebnf">Token :: 
   ...
   AtName

AtName :: 
   @ IdentifierName 
</pre>
<p>
At-Names are used to identify lexically scoped bindings whose values are always <a href="doku.php%3Fid=harmony:private_name_objects.html" class="wikilink1" title="harmony:private_name_objects" onclick="return svchk()" onkeypress="return svchk()">Name Objects</a>. Such bindings are introduced using new declaration statements. For example: 
</p>
<pre class="code javascript"><span class="kw3">name</span> @foo;  <span class="co1">//declare a lexically scoped At-Name with a new unique name value.</span></pre>
<p>
A name declaration of the above form creates a constant binding in the local scope contour whose value is a newly created <a href="doku.php%3Fid=harmony:private_name_objects.html" class="wikilink1" title="harmony:private_name_objects" onclick="return svchk()" onkeypress="return svchk()">Unique Name Objects</a>. Semantically the above declaration is similar to:
</p>
<pre class="code javascript"><span class="kw2">import</span> <span class="kw3">Name</span> from <span class="st0">"@name"</span>;
<span class="kw2">const</span> __foo = <span class="kw2">new</span> <span class="kw3">Name</span><span class="br0">&#40;</span><span class="kw2">true</span><span class="br0">&#41;</span>;  <span class="co1">// __foo represents an unique identifier that is different from foo</span></pre>
<p>
The static semantics for name declaration are similar to let/const declarations. They have a temporal dead zone and a lexical contour may not contain multiple declarations for a specific At-Name.
</p>

<p>
A name declaration may bind only an At-Name. It is an early error to try to bind a regular identifier in a name name declaration: 
</p>
<pre class="code javascript"><span class="kw3">name</span> foo;  <span class="co1">//this is an early error. Only At-Names are allowed</span></pre>
<p>
For binding purposes, At-Names are distinct from the same <em>IdentifierName</em> without the leading <strong>@</strong>. 
</p>
<pre class="code javascript"><span class="br0">&#123;</span>
   <span class="co1">//these are two distinct declarations that create separate bindings for the At-Name &quot;@foo&quot; and the identifier &quot;foo&quot;.</span>
   <span class="kw3">name</span> @foo;
   <span class="kw2">const</span> foo = <span class="kw2">new</span> <span class="kw3">Name</span><span class="br0">&#40;</span><span class="kw2">true</span><span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre>
<p>
At-Names are not simply identifiers prefixed with a &ldquo;@&rdquo;. They are special binding forms that are handled specially by environment records. At-Names never shadow or conflict with identifier based bindings. At-Names may be declared in the global scope, but they do not create global property objects. Instead they exist (possibly along with modules names) as part of the global environment record that is separate from the global object.
</p>

<p>
Like let/const declarations, a single name declaration may create multiple bindings: 
</p>
<pre class="code javaScript"><span class="kw3">name</span> @foo, @bar, @baz;</pre>
<p>
 Again, only <em>AtNames</em> may occur in such a declaration list.
</p>

</div>
<!-- SECTION [183-2474] -->
<a name="private_name_declarations"></a><h3>Private Name Declarations</h3>
<div class="level3">

<p>
A private declaration of the above form creates a constant binding in the local scope contour whose value is a newly created <a href="doku.php%3Fid=harmony:private_name_objects.html" class="wikilink1" title="harmony:private_name_objects" onclick="return svchk()" onkeypress="return svchk()">Private Name Objects</a>.  A private declaration is just like a name declaration except that the bound value is a private name rather than a unique name: 
</p>
<pre class="code javascript"><span class="kw2">private</span> @secret;  <span class="co1">//declare a lexically scoped At-Name with a private name value.</span></pre>
<p>
Semantically the above declaration is similar to:
</p>
<pre class="code javascript"><span class="kw2">import</span> <span class="kw3">Name</span> from <span class="st0">"@name"</span>;
<span class="kw2">const</span> __secret = <span class="kw2">new</span> <span class="kw3">Name</span><span class="br0">&#40;</span><span class="kw2">false</span><span class="br0">&#41;</span>;  <span class="co1">//__secret represents an unique identifier that is different from &quot;secret&quot;</span></pre>
<p>
Other than for the type of value they create, name declarations and private name declarations are semantically identical. In most places in this strawman, discussions of name declarations apply equally to private name declarations. 
</p>

</div>
<!-- SECTION [2475-3377] -->
<a name="backwards_compatibility_considerations"></a><h3>Backwards Compatibility Considerations</h3>
<div class="level3">

<p>
 Name declarations use a keyword that was not reserved in previous ECMAScript editions. Hence, existing programs may use &ldquo;name&rdquo; as an variable or function name: 
</p>
<pre class="code javascript"><span class="kw2">var</span> <span class="kw3">name</span>;
<span class="kw3">name</span> = <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw3">alert</span><span class="br0">&#40;</span><span class="st0">'name'</span><span class="br0">&#41;</span><span class="br0">&#125;</span>
<span class="kw3">name</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;</pre>
<p>
With the addition of name declarations, &ldquo;name&rdquo; would be a context sensitive keyword. It only interpreted as a keyword when it appears as the first token in a <em>Declaration</em> context and is immediately followed by an <em>AtName</em>. Single-token look-ahead is adequate to disambiguate valid name declarations or any other uses of the identifier &ldquo;name&rdquo;.
</p>

<p>
Because the second token of a name declaration must be an <em>AtName</em>, there is no need to restrict line terminators after the contextual &ldquo;name&rdquo; keyword in order to maintain backwards comparability in the presences of ASI. Hence multi-line name declarations are allowed: 
</p>
<pre class="code javascript"><span class="kw3">name</span>
   @foo,
   @bar;</pre>
</div>
<!-- SECTION [3378-4335] -->
<a name="referencing_and_using_at-names"></a><h2>Referencing and Using At-Names</h2>
<div class="level2">

</div>
<!-- SECTION [4336-4380] -->
<a name="at-names_in_expressions"></a><h3>At-Names in Expressions</h3>
<div class="level3">

<p>
An <em>AtName</em> may occur as a <em>PrimaryExpression</em>, similar to an <em>Identifier</em>:
</p>
<pre class="code ebnf">PrimaryExpression ::
   ...
   AtName
</pre>
<p>
An<em>AtName</em> used as a primary express evaluates to its unique or private name value.  However, it is an early syntax error if a name declaration for the referenced <em>AtName</em> is not within the scope of the expression. Because AtNames always has a constant binding, it is an early error to use an <em>AtName</em> as the left-hand-side of an assignment operator.
</p>

<p>
A usage example:
</p>
<pre class="code javascript"><span class="kw3">name</span> @foo;
<span class="kw2">private</span> @bar;
let obj = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
obj<span class="br0">&#91;</span>@foo<span class="br0">&#93;</span> = <span class="nu0">1</span>;  <span class="co1">//create a couple properties</span>
obj<span class="br0">&#91;</span>@bar<span class="br0">&#93;</span> = <span class="nu0">2</span>;
&nbsp;
<span class="kw2">function</span> logProp<span class="br0">&#40;</span>o,key<span class="br0">&#41;</span> <span class="br0">&#123;</span>console.<span class="me1">log</span><span class="br0">&#40;</span><span class="st0">"property value: "</span>+ o<span class="br0">&#91;</span>key<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#125;</span>
&nbsp;
logProp<span class="br0">&#40;</span>obj, @foo<span class="br0">&#41;</span>; <span class="co1">// will log &quot;property value: 1&quot;</span>
logProp<span class="br0">&#40;</span>obj, @bar<span class="br0">&#41;</span>; <span class="co1">// will log &quot;property value: 2&quot;</span>
let key = @foo;     <span class="co1">// assign value of @foo to variable key</span>
logProp<span class="br0">&#40;</span>obj,key<span class="br0">&#41;</span>;   <span class="co1">// will also log &quot;property value: 1&quot;</span></pre>
<p>
When used as a primary expression, <em>AtNames</em> behave just like const declaration references.  The above example behaves identicially to: 
</p>
<pre class="code javascript"><span class="kw2">const</span> __foo = <span class="kw2">new</span> <span class="kw3">Name</span><span class="br0">&#40;</span><span class="kw2">true</span><span class="br0">&#41;</span>;
<span class="kw2">const</span> __bar = <span class="kw2">new</span> <span class="kw3">Name</span><span class="br0">&#40;</span><span class="kw2">false</span><span class="br0">&#41;</span>;
let obj = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
obj<span class="br0">&#91;</span>__foo<span class="br0">&#93;</span> = <span class="nu0">1</span>;  <span class="co1">//create a couple properties</span>
obj<span class="br0">&#91;</span>__bar<span class="br0">&#93;</span> = <span class="nu0">2</span>;
&nbsp;
<span class="kw2">function</span> logProp<span class="br0">&#40;</span>o,key<span class="br0">&#41;</span> <span class="br0">&#123;</span>console.<span class="me1">log</span><span class="br0">&#40;</span><span class="st0">"property value: "</span>+ o<span class="br0">&#91;</span>key<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#125;</span>
&nbsp;
logProp<span class="br0">&#40;</span>obj,__foo<span class="br0">&#41;</span>;  <span class="co1">//will log &quot;property value: 1&quot;</span>
logProp<span class="br0">&#40;</span>obj,__bar<span class="br0">&#41;</span>;  <span class="co1">//will log &quot;property value: 2&quot;</span>
let key = __foo;     <span class="co1">//assign value of @foo to variable key</span>
logProp<span class="br0">&#40;</span>obj,key<span class="br0">&#41;</span>;    <span class="co1">//will also log &quot;property value: 1&quot;</span></pre>
<p>
While <em>AtNames</em> can be used in expressions, their utility is greater when they appear in various non-expression contexts.
</p>

</div>
<!-- SECTION [4381-6064] -->
<a name="at-names_in_dot_notation_property_accessors"></a><h3>At-Names in Dot Notation Property Accessors</h3>
<div class="level3">

<p>
 An <em>AtName</em> may occur after a dot in a property accessor:
</p>
<pre class="code javascript"><span class="kw3">name</span> @foo, @bar;
let obj = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
&nbsp;
<span class="co1">//use assignment to define two properties</span>
obj.@foo = <span class="kw2">function</span><span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="br0">&#123;</span><span class="kw3">alert</span><span class="br0">&#40;</span>v + <span class="kw1">this</span>.@bar<span class="br0">&#41;</span><span class="br0">&#125;</span> ;
obj.@bar = <span class="st0">"world!"</span>;
&nbsp;
<span class="co1">//call a method</span>
obj.@foo<span class="br0">&#40;</span><span class="st0">"Hello, "</span><span class="br0">&#41;</span>;</pre>
<p>
When a <em>AtName</em> appears after a dot in a property access, the <em>AtName</em> is dynamically resolved to a declared name binding and the binding value is used as the key for the property access.  It is an early error if the property access is not within the scope of a name declaration for the <em>AtName</em>.
</p>

<p>
An property access such as <code>obj.@foo</code> is semantically identical to a property access like <code>obj[@foo]</code>.   However, the dot notation is more suggestive of the intent to use a fixed rather than a dynamically variable computed property value.
</p>

</div>
<!-- SECTION [6065-6936] -->
<a name="at-names_in_object_literals"></a><h3>At-Names in Object Literals</h3>
<div class="level3">

<p>
 An <em>AtName</em> may appear in any <em>PropertyName</em> context within an object literal: 
</p>
<pre class="code javascript"><span class="kw2">private</span> @foo, @bar, @baz, @bam;
let obj = <span class="br0">&#123;</span>
   @foo: <span class="st0">"a data property"</span>,
   @bar<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="st0">"a concise method property"</span><span class="br0">&#125;</span>,
   get @baz<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="st0">"a get accessor"</span><span class="br0">&#125;</span>,
   *@bam<span class="br0">&#40;</span>n<span class="br0">&#41;</span> <span class="br0">&#123;</span>yield <span class="nu0">0</span>; <span class="kw1">return</span> n<span class="br0">&#125;</span> <span class="co1">//a generator method</span>
<span class="br0">&#125;</span>;</pre>
<p>
 Appearance of an <em>AtName</em> as a <em>PropertyName</em> must be within the scope of a name declaration for that At-Name. It is in early error if an unresolvable <em>AtName</em> is used as a <em>PropertyName</em>.
</p>

<p>
 Using At-Names in object literals supports declarative construction of objects that include unique/private name keys.  Without the use of At-Names the definition of the above object would have to be expressed more imperatively : 
</p>
<pre class="code javascript"><span class="kw2">const</span> __foo = <span class="kw2">new</span> <span class="kw3">Name</span><span class="br0">&#40;</span><span class="br0">&#41;</span>,
      __bar = <span class="kw2">new</span> <span class="kw3">Name</span><span class="br0">&#40;</span><span class="br0">&#41;</span>,
      __baz = <span class="kw2">new</span> <span class="kw3">Name</span><span class="br0">&#40;</span><span class="br0">&#41;</span>,
      __bam = <span class="kw2">new</span> <span class="kw3">Name</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
let obj = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
obj<span class="br0">&#91;</span>__foo<span class="br0">&#93;</span> = <span class="st0">"a data property"</span>;
obj<span class="br0">&#91;</span>__bar<span class="br0">&#93;</span> = <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="st0">"a concise method property"</span><span class="br0">&#125;</span>;
Object.<span class="me1">defineProperty</span><span class="br0">&#40;</span>obj,__baz,<span class="br0">&#123;</span>get: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="st0">"a get accessor"</span><span class="br0">&#125;</span>, configurable: <span class="kw2">true</span><span class="br0">&#125;</span><span class="br0">&#41;</span>;
obj<span class="br0">&#91;</span>__bam<span class="br0">&#93;</span> = <span class="kw2">function</span> *<span class="br0">&#40;</span>n<span class="br0">&#41;</span> <span class="br0">&#123;</span>yield <span class="nu0">0</span>; <span class="kw1">return</span> n<span class="br0">&#125;</span>;</pre>
</div>
<!-- SECTION [6937-8114] -->
<a name="at-names_in_class_definitions"></a><h3>At-Names in Class Definitions</h3>
<div class="level3">

<p>
 Similarly to their use in object literals, an <em>AtName</em> may appear in any <em>PropertyName</em> context within a class definition: 
</p>
<pre class="code javascript"><span class="kw2">private</span> @x, @y;
<span class="kw3">name</span> @validate;
<span class="kw2">class</span> Point <span class="br0">&#123;</span>
   get x<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="kw1">this</span>.@x<span class="br0">&#125;</span>
   set x<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">this</span>.@x = <span class="kw1">this</span>.@validate<span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="br0">&#125;</span>
   get y<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="kw1">this</span>.@y<span class="br0">&#125;</span>
   set y<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">this</span>.@y = <span class="kw1">this</span>.@validate<span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="br0">&#125;</span>
   @validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">typeof</span> value !== <span class="st0">"number"</span><span class="br0">&#41;</span> <span class="kw1">throw</span> TypeError<span class="br0">&#40;</span><span class="st0">"number expected"</span><span class="br0">&#41;</span>;
      <span class="kw1">return</span> value;
   <span class="br0">&#125;</span>
   constructor <span class="br0">&#40;</span>x,y<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">this</span>.<span class="me1">x</span> = x;
      <span class="kw1">this</span>.<span class="me1">y</span> = y;
   <span class="br0">&#125;</span>
<span class="br0">&#125;</span>;
&nbsp;
<span class="kw2">class</span> QIPoint <span class="kw2">extends</span> Point<span class="br0">&#123;</span>
   @validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">super</span>.@validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span>;
      <span class="kw1">if</span> <span class="br0">&#40;</span>value&lt;<span class="nu0">0</span><span class="br0">&#41;</span> <span class="kw1">throw</span> RangeError<span class="br0">&#40;</span><span class="st0">"negative values not accepted"</span><span class="br0">&#41;</span>;
      <span class="kw1">return</span> value;
   <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
 Again, it is useful to contrast this to the equivalent code written without At-Names:
</p>
<pre class="code javascript"><span class="kw2">const</span> __x = <span class="kw2">new</span> <span class="kw3">Name</span><span class="br0">&#40;</span><span class="br0">&#41;</span>, __y= <span class="kw2">new</span> <span class="kw3">Name</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
<span class="kw2">const</span> __validate = <span class="kw2">new</span> <span class="kw3">Name</span><span class="br0">&#40;</span><span class="kw2">true</span><span class="br0">&#41;</span>;
<span class="kw2">class</span> Point <span class="br0">&#123;</span>
   get x<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="kw1">this</span><span class="br0">&#91;</span>__x<span class="br0">&#93;</span><span class="br0">&#125;</span>
   set x<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">this</span><span class="br0">&#91;</span>__x<span class="br0">&#93;</span> = <span class="kw1">this</span><span class="br0">&#91;</span>__validate<span class="br0">&#93;</span><span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="br0">&#125;</span>
   get y<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="kw1">this</span><span class="br0">&#91;</span>__y<span class="br0">&#93;</span><span class="br0">&#125;</span>
   set y<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">this</span><span class="br0">&#91;</span>__y<span class="br0">&#93;</span> = <span class="kw1">this</span><span class="br0">&#91;</span>__validate<span class="br0">&#93;</span><span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="br0">&#125;</span>
   constructor <span class="br0">&#40;</span>x,y<span class="br0">&#41;</span> <span class="br0">&#123;</span>
       <span class="kw1">this</span>.<span class="me1">x</span> = x;
       <span class="kw1">this</span>.<span class="me1">y</span> = y;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>;
Point.<span class="me1">prototype</span> = <span class="kw2">function</span> __validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>
   <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">typeof</span> value !== <span class="st0">"number"</span><span class="br0">&#41;</span> <span class="kw1">throw</span> TypeError<span class="br0">&#40;</span><span class="st0">"number expected"</span><span class="br0">&#41;</span>;
   <span class="kw1">return</span> value;
<span class="br0">&#125;</span>;
&nbsp;
<span class="kw2">class</span> QIPoint <span class="kw2">extends</span> Point <span class="br0">&#123;</span><span class="br0">&#125;</span>;
&nbsp;
<span class="co1">// note that the following is currently illegal, because it contains a super reference outside of a class definition body</span>
QIPoint.<span class="me1">prototype</span> = <span class="kw2">function</span> __validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>
   <span class="kw2">super</span><span class="br0">&#91;</span>__validate<span class="br0">&#93;</span><span class="br0">&#40;</span>value<span class="br0">&#41;</span>;
   <span class="kw1">if</span> <span class="br0">&#40;</span>value&lt;<span class="nu0">0</span><span class="br0">&#41;</span> <span class="kw1">throw</span> RangeError<span class="br0">&#40;</span><span class="st0">"negative values not accepted"</span><span class="br0">&#41;</span>;
   <span class="kw1">return</span> value;
<span class="br0">&#125;</span></pre>
<p>
   <img src="lib/images/smileys/icon_exclaim.gif" align="middle" alt=":!:" /> The above example demonstrates that without At-Names, there is no way to define unique/private named methods within a class definition.  Instead all such methods must be imperatively added to the class prototype object.  In this example, using the current consensus class semantics it is actually impossible to legally define the subclass QIPoint.  The problem is that without At-Names the method with the unique name key __validate must be defined separate from the class definition.  However, it is currently illegal to reference <strong>super</strong> in a function that is outside of the body of a class definition. This issue is eliminated when At-Name are used within class declarations.  It could also be eliminated by supporting the <a href="doku.php%3Fid=strawman:define_properties_operator.html" class="wikilink1" title="strawman:define_properties_operator" onclick="return svchk()" onkeypress="return svchk()">:= define properties operator</a> and allowing it to rebind <strong>super</strong>.   
</p>

</div>
<!-- SECTION [8115-10586] -->
<a name="other_possible_at-name_features"></a><h2>Other Possible At-Name Features</h2>
<div class="level2">

<p>
 The above is a base level of syntactic support for Unique/Private Names.  It could be enhanced in the following ways.
</p>

</div>
<!-- SECTION [10587-10752] -->
<a name="name_declarations_with_explicit_initializers"></a><h3>Name Declarations with Explicit Initializers</h3>
<div class="level3">

<p>
As describe above name declarations always create a binding to a newly instantiated unique/private name object. The actually declaration consists of a comma-separated list of <em>AtName</em> tokens.  Unlike const/let declarations there is no optional <em>Initialiser</em>.  If an <em>Initialiser</em> is allowed, then such name declarations could create alias for already existing unique/private name objects.  For example:
</p>
<pre class="code javascript"><span class="kw3">name</span> @foo;
<span class="kw3">name</span> @bar = @foo;
console.<span class="me1">log</span><span class="br0">&#40;</span>@foo === @bar<span class="br0">&#41;</span>;  <span class="co1">//true because both @foo and @bar are bound to the same name object</span>
let obj = <span class="br0">&#123;</span>@foo: <span class="nu0">42</span><span class="br0">&#125;</span>;
console.<span class="me1">log</span><span class="br0">&#40;</span>obj.@bar<span class="br0">&#41;</span>;  <span class="co1">//42</span></pre>
<p>
The name declaration initialization semantics would ensure that the value bound to the <em>AtName</em> was always a name value.  It would be a runtime TypeError if the value of the <em>initialiser</em> was not a name object.
</p>

<p>
The primary use case of such initialized name declaration would be to allow easy use of unique/private names that are obtained by function call or long qualified path names.  For example:
</p>
<pre class="code javascript"><span class="kw3">name</span> @secret = GeorgeFenneman.<span class="me1">getTodaysSecretWord</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
<span class="kw3">name</span> @reset = Graphics.<span class="me1">colorModels</span>.<span class="me1">CYN</span>.<span class="me1">resetKey</span>;
let obj = <span class="br0">&#123;</span>
   @secret: <span class="st0">'cigar'</span>,
   init<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
       Background.@reset<span class="br0">&#40;</span><span class="br0">&#41;</span>;
   <span class="br0">&#125;</span>
<span class="br0">&#125;</span>;</pre>
<p>
Name declarations and modules are covered in the next item. However, it is appropriate here to point out that names with initializers also provides a basic mechanism for sharing name declarations between modules:
</p>
<pre class="code javascript">module A <span class="br0">&#123;</span>
   <span class="kw3">name</span> @aName;
   <span class="kw2">export</span> <span class="kw2">const</span> aName=@aName;
<span class="br0">&#125;</span>
module B <span class="br0">&#123;</span>
   <span class="kw2">import</span> aName from A;
   <span class="kw3">name</span> @aName=aName;
   ...
<span class="br0">&#125;</span></pre>
<p>
The main issue with initialized name declarations is that it premits what appears to be distinct <em>AtNames</em> to actually reference the same property key.  For example, 
</p>
<pre class="code">
name @foo;
name @bar = @foo;
...
...
let obj={
   @foo: 1,
   @bar: 2
};
</pre>

<p>
 A casual inspection of the above object literal would suggest that it is defining an object with two properties.  However, because both @foo and @bar have the same name object value, it is really creating an object with a single property. It has been previously argued in the context of the <a href="doku.php%3Fid=harmony:object_literals.html#object_literal_computed_property_keys" class="wikilink1" title="harmony:object_literals" onclick="return svchk()" onkeypress="return svchk()">computed property keys proposal</a> that this could be error prone for code readers and could preclude certain sorts of early code optimization opportunities. However, aliasing of computed or long path names seems to have relatively high utility that may justify the asociated hazards.      
</p>

</div>
<!-- SECTION [10753-13306] -->
<a name="exportimport_of_name_declarations"></a><h3>Export/Import of Name Declarations</h3>
<div class="level3">

<p>
 Can a name declaration have an export prefix?  This seems desirable.  For example: 
</p>
<pre class="code javascript">module SystemNames <span class="br0">&#123;</span>
   <span class="co1">//make available unique names that are used as extension points for some standard built-in function</span>
   <span class="kw2">export</span> <span class="kw3">name</span> @iterator, @toStringTag, @concatTarget, @metaObject;
<span class="br0">&#125;</span>
&nbsp;
module myCode <span class="br0">&#123;</span>
   <span class="kw2">import</span> @toStringTag from SystemNames;
   let obj = <span class="br0">&#123;</span>
      x: <span class="nu0">0</span>,
      y: <span class="nu0">0</span>,
      @toStringTag: <span class="st0">"literal point"</span>   <span class="co1">//text used by Object.prototype.toString</span>
   <span class="br0">&#125;</span>;
   ...
<span class="br0">&#125;</span>
&nbsp;
module myCollection <span class="br0">&#123;</span>
   <span class="kw2">import</span> @concatTarget from SystemNames;
   <span class="kw2">export</span> <span class="kw2">class</span> MyArraySubclass <span class="kw2">extends</span> Array <span class="br0">&#123;</span>
      @concatTarget<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
          <span class="kw1">return</span> <span class="kw2">new</span> <span class="kw1">this</span>.<span class="me1">constructor</span><span class="br0">&#40;</span><span class="br0">&#41;</span>; <span class="co1">//make sure concat returns subclass instances</span>
      <span class="br0">&#125;</span>
      ...
   <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
 The above seems like a desirable way to share name declaration among modules.  However, a problem arises with module instances.  In addition to being usable as explicit imports, Module exports also appear as properties of the associated module instance. Name declarations based on At-Names will cause issues if they appear as properties of module instances. Consider: 
</p>
<pre class="code javascript">module MyModule <span class="br0">&#123;</span>
   <span class="co1">// This can't work, @concatTarget isn't defined in the scope of MyModule,</span>
   <span class="co1">// its value is what we want to import</span>
   <span class="kw3">name</span> @ct = SystemNames.@concatTarget;
&nbsp;
   <span class="co1">// This shouldn't work. It creates confusion between lexically scoped</span>
   <span class="co1">// At-Names and string property keys that we have avoided up to this point.</span>
   <span class="kw3">name</span> @tST = SystemNames<span class="br0">&#91;</span><span class="st0">"@toStringTarget"</span><span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre>
<p>
The solution to this problem may be to simply disallow name declarations from appearing as properties of module instance objects and to require the use of explicit imports for cross-module name declaration access.
</p>
<pre class="code"></pre>

</div>
<!-- SECTION [13307-15087] -->
<a name="class_local_name_declarations"></a><h3>Class Local Name Declarations</h3>
<div class="level3">

<p>
 As shown <span class="curid"><a href="doku.php%3Fid=strawman:syntactic_support_for_private_names.html#at-names_in_class_definitions" class="wikilink1" title="strawman:syntactic_support_for_private_names" onclick="return svchk()" onkeypress="return svchk()">above</a></span>, the private name declarations used within a class definition must occur in separate declarations that are not part of the actual class definition. This is anti-modular in that it breaks what should be a cohesive class definition into multiple pieces. This results in refactoring hazards and code that is more difficult to read.
</p>

<p>
A solution to this problem would be to allow name declarations to occur as <em>ClassElement</em> within a <em>ClassBody</em>: 
</p>
<pre class="code ebnf">ClassElement :
   NameDeclaration
   PrivateDeclaration
   MethodDefinition
   ;
</pre>
<p>
 The <em>ClassBody</em> would serve as a new nested lexical contour for any name declarations that appear as a <em>ClassElement</em>. Any <strong>name</strong> or <strong>private</strong> declarations within class body are local to that body. Because name declarations are  the only declaration forms that are class elements, the lexical contour of a <em>ClassBody</em> only contains  bindings for At-Names.
</p>

<p>
Using <em>ClassElement</em> level name declarations the class example from above can be restated as: 
</p>
<pre class="code javascript"><span class="kw3">name</span> @validate;
&nbsp;
<span class="kw2">class</span> Point <span class="br0">&#123;</span>
   <span class="kw2">private</span> @x, @y;  <span class="co1">// &lt;======= private declaration now scoped to class body</span>
   get x<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="kw1">this</span>.@x<span class="br0">&#125;</span>
   set x<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">this</span>.@x = <span class="kw1">this</span>.@validate<span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="br0">&#125;</span>
   get y<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="kw1">this</span>.@y<span class="br0">&#125;</span>
   set y<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">this</span>.@y = <span class="kw1">this</span>.@validate<span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="br0">&#125;</span>
   @validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">typeof</span> value !== <span class="st0">"number"</span><span class="br0">&#41;</span> <span class="kw1">throw</span> TypeError<span class="br0">&#40;</span><span class="st0">"number expected"</span><span class="br0">&#41;</span>;
      <span class="kw1">return</span> value;
   <span class="br0">&#125;</span>
   constructor <span class="br0">&#40;</span>x,y<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">this</span>.<span class="me1">x</span> = x;
      <span class="kw1">this</span>.<span class="me1">y</span> = y;
   <span class="br0">&#125;</span>
<span class="br0">&#125;</span>;
&nbsp;
<span class="kw2">class</span> QIPoint <span class="kw2">extends</span> Point<span class="br0">&#123;</span>
   @validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">super</span>.@validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span>;
      <span class="kw1">if</span> <span class="br0">&#40;</span>value &lt; <span class="nu0">0</span><span class="br0">&#41;</span> <span class="kw1">throw</span> RangeError<span class="br0">&#40;</span><span class="st0">"negative values not accepted"</span><span class="br0">&#41;</span>;
      <span class="kw1">return</span> value;
   <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
Note that the declaration for <code>@validate</code> still needs to be outside the body of Point.  This is because it is shared among two separate class bodies and hence can&rsquo;t be scoped to either individual body.
</p>

</div>
<!-- SECTION [15088-17080] -->
<a name="class_protected_name_declarations"></a><h3>Class &quot;Protected&quot; Name Declarations</h3>
<div class="level3">

<p>
In the above example, the declaration of <code>@validate</code> must be outside of both class declarations so it can be referenced from within the class bodies of both declarations.  In this example, placeing the name declaration at the same lexical level as the the class declarations is sufficient to achieved the necessary shared visibility for <code>@validate</code>.
</p>

<p>
However, it is frequently desirable for subclasses to have access to non-public properties of superclasses that are defined in different modules or scopes. Such would be the case if <code>QIPoint</code> in this example needed to be defined in a separate source file.  Static OO languages such as C++ and Java support this with the concept of &ldquo;protected&rdquo; member visibility. A protected member is visible to subclasses but not visible to to code that is outside the subclass class hierarchy within which it is declared.
</p>

<p>
Note that &ldquo;protected&rdquo; member visibility is not a security mechanism, as such members can be accessed by any code that is capable of subclassing the class that defines a protected member.  Instead, &ldquo;protected&rdquo; member visibility is useful as a means of formalizing a <em>public</em> subclass extensibility interface provided by a class. Separation between the subclass and client object interfaces can be clarified by using using &ldquo;protected&rdquo; member names for members of the subclass interface and normal &ldquo;public&rdquo; names  for the regular client object interface. 
</p>

<p>
The concept of subclass &ldquo;protected&rdquo; property visibility can be supported for ECMAScript by providing a <strong>protected</strong> name declaration that can only occur as a <em>ClassElement</em>.  Within a <em>ClassBody</em>, a <strong>protected</strong> name declaration is semantically equivalent to a <strong>name</strong> declaration.  This permits the above Point example to be restated as:
</p>
<pre class="code javascript"><span class="kw2">class</span> Point <span class="br0">&#123;</span>
   <span class="kw2">private</span> @x, @y; 
   <span class="kw2">protected</span> @validate;  <span class="co1">//&lt;==== protected is locally scoped to class body and ...</span>
   get x<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="kw1">this</span>.@x<span class="br0">&#125;</span>
   set x<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">this</span>.@x = <span class="kw1">this</span>.@validate<span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="br0">&#125;</span>
   get y<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="kw1">this</span>.@y<span class="br0">&#125;</span>
   set y<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">this</span>.@y = <span class="kw1">this</span>.@validate<span class="br0">&#40;</span>v<span class="br0">&#41;</span><span class="br0">&#125;</span>
   @validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">typeof</span> value !== <span class="st0">"number"</span><span class="br0">&#41;</span> <span class="kw1">throw</span> TypeError<span class="br0">&#40;</span><span class="st0">"number expected"</span><span class="br0">&#41;</span>;
      <span class="kw1">return</span> value;
   <span class="br0">&#125;</span>
   constructor <span class="br0">&#40;</span>x,y<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">this</span>.<span class="me1">x</span> = x;
      <span class="kw1">this</span>.<span class="me1">y</span> = y;
   <span class="br0">&#125;</span>
<span class="br0">&#125;</span>;</pre>
<p>
Locally, within the class body, a <strong>protected</strong> name declaration is semantically equivalent to a <strong>name</strong> declaration. It creates a new unique name object and binds it to an At-Name within the scope of the class body.  However, such declarations have an additional semantics that name declaration do not have:  the protected At-Name bindings are also visible as local bindings within the bodies of any subclass definitions that directly or indirectly &ldquo;extends&rdquo; the class declaration containing the protected name declaration.  This permits  <code>QIPoint</code> to reference <code>@validate</code> even if it isn&rsquo;t in the same module or source files as <code>Point</code>: 
</p>
<pre class="code javascript"><span class="kw2">class</span> QIPoint <span class="kw2">extends</span> Point<span class="br0">&#123;</span>
   @validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>  <span class="co1">//&lt;==== @validate At-Name binding is &quot;inherited&quot; from Point</span>
      <span class="kw2">super</span>.@validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span>;
      <span class="kw1">if</span> <span class="br0">&#40;</span>value&lt;<span class="nu0">0</span><span class="br0">&#41;</span> <span class="kw1">throw</span> RangeError<span class="br0">&#40;</span><span class="st0">"negative values not accepted"</span><span class="br0">&#41;</span>;
      <span class="kw1">return</span> value;
   <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
How does this work? When a class definition that contains <strong>protected</strong> name declarations in its class body is evaluated, a <code>Map</code> object is created.  The keys of this map are the strings representation of At-Names that appear in protected declarations within the class body. The values of each map element is the unique name object that is bond to the corresponding At-Name.  This map is stored as the value of a property of the class object (the constructor) that is created by evaluating the class definition. The name of this property is a system provided unique name that we will refer to as <code>@protectedBindings</code>. Because the protected At-Name bindings of a class are a direct reflection of the source code of the class, the <code>@protectedBindings</code> property of a class object is frozen and the its map value is immutable.
</p>

<p>
So, for example, <code>Point.@protectedBindings.get(&rdquo;@validate&rdquo;)</code> would evaluate to the same unique name value as a reference to <code>@validate</code> from within the class body of <code>Point</code>.
</p>

<p>
When a class definition with an <strong>extends</strong> clause is evaluated it walks the prototype chain of the extended object looking for <code>@protectedBindings</code> maps. From all such maps it composes a new lexical environment, called the <em>inherited names environment</em>,  containing At-Name bindings.  When constructing the inherited names environment, protected name bindings in subclasses over-ride any like-named bindings from superclasses. The inherited names environment is used as an intermediate lexical environment between the environment containing the class definition and the class body environment.  The inherited names environment shadows the environment containing the class definition and is, itself, shadowed by its class body environment.
</p>

</div>
<!-- SECTION [17081-22036] -->
<a name="scoping_issues_with_protected_properties"></a><h4>Scoping Issues with Protected Properties</h4>
<div class="level4">

<p>
 In the absence of protected name declarations, At-Name references are statically resolvable to specific bindings.  As stated above, it is an early error for a reference to an At-Name to not be statically in the scope of a name declaration.  As described so far, protected declaration would make such static At-Name resolution impossible.  Consider this class declaration that occurs by itself in a module:
</p>
<pre class="code javascript">module QI <span class="br0">&#123;</span>
  <span class="kw2">class</span> QIPoint <span class="kw2">extends</span> Point<span class="br0">&#123;</span>
     @validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>     <span class="co1">//&lt;==== we can't tell by inspection whether @validate is defined</span>
        <span class="kw2">super</span>.@validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span>;
        <span class="kw1">if</span> <span class="br0">&#40;</span>value&lt;<span class="nu0">0</span><span class="br0">&#41;</span> <span class="kw1">throw</span> RangeError<span class="br0">&#40;</span><span class="st0">"negative values not accepted"</span><span class="br0">&#41;</span>;
        <span class="kw1">return</span> value;
     <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
Whether or not the references to <code>@validate</code> are legal now depend upon upon the value of <code>Point</code> used when the <code>QIPoint</code> class definition is evaluated. If <code>Point</code> has <code>&ldquo;@validate&rdquo;</code> in its <code>@protectedBindings</code> maps then the class definition for <code>QIPoint</code> is valid. If not, a dynamic error will occur when evaluating the class definition.
</p>

<p>
Another issue is illustrated by this version: 
</p>
<pre class="code javascript">module QI <span class="br0">&#123;</span>
&nbsp;
  <span class="kw2">private</span> @validate;
&nbsp;
  <span class="kw2">class</span> QIPoint <span class="kw2">extends</span> Point<span class="br0">&#123;</span>
     @validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>  <span class="co1">//&lt;==== does this use the module level definition of @validate or one inherited from Point?</span>
        <span class="kw2">super</span>.@validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span>;
        <span class="kw1">if</span> <span class="br0">&#40;</span>value&lt;<span class="nu0">0</span><span class="br0">&#41;</span> <span class="kw1">throw</span> RangeError<span class="br0">&#40;</span><span class="st0">"negative values not accepted"</span><span class="br0">&#41;</span>;
        <span class="kw1">return</span> value;
     <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
 In this case there is a local definition of <code>@validate</code> that is clearly in scope of the class definition&rsquo;s <code>@validate</code> references.  However, in the presence of protected name declarations we can&rsquo;t be sure that this local declaration is actually being used because if <code>Point</code> has a protected declaration for <code>@validate</code> it will shadow the local declaration. Even if this happen, it is other clear whether or not that is the actual programmer&rsquo;s intent.
</p>

<p>
One way around such issue is to always require an explicit <strong>protected</strong> declaration within a class definition, in order to reference inherited protected named.  In that case, class definitions would not automatically include the inherited names environment in the scope chain of a class body.  Instead, when a protected name declaration is instantiated in the class body&rsquo;s local scope its At-Name is first looked up in the inherited names environment if a binding is found, its value is used to initialize the local At-Name binding.  If an inherited binding is not found and new unique name object is created and used to initialize the local At-Name binding.  With this semantics, the validity of all At-Name reference can again be determined. For example:
</p>
<pre class="code javascript">module QI <span class="br0">&#123;</span>
  <span class="kw2">class</span> QIPoint <span class="kw2">extends</span> Point<span class="br0">&#123;</span>
     @validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>     <span class="co1">//&lt;==== static error - @validate not declared</span>
        <span class="kw2">super</span>.@validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span>;
        <span class="kw1">if</span> <span class="br0">&#40;</span>value&lt;<span class="nu0">0</span><span class="br0">&#41;</span> <span class="kw1">throw</span> RangeError<span class="br0">&#40;</span><span class="st0">"negative values not accepted"</span><span class="br0">&#41;</span>;
        <span class="kw1">return</span> value;
     <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
 In this example, we know the references to <code>@validate</code> within <code>QIPoint</code> is invalid because the class is not visibly in the scope of any name declarations for <code>@validate</code>.  Any protected names provided by <code>Point</code> will not be visible because there are not <strong>protected</strong> declarations within the body of <code>QIPoint</code>.   
</p>
<pre class="code javascript">module QI <span class="br0">&#123;</span>
  <span class="kw2">class</span> QIPoint <span class="kw2">extends</span> Point<span class="br0">&#123;</span>
     <span class="kw2">protected</span> @validate;   <span class="co1">//&lt;=== either a new or inherited local name</span>
     @validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>     <span class="co1">//&lt;==== statically binds to local declaration</span>
        <span class="kw2">super</span>.@validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span>;
        <span class="kw1">if</span> <span class="br0">&#40;</span>value&lt;<span class="nu0">0</span><span class="br0">&#41;</span> <span class="kw1">throw</span> RangeError<span class="br0">&#40;</span><span class="st0">"negative values not accepted"</span><span class="br0">&#41;</span>;
        <span class="kw1">return</span> value;
     <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
 In the second example, references to <code>@validate</code> within <code>QIPoint</code> are guaranteed to resolve because the class body contains a <strong>protected</strong> declaration for <code>@validate</code>.  If <code>Point</code> provides a protected binding for <code>@validate</code> its value will be used within <code>QIPoint</code>.  If Point does not provide such a binding then a new unique name object is created and used as the value of <code>@validate</code>.
</p>
<pre class="code javascript">module QI <span class="br0">&#123;</span>
&nbsp;
  <span class="kw2">private</span> @validate;
&nbsp;
  <span class="kw2">class</span> QIPoint <span class="kw2">extends</span> Point<span class="br0">&#123;</span>
     <span class="kw2">protected</span> @validate;
     @validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>  <span class="co1">//&lt;==== always binds to the module level declaration.</span>
        <span class="kw2">super</span>.@validate<span class="br0">&#40;</span>value<span class="br0">&#41;</span>;
        <span class="kw1">if</span> <span class="br0">&#40;</span>value&lt;<span class="nu0">0</span><span class="br0">&#41;</span> <span class="kw1">throw</span> RangeError<span class="br0">&#40;</span><span class="st0">"negative values not accepted"</span><span class="br0">&#41;</span>;
        <span class="kw1">return</span> value;
     <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
 Finally, in the last example, we know that references to <code>@validate</code> within <code>QIPoint</code> will not resolve to the the module-level private declaration.  Instead, it will resolve to the class-scoped binding provided by either <code>Point</code> or <code>QIPoint</code>. In either case, their is a clearly expressed programmer&rsquo;s intent to use a class-proved protected <code>@validate</code> binding rather than the lexically available private name binding.
</p>

<p>
The use of protected inherited member visibility to delineate subclass extension interfaces is an important technique in object-oriented programming. But, issues concerning interactions between inheritance-based scoping and syntactic lexical scoping are common in object-oriented languages. It isn&rsquo;t clear whether they are always a significant usage problem or just strange edge cases.  However, the pervasive use of lexical scoping within ECMAScript suggest that implicit inheritance-based scoping of protected members is likely to be error prone. In that light, the preferable semantics for protected name declarations in ECMAScript may be the alternative semantics that requires an explicit <strong>protected</strong> declaration within a class body to enable  visibility of inherited protected At-Names.
</p>

</div>
<!-- SECTION [22037-27679] -->
<a name="other_syntactic_approaches_to_private_names"></a><h2>Other Syntactic Approaches to Private Names</h2>
<div class="level2">

<p>
 There are been several previous unsuccessful attempts to provide syntactic support for private names.  The primary innovation in this current proposal is the use of @ as sigil prefix for all declared private names intended for use in non-expression contexts.  This seems to address abmiguities that existed in earlier proposals.
</p>

<p>
For the previous proposals see: 
</p>
<ul>
<li class="level1"><div class="li"> <a href="doku.php%3Fid=harmony:object_literals.html#object_literal_computed_property_keys" class="wikilink1" title="harmony:object_literals" onclick="return svchk()" onkeypress="return svchk()">Computed Property Keys Proposal</a></div>
</li>
<li class="level1"><div class="li"> <a href="doku.php%3Fid=strawman:private_names.html" class="wikilink1" title="strawman:private_names" onclick="return svchk()" onkeypress="return svchk()">Private Names: Unique Unforgeable Property Names</a></div>
</li>
<li class="level1"><div class="li"> <a href="doku.php%3Fid=strawman:names.html" class="wikilink1" title="strawman:names" onclick="return svchk()" onkeypress="return svchk()">names</a></div>
</li>
</ul>

</div>
<!-- SECTION [27680-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/7/7219e5b8358bfd932cb56a3fe04c9559.xhtml used -->
</body>
</html>
