<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=harmony:direct_proxies&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="http://wiki.ecmascript.org/feed.php?mode=list&amp;ns=harmony" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=harmony:direct_proxies&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=harmony:direct_proxies&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:direct_proxies&amp;do=export_html.html#direct_proxies" class="toc">Direct Proxies</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:direct_proxies&amp;do=export_html.html#api" class="toc">API</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:direct_proxies&amp;do=export_html.html#wrapping_irregular_objects" class="toc">Wrapping irregular Objects</a></span></li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:direct_proxies&amp;do=export_html.html#virtual_objects" class="toc">Virtual Objects</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:direct_proxies&amp;do=export_html.html#reflect_module" class="toc">reflect module</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:direct_proxies&amp;do=export_html.html#interaction_with_prototypal_inheritance" class="toc">Interaction with Prototypal Inheritance</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:direct_proxies&amp;do=export_html.html#invariant_enforcement" class="toc">Invariant enforcement</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:direct_proxies&amp;do=export_html.html#revocable_proxies" class="toc">Revocable Proxies</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:direct_proxies&amp;do=export_html.html#draft_spec" class="toc">Draft Spec</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:direct_proxies&amp;do=export_html.html#open_issues" class="toc">Open Issues</a></span><ul class="toc">
<li class="clear"><ul class="toc">
<li class="clear"><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:direct_proxies&amp;do=export_html.html#discussed_during_tc39_september_2012_meeting_northeastern_u._boston" class="toc">Discussed during TC39 September 2012 Meeting, NorthEastern U., Boston</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:direct_proxies&amp;do=export_html.html#discussed_during_tc39_july_2012_meeting_microsoft_redmond" class="toc">Discussed during TC39 July 2012 Meeting, Microsoft, Redmond</a></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:direct_proxies&amp;do=export_html.html#references" class="toc">References</a></span></li>
</ul>
</div>
</div>

<a name="direct_proxies"></a><h1>Direct Proxies</h1>
<div class="level1">

<p>
 <strong>This proposal has progressed to the Draft ECMAScript 6 Specification (Sept. 2013 draft Sections <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-proxy-object-internal-methods-and-internal-data-properties" class="urlextern" target="_blank" title="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-proxy-object-internal-methods-and-internal-data-properties" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">9.3</a> and <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-proxy-objects" class="urlextern" target="_blank" title="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-proxy-objects" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">26.2</a>), which is available for review here: <a href="doku.php%3Fid=harmony:specification_drafts.html" class="wikilink1" title="harmony:specification_drafts" onclick="return svchk()" onkeypress="return svchk()">specification_drafts</a>. Any new issues relating to them should be filed as bugs at <a href="http://bugs.ecmascript.org" class="urlextern" target="_blank" title="http://bugs.ecmascript.org" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">http://bugs.ecmascript.org</a>. The content on this page is for historic record only and may no longer reflect the current state of the feature described within.</strong>
</p>

<p>
 This Proxy <acronym title="Application Programming Interface">API</acronym> replaces the earlier <a href="doku.php%3Fid=harmony:proxies.html" class="wikilink1" title="harmony:proxies" onclick="return svchk()" onkeypress="return svchk()">proxies</a> <acronym title="Application Programming Interface">API</acronym>. A summary of the major differences between this <acronym title="Application Programming Interface">API</acronym> and the previous <acronym title="Application Programming Interface">API</acronym> can be found on <a href="doku.php%3Fid=strawman:direct_proxies.html" class="wikilink1" title="strawman:direct_proxies" onclick="return svchk()" onkeypress="return svchk()">the old strawman page</a>.
</p>

</div>
<!-- SECTION [1-839] -->
<a name="api"></a><h2>API</h2>
<div class="level2">

<p>
 To construct a proxy that wraps a given <code>target</code> object:
</p>
<pre class="code javascript"><span class="kw2">var</span> proxy = Proxy<span class="br0">&#40;</span>target, handler<span class="br0">&#41;</span>;</pre>
<p>
Both <code>target</code> and <code>handler</code> must be proper Objects. It is not necessary to use <code>new</code> to create new proxy objects.
</p>

<p>
The <code>handler</code> is an object that may implement the following <acronym title="Application Programming Interface">API</acronym> (name denotes a property name, &rarr; is followed by return type, [t] means array-of-t, etc.):
</p>
<pre class="code javascript"><span class="br0">&#123;</span>
  getOwnPropertyDescriptor: <span class="kw2">function</span><span class="br0">&#40;</span>target,<span class="kw3">name</span><span class="br0">&#41;</span> -&gt; desc | undefined          <span class="co1">// Object.getOwnPropertyDescriptor(proxy,name)</span>
  getOwnPropertyNames:      <span class="kw2">function</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span> -&gt; <span class="br0">&#91;</span> string <span class="br0">&#93;</span>                     <span class="co1">// Object.getOwnPropertyNames(proxy) </span>
  getPrototypeOf:           <span class="kw2">function</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span> -&gt; any                            <span class="co1">// Object.getPrototypeOf(proxy)</span>
  defineProperty:           <span class="kw2">function</span><span class="br0">&#40;</span>target,<span class="kw3">name</span>, desc<span class="br0">&#41;</span> -&gt; boolean             <span class="co1">// Object.defineProperty(proxy,name,desc)</span>
  deleteProperty:           <span class="kw2">function</span><span class="br0">&#40;</span>target,<span class="kw3">name</span><span class="br0">&#41;</span> -&gt; boolean                   <span class="co1">// delete proxy[name]</span>
  freeze:                   <span class="kw2">function</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span> -&gt; boolean                        <span class="co1">// Object.freeze(proxy)</span>
  seal:                     <span class="kw2">function</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span> -&gt; boolean                        <span class="co1">// Object.seal(proxy)</span>
  preventExtensions:        <span class="kw2">function</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span> -&gt; boolean                        <span class="co1">// Object.preventExtensions(proxy)</span>
  isFrozen:                 <span class="kw2">function</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span> -&gt; boolean                        <span class="co1">// Object.isFrozen(proxy)</span>
  isSealed:                 <span class="kw2">function</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span> -&gt; boolean                        <span class="co1">// Object.isSealed(proxy)</span>
  isExtensible:             <span class="kw2">function</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span> -&gt; boolean                        <span class="co1">// Object.isExtensible(proxy)</span>
  has:                      <span class="kw2">function</span><span class="br0">&#40;</span>target,<span class="kw3">name</span><span class="br0">&#41;</span> -&gt; boolean                   <span class="co1">// name in proxy</span>
  hasOwn:                   <span class="kw2">function</span><span class="br0">&#40;</span>target,<span class="kw3">name</span><span class="br0">&#41;</span> -&gt; boolean                   <span class="co1">// ({}).hasOwnProperty.call(proxy,name)</span>
  get:                      <span class="kw2">function</span><span class="br0">&#40;</span>target,<span class="kw3">name</span>,receiver<span class="br0">&#41;</span> -&gt; any              <span class="co1">// receiver[name]</span>
  set:                      <span class="kw2">function</span><span class="br0">&#40;</span>target,<span class="kw3">name</span>,val,receiver<span class="br0">&#41;</span> -&gt; boolean      <span class="co1">// receiver[name] = val</span>
  enumerate:                <span class="kw2">function</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span> -&gt; iterator                       <span class="co1">// for (name in proxy) (iterator should yield all enumerable own and inherited properties)</span>
  keys:                     <span class="kw2">function</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span> -&gt; <span class="br0">&#91;</span>string<span class="br0">&#93;</span>                       <span class="co1">// Object.keys(proxy)  (return array of enumerable own properties only)</span>
  apply:                    <span class="kw2">function</span><span class="br0">&#40;</span>target,thisArg,args<span class="br0">&#41;</span> -&gt; any               <span class="co1">// proxy(...args)</span>
  construct:                <span class="kw2">function</span><span class="br0">&#40;</span>target,args<span class="br0">&#41;</span> -&gt; any                       <span class="co1">// new proxy(...args)</span>
<span class="br0">&#125;</span></pre>
<p>
Each of the above methods is called a &ldquo;trap&rdquo;. The first argument to each trap is a reference to the <code>target</code> object wrapped by the proxy that triggered the trap. The comment behind each trap signature shows example code that may trigger the trap.
</p>

<p>
All traps are optional. If missing (more precisely, if <code>handler[trapName]</code> returns <code>undefined</code>), the proxy defaults to forwarding the intercepted operation to its <code>target</code> object.
</p>

<p>
<strong>Non-interceptable operations</strong> Some operations are insensitive to proxies, and are implicitly applied to the proxy&rsquo;s <code>target</code> instead:
</p>
<pre class="code javascript"><span class="kw1">typeof</span> proxy                 <span class="co1">// equivalent to typeof target</span>
proxy <span class="kw1">instanceof</span> F           <span class="co1">// equivalent to target instanceof F</span></pre>
<p>
<strong>Identity</strong> A proxy has its own identity, which is distinct from its target. Hence <code>proxy !== target</code> and for any WeakMap <code>wm</code>, <code>wm.get(proxy)</code> is not necessarily equal to <code>wm.get(target)</code>.
</p>

<p>
<strong>Functions</strong> The <code>apply</code> and <code>construct</code> traps are triggered <em>only</em> if <code>typeof target === &ldquo;function&rdquo;</code>. Otherwise, trying to call or construct a proxy fails just like when trying to call/construct a non-function object.
</p>

<p>
Note the role of the 2nd <code>thisArg</code> argument to the <code>apply</code> trap:
</p>
<pre class="code javascript"><span class="kw2">var</span> fun = <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#123;</span><span class="br0">&#125;</span>;
<span class="kw2">var</span> proxy = Proxy<span class="br0">&#40;</span>fun, handler<span class="br0">&#41;</span>;
&nbsp;
proxy<span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span>; <span class="co1">// triggers handler.apply(fun, undefined, args)</span>
<span class="kw2">var</span> obj = <span class="br0">&#123;</span> m: proxy <span class="br0">&#125;</span>; obj.<span class="me1">m</span><span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span>; <span class="co1">// triggers handler.apply(fun, obj, args)</span>
<span class="kw2">Function</span>.<span class="me1">prototype</span>.<span class="me1">apply</span>.<span class="me1">call</span><span class="br0">&#40;</span>proxy, thisArg, args<span class="br0">&#41;</span>; <span class="co1">// triggers handler.apply(fun,thisArg,args)</span></pre>
</div>
<!-- SECTION [840-4998] -->
<a name="wrapping_irregular_objects"></a><h2>Wrapping irregular Objects</h2>
<div class="level2">

<p>
 A proxy may wrap irregular objects such as functions, arrays, Date objects and host objects. In such cases, a proxy acquires any internal properties (other than the standard internal properties for regular Objects) from its wrapped target.
</p>

<p>
Some standard internal properties on regular Objects are always shared with the wrapped target: this includes the [[Class]] internal property:
</p>
<ul>
<li class="level1"><div class="li"> calling <code>Object.prototype.toString.call(proxy)</code> uses the <code>target</code>&lsquo;s [[Class]] in the result string</div>
</li>
<li class="level1"><div class="li"> <code>typeof proxy</code> is equal to <code>typeof target</code>.</div>
</li>
</ul>

<p>
 A proxy does not have a [[Prototype]] internal property. Prototype access should instead trigger the <code>getPrototypeOf</code> trap, and check if the return value of that trap is consistent with the [[Prototype]] value of the proxy&rsquo;s [[Target]] (see invariant enforcement, below).
</p>

<p>
A proxy does not have an [[Extensible]] internal property. Accessing this internal property should instead trigger the <code>isExtensible</code> trap, and check if the return value of that trap is consistent with the [[Extensible]] value of the proxy&rsquo;s [[Target]] (see invariant enforcement, below).
</p>

<p>
<strong>Date</strong> Example:
</p>
<pre class="code javascript"><span class="kw2">var</span> d = <span class="kw2">new</span> Date<span class="br0">&#40;</span><span class="br0">&#41;</span>;
<span class="kw2">var</span> p = Proxy<span class="br0">&#40;</span>d, <span class="br0">&#123;</span><span class="br0">&#125;</span><span class="br0">&#41;</span>;
Object.<span class="me1">prototype</span>.<span class="me1">toString</span>.<span class="me1">call</span><span class="br0">&#40;</span>p<span class="br0">&#41;</span> <span class="co1">// &quot;[object Date]&quot;</span>
Object.<span class="me1">getPrototypeOf</span><span class="br0">&#40;</span>p<span class="br0">&#41;</span> <span class="co1">// Date.prototype</span>
<span class="kw1">typeof</span> p <span class="co1">// &quot;object&quot;</span>
p === d <span class="co1">// false</span></pre>
<p>
<strong>Function</strong> When the wrapped <code>target</code> is a Function:
</p>
<ul>
<li class="level1"><div class="li"> <code>Object.prototype.toString.call(proxy)</code> returns <code>&ldquo;[object Function]&rdquo;</code></div>
</li>
<li class="level1"><div class="li"> <code>Function.prototype.toString.call(proxy)</code> returns <code>Function.prototype.toString.call(target)</code></div>
</li>
<li class="level1"><div class="li"> <code>Function.prototype.apply.call(proxy, rcvr, args)</code> triggers <code>handler.apply(target, rcvr, args)</code></div>
</li>
<li class="level1"><div class="li"> <code>Function.prototype.call.call(proxy, rcvr, ...args)</code> triggers <code>handler.apply(target, rcvr, args)</code></div>
</li>
<li class="level1"><div class="li"> <code>Function.prototype.bind.call(proxy, rcvr, ...args)</code> returns a currying of the proxy</div>
</li>
</ul>

<p>
 The [[Call]] and [[Construct]] behavior of a proxy <code>p</code> is governed by the following rule:
</p>
<ul>
<li class="level1"><div class="li"> If <code>typeof target === &ldquo;function&rdquo;</code>, then so is <code>typeof p</code> and calling/constructing the proxy always traps the <code>apply/construct</code> trap.</div>
</li>
<li class="level1"><div class="li"> If <code>typeof target !== &ldquo;function&rdquo;</code>, then so is <code>typeof p</code> and any attempt to call/construct <code>p</code> raises a <code>TypeError</code> as usual, stating that <code>p</code> is not a function. The <code>apply</code> or <code>construct</code> traps are never invoked.</div>
</li>
</ul>

<p>
 This upholds the constraints that:
</p>
<ul>
<li class="level1"><div class="li"> The result of <code>typeof</code> is stable: it depends only on <code>typeof target</code>, not on the presence or absence of the <code>apply</code> or <code>construct</code> traps.</div>
</li>
<li class="level1"><div class="li"> An object is callable if and only if <code>typeof obj === &ldquo;function&rdquo;</code>.</div>
</li>
</ul>

<p>
 The second restriction could be revisited if there exist host objects that are not <code>typeof &ldquo;function&rdquo;</code> but that are callable/constructable.
</p>

<p>
<strong>Array</strong>
</p>
<pre class="code javascript"><span class="kw2">var</span> target = <span class="br0">&#91;</span><span class="br0">&#93;</span>;
<span class="kw2">var</span> p = Proxy<span class="br0">&#40;</span>target, handler<span class="br0">&#41;</span>;
Object.<span class="me1">prototype</span>.<span class="me1">toString</span>.<span class="me1">call</span><span class="br0">&#40;</span>p<span class="br0">&#41;</span> <span class="co1">// &quot;[object Array]&quot;</span>
Object.<span class="me1">getPrototypeOf</span><span class="br0">&#40;</span>p<span class="br0">&#41;</span> <span class="co1">// Array.prototype</span>
<span class="kw1">typeof</span> p <span class="co1">// &quot;object&quot;</span>
Array.<span class="me1">isArray</span><span class="br0">&#40;</span>p<span class="br0">&#41;</span> <span class="co1">// true</span>
p<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> <span class="co1">// triggers handler.get(target, &quot;0&quot;, p)</span></pre>
<p>
<strong>Non-generic built-in functions</strong>
</p>

<p>
As noted in the &ldquo;open issues&rdquo; below, it is not yet clear how proxies should behave when passed as the <code>this</code>-binding of built-in methods like <code>Date.prototype.getTime</code>:
</p>
<pre class="code javascript"><span class="kw2">var</span> d = <span class="kw2">new</span> Date<span class="br0">&#40;</span><span class="br0">&#41;</span>;
<span class="kw2">var</span> p = <span class="kw2">new</span> Proxy<span class="br0">&#40;</span>d,<span class="br0">&#123;</span><span class="br0">&#125;</span><span class="br0">&#41;</span>;
Date.<span class="me1">prototype</span>.<span class="me1">getTime</span>.<span class="me1">call</span><span class="br0">&#40;</span>p<span class="br0">&#41;</span>; <span class="co1">// forward to d or fail?</span></pre>
<p>
The ideal solution would be for <code>Date.prototype.getTime</code> and similar methods to be specified as <em>generic</em> methods (i.e. methods applicable to any object), which use the new <a href="doku.php%3Fid=harmony:private_name_objects.html" class="wikilink1" title="harmony:private_name_objects" onclick="return svchk()" onkeypress="return svchk()">private symbol</a> mechanism to lookup state that is unique to Date instances. However, the <a href="doku.php%3Fid=strawman:proxy_symbol_decoupled.html" class="wikilink1" title="strawman:proxy_symbol_decoupled" onclick="return svchk()" onkeypress="return svchk()">interaction between proxies and private symbols</a> is still under discussion.
</p>

</div>
<!-- SECTION [4999-8841] -->
<a name="virtual_objects"></a><h1>Virtual Objects</h1>
<div class="level1">

<p>
 Since this Proxy <acronym title="Application Programming Interface">API</acronym> requires one to pass an existing object as a <code>target</code> to wrap, it may seem that this <acronym title="Application Programming Interface">API</acronym> precludes the creation of fully &ldquo;virtual&rdquo; objects that are not represented by an existing JSObject. It&rsquo;s easy to create such &ldquo;virtual&rdquo; proxies: just pass a fresh empty object as the target to <code>Proxy</code> and implement all the handler traps so that none of them defaults to forwarding, or otherwise touches the <code>target</code>.
</p>

<p>
As long as the virtual proxy doesn&rsquo;t expose non-configurable properties or becomes non-extensible, the target object is fully ignored (except to acquire internal properties such as the target&rsquo;s [[Class]]).
</p>

<p>
To accomodate such virtual object abstractions, and to keep these abstractions in sync with future editions of the spec, we propose built-in library support in the form of a <a href="doku.php%3Fid=harmony:virtual_object_api.html" class="wikilink1" title="harmony:virtual_object_api" onclick="return svchk()" onkeypress="return svchk()">virtual object api</a>.
</p>

</div>
<!-- SECTION [8842-9723] -->
<a name="reflect_module"></a><h1>reflect module</h1>
<div class="level1">

<p>
 Direct proxies are made accessible from a new <a href="doku.php%3Fid=harmony:reflect_api.html" class="wikilink1" title="harmony:reflect_api" onclick="return svchk()" onkeypress="return svchk()">&quot;@reflect&quot; module</a>. This module also contains &ldquo;helper&rdquo; functions that correspond one-to-one to each of the trap methods of the handler <acronym title="Application Programming Interface">API</acronym>. They enable Proxy handlers to conveniently forward an operation to their target object. These methods can also be useful for general reflection use.
</p>

</div>
<!-- SECTION [9724-10112] -->
<a name="interaction_with_prototypal_inheritance"></a><h1>Interaction with Prototypal Inheritance</h1>
<div class="level1">

<p>
 Proxies may be used as prototypes of other objects, e.g. by calling <code>Object.create(proxy)</code>. When a proxy is used as a prototype, some of its traps may get triggered not because the proxy itself was &ldquo;touched&rdquo; by external code, but rather an object that inherits (directly or indirectly) from the proxy:
</p>
<pre class="code javascript"><span class="kw2">var</span> proxy = Proxy<span class="br0">&#40;</span>target, handler<span class="br0">&#41;</span>;
<span class="kw2">var</span> child = Object.<span class="me1">create</span><span class="br0">&#40;</span>proxy<span class="br0">&#41;</span>;
&nbsp;
child<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span>                   <span class="co1">// triggers handler.get(target,name,child)</span>
child<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span> = val             <span class="co1">// triggers handler.set(target,name,val,child)</span>
<span class="kw3">name</span> <span class="kw1">in</span> child                 <span class="co1">// triggers handler.has(target,name)</span>
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> prop <span class="kw1">in</span> child<span class="br0">&#41;</span> <span class="br0">&#123;</span>...<span class="br0">&#125;</span> <span class="co1">// triggers handler.enumerate(target)</span></pre>
<p>
Note that the <code>get</code> and <code>set</code> traps get access to the <code>child</code> on which the original property access or assignment took place. This is in contrast to an &ldquo;own&rdquo; property access, which gets passed a reference to the proxy itself:
</p>
<pre class="code javascript"><span class="kw2">var</span> proxy = Proxy<span class="br0">&#40;</span>target, handler<span class="br0">&#41;</span>;
proxy<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span> <span class="co1">// triggers handler.get(target,name,proxy)</span></pre>
</div>
<!-- SECTION [10113-11207] -->
<a name="invariant_enforcement"></a><h1>Invariant enforcement</h1>
<div class="level1">

<p>
 A proxy ensures that its handler and its target do not contradict each other as far as non-configurability and non-extensibility are concerned. That is: the direct proxy inspects the return values from the handler traps, and checks whether these return values make sense given the current state of its target. If the handler and the target are always consistent, then the enforcement will have no observable effects. Otherwise, upon detection of an invariant violation, the proxy will throw a <code>TypeError</code>.
</p>

<p>
Below is a list of invariants for Objects based on the ES5 spec.
</p>

<p>
Definitions:
</p>
<ul>
<li class="level1"><div class="li"> A <em>sealed property</em> is a non-configurable own property of the target.</div>
</li>
<li class="level1"><div class="li"> A <em>frozen property</em> is a non-configurable non-writable own property of the target.</div>
</li>
<li class="level1"><div class="li"> A <em>new property</em> is a property that does not exist on a non-extensible target.</div>
</li>
<li class="level1"><div class="li"> Two property descriptors <code>desc1</code> and <code>desc2</code> for a property <code>name</code> are <em>incompatible</em> if <code>desc1 = Object.getOwnPropertyDescriptor(target,name)</code> and <code>Object.defineProperty(target,name,desc2)</code> would throw a <code>TypeError</code>.</div>
</li>
</ul>

<p>
 <strong>getOwnPropertyDescriptor</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Non-configurability invariant: cannot return incompatible descriptors for sealed properties </div>
</li>
<li class="level1"><div class="li"> Non-extensibility invariant: must return undefined for new properties</div>
</li>
<li class="level1"><div class="li"> Invariant checks:</div>
<ul>
<li class="level2"><div class="li"> if trap returns undefined, check if the property is configurable</div>
</li>
<li class="level2"><div class="li">  if property exists on target, check if the returned descriptor is compatible</div>
</li>
<li class="level2"><div class="li"> if returned descriptor is non-configurable, check if the property exists on the target and is also non-configurable</div>
</li>
</ul>
</li>
</ul>

<p>
 <strong>defineProperty</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Non-configurability invariant: cannot succeed (return true) for incompatible changes to sealed properties </div>
</li>
<li class="level1"><div class="li"> Non-extensibility invariant: must reject (return false) for new properties</div>
</li>
<li class="level1"><div class="li"> Invariant checks:</div>
<ul>
<li class="level2"><div class="li"> on success, if property exists on target, check if existing descriptor is compatible with argument descriptor</div>
</li>
<li class="level2"><div class="li"> on success, if argument descriptor is non-configurable, check if the property exists on the target and is also non-configurable</div>
</li>
</ul>
</li>
</ul>

<p>
 <strong>getOwnPropertyNames</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Non-configurability invariant: must report all sealed properties</div>
</li>
<li class="level1"><div class="li"> Non-extensibility invariant: must not list new property names </div>
</li>
<li class="level1"><div class="li"> Invariant checks:</div>
<ul>
<li class="level2"><div class="li"> check whether all sealed target properties are present in the trap result</div>
</li>
<li class="level2"><div class="li"> If the target is non-extensible, check that no new properties are listed in the trap result</div>
</li>
</ul>
</li>
</ul>

<p>
 <strong>deleteProperty</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Non-configurability invariant: cannot succeed (return true) for sealed properties</div>
</li>
<li class="level1"><div class="li"> Invariant checks:</div>
<ul>
<li class="level2"><div class="li"> on success, check if the target property is configurable</div>
</li>
</ul>
</li>
</ul>

<p>
 <strong>getPrototypeOf</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Invariant check: check whether the target&rsquo;s prototype and the trap result are identical (according to the <a href="doku.php%3Fid=harmony:egal.html" class="wikilink1" title="harmony:egal" onclick="return svchk()" onkeypress="return svchk()">egal</a> operator)</div>
</li>
</ul>

<p>
 <strong>freeze | seal | preventExtensions</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Invariant checks:</div>
<ul>
<li class="level2"><div class="li"> on success, check if isFrozen(target), isSealed(target) or !isExtensible(target)</div>
</li>
</ul>
</li>
</ul>

<p>
 <strong>isFrozen | isSealed | isExtensible</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Invariant check: check whether the boolean trap result is equal to isFrozen(target), isSealed(target) or isExtensible(target)</div>
</li>
</ul>

<p>
 <strong>hasOwn</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Non-configurability invariant: cannot return false for sealed properties</div>
</li>
<li class="level1"><div class="li"> Non-extensibility invariant: must return false for new properties </div>
</li>
<li class="level1"><div class="li"> Invariant checks:</div>
<ul>
<li class="level2"><div class="li"> if false is returned, check if the target property is configurable</div>
</li>
<li class="level2"><div class="li"> if false is returned, the property does not exist on target, and the target is non-extensible, throw a TypeError</div>
</li>
</ul>
</li>
</ul>

<p>
 <strong>has</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Non-configurability invariant: cannot return false for sealed properties</div>
</li>
<li class="level1"><div class="li"> Invariant checks:</div>
<ul>
<li class="level2"><div class="li"> if false is returned, check if the target property is configurable</div>
</li>
</ul>
</li>
</ul>

<p>
 <strong>get</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Non-configurability invariant: cannot return inconsistent values for frozen data properties, and must return undefined for sealed accessors with an undefined getter </div>
</li>
<li class="level1"><div class="li"> Invariant checks:</div>
<ul>
<li class="level2"><div class="li"> if property exists on target as a data property, check whether the target property&rsquo;s value and the trap result are identical (according to the <a href="doku.php%3Fid=harmony:egal.html" class="wikilink1" title="harmony:egal" onclick="return svchk()" onkeypress="return svchk()">egal</a> operator)</div>
</li>
<li class="level2"><div class="li"> if property exists on target as an accessor, and the accessor&rsquo;s <code>get</code> attribute is undefined, check whether the trap result is also undefined.</div>
</li>
</ul>
</li>
</ul>

<p>
 <strong>set</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Non-configurability invariant: cannot succeed (return true) for frozen data properties or sealed accessors with an undefined setter </div>
</li>
<li class="level1"><div class="li"> Invariant checks:</div>
<ul>
<li class="level2"><div class="li"> on success, if property exists on target as a data property, check whether the target property&rsquo;s value and the update value are identical (according to the <a href="doku.php%3Fid=harmony:egal.html" class="wikilink1" title="harmony:egal" onclick="return svchk()" onkeypress="return svchk()">egal</a> operator)</div>
</li>
<li class="level2"><div class="li"> on success, if property exists on target as an accessor, check whether the accessor&rsquo;s <code>set</code> attribute is not undefined</div>
</li>
</ul>
</li>
</ul>

<p>
 <strong>keys</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Non-configurability invariant: must report all enumerable sealed properties</div>
</li>
<li class="level1"><div class="li"> Non-extensibility invariant: must not list new property names</div>
</li>
<li class="level1"><div class="li"> Invariant checks:</div>
<ul>
<li class="level2"><div class="li"> Check whether all enumerable sealed target properties are listed in the trap result</div>
</li>
<li class="level2"><div class="li"> If the target is non-extensible, check that no new properties are listed in the trap result</div>
</li>
</ul>
</li>
</ul>

<p>
 <strong>enumerate</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Non-configurability invariant: must report all enumerable sealed properties</div>
</li>
<li class="level1"><div class="li"> Invariant checks:</div>
<ul>
<li class="level2"><div class="li"> Check whether all enumerable sealed target properties are listed in the trap result</div>
</li>
</ul>
</li>
</ul>

<p>
 More information about these invariants can be found in the header documentation of the <a href="http://code.google.com/p/es-lab/source/browse/trunk/src/proxies/DirectProxies.js#92" class="urlextern" target="_blank" title="http://code.google.com/p/es-lab/source/browse/trunk/src/proxies/DirectProxies.js#92" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">prototype implementation</a>.
</p>

</div>
<!-- SECTION [11208-16698] -->
<a name="revocable_proxies"></a><h1>Revocable Proxies</h1>
<div class="level1">

<p>
 <a href="doku.php%3Fid=strawman:revokable_proxies.html" class="wikilink1" title="strawman:revokable_proxies" onclick="return svchk()" onkeypress="return svchk()">Revocable proxies</a> are proxies whose <code>target</code>-link can be nulled out, allowing for the target (and the handler) to become eligible for garbage-collection. Revocable proxies are created by calling the factory method <code>Proxy.revocable</code>:
</p>
<pre class="code javascript">let <span class="br0">&#123;</span> proxy, revoke <span class="br0">&#125;</span> = Proxy.<span class="me1">revocable</span><span class="br0">&#40;</span>target, handler<span class="br0">&#41;</span>;
proxy.<span class="me1">foo</span> <span class="co1">// traps as usual</span>
revoke<span class="br0">&#40;</span><span class="br0">&#41;</span>  <span class="co1">// revokes the proxy, always returns undefined</span>
proxy.<span class="me1">foo</span> <span class="co1">// throws TypeError: &quot;proxy is revoked&quot;</span></pre><ul>
<li class="level1"><div class="li"> The factory method <code>Proxy.revocable(target, handler)</code> returns an object <code>{proxy: proxy, revoke: revoke}</code>.</div>
</li>
<li class="level1"><div class="li"> <code>revoke</code> is a zero-argument function that, when called, revokes its associated proxy.</div>
</li>
<li class="level1"><div class="li"> Revoking an already revoked proxy has no effect.</div>
</li>
<li class="level1"><div class="li"> Once a proxy is revoked, it remains forever revoked.</div>
</li>
<li class="level1"><div class="li"> Revoking a proxy is equivalent to replacing the handler such that all handler traps throw a <code>TypeError</code> unconditionally.</div>
</li>
</ul>

</div>
<!-- SECTION [16699-17664] -->
<a name="draft_spec"></a><h1>Draft Spec</h1>
<div class="level1">

<p>
 See the <a href="doku.php%3Fid=harmony:proxies_spec.html" class="wikilink1" title="harmony:proxies_spec" onclick="return svchk()" onkeypress="return svchk()">proxies spec</a>.
</p>

</div>
<!-- SECTION [17665-17725] -->
<a name="open_issues"></a><h1>Open Issues</h1>
<div class="level1">
<pre class="code">
* Removed ''iterate()'' trap as iterators can be defined on any old object via an ''iterate'' unique name. See discussion at [[harmony:iterators]]. A proxy will intercept the request for its iterator via the ''get'' trap, which is passed the unique ''iterator'' name as argument.</pre>
 
</div>
<!-- SECTION [17726-18037] -->
<a name="discussed_during_tc39_september_2012_meeting_northeastern_u._boston"></a><h4>Discussed during TC39 September 2012 Meeting, NorthEastern U., Boston</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> <a href="https://mail.mozilla.org/pipermail/es-discuss/2012-September/024826.html" class="urlextern" target="_blank" title="https://mail.mozilla.org/pipermail/es-discuss/2012-September/024826.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Enumerate trap signature</a>: consider making the <code>enumerate()</code> trap return an iterator rather than an array of strings. To retain the benefits of an iterator (no need to store collection in memory), we might need to waive the duplicate properties check. Resolution: accepted (duplicate properties check is waived in favor of iterator return type)</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <a href="doku.php%3Fid=strawman:proxies_names.html" class="wikilink1" title="strawman:proxies_names" onclick="return svchk()" onkeypress="return svchk()">proxies and private names</a> strawman: discusses how proxies and private names should interact. Resolution: consensus on adding a new third &ldquo;whitelist&rdquo; argument to <code>Proxy</code> to control interaction with private names.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <a href="doku.php%3Fid=strawman:revokable_proxies.html" class="wikilink1" title="strawman:revokable_proxies" onclick="return svchk()" onkeypress="return svchk()">revokable proxies</a> strawman: required to implement caretaker proxies that can release their target, so that it can be garbage-collected. Resolution:</div>
<ul>
<li class="level2"><div class="li"> Consensus on the need for revocable proxies.</div>
</li>
<li class="level2"><div class="li"> Further discussion is needed on whether frozen objects (and in particular: tests such as isFrozen) should be revocable, either via revocable proxies or via traps that throw.</div>
</li>
</ul>
</li>
</ul>

</div>
<!-- SECTION [18038-19205] -->
<a name="discussed_during_tc39_july_2012_meeting_microsoft_redmond"></a><h4>Discussed during TC39 July 2012 Meeting, Microsoft, Redmond</h4>
<div class="level4">

<p>
 <strong>proto and proxies</strong> 
</p>
<ul>
<li class="level1"><div class="li"> If __proto__ is specified normative mandatory per the May TC39 meeting, consider adding a <code>getPrototypeOf</code> trap. This would simplify membranes. Writable __proto__ already destroys the invariant that the [[Prototype]] link is stable. Engines already need to accomodate.</div>
</li>
<li class="level1"><div class="li"> <code>Object.getPrototypeOf(proxy) // &rArr; handler.getPrototypeOf(target)</code></div>
</li>
<li class="level1"><div class="li"> Invariant enforcement: trap must return same prototype object as its target (so the trap by itself doesn&rsquo;t introduce mutable prototype chains)</div>
</li>
<li class="level1"><div class="li"> MarkM: even with mutable __proto__, there are still some invariants to be preserved:</div>
<ol>
<li class="level2"><div class="li"> non-extensible objects should have a stable prototype link</div>
</li>
<li class="level2"><div class="li"> deleting Object.prototype.__proto__ should remove the ability to modify the prototype of objects</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Membranes can use the trap to keep their &ldquo;shadow&rdquo; target in-sync with their &ldquo;real&rdquo; target: if realTarget.[[Prototype]] changed, membrane can set shadowTarget&rsquo;s [[Prototype]] to a wrapped version, then return the wrapped version.</div>
</li>
<li class="level1"><div class="li"> Spec should be refactored so that instead of an internal [[Prototype]] property, there exists an internal method ([[GetProto]]?). Each use of [[GetProto]] in the spec would trigger the <code>getPrototypeOf</code> trap.</div>
</li>
<li class="level1"><div class="li"> Do we need a corresponding <code>setPrototypeOf</code> trap? Depends on how we end up specifying __proto__: if as special data prop, there won&rsquo;t be an observable capability to set prototypes on objects. If as an accessor, then the __proto__ setter applied to a proxy would trigger such a trap. We could also poison the setter, at which point there is no need for <code>setPrototypeOf</code>.</div>
</li>
<li class="level1"><div class="li"> Regardless of how we spec __proto__, proxy.__proto__ should just trigger the proxy&rsquo;s <code>get</code> trap (similar for <code>set</code>). The handler gets to decide whether this property name is magical or not.</div>
</li>
</ul>

<p>
 <strong>trapping instanceof</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Thread on <a href="https://mail.mozilla.org/pipermail/es-discuss/2012-June/023676.html" class="urlextern" target="_blank" title="https://mail.mozilla.org/pipermail/es-discuss/2012-June/023676.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">es-discuss</a>: should <code>instanceof</code> trap? See earlier <a href="doku.php%3Fid=strawman:proxy_instanceof.html" class="urlextern" target="_blank" title="http://wiki.ecmascript.org/doku.php?id=strawman:proxy_instanceof" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">strawman</a> for how this could work. Does giving the RHS function access to the LHS instance consistute a serious capability leak?</div>
</li>
<li class="level1"><div class="li"> <code>x instanceof Proxy(t,h) &rArr; h.hasInstance(t,x)</code></div>
</li>
<li class="level1"><div class="li"> Proposed solution is OK but maybe better done via a private name? Discussion: how do we decide on private name vs. trap? If it has invariants associated with it, definitely need a trap.</div>
</li>
<li class="level1"><div class="li"> On the issue of the &ldquo;capability leak&rdquo; of giving the RHS access to the LHS: there is little or no legacy capability-secure code that would rely on the current expectation that LHS and RHS don&rsquo;t get access to each other. In going forward, we can just explain <code>instanceof</code> as sending a message to the RHS, passing LHS as argument (explicit capability grant rather than a &ldquo;leak&rdquo;).</div>
</li>
</ul>

<p>
 <strong>trapping isSealed and friends</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Make <code>Object.{isExtensible, isSealed, isFrozen}</code> trappable for direct proxies. This would again simplify membranes (makes it possible to maintain the extensibility state of the wrapped target across a membrane). Invariant enforcement would check whether the return value of these traps is consistent with the state of the target.</div>
</li>
</ul>

<p>
 <strong>nativeCall trap</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Built-in methods applied to proxies: for Date, agreed that it would be sensible to &ldquo;unwrap&rdquo; the proxy (e.g. <code>Date.prototype.getTime.call(Proxy(aDate, handler)) &rArr; aDate.getTime()</code>). This seems fine as long as such built-ins don&rsquo;t return an object but just a primitive value. </div>
</li>
<li class="level1"><div class="li"> Instead of auto-unwrapping, could delegate to a generic trap that can decide to forward or do something else: <code>Date.prototype.getYear.call(Proxy(t, h)) &rArr; h.nativeCall(t, Date.prototype.getYear, [])</code></div>
</li>
<li class="level1"><div class="li"> potential capability leak: the trap gets access to the function, which could be a closely held capability that shouldn&rsquo;t be leaked to the proxy.</div>
</li>
<li class="level1"><div class="li"> Conclusion: let&rsquo;s not introduce such a trap. Instead, wherever we think we need this trap, try to turn the non-generic method into a generic method so that the method becomes applicable to Objects/Proxies.</div>
</li>
<li class="level1"><div class="li"> Example: for Date.prototype methods, we might represent [[PrimitiveValue]] as a unique name, so any object with the unique name could mimic Date instances and be a valid this-binding of the <code>Date.prototype</code> methods.</div>
</li>
</ul>

<p>
 <strong>Proxies and private names</strong> 
</p>
<ul>
<li class="level1"><div class="li"> <code>proxy[name]</code> triggers <code>handler.getName(target, name.public)</code> trap</div>
</li>
<li class="level1"><div class="li"> trap returns either:</div>
<ol>
<li class="level2"><div class="li"> <code>[ name, value ]</code> : by returning the name object, handler can &ldquo;prove&rdquo; to the proxy that it indeed knows about the private name, and can provide the corresponding value</div>
</li>
<li class="level2"><div class="li"> <code>undefined</code>: handler signals to proxy &ldquo;I don&rsquo;t know about this private name, please forward to the target&rdquo;</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> For all traps that take a property name string, we now need an equivalent trap that takes a &lsquo;name object&rsquo;. All of these &ldquo;Name&rdquo; traps have the same interface as getName: they consume the .public property of a Name, and must provide either a tuple with the original Name, or undefined to auto-forward.</div>
</li>
</ul>

<p>
 <strong>VirtualHandler</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Fundamental traps in the VirtualHandler: change from &ldquo;abstract&rdquo; methods that throw to forwarding to the target.</div>
</li>
<li class="level1"><div class="li"> Rename VirtualHandler to just Handler.</div>
</li>
</ul>

<p>
 <strong>defaultValue</strong> 
</p>
<ul>
<li class="level1"><div class="li"> Do we want a <code>defaultValue</code> trap that intercepts internal invocations to the built-in [[DefaultValue]] method on Proxies, or do we want to expose it via a privately named property, or just inherit the default Object behavior for Proxies? Sentiment at the July TC39 meeting was against adding a trap &ndash; with <a href="doku.php%3Fid=strawman:value_objects.html" class="wikilink1" title="strawman:value_objects" onclick="return svchk()" onkeypress="return svchk()">value objects</a> we&rsquo;d want more choices than number and string as return types.</div>
</li>
</ul>

</div>
<!-- SECTION [19206-24918] -->
<a name="references"></a><h1>References</h1>
<div class="level1">
<ul>
<li class="level1"><div class="li"> <a href="https://github.com/tvcutsem/harmony-reflect" class="urlextern" target="_blank" title="https://github.com/tvcutsem/harmony-reflect" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Prototype implementation</a> based on the old Proxy <acronym title="Application Programming Interface">API</acronym> as implemented in Firefox 4/Chrome 17: after loading this file, the page effectively has access to the Proxy <acronym title="Application Programming Interface">API</acronym> as specified here.</div>
</li>
</ul>

</div>
<!-- SECTION [24919-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/c/ccabb6b17b461fb251f1b56df2370a75.xhtml used -->
</body>
</html>
