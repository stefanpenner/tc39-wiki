<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=strawman:relationships&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=strawman" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=strawman:relationships&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=strawman:relationships&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:relationships&amp;do=export_html.html#relationships" class="toc">Relationships</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:relationships&amp;do=export_html.html#semantics_expository_syntax" class="toc">Semantics, Expository Syntax</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:relationships&amp;do=export_html.html#interactions_with_proxies" class="toc">Interactions with Proxies</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:relationships&amp;do=export_html.html#geti_and_seti_behavior_on_weakmaps_and_maps" class="toc">@geti and @seti behavior on WeakMaps and Maps</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:relationships&amp;do=export_html.html#how_this_answers_some_open_design_questions" class="toc">How this answers some open design questions</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:relationships&amp;do=export_html.html#why_we_need_both_unique_symbols_and_private_fields" class="toc">Why we need both unique symbols and private fields</a></span><ul class="toc">
<li class="clear"><ul class="toc">
<li class="clear"><ul class="toc">
<li class="level5"><span class="li"><a href="doku.php%3Fid=strawman:relationships&amp;do=export_html.html#use_case_for_something_like_unique_symbols_public_symbols_guids_funny-looking_strings" class="toc">Use case for something like unique symbols / public symbols / guids / funny-looking strings</a></span></li>
<li class="level5"><span class="li"><a href="doku.php%3Fid=strawman:relationships&amp;do=export_html.html#use_case_for_something_like_private_symbols_weak_maps_fields" class="toc">Use case for something like private symbols / weak maps / fields</a></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<a name="relationships"></a><h1>Relationships</h1>
<div class="level1">

<p>
 This proposal is based on input gathered from the March 2013 TC39 meeting, after MarkM&rsquo;s discussion of &ldquo;relationships&rdquo;: <a href="lib/exe/fetch.php%3Fid=strawman%253Arelationships&amp;cache=cache&amp;media=meetings:relationships.pdf" class="urlextern" title="meetings:relationships.pdf" style="background-image: url(lib/images/fileicons/pdf.png)" onclick="return svchk()" onkeypress="return svchk()">relationships.pdf</a>
</p>

<p>
Currently, there are three core abstractions by which an object x can represent that it is in a relationship r with a value y, depending on the kind of object that r is:
</p>
<ul>
<li class="level1"><div class="li"> If r is a string, then r names a property whose value is y. This property respects all the normal reflective rules.</div>
</li>
<li class="level1"><div class="li"> If r is a unique symbol, then r names a property whose value is y. This property respects all the normal reflective rules.</div>
</li>
<li class="level1"><div class="li"> If r is a so-called &ldquo;private symbol&rdquo;, then x makes visible only to those who hold r that x is in the r relationship with y. This is hidden from the normal reflective rules, to prevent discovery (getOwnPropertyNames) and theft (proxy traps).</div>
</li>
</ul>

<p>
 In addition, if r is any value other than the above cases, then r is coerced to a string, and this stringified r is used according to the first case above.
</p>

<p>
In this proposal, we make &ldquo;unique symbols&rdquo; and so-called &ldquo;private symbols&rdquo; more different from each other. The unqualified &ldquo;symbol&rdquo; means the same thing as &ldquo;unique symbol&rdquo;, and represents a new primitive type that can be used to name properties much as strings can. Their novel feature is their unforgeable uniqueness &ndash; the only way to obtain a particular symbol is either to create the symbol or to obtain it from something that already has access to it. Thus, unlike strings, they can be used to name properties with fewer worries about <em>accidental</em> collisions.
</p>

<p>
By contrast, so-called &ldquo;private symbols&rdquo; become &ldquo;field&rdquo; objects. When r is a field, then we would equivalently say &ldquo;x has an r field whose value is y.&rdquo; Both fields and properties are forms of relationship.
</p>

<p>
This strawman is primarily about semantics, but we introduce some expository syntactic conventions for discussing these semantics. Whether this syntax itself becomes accepted is a separate debate.
</p>

</div>
<!-- SECTION [1-1974] -->
<a name="semantics_expository_syntax"></a><h2>Semantics, Expository Syntax</h2>
<div class="level2">
<pre class="code javascript">  x @ r <span class="co1">// The object x is in the r relationship with what value?</span>
  x @ r = y; <span class="co1">// Store that x is in the r relationship with value y.</span></pre>
<p>
The syntax above can be used for all three kinds of r, and therefore for both forms of relationship. The key is that the semantics of &ldquo;<code>@</code>&rdquo; does case splitting on the kind of value r is. To do so, we need to determine whether r represents a field object but without breaking compatibility with pre-ES6 JavaScript code. The test looks like a duck typing test, in that we&rsquo;re detecting presence or absence of properties, but we&rsquo;re doing this for unique-symbol-named properties rather than string valued properties. Thus, we avoid the <em>accidental</em> collision dangers of string-based duck typing, and avoid breaking legacy code.
</p>

<p>
We assume two unique symbols for this purpose, which we name &ldquo;<code>@geti</code>&rdquo; and &ldquo;<code>@seti</code>&ldquo;. We add methods for these symbols to <code>Map.prototype</code> and <code>WeakMap.prototype</code>, enabling their instances to pass this safe duck typing test so that they can serve as fields.
</p>
<pre class="code">
  xExpr @ relExpr
    let x = the result of evaluating the xExpr expression
    let r = the result of evaluating the relExpr expression
    return the result of calling [[GetRelationship]](x, r)

  [[GetRelationship]](x, r)
    if r is a string or symbol, or if (let getter = r.[[Get]](@geti)) is undefined, then
      return the value of x.[[Get]]( r ), i.e.
      // In this case, &quot;x@r&quot; means the same thing as &quot;x[r]&quot;
    else
      return the result of getter.[[Call]](r, x)
      // In this case, &quot;x@r&quot; mean the same as &quot;r[@geti](x)&quot;
</pre>
<pre class="code">
  xExpr @ relExpr = yExpr
    let x = the result of evaluating the xExpr expression
    let r = the result of evaluating the relExpr expression
    let y = the result of evaluating the yExpr expression
    return the result of calling [[SetRelationship]](x, r, y)

  [[SetRelationship]](x, r, y)
    if r is a string or symbol, or if (let setter = r.[[Get]](@seti) is undefined, then
      return the value of x.[[Set]](r, y), i.e.
      // In this case, &quot;x@r = y&quot; means the same thing as &quot;x[r] = y&quot;
    else      
      return the result of setter.[[Call]](r, x, y)
      // In this case, &quot;x@r = y&quot; mean the same as &quot;r[@seti](x, y)&quot;
</pre>

</div>
<!-- SECTION [1975-4279] -->
<a name="interactions_with_proxies"></a><h2>Interactions with Proxies</h2>
<div class="level2">

<p>
 The [[GetRelationship]] and [[SetRelationship]] internal functions do not themselves trap, nor do they test if any of their operands are proxies. Rather, by engaging in the logic specified above, when their operands are proxies, they trigger traps on these proxies. To understand how, let&rsquo;s explore how xExpr@relExpr executes when both operand expressions evaluate to proxies.
</p>
<ol>
<li class="level1"><div class="li"> The expressions are evaluated and [[GetRelationship]](x, r) is called.</div>
</li>
<li class="level1"><div class="li"> r is neither a string nor a symbol</div>
</li>
<li class="level1"><div class="li"> &ldquo;let getter = r.[[Get]](@geti)&rdquo; triggers r&rsquo;s &ldquo;get&rdquo; trap with unique symbol @geti as the property name.</div>
</li>
<li class="level1"><div class="li"> Whatever r&rsquo;s get trap returns is the getter.</div>
</li>
<li class="level1"><div class="li"> If the getter is undefined, then</div>
<ol>
<li class="level2"><div class="li"> &ldquo;x.[[Get]]( r )&rdquo; will trigger x&rsquo;s &ldquo;get&rdquo; trap, but with a stringification of r (since r is not a unique symbol)</div>
<ol>
<li class="level3"><div class="li"> let toString = r.[[Get]](&rdquo;toString&rdquo;)</div>
</li>
<li class="level3"><div class="li"> let rStr = toString.[[Call]](r, [])</div>
</li>
<li class="level3"><div class="li"> (Fill in remaining steps of coercion to string)</div>
</li>
<li class="level3"><div class="li"> trigger x&rsquo;s get trap with rStr as the property name.</div>
</li>
</ol>
</li>
<li class="level2"><div class="li"> Return what x&rsquo;s get trap returns.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> else</div>
<ol>
<li class="level2"><div class="li"> return getter.[[Call]](r, x)</div>
</li>
</ol>
</li>
</ol>

<p>
 Note that, if getter is itself a proxy, then the last line above triggers the getter&rsquo;s &ldquo;call&rdquo; trap.
</p>

</div>
<!-- SECTION [4280-5545] -->
<a name="geti_and_seti_behavior_on_weakmaps_and_maps"></a><h2>@geti and @seti behavior on WeakMaps and Maps</h2>
<div class="level2">
<pre class="code javascript">  <span class="kw2">function</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>MapGetInherited<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#40;</span><span class="kw1">this</span>, base<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">while</span> <span class="br0">&#40;</span>base !== <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span><span class="br0">&#91;</span>MapHas<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#40;</span><span class="kw1">this</span>, base<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>MapGet<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#40;</span><span class="kw1">this</span>, base<span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>
      base = base.<span class="br0">&#91;</span><span class="br0">&#91;</span>GetPrototype<span class="br0">&#93;</span><span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">void</span> <span class="nu0">0</span>;
  <span class="br0">&#125;</span>
  Map.<span class="me1">prototype</span><span class="br0">&#91;</span>@geti<span class="br0">&#93;</span> = <span class="br0">&#91;</span><span class="br0">&#91;</span>MapGetInherited<span class="br0">&#93;</span><span class="br0">&#93;</span>;
  Map.<span class="me1">prototype</span><span class="br0">&#91;</span>@seti<span class="br0">&#93;</span> = <span class="br0">&#91;</span><span class="br0">&#91;</span>MapSet<span class="br0">&#93;</span><span class="br0">&#93;</span>;
&nbsp;
  <span class="kw2">function</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>WeakMapGetInherited<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#40;</span><span class="kw1">this</span>, base<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">while</span> <span class="br0">&#40;</span>base !== <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#91;</span><span class="br0">&#91;</span>WeakMapHas<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#40;</span><span class="kw1">this</span>, base<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> <span class="br0">&#91;</span><span class="br0">&#91;</span>WeakMapGet<span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#40;</span><span class="kw1">this</span>, base<span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>
      base = base.<span class="br0">&#91;</span><span class="br0">&#91;</span>GetPrototype<span class="br0">&#93;</span><span class="br0">&#93;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="kw1">void</span> <span class="nu0">0</span>;
  <span class="br0">&#125;</span>
  WeakMap.<span class="me1">prototype</span><span class="br0">&#91;</span>@geti<span class="br0">&#93;</span> = <span class="br0">&#91;</span><span class="br0">&#91;</span>WeakMapGetInherited<span class="br0">&#93;</span><span class="br0">&#93;</span>;
  WeakMap.<span class="me1">prototype</span><span class="br0">&#91;</span>@seti<span class="br0">&#93;</span> = <span class="br0">&#91;</span><span class="br0">&#91;</span>WeakMapSet<span class="br0">&#93;</span><span class="br0">&#93;</span>;</pre>
<p>
In other words, initially Map.prototype.set === Map.prototype[@seti]. Map.prototype[@geti] is like Map.prototype.get, except that it follows the argument&rsquo;s prototype chain upward until it finds it as a key or it exhausts the prototype chain.
</p>

<p>
Semantically, likewise for WeakMaps. However, WeakMaps are expected to store their associations as weakmap&rarr;value fields within the key objects, much as properties are stored within these key objects. Thus, the implementation of [[WeakMapGetInherited]] should reuse all the machinery already built for optimizing inherited property lookup.
</p>

</div>
<!-- SECTION [5546-6858] -->
<a name="how_this_answers_some_open_design_questions"></a><h2>How this answers some open design questions</h2>
<div class="level2">

<p>
 Q: Should we scope this get/set protocol of private symbols only to proxies, or should we open it up to arbitrary objects? (so that <code>nonProxy[psymbol]</code> also triggers the symbol&rsquo;s &ldquo;get&rdquo; method)
</p>

<p>
A: Open it up to arbitrary objects. This is necessary anyway to achieve transparency across membranes. 
</p>

<p>
Q: Do we want to introduce a separate &ldquo;private symbol&rdquo; type, or instead adapt WeakMaps to play the role of private symbols?
</p>

<p>
A: Since so-called &ldquo;private symbols&rdquo;, i.e., fields, are duckish typed by the presence of @geti and @seti, we enable WeakMaps and WeakMap proxies to be used as fields, but we do not preclude other objects from being used as fields. However, to get efficient lookup by built-in support, it seems we cannot do better than the optimizations expected for WeakMaps anyway.
</p>

<p>
Q: Should unique symbols follow the same protocol as private symbols w.r.t. interception by proxies?
</p>

<p>
A: Absolutely not. Regarding how they cross the proxy boundary, unique symbols and fields are opposites. Unique fields cross the boundary by trapping on the base object, whereas fields cross the boundary by trapping on the field (see below for more).
</p>

</div>
<!-- SECTION [6859-8063] -->
<a name="why_we_need_both_unique_symbols_and_private_fields"></a><h2>Why we need both unique symbols and private fields</h2>
<div class="level2">

<p>
 There has been a lot of debate re. whether ES needs both unique symbols <em>and</em> private fields, given that both features provide some form of collision-free namespacing. However, from a mutability and sharing perspective, they serve opposite use cases, and so both appear necessary.
</p>

<p>
Paraphrasing from MarkM&rsquo;s post on <a href="http://esdiscuss.org/topic/unique-public-symbols-as-strings#content-24" class="urlextern" target="_blank" title="http://esdiscuss.org/topic/unique-public-symbols-as-strings#content-24" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">es-discuss</a>:
</p>

</div>
<!-- SECTION [8064-8533] -->
<a name="use_case_for_something_like_unique_symbols_public_symbols_guids_funny-looking_strings"></a><h5>Use case for something like unique symbols / public symbols / guids / funny-looking strings</h5>
<div class="level5">

<p>
 Given that <code>base@r = v</code> succeeds at mutating something, we account for the mutable state as belonging to <code>base</code>. This allows <code>r</code> to be  transitively immutable, and so sharable between subsystems that should not be able to communicate. All the unique symbols mentioned in the ES6 spec itself are of this form. Clearly, everyone (even across  realms) must mean the same thing by <code>@iterator</code>, and so <code>@iterator</code> should not be mutable.
</p>

<p>
When doing the operation across a membrane, where let&rsquo;s say the  original of all three objects are on the other side of the membrane,  it should be the proxy for the <code>base</code> object which traps the operation. Ideally, <code>r</code> should not be proxied, but should pass through the membrane in both directions untranslated.
</p>

<p>
By trapping at <code>base</code>, a <code>base</code> proxy which did not know <code>r</code> is able to obtain <code>r</code> in its trap handler.
</p>

</div>
<!-- SECTION [8534-9506] -->
<a name="use_case_for_something_like_private_symbols_weak_maps_fields"></a><h5>Use case for something like private symbols / weak maps / fields</h5>
<div class="level5">

<p>
 Given that <code>base@r = v</code> succeeds at mutating something, we account for the mutable state as belonging to <code>r</code>. This allows <code>base</code> to be transitively immutable, and so sharable between subsystems that should not be able to communicate. (Note that, although we account for the mutable state as belonging to <code>r</code> in the semantics, the implementation should always store the actual mutable state in the storage record implementing the base object, just as it would do for an internal property.)
</p>

<p>
When doing the operation across a membrane, where let&rsquo;s say the original of all three objects are on the other side of the membrane, it should be the proxy for the <code>r</code> object which traps the operation.
</p>

<p>
By trapping at <code>r</code>, an <code>r</code> proxy which did not know <code>base</code> is able to obtain the base in its trap handler. 
</p>

</div>
<!-- SECTION [9507-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/6/6e46a99c65a85becdf4e989436ceb01f.xhtml used -->
</body>
</html>
