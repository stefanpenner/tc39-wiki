I've started a separate [[formal type system]] page for discussion of the formal definition of the type system.

 --- //[[dherman@ccs.neu.edu|Dave Herman]] 2006/05/02 09:06//

The conclusion on the structural type system have been broken out as [[proposals:structural types and typing of initializers]], and there are many links off that proposal to type-related pages.

 --- //[[lth@opera.com|Lars T Hansen]] 2006/05/23 04:12//

I'm archiving some older, settled discussions under the ''discussions:'' namespace, trying to reclaim this page for its original purpose.  I'm leaving links from here to the archival pages.

 --- //[[jorendorff@mozilla.com|Jason Orendorff]] 2007/07/03 06:00//



====== Notes ======

My current type system notes.   --- //[[lth@opera.com|Lars T Hansen]] 2006/04/07 03:20//

===== The unparameterized type system =====

==== Primitive types ====

These are the primitive types: 

  * #VOID
  * #NULL
  * #OBJECT


==== Type relationships ====

Any type is a subtype of itself:

<code>
     t <: t
</code>

Relationships for other types are given below.



==== Union types ====

Union types have the following structure:

<code>
      (union t1 .. tn)
</code>

where the types are distinct and the ordering of the t1 .. tn has no impact on the meaning of the type.

The built-in type #ANY, written simply "*", is a union type:

<code>
      #ANY = (union #VOID #NULL #OBJECT)
</code>

A type t is a subtype of a union type (sum t1 .. tn) if it is a subtype of any of
the constituent types t1 .. tn:

<code>
      t <: (union t1 .. tn) iff (t <: t1) or ... or (t <: tn)
</code>

A union type s is a subtype of another type t if every member of s is a subtype
of t:

<code>
      (union s1 .. sn) <: t iff s1 <: t and ... and sn <: t
</code>

Union types are flattened when included in a union:

<code>
      (union (union s1 ... sn) t1) => (union s1 ... sn t1)
</code>

==== Nullable types ====

A "nullable type", written "?typename", is a union type with #NULL:

<code>
      ?Object = (union #OBJECT #NULL)
</code>

A "non-nullable type", written "typename!", is a type that is not a union
with #NULL:

<code>
      Object! = #OBJECT
</code>

You can't write "?typename!", "??typename", or similar nonsense; the compiler 
will yell at you if you do.  See [[proposals:syntax for type expressions]].

The rules for the nullability operators are:

<code>
      ?(union #NULL x) -> (union #NULL x)
      ?x               -> (union #NULL x)
      (union #NULL x)! -> x
      x!               -> x 
</code>

==== Other built-in types ====

In addition to #VOID, #NULL, #OBJECT, and #ANY there are built-in types 
#STRING, #NUMBER, #BOOLEAN, #ARRAY, #REGEXP, #DATE, #NAMESPACE, #INT, 
and #UINT, all of which are direct subtypes of #OBJECT.  (Yes, even 
#INT and #UINT, though it would seem more natural if these were seen 
as subtypes of #NUMBER?)


==== Type environment ====

The type environment maps type names to type values.  

The initial type environment contains the following bindings:

<code>
    Object    -> (sum #NULL #OBJECT)
    String    -> (sum #NULL #STRING)
    Number    -> #NUMBER
    Boolean   -> #BOOLEAN
    Array     -> (sum #NULL #ARRAY)
    RegExp    -> (sum #NULL #REGEXP)
    Date      -> (sum #NULL #DATE)
    int       -> #INT
    uint      -> #UINT
</code>

==== Class and interface types ====

Class and interface definitions introduce bindings for nullable types named 
by the class and interface names.  Thus a class name C maps to the type 
(sum C.class #NULL) in the type environment.

The #NULL part of the type is stripped away when the class or interface is used
in contexts where it is not meaningful, notably when the class or interface is
used to define a derived class or interface.

Class types have the following structure:

<code>
      (class <name> (extends <classtype> ...) 
                    (implements <interfacetype> ...)
                    (methods <functiontype> ...)
                    (properties <type> ...)
                    (attributes XXX ...))
</code>

The "extends" list lists all classes that this class extends, in
inheritance order from most specific superclass to least specific.  The
last class in the list is always #OBJECT.

The "implements" list lists all interfaces that this class implements, without
duplicates, sorted in lexicographic order by the interface name.


Interface types have the following structure:

<code>
      (interface <name> (extends <interfacetype> ...)
                        (methods <functiontype> ...)
                        (attributes XXX ...))
</code>

The "extends" list lists all interfaces that this class extends, without
duplicates, sorted in lexicographic order by the interface name.

Class names and interface names are fully qualified by their package names.

Class and interface names are globally unique since duplicate names aren't 
allowed in the same package scope and the package name acts as a prefix
on classes and interfaces inside the package.

A class D is a subtype of type B if B appears on D's extends list, ie, D=B
or there exist classes D=C1 .. Cn=B in the program forming a chain of direct 
superclasses from D to B.

A class D is of interface type I if I appears on D's implements list.

An interface I extends an interface type J if J appears on I's extends list.

A class D may have a class B on its extends list iff:
  * (many rules here)

A class D may have an interface I on its implements list iff:
  * (many rules here)

An interface I may have an interface J on its extends list iff:
  * (many rules here)

==== Literals ====

<code>
Integer in range -2^31..2^31-1            #INT
Integer in 2^31..2^32-1                   #UINT
Number outside #INT/#UINT range           #NUMBER
null                                      #NULL
true, false                               #BOOLEAN
{ field, ... }                            #OBJECT
[ value, ... ]                            #ARRAY
"..." or '...'                            #STRING
/.../...                                  #REGEXP
</code>

==== Function types ====

Function types have the following structure:

<code>
      (function (t1 .. tn) a? tt tr)
</code>

where ''t1'' through ''tn'' are the types of the formal arguments; ''a?'' is a flag saying whether the last parameter is a rest argument; ''tt'' is the constrained type of ''this''; and ''tr'' is the return type.

If ''a?'' is true then ''tn'' is always an Array type.

A function definition yields a function type for the function, but this type is unnamed and not present in the type environment.

A syntax for defining both unnamed and named function types is described in the proposal [[proposals:syntax for function types]]. 

The relationship (function (f1 .. fn) fa? ft fr) <: (function (g1 .. gn) ga? gt gr) if
  * gi <: fi for all i
  * gt <: ft
  * fr <: gr
  * fa? = ga?


==== Object and array types =====

Structural object types (sometimes called record types) provide a partial description (a view) of the structure of an object.

Record types provide useful types to the object system of the ECMAScript 3 sublanguage.  While it's possible to talk about this sublanguage using the type ''Object'' for the types of the objects constructed, stored, passed, and returned, doing so provides very little information in a language where everything's derived from ''Object''.  Record types allow these objects to be described more carefully.

Record types are for now only described in terms of plain ECMAScript 3 objects.

At this time it is unclear what adding record types to the language will do to the language, especially in terms of the performance of dynamic type checking.  The way they are written up here, record types are like undeclared interfaces: a datum of any type may conform to a record type at run-time.  

A record type has this structure:

    (object (name1 type1) ...)

The type states that any object conforming to the type contains the named fields with the given types (or subtypes thereof).

Array types are simply object types:

    (object (0 t1) ... (* tn) (length uint))

where the field name * signifies all nonnegative integer names below 2^32 not mentioned elsewhere in the list of fields.

Subtyping of object types is straightforward:

    (object (x t)) <: (object)

for any x and t, and

    (object (x t1)) <: (object (x t2))

if ''t1 <: t2''.

The subtyping rule extends to instances of classes: consider

    class C {
        var x : int, y : int;
    }

We have that 

    C <: (object (x int) (y int))

(though not in the other direction).

==== Conversions ====

A type A can be used where another type B is expected even if A is not a 
subtype of B, provided a run-time conversion exists from values of type A 
to values of type B.  The conversions may only apply in some contexts.

The following conversions are built-in.

Always valid:

<code>
   #INT          -> #NUMBER
   #UINT         -> #NUMBER
   #NUMBER       -> #INT
   #NUMBER       -> #UINT
   #INT          -> #UINT
   #UINT         -> #INT
</code>

(At this point it should be clear that int and uint are just hints to the
compiler to generate better code.)

The following conversion applies in conditional-expression contexts, ie, in 
do-while, if, for, and while statements and in conditional expressions:

<code>
   #ANY          -> #BOOLEAN
</code>

(There are others.)


===== The parameterized type system =====

Class, interface, and function types can be parameterized.  A parameterized
type is seen as a function from types to types.

Parameterized types appear in the type environment with a structure that
looks like this:

<code>
    (ptype (I1 .. In) Tr)
</code>

where the I1 .. In are just parameter names and the T is a template into which
the actual (type) values of the I1 .. In are inserted to create a new type.

Thus the mapping

<code>
    Pair -> (ptype (I1 I2) (class (Pair I1 I2) ... 
                                  (methods ((head (function () I1)) 
                                            (tail (function () I2))))))
</code>

applied to #INT, #STRING becomes the class type

<code>
    (class Pair#INT#STRING
           (methods ((head (function () #INT)) 
                     (tail (function () #STRING))))))
</code>

Parameterized types applied to the same parameters yield types that are equal,
ie, ''Pair(int,String) = Pair(int,String)''.





====== Types for literals ======

See [[discussion:object literals, type of]].





====== RELAX-NG types ======

I mentioned this above, but it got passed over. I suspect we're just too late in the process for ES4 to support anything like it, but I feel I'd be doing a disservice if I didn't suggest that we at least //leave room// for types which are compatible with RELAX-NG / Xduce / Cduce in the future. 

Briefly, this is a type system:

  * Oriented towards typing XML documents (XML people call types "schemas")
  * Supporting types which are structural combinations of named elements and attributes
  * Structural combination rules are similar to regular expressions: 
    * Sequence, Alternation, Kleene-star

Note that we are already talking about supporting structural array types with simple sequential specification (interpreted as records with integer fields), and permitting Kleene-star //in tail position// of such types. So we're not necessarily very far from RELAX-NG types.

Possible advantages here involve trying to improve the types in E4X; currently I think they'll all just wind up with ''XML'' or ''DOM'' type. It might be nice to be able to say //which kind// of XML document a function takes.

Another possible applpication is in writing typed destructuring assignments on XML documents or regexps. I can only vaguely imagine what a syntax for that might look like.

<code>
// Bind a sequence of meta tags to m
let m : <meta>*;
<><html><head><{meta*: m}></head><{*}></html></> = xhtml_producer();
</code>

Ugh, I sort of wish I hadn't written this note. But there it is. Is it worth leaving the door open? Is the parser for type expressions in a safe enough corner of the grammar that we'll be safe sticking ''*'' and ''+'' and whatnot in there in the future?

 --- //[[graydon@mozilla.com|graydon]] 2006/05/12 17:11//

Graydon, see "The XML connection" near the bottom of [[proposals:destructuring assignment]] -- Ed proposed something like this in a meeting (at Adobe in SF, IIRC) in thinking about destructuring using object and array "literals", and other "literals", to which Lars replied "provocative!" and wrote up that paragraph.

There's clearly something here.  Since we are not folding E4X into Edition 4, I would like to see this pursued in the "E4X for ES4" update. You are quite right that E4X needs something very much like the type systems developed by Pierce et al.

In the mean time, for ES4, what should we do to future-proof?

 --- //[[brendan@mozilla.org|Brendan Eich]] 2006/05/13 17:02//

I'm not sure we know what to do to future-proof. I think at least:

  * The type system, formally, has to be OK supporting it. We currently have type constructors for sequences (in arrays) with trailing kleene stars. We'd need to be sure that sequences of elements with arbitrary kleene stars and alternatives can participate in the type system without ruining the type and subtype judgments.
  * The type grammar needs to have some room for extension, so we can //denote// such types.
  * (Optionally) the destructuring assignment grammar needs to have some room for extension.

It's good to hear that this round will not be including merger with E4X; we've mentioned it so many times during discussion that I wasn't sure.

 --- //[[graydon@mozilla.com|graydon]] 2006/05/16 12:04//

We started our discussion of structural types by imagining that primitive types like ''Function'', ''Array'', and ''Object'' would have type parameters, but we now have dedicated syntax for these. I propose we eliminate the type parameters from ''Function'', ''Array'', and ''Object'', since we don't have a way of expressing variable-arity type parameters, which would make it impossible to implement these classes in ECMAScript a la [[proposals:builtin classes]]. I would think it'd be far more trouble than it's worth to add variable-arity type parameters just for these three special cases, especially since it's duplicating functionality we already get from the ''function'', ''[..]'', and ''{..}'' type constructor syntax.

So I propose that types ''Function'', ''Array'', and ''Object'' are unparameterized classes. From the standpoint of the type checker, these types are interchangeable with ''function(this:*, ...rest:*):*'', ''[*]'', and ''{}'', respectively. If programmers want more precise structural types they should use the structural type syntax.

Does that sound reasonable?

 --- //[[dherman@ccs.neu.edu|Dave Herman]] 2006/08/11 17:16//

Yes, it sounds reasonable.  (I'd much rather write ''[int]'' than ''Array.<int>'' anyway.)

 --- //[[lth@opera.com|Lars T Hansen]] 2006/08/23 09:28//

====== Notes, take 2 ======

**These were moved here from [[spec:type_system]] on 2007/03/11 by Dave.**

Beginnings of a draft spec unifying all the aspects of the type system.

 --- //[[dherman@ccs.neu.edu|Dave Herman]] 2006/08/11 17:03//

====== Abstract syntax for types ======

Types :

<code ebnf>
T ::= *
   |  Identifier
   |  (FUNCTION (THIS T) (ARGS T1 .. Tn) REST? (RETURN T))  // REST is a type, or the null pointer
   |  (UNION T ..)                                // Ordered, for conversions
   |  (OBJECT (Identifier T) ..)
   |  (ARRAY T .. T) // last element is a "rest" type
   |  (PARAMETERIZED Identifier T ...)

// these are a subset of Identifier
P ::= intrinsic::Null
   |  intrinsic::Undefined
   |  intrinsic::Boolean
   |  intrinsic::String
   |  intrinsic::Number
   |  intrinsic::int
   |  intrinsic::uint
   |  intrinsic::double
   |  intrinsic::decimal
   |  intrinsic::Date
   |  intrinsic::RegExp
</code>

The above are an abstract syntax for types. Parsing involves resolving various issues, including: 
    * ''intrinsic::Null'' is always explicit in abstract syntax
    * ''!'' is translated by removing ''intrinsic::Null''
    * ''?'' is translated as ''(UNION intrinsic::Null T)''

Type arguments are always optional; any missing required type parameters are bound to ''*''. It is a semantic error for a type argument list to be longer than its corresponding type parameter list.

<code>
type pairint = [int,int]
type pair.<T> = [T,T];
</code>
In the context of the above type definitions, we consider the type name ''pairint'' to simply be an abbreviation for ''[int,int]'', and so references to ''pairint'' are actually replaced by ''[int,int]'' at some stage during parsing. 

This approach also extends to parameterized type definitions, and so ''pair.<int>'' is also replaced by ''[int,int]'' during parsing. Note that an unparameterized reference to ''pair'' would be equivalent to ''pair.<*>'' or ''[*,*]''.

Thus, in the AST, the only occurrences of (PARAMETERIZED Id ...) is for parameterized class and interface types.

====== Subtyping ======

There are two relationships between types: subtyping and conversion (described below). A type ''T1'' is a subtype of another type ''T2'' if, conceptually, anything you can do with a ''T2'' you can do with a ''T1'' (i.e., a ''T1'' "is a" ''T2'').  We use the symbol <: to mean subtyping. 

The subtyping relation is defined by the following (incomplete) set of rules:
  * Subtyping is reflexively and transitively closed.
  * The type * is the maximal type, that is, every type is a subtype of *.
  * The ''(ARRAY)'' type is equivalent to ''intrinsic::Array''. 
  * The ''(FUNCTION (THIS ?) (ARGS) * (RETURN *))'' type is equivalent to ''intrinsic::Function''. 
  * The ''(OBJECT)'' type is equivalent to ''intrinsic::Object''.
  * Record subtyping is covariant, even though record fields are mutable, thus requiring a check on field writes (much like with arrays in Java). In more detail, a record type ''(OBJECT (Id1 S1) ... (Idm Sm))'' is a subtype of ''(OBJECT (Id1 T1) ... (Idn Tn))'' if
    * m ≤ n
    * the identifiers Id1 .. Idm match  (ordering does not matter)
    * each type Si (for 1 ≤ i ≤ m) is a subtype of Ti
  * For union types, ''(UNION S1 .. Sm)'' is a subtype of ''(UNION T1 .. Tn)'' if each Si is a subtype of some Tj.
    * We consider any type T to be equivalent to the singleton union type ''(UNION T)''. 
    * Thus, a non-union type S is a subtype of ''(UNION T1 .. Tn)'' if S is a subtype of some Tj. 
    * Similarly, ''(UNION S1 .. Sm)'' is a subtype of a non-union type T  if each Si is a subtype of T.
  * Like records, array subtyping is convariant, and again requires a write-barrier check. Array subtyping is complicated somewhat by the presence of rest type. Specifically, ''(ARRAY S1 .. Sm)'' is a subtype of ''(ARRAY T1 .. Tn)'' if
    * Si <: Ti for each 1 ≤ i ≤ min(m,n)
    * Si <: Tn for each n < i ≤ m
    * Sm <: Ti for each m < i ≤ n
  * Function subtyping is complicated by the presence of rest arguments. Specifically, ''(FUNCTION (THIS U)  (ARGS S1  .. Sm) V (RETURN T))'' is a subtype of ''(FUNCTION (THIS U') (ARGS S1' .. Sn') V' (RETURN T'))''     provided that
    * U' <: U (contravariant subtyping on the ''THIS'' argument)
    * Si' <: Si for 1 ≤ i ≤ min(m,n) (contravariant subtyping on arguments)
    * T <: T' (covariant subtyping on the result)
    * In addition, one of the following three cases must hold:
      - Neither function type has rest arguments:
        * V = V' = null
        * m = n (both argument lists are the same length).
      - Only the first function type has rest arguments:
        * V' = null but V != null
        * m ≤ n 
        * Si' <: V for m < i ≤ n.
      - Both function types have rest arguments:
        * V != null and V' != null
        * Si' <: V for m < i ≤ n 
        * V' <: S for n < i ≤ m 
        * V' <: V
  * Subtyping of classes reflects the inheritance hierarchy. That is, if class C extends D, then C is a subtype of D. 
  * This rule gets more complicated in the presence of parameterized class definitions, such as ''class C.<A1, .., Am> extends D.<T1 .. Tn>''. In this case, the instantiated class type ''(PARAMETERIZED C S1 .. Sm)'' is a subtype of ''(PARAMETERIZED D  T1' .. Tn')'', where each Ti' is obtained from T' by replacing each reference to a formal type parameter Aj by the corresponding actual type parameter Sj. 
  * A similar rule applies to classes implementing interfaces, and interfaces extending other interfaces.
  * Each class type is also a subtype of the corresponding object type. That is, given a class declaration
<code>
    class C {
        var x : int, y : int;
    }
</code>
we have that C is a subtype of ''(OBJECT (x int) (y int))'' (though not in the other direction).


----

For record subtyping, don't you want m >= n and the bounds in the next two rules to use n instead of m?  The way I read this, a record {x:T1, y:T2} cannot be a subtype of {x:T1} but that seems wrong.

I also think ''intinsic::Function'' is more complex than you make it, because Function is a class with several instance properties.  It's more like a union of a nominal type (capturing its data structure nature) and the function type you list.

 --- //[[lth@opera.com|Lars T Hansen]] 2006/09/21 07:54//

====== Conversions ======

Some types, such as ''int'' and ''double'', are not subtypes of one another but are still related: it's possible to use an ''int'' as a ''double'' via a runtime conversion. This is the conversion relationship: the type ''int'' is //convertible// to ''double''.
There are a number of places where type conversions occur, e.g.:

  * interconvertible base types like ''int'' and ''double''
  * using something of type * in a statically typed context
  * structural types with convertible component types

In each conversion, a value that has a given tag needs to be converted to some other type.
This check for convertibility is performed statically, although the conversion itself is performed at runtime. The symbol ~<: means convertible. For example, int ~<: double.

The following rules clarify which types are convertible to other types. Convertibility is closely related to, but more general than subtyping, and many of the convertibility rules are quite similar to corresponding subtyping rules.

  * Any type is convertable to boolean.
  * The type * is convertible to every type
  * If S is a subtype of T, then S is (trivially) convertable to T.
  * Convertibility is reflexive, but (unlike subtyping) not transitive. For example, int is convertiable to *, and * is convertable to string, but int is __not__ convertable to string.
  * For union types, (UNION S1 .. Sm) is convertable to (UNION T1 .. Tn) if each Si is convertable to some Tj. **NOTE: What to do about ambiguity?**
  * ''intrinsic::Array'' is convertable to any ''(ARRAY ...)'' type.
  * ''intrinsic::Function'' is convertable to any ''(FUNCTION...)'' type.
  * ''intrinsic::Object'' is convertable to any ''(OBJECT...)'' type.
  * ''(ARRAY S1 .. Sm)'' is convertable to ''(ARRAY T1 .. Tn)'' if
    * Si ~<: Ti for each 1 ≤ i ≤ min(m,n)
    * Si ~<: Tn for each n < i ≤ m
    * Sm ~<: Ti for each m < i ≤ n
  * A record type ''(OBJECT (Id1 S1) ... (Idm Sm))'' is convertable to ''(OBJECT (Id1 T1) ... (Idn Tn))'' if
    * m ≤ n
    * the identifiers Id1 .. Idm match
    * each type Si (for 1 ≤ i ≤ m) is convertable to Ti
  *  ''(FUNCTION (THIS U)  (ARGS S1  .. Sm) V (RETURN T))'' is convertable to ''(FUNCTION (THIS U') (ARGS S1' .. Sn') V' (RETURN T'))''     provided that
    * U' ~<: U  
    * Si' ~<: Si for 1 ≤ i ≤ min(m,n)  
    * T ~<: T'  
    * In addition, one of the following three cases must hold:
      - Neither function type has rest arguments:
        * V = V' = null
        * m = n (both argument lists are the same length).
      - Only the first function type has rest arguments:
        * V' = null but V != null
        * m ≤ n 
        * Si' ~<: V for m < i ≤ n.
      - Both function types have rest arguments:
        * V != null and V' != null
        * Si' ~<: V for m < i ≤ n 
        * V' ~<: S for n < i ≤ m 
        * V' ~<: V


====== Runtime Type Tags ======

Runtime values must carry around type information to enforce the rules of the type system. These runtime //tags// are associated with all values (such as objects and primitives) and slots (mutable properties). A tag is a runtime representation of a type.

In general, tags can represent any type, except parameterized types that are not fully instantiated. Furthermore, there are restrictions on value tags detailed below.

===== Values =====

Every runtime value contains an internal tag indicating some information about the value's type. A value's tag is a fully instantiated type whose top-level type constructor cannot be a ''UNION'' type or the type ''*''.

For primitive values and instances of classes, the value's tag is simply its associated type. For structurally typed functions and objects, the type tag contains all the static type information associated with the literal expression that constructed the value.

For example, an untyped function object might have the tag:

  (FUNCTION (THIS *) (ARGS *) #t (RETURN *))

Dynamically typed object literals have the structural type

  (OBJECT)

because it's known that they are objects but there are no other known constraints.

Examples:

<code javascript>
// tag: (FUNCTION (THIS *) (ARGS int) #f (RETURN String))
function f(x : int) : String { ... }

// tag: (OBJECT (x int) (y int))
{ x: 3, y: 4 } : { x: int, y: int }

// tag: (OBJECT (x int))
{ x: 3, y: 4 } : { x: int }

// tag: (OBJECT)
{ x: 3, y: 4 } : *
</code>

===== Slots =====

Mutable entities such as object properties are known as //slots//. All slots have associated type tags. A slot tag may represent any fully instantiated type.

<code javascript>
// x's tag: int
{ x: 3 } : { x: int }

// x's tag: (UNION int String)
{ x: 3 } : { x: (int,String) }
</code>

===== Runtime Checks =====

Runtime checks occur when setting a slot or passing a value to a function or method. The check involves testing whether the value's tag is compatible with the expected type (associated with the slot or function signature). Runtime checks also occur when accessing a slot value or returning from a function. The check involves testing whether the returned value or slot value is compatible with the expected type (associated with the slot or function signature).

If a runtime check succeeds but requires an implicit conversion, the conversion is performed automatically.

Compilers are free to skip a dynamic check if they can prove that the check is guaranteed to succeed without conversion.

====== Implementing Conversions ====== 

For any pair of convertable types S and T, we must at runtime be able to convert values of type S to type T. For simple types like ''int'' and ''double'', the runtime conversion
is straight-forward. But there are two things that make conversion
more subtle: functions and mutable slots.

The following example illustrates how mutable slots are problematic:

<code javascript>
type Box = { val: TCPSocket }

var boxAny : * = { val: new TCPSocket } : *
var box : Box = boxAny          // conversion from * ~> Box
boxAny.val = new RubberChicken  // no problem, boxAny is untyped
box.val                         // ERROR: no longer a TCPSocket!
</code>

At some point, it has to be an error for ''o.x.val'' to be a
''RubberChicken'', because the type system promised it would always be
a ''TCPSocket''. It's not in general possible to catch this kind of
error statically, because of type ''*''. 



For the example above, the conversion from * to Box does not introduce a wrapper or view;
box is just set to  point to the same record as boxAny.
On the access to box.val (or any access to a record), since box has type Box = {val:TCPSocket}
and the underlying record is not guaranteed to hold a TCPSocket,
the compiler will insert a check that box.val returns a TCPSocket,
and will issue a dynamic type error otherwise.

For other code like: 

<code javascript>
type Box = { val: TCPSocket }
function f(box:Box) {
    return box.val;
}
</code>

the compiler will also insert the same dynamic check.

Of course, a sufficiently-smart compiler could prove many of these checks
are redundant via static analysis. 

===== Informative notes on dynamic optimization =====

In the following, we assume that there is an object ''OBJ'' that has a type ''T'', and ''n'' slots ''S1:U1'' .. ''S//n//:U//n//'' //outside// ''OBJ'', that //refer// to ''OBJ''. Then when attempting a property read ''S//i//.x'', intended to extract field ''x'' from ''OBJ'' via some referencing slot ''S//i//:U//i//'', we have two ways to cache type-compatibility information to make this read efficient:

  - ''OBJ'' can carry a single bit that is set when //any// slot ''S//k//:U//k//'' exists with ''Uk != T''. 
    * When the bit is set, ''S//i//.x'' must perform a typecheck between ''U//i//'' and ''T''.
    * When the bit is cleared, we know that //every// ''S//k//:U//k//'' has ''U//k// == T'', so ''S//i//.x'' can proceed without a typecheck.
    * This bit (on ''OBJ'') may be modified any time a new ''S//j//'' is made to refer to ''OBJ''.

  - Every slot ''S//i//:U//i//'' //that currently refers to ''OBJ:T''// can carry a single bit that indicates whether ''U//i// != T''.  
    * When the bit is set, as above, ''S//i//.x'' must perform a typecheck between ''U//i//'' and ''T''.
    * When the bit is cleared, as above, no type comparison is required.
    * These bits (on every ''S//i//'') must be set or cleared any time an ''S//i//'' is given a referent: there's only one bit and it relates to the //current referent//.

Essentially the first case spends a bit less space (one bit per object), but is more likely to enter the slow slot-to-object type comparison. The second case spends a bit more space (one bit per slot) but is less likely to enter the slow type comparison.


====== Type Parameters ======

  * separate phase before type checking
  * type variable scope
    * binding occurrences (class declarations, function declarations)
    * where free type variables can('t) occur
  * parameterization (i.e., type substitution)

====== Type Checking ======

  * ''void'' functions <=> ''return'' syntactic restrictions
  * generator functions <=> return type
  * generator functions <=> ''yield'' syntactic restrictions
  * generally, any type is convertible to booleans 
  * types ''Null'' and ''Undefined'' don't allow object operations
  * what about object operations on nullable types?
  * ''with'' follows [[proposals:reformed with]]

====== Miscellaneous (not yet organized) ======

  * libraries in initial environment -- impl.-specific, but must have:
    * ''DontDelete''
    * runtime type constraint
  * no environment needed for subtyping (inside parameterized class definitions we may have type variables, but these are always universally quantified so they do not need to be bound in the type environment) 
  * parsing of concrete type expressions/definitions to abstract syntax

  * explain abstract syntax and meta-syntax
  * The operator ''v is T'' checks if the tag of the value v is a subtype of the type T.
  * The operator ''v to T'' checks if the tag of v is //convertible// to the type T, and throws a TypeError if not. Note that this requires invoking the convertibility checking algorithm, but only looks at the value's tag, not its actual contents. For example:

<code javascript>
var o : * = { x: 3, y: 'foo' } : { x: int }
o isTagCompatible { x: int, y: int } // true
</code>

Notice also that for union types, the tag subtyping check involves an
implicit ''typecase'' on the variants of the union:

<code javascript>
var o : * = function(x) { return x }
o isTagCompatible (int, function(int):int) // true
</code>


More details are in [[clarification:formal type system]]

----
