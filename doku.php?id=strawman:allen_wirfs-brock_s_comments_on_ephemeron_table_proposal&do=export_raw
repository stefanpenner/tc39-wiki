====== Allen's comments on original Ephemeron proposal ======


I don’t have any principled objections to the Ephemeron proposal.  I do have a lot of nits.  I’ll try to list them ordered in approximately decreasing importance.

1) We should expose the EphemeronTable functionality using more user approachable concepts. While I have a fondness for the term Ephemeron, I think it should be reserved for use by the technical memory management community and not exposed to ordinary users.  Instead, what I would expose are use case rooted concepts that are understandable by mid-level JavaScript programmers  who aren’t garbage collection experts.  The primary use case is a registry or map that associates an object identify key with a value.  That’s the concept we should be exposing.  The circular reference problem isn’t one that is on the mind of most users trying to deal with this use case.  If a key object is not accessible independently of such tables then that object  conceptually is garbage just like any other object that isn’t reachable from normal roots. When you explain to most users why that isn’t the case, they perceive it as a bug in the implementation of the table. So, I suggest that we should expose this functionality named something like ObjectMap or ObjectRegistry and that we don’t even talk about Ephemeron semantics in the conceptual description that most users would be exposed to.  It is only in the detailed semantics that  we need to remind implementers that they need to avoid the circularity bug.

2) I would drop the whole opt_useKeyLifetime business and the who discussion of Rhino style implementations.  The basic problems with this sort of exposed tweak is the conceptual complexity burden it creates for user.   Whether they need to really know about it or not, they will worry about trying to understand it, just because it is there.  And unfortunately, in most cases they won’t understand it, but since it is there they will think that it is something important and will guess at the value they should specify or just copy  some other usage.   Understandability of the EphemeronTable proposal  is just a whole lot better if this concept is dropped.  Regarding Rhino, there are two ways to look at it. Either, they are already covered because you don’t guarantee  collection (but, like all implementers they should make a best effort to recover inaccessible storage) or they are non-compliant (tough).

3) Express invariants, not algorithms. Similar to Cormac’s concerns , I don’t think we should be expressing GC-like algorithms, even non-normatively.  Resource management requirements are better expressed as invariants that must be maintained by the underlying implementation.  ES 1-5 has an implicit invariant  that any object that is transitively reachable starting from either the global object or the active execution context will continue to exist as long as it remains reachable (and it’s interesting that this invariant isn’t explicit, and that ECMAScript doesn’t actually mandate reuse of resources associated with non-reachable objects). I believe that we can craft an additional invariant(s) that cover the essential semantics of EphemeronTable.  (basically, reachability of the table does not imply reachability of  keys or values and that if a key is reachable starting from the regular roots than its value is also reachable and so is anything that the value transitively references (including via an EphemeronTable mapping).  We can provide an informative reference to appropriate Ephemeron related papers as providing possible implementation techniques but we really don’t need to say anything more.

4) opt_expectedSize should be first argument.  If I can’t convince you to get ride of opt_useKeyLifetimes I’d want the expected size hint to be the first argument.  It is much more likely to be understood and used.

5) Given how you feel about non-determinist behavior I’m surprised that you are content to allow MAY collect semantics for EphemeronTables (and for GC in general, for that matter).  I don’t think it is possible to actually write reliable programs of any substance without assuming that some sort of GC will occur.  Similarly, any production use of EphemeronTables is probably going to fail if they aren’t implemented with at least weak key semantics.  I wouldn’t want to require precise collection or maybe not even timely collection but it might be reasonable to  require that an implementation make an effort recover resources associated with unreachable objects prior to terminating a program because of resource exhaustion. 

6) Get rid of the whole name abstraction discussion.  It’s a distraction and there is nothing essential there.

7) Undefined as missing key flag.  I’m a little uncomfortable with having no way to distinguish between a key that is not in the table and one whose value is undefined. However, I think returning undefined from get for missing keys is probably fine in most cases.  I would consider two alternatives for addressing the special cases where the difference between absent and undefined value may matter.  Either add an additional boolean valued  method exists(key) (or hasKey(key) etc.)  or add a seldom used optional second argument to get that when truthy indicaties to throw if key is missing (or alternatively pass a function as the second argument and call it if the key is missing).

8)  Use a constructor instead of a factory function.  We need consistency in the design patterns used for built-in ECMAScript objects.  Unless we agree to  depreciating new and the existing built-in constructors I think we should stick with the established pattern of using a constructor for most built-in types of objects.

9) EphemeronTable objects shouldn’t be born frozen.  Same argument as 8 about using consistent design patterns. No other currently built-in object kinds are born frozen. 

10) I’m still a little concerned that a good implementation needs to scale from very small tables to very large ones that it is hard to design such scalable hashtables without knowing something about usage patterns (particularly insertion/deletion/access patterns)

Regarding WeakPtr…I’d be more conformable with weak “vectors”.  I think the primary use case is building as associative structure that maps primitive values to objects.  Things like interned symbol tables or maps of external surrogate id’s to objects.  Having to impose a separate WeakPtr object for each value entry seems like excessive overhead, as does associating executor state with each value entry.  (Also see side-bar about GC overhead below).  Using a weak vector (a dense numerically indexed array like object) to build such a data structure eliminates this extra overhead.  A single executor can then be used for the entire weak vector.   I’d actually be content with no notification however some sort of residue value is needed to avoid messing up hashing algorithms.

GC Overhead sidebar:  The great thing about generation copying collectors is that that collection time is proportional  to the number of retained objects rather than the number of allocated objects.  That means that if you create a lot of ephemeral objects (and we all should) collections are still cheap and fast because they only need to consider reachable objects and can ignore the (likely) majority that have been created and discarded since the last collection.  One issue with most weak pointer algorithms (including the ephemeron algorithms) is that they are have to do at least some processing for every existent such object. If you have too many of them it becomes drag on overall collector throughput.

