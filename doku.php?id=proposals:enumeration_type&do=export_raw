====== Rationale ======
An enumeration type defines a type name for a related group of symbolic constants. Enumerations are used for "multiple choice" scenarios, in which a runtime decision is made from a fixed number of choices that are known at compile-time.

The use of enumerations is superior to the use of integer constants (or classes with static final fields) — as is common in languages without the notion of enumerations — because the use of enumerations makes the code more readable and self-documenting. The self-documenting nature of the code also makes it possible for the development tool to assist with code writing and other "designer" activities.

An enumeration type is a distinct type with named constants.

Syntax
<code>
[modifiers] enum enumName [ : typeAnnotation] {
  enumValue1 [ = initializer1]
  [,enumValue2 [ = initializer2]
  [, ... [,enumValueN [ = initializerN ] ]]]
}
</code>


Where:
<code>
modifiers 
Optional. Modifiers that control the visibility and behavior of the enumeration.

enumName 
Required. Name of the enumerated type.

typeAnnotation 
Optional. The underlying data type of the enumeration. Must be an integral data type. The default is int.

enumValue1, enumValue2, ..., enumValueN 
Optional. An enumerated type member.

initializer1, initializer2, ..., initializerN 
Optional. A constant expression that overrides the default numerical value of an enumeration member.
</code>

Sample:
<code>
enum Color
{
    Red,
    Green,
    Blue
}
</code>

The declaration of an enumeration type is similar to a class declaration. However the following additions rules apply:
  - We use the keyword enum
  - enumeration types are implicitly <del>static and</del> final
  - the allowed class modifiers are public and private
  - enum types are integral.

An enum declaration introduces a new enumerated data type into the program. An enum declaration can appear only in contexts where a class declaration can appear, that is, at global scope, at package scope, or at class scope, but not inside a function or method.

You can declare the underlying type of an enumeration to be any integral data type. Enumeration members implicitly coerce to and from the underlying data type, allowing for direct assignments of numeric data to variables typed as enum. By default, the underlying data type of an enumeration is int.

Each enumerated type member has a name and an optional initializer. An initializer must be a compile-time, constant expression that is of the same type as the enumeration specified, or convertible to that type. The value of the first enumerated type member is zero or the value of the initializer, if provided. The value of each subsequent enumerated type member is one more then the previous member or the value of the initializer, if provided.

  * The constant value for each enum member shall be in the range of the underlying type for the enum.
  * Multiple enum members can share the same associated value. The associated value of an enum member shall not, directly or indirectly, use the value of its own associated enum member. Other than this circularity restriction, enum member initializers can freely refer to other enum member initializers, regardless of their textual position.
  * Within an enum member initializer, values of other enum members are always treated as having the type of their underlying type, so that casts are not necessary when referring to other enum members.

An enum value is accessed in a manner that's similar to accessing a static class member. The name of the member must be qualified with the name of the enumeration, for example Color.Red. When assigning a value to a variable of an enum type, one of following may be used: a fully qualified name (such as Color.Red), a string representation of the name (such as "Red"), or a numeric value.

If an enum is assigned a string that is known at compile time, the compiler will perform the necessary conversion. For example, "Red" would be replaced with Color.Red. If the string is not known at compile time, a conversion will be made at run time. That conversion may fail if the string is not a valid member of the enumerated type. Because the conversion takes time and run-time errors may be generated, avoid assigning a string-typed variable to an enum.

A variable of an enumerated type can hold values outside the range of declared values. One use of this feature is to allow combinations of members used as bit flags, as in done in the example below. Converting an enum variable to a string results in the string representation of the member name. In the case where a union of bit flags results in a value that is not one of the named constants, converting an enum variable to a string results in the stringified representaition of the numeric value.

Example:
<code>
enum FormatFlags {
   // Can't use the default values, since we need explicit bits
   ToUpperCase = 1,   // Should not combine ToUpper and ToLower.
   ToLowerCase = 2,
   TrimLeft    = 4,   // Trim leading spaces.
   TrimRight   = 8,   // Trim trailing spaces.
   UriEncode   = 16   // Encode string as a URI.
}

function Format(s : String, flags : FormatFlags) : String {
   var ret : String = s;

   if (flags & FormatFlags.ToUpperCase) ret = ret.toUpperCase();
   if (flags & FormatFlags.ToLowerCase) ret = ret.toLowerCase();
   if (flags & FormatFlags.TrimLeft)    ret = ret.replace(/^\s+/g, "");
   if (flags & FormatFlags.TrimRight)   ret = ret.replace(/\s+$/g, "");
   if (flags & FormatFlags.UriEncode)   ret = encodeURI(ret);

   return ret;
}

// Combine two enumeration values and store in a FormatFlags variable.
var trim : FormatFlags = FormatFlags.TrimLeft | FormatFlags.TrimRight;

// Combine two enumeration values and store in an int variable.
var lowerURI : int = FormatFlags.UriEncode | FormatFlags.ToLowerCase;

var str : String = "  hello, WORLD  ";

print(trim + ": " + Format(str, trim));
print(FormatFlags.ToUpperCase + ": " + Format(str, FormatFlags.ToUpperCase));
print(lowerURI + ": " + Format(str, lowerURI));
</code>

The above code would print the following:
<code>
12: hello, WORLD
ToUpperCase:   HELLO, WORLD
18: %20%20hello,%20world%20%20
</code>

**Semantics**

**Instantiation**: Consider an enumeration as applying a constraint on the underlying type bounding it to a specific set of values – then an enum type is just representing a set of constants. Suppose we permit explicit instantiation we could end up with multiple enum objects. What should be the semantics of the equality operators '==' and '!=' ? Should they support reference semantics or value semantics? To keep things simple, we should not permit the user to explicitly instantiate an enum using the new operator.

**Declared accessiblity**: 'public' and 'private' can be the declared accessibility.

**Default values**: Each enum member has an associated constant value. The associated value of an enum member can be assigned either implicitly or explicitly.

If the declaration of the enum member has a constant-expression initializer, the value of that constant expression, implicitly converted to the underlying type of the enum, is the associated value of the enum member.

If the declaration of the enum member has no initializer, its associated value is set implicitly, as follows:
  * If the enum member is the first member declared in the enum type, its associated value is 0.
  * Otherwise, the associated value of the member is obtained by incrementing the associated value of the lexically preceding member by 1. This incremented value must be within the range of values that can be represented by the underlying type.

**enum members**: Each enum member has an associated constant value. Multiple enum members may share the same associated value. It should be possible to associate a constant with each enum member at compile-time. Consequently, this association should not involve any circular reference. Other than this circularity restriction, enum member initializers may freely refer to other enum member initializers, regardless of their lexical position.

**Assignment**: An enumeration type cannot be implicitly converted to its underlying type; an explicit cast shall be required.

**enum values and operations**: Each enum type defines a distinct type; an explicit enumeration conversion is required to convert between two enum types. The set of values that an enum type can take on is not limited by its enum members. In particular, any value of the underlying type of an enum can be cast to the enum type, and is a distinct valid value of that enum type.

The following operators can be used on values of enum types: ==, !=, <, >, < = , >=, +, -, ^, &, |, ~ .

 --- //[[pratapl@microsoft.com|Pratap Lakshman]] 2007/02/22 09:19//

----
Given the earlier 'minimalist' discussion, I would like this proposal withdrawn.
 --- //[[pratapl@microsoft.com|Pratap Lakshman]] 2007/03/16 13:28//
----
Proposal revived. 

This proposal has merit and should be accepted or rejected based on the net value it provides to ES4. AS3 users have been asking for an enumeration type and other languages have them. This is evidence that they belong in ES4. Let's not cut them prematurely.

 --- //[[jodyer@adobe.com|Jeff Dyer]] 2007/03/18 12:45//
----
Here is a repro that I had said I would plug in after the last phone meeting:

<code>
enum Color { Red, Green };

var c : Color = Color.Red;
print(c);               // Red

var c2 : Color = "Red";
print(c2);              // Red

print(c2 == Color.Red); // true
print(c2 == c);         // true

var c3 : Color = (Color) (0);
print(c3);              // Red
print(c3 == Color.Red); // true
print(c3 == c2);        // true
print(c3 == c);         // true
</code>
 --- //[[pratapl@microsoft.com|Pratap Lakshman]] 2007/03/21 13:23//

I think this is a low value feature. ECMAScript already has strings, which (because === works on strings) can act as atomic symbols. The switch statement can work on strings, so most of the usefulness of enum is already built into the language. For the applications that require explicit mapping of symbols to numbers, ECMAScript has object and array structures that can easily do the mapping.

We already have too many low value features. We should only be adding high value features.

 --- //[[crock@yahoo-inc.com|Douglas Crockford]] 2007/03/24 11:00//

Strings can't be checked for misspellings (typos are a real problem in string-based code, in scripted MS COM and Mozilla XPCOM to cite two relevant example domains). They also are not categorical sum types, so you can't get that warning for a forgotten ''case'' in ''switch'' that lacks ''default''. And maintaining string <-> integer mappings is verbose and error prone (in part because of prototype-delegated pollution of the mapping object). See [[http://lxr.mozilla.org/mozilla/source/js/narcissus/jsdefs.js#141|an example from Narcissus]].

This is a deferred proposal, but it seems better to avoid advocacy in the proposals namespace, or start a discussion page if we must. For now I will record technical costs imposed by deferring enums, and make a quantitative point: Of course many things in the language can be done in a simpler language. ''do-while'' and ''switch'' could have been left out of Edition 2. I left them out of JS1.0 in 1995 because I was in a rush. That they could be rewritten using other primitives does not make them fruitless, or mean that their addition harmed the language.

Wasting programmers' time reinventing custom wheels, writing verbose and error-prone boilerplate, and missing standard forms from related programming languages -- these all exact a cost too. The cost grows as the language becomes more popular and more people have to reinvent, write too much code, and repeat the same kinds of mistakes. Hence the larger feature surface of mature languages, including draft ES4.

 --- //[[brendan@mozilla.org|Brendan Eich]] 2007/03/24 23:16//