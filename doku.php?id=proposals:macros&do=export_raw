We could add a macro-expansion phase to the execution model. I believe the correct place to put them is after the initial parse and execution of package-import pragmas (to permit packaged macros). 

There is a ton of work on macro systems. My preference is to model them as functions from typed ASTs to typed ASTs, with a gensym function or perhaps a general alpha-converting splice operator, and require users to explicitly quote the type of AST they want (see [[proposals:quoting]]), rather than trying to work out a way of wedging "any parse context" into the macro's argument-list context. The expansion phase then becomes a partial execution phase on function call sites which have an acceptable type and are marked a particular way (say with a sigil). But it might be possible to do many different things.

Many languages (lisp, C) implement macros transparently, such that a call site "looks the same" whether it is a macro or a function. I believe this is a usability mistake: it obscures program meaning too much.

Some languages (camlp4, dylan) permit extension of the main language grammar, such that call sites cannot even be determined: entirely new syntactic constructs may be defined without any marking. I believe these are bad for comprehension as well.

Anyone with deeper experience with macro systems care to suggest something specific for ES4 (Dave)?