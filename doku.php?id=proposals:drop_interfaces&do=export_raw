====== Remove interfaces ======

This is a simple proposal: remove interfaces from the spec. They make the language larger, and may not add as much expressive power as they cost. Some of the mechanisms provided by interfaces, such as ''comparable'', can be provided more safely by [[type parameters]] and the first class functions already present in the language.

Dave Herman corresponded with Brendan and wrote in favor of interfaces, arguing that Java muddied the waters by allowing classes to be used as types too freely.  Classes should be implementations, and API client code should use interfaces mostly, not classes, to avoid binding to concrete implementations. Quoting Dave;

  Interfaces are great for:
  - the type of function/method inputs and outputs
  - the type of `this' in methods that can by dynamically inserted into other objects
  - the type of the superclass for mixins

 --- //[[brendan@mozilla.com|brendan]] 2006/02/02 18:00//
-----
Response:

I agree with all Dave's points. 

I do not agree that these points necessitate the presence of interfaces in the language.

The language currently does not have mixins with typed dependencies (a la Scala traits). It has single-inheritence in the static mode, and dynamic delegation through prototypes.

Nor does the language have a typed ''this'' on extracted methods. It has bound methods and methods with a completely dynamic ''this'' (for ES3 compatibility).

In other words, I believe the only use of interfaces in this language is for function/method parameter types, and I argue that even in this regard -- especially given the presence of bound methods -- they are less important than type parameters. 

Consider these two cases:

<code>
// With interfaces

interface Surface { function draw_point(x: int, y: int, c: Color):void; }
class Screen implements Surface { ... }
class Painter 
{ 
  function do_drawing(Surface s) 
  { 
    ...; 
    s.draw_point(x, y, c); 
  }
}

Screen s = new Screen;
Painter p = new Painter;
p.do_drawing(s);
</code>

<code>
// With bound methods

class Screen { function draw_point(x: int, y: int, c: Color) { ... } }
class Painter 
{ 
  function do_drawing (point_fn: function(int,int,Color):void) 
  {
    ...; 
    point_fn(x,y,c); 
  } 
}

Screen s = new Screen;
Painter p = new Painter;
p.do_drawing(s.draw_point); 
</code>

The latter is somewhat less direct in what it's saying, but it's also more flexible style, and doesn't require as much pre-existing agreement between the designers and users of the various classes in a program.

I am certainly not universally opposed to interfaces. I just saw them as a feature which might cost more than they buy in this language.

 --- //[[graydon@mozilla.com|graydon]] 2006/02/02 18:28//

IIUC, your example gets away with the fact that you're only using one particular method of a given object, so you use a function type instead. But what happens when you want to pass as an argument an object that must support several methods?

<code>
interface DOMNode {
    function getChildren():Array[DOMNode];
    function getTag():String;
    function getAttribute(String):String;
    ...
}
function dfs(DOMNode node, String tag):Array[DOMNode] {
    ... dfs(node.getChildren()) ...
    ... node.getTag() ...
}
</code>

In practice, people already use informal interfaces to specify the behavior of their JavaScript API's. For example: [[http://developer.mozilla.org/en/docs/Gecko_DOM_Reference|Gecko DOM API]].

 --- //[[dherman@ccs.neu.edu|Dave Herman]] 2006/02/03 13:25//

----

Sure. So if you want to use functions ''A'', ''B'', and ''C'', you either:

  * Require parameters of function types ''A'', ''B'', and ''C'', //or//
  * Make a "glue class" ''D'' which takes ''A'', ''B'' and ''C'' as constructor arguments, and can be passed around as a unit. This is just "simulating inheritence with delegation".

I guess the general point I was making is that inheritence is a subset of the functionality of "types + delegation", and we already have strong mechanisms for types and delegation in the spec. So fancier forms of inheritence seem a bit like window dressing. We can probably define interfaces //in terms of// classes and bound methods. 

In any case, I don't mean to belabor the point. I'm in no way wedded to this proposal: interfaces seemed to me like trimmable fat, but I have no specific goals which hinge on interfaces being removed. I'm happy to retract the proposal if they're widely seen as useful.

 --- //[[graydon@mozilla.com|graydon]] 2006/02/03 13:47//

----

Another reason we thought about dropping interfaces was that waldemar specified and then removed them from his draft (more below), then JScript.NET implemented one variant, and more recently AS3 implemented another variant.  We would have to reconcile differences, revisit and overcome waldemar's objection, and not sink too much time into this at the cost of something as valuable, or more important.

Waldemar was generally concerned that type annotations could be erased from a large-scale, partly-migrated program and the program's meaning would not change. That meant no method overloading -- no dispatching a method based on types. Interfaces make it too likely that names will collide. We could forbid name collisions, or require them to have the same signature (and when a class implements both interfaces, it has one method implementing that name), which IIRC is what AS3 does. Or we could do what JScript.NET did and dispatch based on type (let's not).

 --- //[[brendan@mozilla.org|Brendan Eich]] 2006/02/03 16:10//

I agree, let's put interfaces back on the table. Without them people try to do all kinds of unnatural things with classes to make them act like types. And without abstract classes or multiple inheritance they just get frustrated. Here's a primer on what we've done and what we would like to have done: 

In AS3, references through an interface typed slot cause that interface's methods (including its inherited methods) to be visible without qualification. So,

<code>
interface T { function m() }
var x : T = o
o.m() // calls T::m
</code>

''o.m()'' would find ''T::m'' in ''o'' regardless of what other m's might be in o. Erasing the type annotation means that the reference might become ambiguous, invisible or change binding to another implementation if o implements multiple interfaces with method m. (more on this below)

In an early version of AS3, a class could have different implementations for different interface methods with the same identifier. E.g.

<code>
interface T { function m() }
interface U { function m() }

class A implements T,U {
  public function m() {}  // implements both
}

class B implements T,U {
  T function m() {}  // implements T's
  U function m() {}  // implements U's
}

class C implements T,U {
  T function m() {}  // implements T's
  public function m() {} // implements all others (U's in this case)
}

var a : A; a.m()   // cool, only one implementation and its visible (public)
var b : B; b.m()   // no m found, interface methods are not public by default
b.T::m(); b.U::m() // fine, explicit qual makes a certain m visible
var c : C; c.m()   // call U::m, T::m not visible
var t : T; t.m()   // no problem
var u : U; u.m()   // ditto
</code>

I would like to propose the same for ES4.

This design gives us:

  * implementations of multiple methods with one public definition
  * implementation of individual interface methods
  * implicit qualification of references with interface typed base expressions
  * explicit qualification to resolve ambiguities (interface extends case), or make visible

Also means:

  * erasing type annotations affects the meaning of the program
  * is different from JScript.NET
