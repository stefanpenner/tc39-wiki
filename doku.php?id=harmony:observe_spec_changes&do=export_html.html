<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="http://wiki.ecmascript.org/feed.php?mode=list&amp;ns=harmony" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_html.html#this_page_is_no_longer_current" class="toc">THIS PAGE IS NO LONGER CURRENT</a></span><ul class="toc">
<li class="clear"><ul class="toc">
<li class="clear"><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_html.html#object.observemodifications_to_existing_internal_algorithms" class="toc">Object.observe: Modifications to existing internal algorithms</a></span><ul class="toc">
<li class="level5"><span class="li"><a href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_html.html#validateandapplypropertydescriptor" class="toc">[[ValidateAndApplyPropertyDescriptor]]</a></span></li>
<li class="level5"><span class="li"><a href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_html.html#delete" class="toc">[[Delete]]</a></span></li>
<li class="level5"><span class="li"><a href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_html.html#preventextensions" class="toc">[[PreventExtensions]]</a></span></li>
<li class="level5"><span class="li"><a href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_html.html#setprototypeof" class="toc">[[SetPrototypeOf]]</a></span></li>
</ul>
</li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_html.html#changes_to_array_methods" class="toc">Changes to Array methods</a></span><ul class="toc">
<li class="level5"><span class="li"><a href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_html.html#array.prototype.pop" class="toc">Array.prototype.pop</a></span></li>
<li class="level5"><span class="li"><a href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_html.html#array.prototype.push" class="toc">Array.prototype.push</a></span></li>
<li class="level5"><span class="li"><a href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_html.html#array.prototype.shift" class="toc">Array.prototype.shift</a></span></li>
<li class="level5"><span class="li"><a href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_html.html#array.prototype.splice" class="toc">Array.prototype.splice</a></span></li>
<li class="level5"><span class="li"><a href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_html.html#array.prototype.unshift" class="toc">Array.prototype.unshift</a></span></li>
</ul>
</li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_html.html#array_exotic_objects" class="toc">Array Exotic Objects</a></span><ul class="toc">
<li class="level5"><span class="li"><a href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_html.html#defineownproperty_p_desc" class="toc">[[DefineOwnProperty]] (P, Desc)</a></span></li>
<li class="level5"><span class="li"><a href="doku.php%3Fid=harmony:observe_spec_changes&amp;do=export_html.html#arraysetlength_abstract_operation" class="toc">ArraySetLength Abstract Operation</a></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<a name="this_page_is_no_longer_current"></a><h1>THIS PAGE IS NO LONGER CURRENT</h1>
<div class="level1">

<p>
 <a href="lib/exe/detail.php%3Fid=harmony%253Aobserve_spec_changes&amp;cache=cache&amp;media=harmony:warning.png.html" class="media" title="harmony:warning.png" onclick="return svchk()" onkeypress="return svchk()"><img src="lib/exe/fetch.php%3Fw=100&amp;h=&amp;cache=cache&amp;media=harmony:warning.png" class="media" alt="" width="100" /></a> <strong>WARNING:</strong> This page is <strong>out of date</strong>. Please see the <a href="https://github.com/arv/ecmascript-object-observe" class="urlextern" target="_blank" title="https://github.com/arv/ecmascript-object-observe" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">latest draft on GitHub</a> for up-to-date information. This page is here only as an archive.
</p>

</div>
<!-- SECTION [1-276] -->
<a name="object.observemodifications_to_existing_internal_algorithms"></a><h4>Object.observe: Modifications to existing internal algorithms</h4>
<div class="level4">

</div>
<!-- SECTION [277-350] -->
<a name="validateandapplypropertydescriptor"></a><h5>[[ValidateAndApplyPropertyDescriptor]]</h5>
<div class="level5">

<p>
 Modify the ValidateAndApplyPropertyDescriptor  algorithm as <u>indicated</u>:
</p>

<p>
9.1.6.3 ValidateAndApplyPropertyDescriptor (O, P, extensible, Desc, current)
</p>

<p>
When the abstract operation ValidateAndApplyPropertyDescriptor is called with Object O, property key P, Boolean value extensible, and property descriptors Desc, and current the following steps are taken:
</p>

<p>
This algorithm contains steps that test various fields of the Property Descriptor Desc for specific values. The fields that are tested in this manner need not actually exist in Desc. If a field is absent then its value is considered to be false.
</p>

<p>
NOTE: If undefined is passed as the O argument only validation is performed and no object updates are performed.
</p>
<ol>
<li class="level1"><div class="li"> Assert: If O is not undefined then P is a valid property key.</div>
</li>
<li class="level1"><div class="li"> <u>Let changeType be a string, initially set to “reconfigure”.</u></div>
</li>
<li class="level1"><div class="li"> If current is undefined, then</div>
<ol>
<li class="level2"><div class="li"> If extensible is false, then return false.</div>
</li>
<li class="level2"><div class="li"> Assert: extensible is true.</div>
</li>
<li class="level2"><div class="li"> If IsGenericDescriptor(Desc) or IsDataDescriptor(Desc) is true, then</div>
<ol>
<li class="level3"><div class="li"> If O is not undefined, then create an own data property named P of object O whose [[Value]], [[Writable]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the value of an attribute field of Desc is absent, the attribute of the newly created property is set to its default value.</div>
</li>
</ol>
</li>
<li class="level2"><div class="li"> Else Desc must be an accessor Property Descriptor,</div>
<ol>
<li class="level3"><div class="li"> If O is not undefined, then create an own accessor property named P of object O whose [[Get]], [[Set]], [[Enumerable]] and [[Configurable]] attribute values are described by Desc. If the value of an attribute field of Desc is absent, the attribute of the newly created property is set to its default value.</div>
</li>
</ol>
</li>
<li class="level2"><div class="li"> <u>Let R be the result of calling [[CreateChangeRecord]] with arguments: &ldquo;add&rdquo;, O, P, current and Desc.</u></div>
</li>
<li class="level2"><div class="li"> <u>Call [[EnqueueChangeRecord]] passing O and R</u></div>
</li>
<li class="level2"><div class="li"> Return true.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Return true, if every field in Desc is absent.</div>
</li>
<li class="level1"><div class="li"> Return true, if every field in Desc also occurs in current and the value of every field in Desc is the same value as the corresponding field in current when compared using the SameValue algorithm.</div>
</li>
<li class="level1"><div class="li"> If the [[Configurable]] field of current is false then</div>
<ol>
<li class="level2"><div class="li"> Return false, if the [[Configurable]] field of Desc is true.</div>
</li>
<li class="level2"><div class="li"> Return false, if the [[Enumerable]] field of Desc is present and the [[Enumerable]] fields of current and Desc are the Boolean negation of each other.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> If IsGenericDescriptor(Desc) is true, then no further validation is required.</div>
</li>
<li class="level1"><div class="li"> Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) have different results, then</div>
<ol>
<li class="level2"><div class="li"> Return false, if the [[Configurable]] field of current is false.</div>
</li>
<li class="level2"><div class="li"> If IsDataDescriptor(current) is true, then</div>
<ol>
<li class="level3"><div class="li"> If O is not undefined, then convert the property named P of object O from a data property to an accessor property. Preserve the existing values of the converted property’s [[Configurable]] and [[Enumerable]] attributes and set the rest of the property’s attributes to their default values.</div>
</li>
</ol>
</li>
<li class="level2"><div class="li"> Else,</div>
<ol>
<li class="level3"><div class="li"> If O is not undefined, then convert the property named P of object O from an accessor property to a data property. Preserve the existing values of the converted property’s [[Configurable]] and [[Enumerable]] attributes and set the rest of the property’s attributes to their default values.</div>
</li>
</ol>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Else if IsDataDescriptor(current) and IsDataDescriptor(Desc) are both true, then</div>
<ol>
<li class="level2"><div class="li"> If the [[Configurable]] field of current is false, then</div>
<ol>
<li class="level3"><div class="li"> Return false, if the [[Writable]] field of current is false and the [[Writable]] field of Desc is true.</div>
</li>
<li class="level3"><div class="li"> If the [[Writable]] field of current is false, then</div>
<ol>
<li class="level4"><div class="li"> Return false, if the [[Value]] field of Desc is present and SameValue(Desc.[[Value]], current.[[Value]]) is false.</div>
</li>
</ol>
</li>
</ol>
</li>
<li class="level2"><div class="li"> else the [[Configurable]] field of current is true, so any change is acceptable.</div>
</li>
<li class="level2"><div class="li"> <u>If [[Configurable]] is not in Desc or SameValue(Desc.[[Configurable]], current.[[Configurable]]) is true and [[Enumerable]] is not in Desc or SameValue(Desc.[[Enumerable]],current.[[Enumerable]]) is true and [[Writable]] is not  in Desc or SameValue(Desc.[[Writable]], current.[[Writable]]) is true, then</u></div>
<ol>
<li class="level3"><div class="li"> <u>Set changeType to be the string &ldquo;update&rdquo;.</u></div>
</li>
</ol>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Else IsAccessorDescriptor(current) and IsAccessorDescriptor(Desc) are both true,</div>
<ol>
<li class="level2"><div class="li"> If the [[Configurable]] field of current is false, then</div>
<ol>
<li class="level3"><div class="li"> Return false, if the [[Set]] field of Desc is present and SameValue(Desc.[[Set]], current.[[Set]]) is false.</div>
</li>
<li class="level3"><div class="li"> Return false, if the [[Get]] field of Desc is present and SameValue(Desc.[[Get]], current.[[Get]]) is false.</div>
</li>
</ol>
</li>
</ol>
</li>
<li class="level1"><div class="li"> If O is not undefined, then</div>
<ol>
<li class="level2"><div class="li"> For each attribute field of Desc that is present, set the correspondingly named attribute of the property named P of object O to the value of the field.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> <u>Let R be the result of calling [[CreateChangeRecord]] with arguments: changeType, O, P, current and Desc.</u></div>
</li>
<li class="level1"><div class="li"> <u>Call [[EnqueueChangeRecord]] passing O and R</u></div>
</li>
<li class="level1"><div class="li"> Return true.</div>
</li>
</ol>

</div>
<!-- SECTION [351-5610] -->
<a name="delete"></a><h5>[[Delete]]</h5>
<div class="level5">

<p>
 Modify the [[Delete]] algorithm as <u>indicated</u>:
</p>

<p>
9.1.10 [[Delete]] (P)
</p>

<p>
When the [[Delete]] internal method of <em>O</em> is called with property key <em>P</em> the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Assert: IsPropertyKey(P) is true.</div>
</li>
<li class="level1"><div class="li"> Let <em>desc</em> be the result of calling the [GetOwnProperty]] internal method of <em>O</em> with argument <em>P</em>.</div>
</li>
<li class="level1"><div class="li"> If <em>desc</em> is undefined, then return true.</div>
</li>
<li class="level1"><div class="li"> <u>Let <em>notifier</em> be the result of calling [[GetNotifier]], passing <em>O</em>.</u></div>
</li>
<li class="level1"><div class="li"> If desc.[[Configurable]] is true, then</div>
<ol>
<li class="level2"><div class="li"> Remove the own property with name <em>P</em> from <em>O</em>.</div>
</li>
<li class="level2"><div class="li"> <u>Let <em>R</em> be the result of calling [[CreateChangeRecord]] with arguments: “delete”, <em>O</em>, <em>P</em> and <em>desc</em>.</u></div>
</li>
<li class="level2"><div class="li"> <u>Call [[EnqueueChangeRecord]] passing <em>O</em> and <em>R</em>.</u></div>
</li>
<li class="level2"><div class="li"> Return true.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Return false.</div>
</li>
</ol>

</div>
<!-- SECTION [5611-6459] -->
<a name="preventextensions"></a><h5>[[PreventExtensions]]</h5>
<div class="level5">

<p>
 9.1.4 [[PreventExtensions]] ()
</p>

<p>
When the [[PreventExtensions]] internal method of <em>O</em> is called the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> <u>Let <em>wasExtensible</em> be the value of the [[Extensible]] internal data property of <em>O</em>.</u></div>
</li>
<li class="level1"><div class="li"> Set the value of the [[Extensible]] internal data property of O to false.</div>
</li>
<li class="level1"><div class="li"> If <em>wasExtensible</em> is false, return true.</div>
</li>
<li class="level1"><div class="li"> <u>Let <em>notifier</em> be the result of calling [[GetNotifier]], passing <em>O</em>.</u></div>
</li>
<li class="level1"><div class="li"> <u>Let <em>R</em> be the result of calling [[CreateChangeRecord]] with arguments: “preventExtensions”, <em>O</em>.</u></div>
</li>
<li class="level1"><div class="li"> <u>Call [[EnqueueChangeRecord]] passing <em>O</em> and <em>R</em>.</u></div>
</li>
<li class="level1"><div class="li"> Return true.</div>
</li>
</ol>

</div>
<!-- SECTION [6460-7147] -->
<a name="setprototypeof"></a><h5>[[SetPrototypeOf]]</h5>
<div class="level5">

<p>
 9.1.2 [[SetPrototypeOf]] (V)
</p>

<p>
When the [[SetPrototypeOf]] internal method of <em>O</em> is called with argument <em>V</em> the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Assert: Either Type(<em>V</em>) is Object or Type(<em>V</em>) is Null.</div>
</li>
<li class="level1"><div class="li"> Let <em>extensible</em> be the value of the [[Extensible]] internal data property of <em>O</em>.</div>
</li>
<li class="level1"><div class="li"> Let <em>current</em> be the value of the [[Prototype]] internal data property of <em>O</em>.</div>
</li>
<li class="level1"><div class="li"> If SameValue(<em>V</em>, <em>current</em>), then return true.</div>
</li>
<li class="level1"><div class="li"> If <em>extensible</em> is false, then return false.</div>
</li>
<li class="level1"><div class="li"> If <em>V</em> is not null, then</div>
<ol>
<li class="level2"><div class="li"> Let <em>p</em> be <em>V</em>.</div>
</li>
<li class="level2"><div class="li"> Repeat, while <em>p</em> is not null</div>
<ol>
<li class="level3"><div class="li"> If SameValue(<em>p</em>, <em>O</em>) is true, then return false.</div>
</li>
<li class="level3"><div class="li"> Let <em>nextp</em> be the result of calling the [[GetPrototypeOf]] internal method of <em>p</em> with no arguments.</div>
</li>
<li class="level3"><div class="li"> ReturnIfAbrupt(<em>nextp</em>).</div>
</li>
<li class="level3"><div class="li"> Let <em>p</em> be <em>nextp</em>.</div>
</li>
</ol>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Set the value of the [[Prototype]] internal data property of <em>O</em> to <em>V</em>.</div>
</li>
<li class="level1"><div class="li"> <u>Let <em>notifier</em> be the result of calling [[GetNotifier]], passing <em>O</em>.</u></div>
</li>
<li class="level1"><div class="li"> <u>Let <em>R</em> be the result of the abstraction operation ObjectCreate (15.2).</u></div>
</li>
<li class="level1"><div class="li"> <u>Call the [[DefineOwnProperty]] internal method of <em>R</em> with arguments <strong><code>&ldquo;type&rdquo;</code></strong>, Property Descriptor {[[Value]]: <strong><code>&ldquo;setPrototype&rdquo;</code></strong>, [[Writable]]: <strong>false</strong>, [[Enumerable]]: <strong>true</strong>, [[Configurable]]: <strong>false</strong>}, and <strong>false</strong>.</u></div>
</li>
<li class="level1"><div class="li"> <u>Call the [[DefineOwnProperty]] internal method of <em>R</em> with arguments <strong><code>&ldquo;object&rdquo;</code></strong>, Property Descriptor {[[Value]]: <em>O</em>, [[Writable]]: <strong>false</strong>, [[Enumerable]]: <strong>true</strong>, [[Configurable]]: <strong>false</strong>}, and <strong>false</strong>.</u></div>
</li>
<li class="level1"><div class="li"> <u>Call the [[DefineOwnProperty]] internal method of <em>R</em> with arguments <strong><code>&ldquo;oldValue&rdquo;</code></strong>, Property Descriptor {[[Value]]: <em>current</em>, [[Writable]]: <strong>false</strong>, [[Enumerable]]: <strong>true</strong>, [[Configurable]]: <strong>false</strong>}, and <strong>false</strong>.</u></div>
</li>
<li class="level1"><div class="li"> <u>Set the [[Extensible]] internal property of <em>R</em> to false.</u></div>
</li>
<li class="level1"><div class="li"> <u>Call [[EnqueueChangeRecord]] on passing <em>O</em> and <em>R</em>.</u></div>
</li>
<li class="level1"><div class="li"> Return true.</div>
</li>
</ol>

</div>
<!-- SECTION [7148-9219] -->
<a name="changes_to_array_methods"></a><h4>Changes to Array methods</h4>
<div class="level4">

</div>
<!-- SECTION [9220-9257] -->
<a name="array.prototype.pop"></a><h5>Array.prototype.pop</h5>
<div class="level5">

<p>
 22.1.3.16 Array.prototype.pop ()
</p>

<p>
The last element of the array is removed from the array and returned. 
</p>
<ol>
<li class="level1"><div class="li"> Let O be the result of calling ToObject passing the this value as the argument.</div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(O).</div>
</li>
<li class="level1"><div class="li"> Let lenVal be the result of Get(O, &ldquo;length&rdquo;).</div>
</li>
<li class="level1"><div class="li"> Let len be ToUint32(lenVal).</div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(len).</div>
</li>
<li class="level1"><div class="li"> If len is zero, </div>
<ol>
<li class="level2"><div class="li"> Let putStatus be the result of Put(O, &ldquo;length&rdquo;, 0, true).</div>
</li>
<li class="level2"><div class="li"> ReturnIfAbrupt(putStatus).</div>
</li>
<li class="level2"><div class="li"> Return undefined.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Else, len &gt; 0</div>
<ol>
<li class="level2"><div class="li"> Let newLen be len–1.</div>
</li>
<li class="level2"><div class="li"> Let indx be ToString(newLen).</div>
</li>
<li class="level2"><div class="li"> <u>Call the [[BeginChange]] internal passing O and &ldquo;splice&rdquo;.</u></div>
</li>
<li class="level2"><div class="li"> Let element be the result of Get(O, indx).</div>
</li>
<li class="level2"><div class="li"> ReturnIfAbrupt(element).</div>
</li>
<li class="level2"><div class="li"> Let deleteStatus be the result of DeletePropertyOrThrow(O, indx).</div>
</li>
<li class="level2"><div class="li"> <u>If deleteStatus.[[type]] is normal, let putStatus be the result of Put(O, &ldquo;length&rdquo;, newLen, true).</u></div>
</li>
<li class="level2"><div class="li"> <u>Call the [[EndChange]] internal passing O and &ldquo;splice&rdquo;.</u></div>
</li>
<li class="level2"><div class="li"> <u>Let elements be a new List.</u></div>
</li>
<li class="level2"><div class="li"> <u>Append element to the end of elements.</u></div>
</li>
<li class="level2"><div class="li"> <u>Let removed be the result of CreateArrayFromList(elements).</u></div>
</li>
<li class="level2"><div class="li"> <u>Let R be the result of calling [[CreateSpliceChangeRecord]] with arguments: O, newLen, removed and 0.</u></div>
</li>
<li class="level2"><div class="li"> <u>Call [[EnqueueChangeRecord]] passing O and R</u></div>
</li>
<li class="level2"><div class="li"> ReturnIfAbrupt(deleteStatus)</div>
</li>
<li class="level2"><div class="li"> ReturnIfAbrupt(putStatus)</div>
</li>
<li class="level2"><div class="li"> Return element.</div>
</li>
</ol>
</li>
</ol>

</div>
<!-- SECTION [9258-10662] -->
<a name="array.prototype.push"></a><h5>Array.prototype.push</h5>
<div class="level5">

<p>
 22.1.3.17 Array.prototype.push ( [ item1 [ , item2 [ , … ] ] ] )
</p>

<p>
The arguments are appended to the end of the array, in the order in which they appear. The new length of the  array is returned as the result of the call.
</p>

<p>
When the push method is called with zero or more arguments item1, item2, etc., the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Let O be the result of calling ToObject passing the this value as the argument.</div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(O).</div>
</li>
<li class="level1"><div class="li"> Let lenVal be the result of Get(O, &ldquo;length&rdquo;).</div>
</li>
<li class="level1"><div class="li"> Let n be ToLength(lenVal).</div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(n).</div>
</li>
<li class="level1"><div class="li"> <u>Let putStatus be n.</u></div>
</li>
<li class="level1"><div class="li"> Let items be an internal List whose elements are, in left to right order, the arguments that were passed to this function invocation.</div>
</li>
<li class="level1"><div class="li"> <u>Let <em>numAdded</em> be the length of the <em>items</em> list.</u></div>
</li>
<li class="level1"><div class="li"> <u>Call the [[BeginChange]] internal method passing O and &ldquo;splice&rdquo;.</u></div>
</li>
<li class="level1"><div class="li"> <u>Repeat, while items is not empty and status.[[type]] is normal</u></div>
<ol>
<li class="level2"><div class="li"> Remove the first element from items and let E be the value of the element.</div>
</li>
<li class="level2"><div class="li"> Let putStatus be the result of Put(O, ToString(n), E, true).</div>
</li>
<li class="level2"><div class="li"> <u>If putStatus.[[type]] is normal, increase n by 1.</u></div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> <u>If putStatus.[[type]] is normal, let putStatus be the result of Put(O, &ldquo;length&rdquo;, n, true).</u></div>
</li>
<li class="level1"><div class="li"> <u>Call the [[EndChange]] internal method passing O and &ldquo;splice&rdquo;.</u></div>
</li>
<li class="level1"><div class="li"> <u>Let removed be the result of ArrayCreate(0).</u></div>
</li>
<li class="level1"><div class="li"> <u>Let R be the result of calling [[CreateSpliceChangeRecord]] with arguments: O, lenVal, removed and numAdded.</u></div>
</li>
<li class="level1"><div class="li"> <u>Call [[EnqueueChangeRecord]] passing O and R</u></div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(putStatus)</div>
</li>
<li class="level1"><div class="li"> Return n.</div>
</li>
</ol>

</div>
<!-- SECTION [10663-12285] -->
<a name="array.prototype.shift"></a><h5>Array.prototype.shift</h5>
<div class="level5">

<p>
 22.1.3.21 Array.prototype.shift ( )
</p>

<p>
The first element of the array is removed from the array and returned. 
</p>
<ol>
<li class="level1"><div class="li"> Let O be the result of calling ToObject passing the this value as the argument.</div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(O).</div>
</li>
<li class="level1"><div class="li"> Let lenVal be the result of Get(O, &ldquo;length&rdquo;).</div>
</li>
<li class="level1"><div class="li"> Let len be ToLength(lenVal).</div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(len).</div>
</li>
<li class="level1"><div class="li"> If len is zero, then</div>
<ol>
<li class="level2"><div class="li"> Let putStatus be the result of Put(O, &ldquo;length&rdquo;, 0, true).</div>
</li>
<li class="level2"><div class="li"> ReturnIfAbrupt(putStatus).</div>
</li>
<li class="level2"><div class="li"> Return undefined.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> <u>Call the [[BeginChange]] internal method passing O and &ldquo;splice&rdquo;.</u></div>
</li>
<li class="level1"><div class="li"> Let first be the result of Get(O, &ldquo;0&rdquo;).</div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(first).</div>
</li>
<li class="level1"><div class="li"> <u>Let status be first</u></div>
</li>
<li class="level1"><div class="li"> Let k be 1.</div>
</li>
<li class="level1"><div class="li"> <u>Repeat, while status.[[type]] is normal and k &lt; len</u></div>
<ol>
<li class="level2"><div class="li"> Let from be ToString(k).</div>
</li>
<li class="level2"><div class="li"> Let to be ToString(k–1).</div>
</li>
<li class="level2"><div class="li"> Let fromPresent be the result of HasProperty(O, from).</div>
</li>
<li class="level2"><div class="li"> Let status be fromPresent.</div>
</li>
<li class="level2"><div class="li"> <u>If status.[[type]] is normal</u></div>
<ol>
<li class="level3"><div class="li"> If fromPresent is true, then</div>
<ol>
<li class="level4"><div class="li"> Let fromVal be the result of Get(O, from).</div>
</li>
<li class="level4"><div class="li"> <u>Let status be fromVal</u>.</div>
</li>
<li class="level4"><div class="li"> <u>If status.[[type]] is normal, let putStatus be the result of Put(O, to, fromVal, true).</u></div>
</li>
</ol>
</li>
<li class="level3"><div class="li"> Else, fromPresent is false</div>
<ol>
<li class="level4"><div class="li"> Let status be the result of DeletePropertyOrThrow(O, to).</div>
</li>
</ol>
</li>
<li class="level3"><div class="li"> Increase k by 1.</div>
</li>
</ol>
</li>
</ol>
</li>
<li class="level1"><div class="li"> <u>If status.[[type]] is normal, let status be the result of DeletePropertyOrThrow(O, ToString(len–1)).</u></div>
</li>
<li class="level1"><div class="li"> <u>If status.[[type]] is normal, let status be the result of Put(O, &ldquo;length&rdquo;, len–1, true).</u></div>
</li>
<li class="level1"><div class="li"> <u>Call the [[EndChange]] internal method passing O and &ldquo;splice&rdquo;.</u></div>
</li>
<li class="level1"><div class="li"> <u>Let elements be a new List.</u></div>
</li>
<li class="level1"><div class="li"> <u>Append first to the end of elements.</u></div>
</li>
<li class="level1"><div class="li"> <u>Let removed be the result of CreateArrayFromList(elements).</u></div>
</li>
<li class="level1"><div class="li"> <u>Let R be the result of calling [[CreateSpliceChangeRecord]] with arguments: O, 0, removed and 0.</u></div>
</li>
<li class="level1"><div class="li"> <u>Call [[EnqueueChangeRecord]] passing O and R.</u></div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(status).</div>
</li>
<li class="level1"><div class="li"> Return first.</div>
</li>
</ol>

</div>
<!-- SECTION [12286-14266] -->
<a name="array.prototype.splice"></a><h5>Array.prototype.splice</h5>
<div class="level5">

<p>
 22.1.3.25 Array.prototype.splice (start, deleteCount [ , item1 [ , item2 [ , … ] ] ] )
</p>

<p>
When the splice method is called with two or more arguments start, deleteCount and (optionally) item1, item2, etc., the deleteCount elements of the array starting at array index start are replaced by the arguments item1, item2, etc. An Array object containing the deleted elements (if any) is returned. The following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Let O be the result of calling ToObject passing the this value as the argument.</div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(O).</div>
</li>
<li class="level1"><div class="li"> Let lenVal be the result of Get(O, &ldquo;length&rdquo;)</div>
</li>
<li class="level1"><div class="li"> Let len be ToLength(lenVal).</div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(len).</div>
</li>
<li class="level1"><div class="li"> Let relativeStart be ToInteger(start).</div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(relativeStart).</div>
</li>
<li class="level1"><div class="li"> If relativeStart is negative, let actualStart be max( (len + relativeStart), 0); else let actualStart be min(relativeStart, len).</div>
</li>
<li class="level1"><div class="li"> If start is not present, then</div>
<ol>
<li class="level2"><div class="li"> Let actualDeleteCount be 0.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Else if deleteCount is not present, then</div>
<ol>
<li class="level2"><div class="li"> Let actualDeleteCount be len - actualStart</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Else,</div>
<ol>
<li class="level2"><div class="li"> Let dc be ToInteger(deleteCount).</div>
</li>
<li class="level2"><div class="li"> ReturnIfAbrupt(dc).</div>
</li>
<li class="level2"><div class="li"> Let actualDeleteCount be min(max(dc, 0), len - actualStart).</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Let A be undefined.</div>
</li>
<li class="level1"><div class="li"> If O is an exotic Array object, then</div>
<ol>
<li class="level2"><div class="li"> Let C be the result of Get(O, &ldquo;constructor&rdquo;).</div>
</li>
<li class="level2"><div class="li"> ReturnIfAbrupt(C).</div>
</li>
<li class="level2"><div class="li"> If IsConstructor(C) is true, then</div>
<ol>
<li class="level3"><div class="li"> Let thisRealm be the running execution context&rsquo;s Realm.</div>
</li>
<li class="level3"><div class="li"> If thisRealm and the value of C&rsquo;s [[Realm]] internal slot are the same value, then</div>
<ol>
<li class="level4"><div class="li"> Let A be the result of calling the [[Construct]] internal method of C with argument (actualDeleteCount).</div>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li class="level1"><div class="li"> If A is undefined, then</div>
<ol>
<li class="level2"><div class="li"> Let A be the result of the abstract operation ArrayCreate with the argument actualDeleteCount.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(A).</div>
</li>
<li class="level1"><div class="li"> Let k be 0.</div>
</li>
<li class="level1"><div class="li"> <u>Call the [[BeginChange]] internal method passing O and &ldquo;splice&rdquo;.</u></div>
</li>
<li class="level1"><div class="li"> <u>Let deletedItems be a new List.</u></div>
</li>
<li class="level1"><div class="li"> <u>Let status be relativeStart.</u></div>
</li>
<li class="level1"><div class="li"> <u>Repeat, while status.[[type]] is normal and k &lt; actualDeleteCount</u></div>
<ol>
<li class="level2"><div class="li"> Let from be ToString(actualStart+k).</div>
</li>
<li class="level2"><div class="li"> Let fromPresent be the result of HasProperty(O, from).</div>
</li>
<li class="level2"><div class="li"> <u>Let status be fromPresent.</u></div>
</li>
<li class="level2"><div class="li"> <u>If status.[[type]] is normal, then</u></div>
<ol>
<li class="level3"><div class="li"> If fromPresent is true, then</div>
<ol>
<li class="level4"><div class="li"> Let fromValue be the result of Get(O, from).</div>
</li>
<li class="level4"><div class="li"> <u>Let status be fromValue.</u></div>
</li>
<li class="level4"><div class="li"> <u>If status.[[type]] is normal, then</u></div>
<ol>
<li class="level5"><div class="li"> <u>Let status be the result of CreateDataPropertyOrThrow(A, ToString(k), fromValue).</u></div>
</li>
<li class="level5"><div class="li"> <u>Append fromValue to the end of deletedItems.</u></div>
</li>
</ol>
</li>
</ol>
</li>
<li class="level3"><div class="li"> Increment k by 1.</div>
</li>
</ol>
</li>
</ol>
</li>
<li class="level1"><div class="li"> <u>If status.[[type]] is not throw, let status be the result of Put(A, &ldquo;length&rdquo;, actualDeleteCount, true).</u></div>
</li>
<li class="level1"><div class="li"> <u>If status.[[type]] is not throw, then</u></div>
<ol>
<li class="level2"><div class="li"> Let items be an internal List whose elements are, in left to right order, the portion of the actual argument list starting with item1. The list will be empty if no such items are present.</div>
</li>
<li class="level2"><div class="li"> Let itemCount be the number of elements in items.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> If status.[[type]] is not throw and itemCount &lt; actualDeleteCount, then</div>
<ol>
<li class="level2"><div class="li"> Let k be actualStart.</div>
</li>
<li class="level2"><div class="li"> <u>Repeat, while status.[[type]] is normal and k &lt; (len – actualDeleteCount)</u></div>
<ol>
<li class="level3"><div class="li"> Let from be ToString(k+actualDeleteCount).</div>
</li>
<li class="level3"><div class="li"> Let to be ToString(k+itemCount).</div>
</li>
<li class="level3"><div class="li"> Let fromPresent be the result of HasProperty(O, from).</div>
</li>
<li class="level3"><div class="li"> <u>Let status be fromPresent.</u></div>
</li>
<li class="level3"><div class="li"> <u>If status.[[type]] is normal, then</u></div>
<ol>
<li class="level4"><div class="li"> If fromPresent is true, then</div>
<ol>
<li class="level5"><div class="li"> Let fromValue be the result of Get(O, from).</div>
</li>
<li class="level5"><div class="li"> <u>Let status be fromValue.</u></div>
</li>
<li class="level5"><div class="li"> <u>If status.[[type]] is normal, let status be the result of Put(O, to, fromValue, true).</u></div>
</li>
</ol>
</li>
<li class="level4"><div class="li"> Else, fromPresent is false</div>
<ol>
<li class="level5"><div class="li"> Let status be the result of DeletePropertyOrThrow(O, to).</div>
</li>
</ol>
</li>
<li class="level4"><div class="li"> <u>If status.[[type]] is normal, Increase k by 1.</u></div>
</li>
</ol>
</li>
</ol>
</li>
<li class="level2"><div class="li"> <u>If status.[[type]] is normal, Let k be len.</u></div>
</li>
<li class="level2"><div class="li"> <u>Repeat, while status.[[type]] is normal and k &gt; (len – actualDeleteCount + itemCount)</u></div>
<ol>
<li class="level3"><div class="li"> Let status be the result of DeletePropertyOrThrow(O, ToString(k–1)).</div>
</li>
<li class="level3"><div class="li"> <u>If status.[[type]] is normal, decrease k by 1.</u></div>
</li>
</ol>
</li>
</ol>
</li>
<li class="level1"><div class="li"> <u>Else if status.[[type]] is normal and itemCount &gt; actualDeleteCount, then</u></div>
<ol>
<li class="level2"><div class="li"> Let k be (len – actualDeleteCount).</div>
</li>
<li class="level2"><div class="li"> <u>Repeat, while status.[[type]] is normal and k &gt; actualStart</u></div>
<ol>
<li class="level3"><div class="li"> Let from be ToString(k + actualDeleteCount – 1).</div>
</li>
<li class="level3"><div class="li"> Let to be ToString(k + itemCount – 1)</div>
</li>
<li class="level3"><div class="li"> Let fromPresent be the result of HasProperty(O, from).</div>
</li>
<li class="level3"><div class="li"> <u>Let status be fromPresent.</u></div>
</li>
<li class="level3"><div class="li"> <u>If status.[[type]] is normal, then</u></div>
<ol>
<li class="level4"><div class="li"> If fromPresent is true, then</div>
<ol>
<li class="level5"><div class="li"> Let fromValue be the result of Get(O, from).</div>
</li>
<li class="level5"><div class="li"> <u>Let status be fromValue.</u></div>
</li>
<li class="level5"><div class="li"> <u>If status.[[type]] is normal, let status be the result of Put(O, to, fromValue, true).</u></div>
</li>
</ol>
</li>
<li class="level4"><div class="li"> Else fromPresent is false,</div>
<ol>
<li class="level5"><div class="li"> Let status be the result of DeletePropertyOrThrow(O, to).</div>
</li>
</ol>
</li>
<li class="level4"><div class="li"> <u>If status.[[type]] is normal, decrease k by 1.</u></div>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li class="level1"><div class="li"> <u>If status.[[type]] is normal, then</u></div>
<ol>
<li class="level2"><div class="li"> Let k be actualStart.</div>
</li>
<li class="level2"><div class="li"> <u>Repeat, while status.[[type]] is normal and items is not empty</u></div>
<ol>
<li class="level3"><div class="li"> Remove the first element from items and let E be the value of that element.</div>
</li>
<li class="level3"><div class="li"> Let status be the result of Put(O, ToString(k), E, true).</div>
</li>
<li class="level3"><div class="li"> <u>If status.[[type]] is normal, increase k by 1.</u></div>
</li>
</ol>
</li>
<li class="level2"><div class="li"> Let status be the result of Put(O, &ldquo;length&rdquo;, len – actualDeleteCount + itemCount, true).</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> <u>Call the [[EndChange]] internal method passing O and &ldquo;splice&rdquo;.</u></div>
</li>
<li class="level1"><div class="li"> <u>Let  removed be CreateArrayFromList(deletedItems).</u></div>
</li>
<li class="level1"><div class="li"> <u>Let R be the result of calling [[CreateSpliceChangeRecord]] with arguments: O, actualStart, removed and itemCount.</u></div>
</li>
<li class="level1"><div class="li"> <u>Call [[EnqueueChangeRecord]] passing O and R</u></div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(status)</div>
</li>
<li class="level1"><div class="li"> Return A.</div>
</li>
</ol>

</div>
<!-- SECTION [14267-20152] -->
<a name="array.prototype.unshift"></a><h5>Array.prototype.unshift</h5>
<div class="level5">

<p>
 22.1.3.28 Array.prototype.unshift ( [ item1 [ , item2 [ , … ] ] ] )
</p>

<p>
The arguments are prepended to the start of the array, such that their order within the array is the same as the order in which they appear in the argument list.
</p>

<p>
When the unshift method is called with zero or more arguments item1, item2, etc., the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Let O be the result of calling ToObject passing the this value as the argument.</div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(O).</div>
</li>
<li class="level1"><div class="li"> Let lenVal be the result of Get(O, &ldquo;length&rdquo;)</div>
</li>
<li class="level1"><div class="li"> Let len be ToLength(lenVal).</div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(len).</div>
</li>
<li class="level1"><div class="li"> Let argCount be the number of actual arguments.</div>
</li>
<li class="level1"><div class="li"> Let k be len.</div>
</li>
<li class="level1"><div class="li"> <u>Let status be len.</u></div>
</li>
<li class="level1"><div class="li"> <u>Call the [[BeginChange]] internal method passing O and &ldquo;splice&rdquo;.</u></div>
</li>
<li class="level1"><div class="li"> <u>Repeat, while status.[[type]] is normal and k &gt; 0,</u></div>
<ol>
<li class="level2"><div class="li"> Let from be ToString(k–1).</div>
</li>
<li class="level2"><div class="li"> Let to be ToString(k+argCount –1).</div>
</li>
<li class="level2"><div class="li"> Let fromPresent be the result of HasProperty(O, from).</div>
</li>
<li class="level2"><div class="li"> <u>Let status be fromPresent.</u></div>
</li>
<li class="level2"><div class="li"> <u>If status.[[type]] is normal, then</u></div>
<ol>
<li class="level3"><div class="li"> If fromPresent is true, then</div>
<ol>
<li class="level4"><div class="li"> Let fromValue be the result of Get(O, from).</div>
</li>
<li class="level4"><div class="li"> <u>Let status be fromValue.</u></div>
</li>
<li class="level4"><div class="li"> <u>If status.[[type]] is normal, let putStatus be the result of Put(O, to, fromValue, true).</u></div>
</li>
<li class="level4"><div class="li"> <u>Let status be putStatus.</u></div>
</li>
</ol>
</li>
<li class="level3"><div class="li"> Else, fromPresent is false</div>
<ol>
<li class="level4"><div class="li"> Let deleteStatus be the result of DeletePropertyOrThrow(O, to).</div>
</li>
<li class="level4"><div class="li"> <u>Let status be deleteStatus.</u></div>
</li>
</ol>
</li>
<li class="level3"><div class="li"> If status.[[type]] is not throw, decrease k by 1.</div>
</li>
</ol>
</li>
</ol>
</li>
<li class="level1"><div class="li"> <u>If status.[[type]] is normal, then</u></div>
<ol>
<li class="level2"><div class="li"> Let j be 0.</div>
</li>
<li class="level2"><div class="li"> Let items be a List whose elements are, in left to right order, the arguments that were passed to this function invocation.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> <u>Repeat, while status.[[type]] is normal and items is not empty</u></div>
<ol>
<li class="level2"><div class="li"> Remove the first element from items and let E be the value of that element.</div>
</li>
<li class="level2"><div class="li"> Let status be the result of Put(O, ToString(j), E, true).</div>
</li>
<li class="level2"><div class="li"> <u>If status.[[type]] is normal, increase j by 1.</u></div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Let status be the result of Put(O, &ldquo;length&rdquo;, len+argCount, true).</div>
</li>
<li class="level1"><div class="li"> <u>Call the [[EndChange]] internal method passing O and &ldquo;splice&rdquo;.</u></div>
</li>
<li class="level1"><div class="li"> <u>Let removed be the result of ArrayCreate(0).</u></div>
</li>
<li class="level1"><div class="li"> <u>Let R be the result of calling [[CreateSpliceChangeRecord]] with arguments: O, 0, removed and argCount.</u></div>
</li>
<li class="level1"><div class="li"> <u>Call [[EnqueueChangeRecord]] passing O and R.</u></div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(status)</div>
</li>
<li class="level1"><div class="li"> Return len+argCount.</div>
</li>
</ol>

</div>
<!-- SECTION [20153-22601] -->
<a name="array_exotic_objects"></a><h4>Array Exotic Objects</h4>
<div class="level4">

</div>
<!-- SECTION [22602-22632] -->
<a name="defineownproperty_p_desc"></a><h5>[[DefineOwnProperty]] (P, Desc)</h5>
<div class="level5">

<p>
 9.4.2.1 [[DefineOwnProperty]] (P, Desc)
</p>

<p>
When the [[DefineOwnProperty]] internal method of an exotic Array object A is called with property P, and Property Descriptor Desc the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Assert: IsPropertyKey(P) is true.</div>
</li>
<li class="level1"><div class="li"> If P is &ldquo;length&rdquo;, then</div>
<ol>
<li class="level2"><div class="li"> Return the result of calling ArraySetLength with arguments A, and Desc.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Else if P is an array index, then</div>
<ol>
<li class="level2"><div class="li"> Let oldLenDesc be the result of calling the [[GetOwnProperty]] internal method of A passing &ldquo;length&rdquo; as the argument. The result will never be undefined or an accessor descriptor because Array objects are created with a length data property that cannot be deleted or reconfigured.</div>
</li>
<li class="level2"><div class="li"> Let oldLen be oldLenDesc.[[Value]].</div>
</li>
<li class="level2"><div class="li"> Let index be ToUint32(P).</div>
</li>
<li class="level2"><div class="li"> Assert: index will never be an abrupt completion.</div>
</li>
<li class="level2"><div class="li"> If index ≥ oldLen and oldLenDesc.[[Writable]] is false, then return false.</div>
</li>
<li class="level2"><div class="li"> Let succeeded be the result of calling OrdinaryDefineOwnProperty passing A, P, and Desc as arguments.</div>
</li>
<li class="level2"><div class="li"> ReturnIfAbrupt(succeeded).</div>
</li>
<li class="level2"><div class="li"> If succeeded is false, then return false.</div>
</li>
<li class="level2"><div class="li"> If index ≥ oldLen</div>
<ol>
<li class="level3"><div class="li"> Set oldLenDesc.[[Value]] to index + 1.</div>
</li>
<li class="level3"><div class="li"> Let succeeded be the result of calling OrdinaryDefineOwnProperty passing A, &ldquo;length&rdquo;, and oldLenDesc as arguments.</div>
</li>
<li class="level3"><div class="li"> ReturnIfAbrupt(succeeded).</div>
</li>
<li class="level3"><div class="li"> <u>Call the [[BeginChange]] internal method passing A and &ldquo;splice&rdquo;.</u></div>
</li>
<li class="level3"><div class="li"> <u>Call the [[EndChange]] internal method passing A and &ldquo;splice&rdquo;.</u></div>
</li>
<li class="level3"><div class="li"> <u>Let removed be the result of ArrayCreate(0).</u></div>
</li>
<li class="level3"><div class="li"> <u>Let R be the result of calling [[CreateSpliceChangeRecord]] with arguments: A, oldLen, removed and (index + 1 - oldLen).</u></div>
</li>
<li class="level3"><div class="li"> <u>Call [[EnqueueChangeRecord]] passing A and R</u></div>
</li>
</ol>
</li>
<li class="level2"><div class="li"> Return true.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Return the result of calling OrdinaryDefineOwnProperty passing A, P, and Desc as arguments.</div>
</li>
</ol>

</div>
<!-- SECTION [22633-24532] -->
<a name="arraysetlength_abstract_operation"></a><h5>ArraySetLength Abstract Operation</h5>
<div class="level5">

<p>
 9.4.2.2 ArraySetLength Abstract Operation
</p>

<p>
When the abstract operation ArraySetLength is called with an exotic Array object A, and Property Descriptor Desc the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> If the [[Value]] field of Desc is absent, then</div>
<ol>
<li class="level2"><div class="li"> Return the result of calling OrdinaryDefineOwnProperty passing A, &ldquo;length&rdquo;, and Desc as arguments.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Let newLenDesc be a copy of Desc.</div>
</li>
<li class="level1"><div class="li"> Let newLen be ToUint32(Desc.[[Value]]).</div>
</li>
<li class="level1"><div class="li"> If newLen is not equal to ToNumber( Desc.[[Value]]), throw a RangeError exception.</div>
</li>
<li class="level1"><div class="li"> Set newLenDesc.[[Value]] to newLen.</div>
</li>
<li class="level1"><div class="li"> Let oldLenDesc be the result of calling the [[GetOwnProperty]] internal method of A passing &ldquo;length&rdquo; as the argument. The result will never be undefined or an accessor descriptor because Array objects are created with a length data property that cannot be deleted or reconfigured.</div>
</li>
<li class="level1"><div class="li"> Let oldLen be oldLenDesc.[[Value]].</div>
</li>
<li class="level1"><div class="li"> If newLen ≥oldLen, then</div>
<ol>
<li class="level2"><div class="li"> Return the result of calling OrdinaryDefineOwnProperty passing A, &ldquo;length&rdquo;, and newLenDesc as arguments.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> If oldLenDesc.[[Writable]] is false, then return false.</div>
</li>
<li class="level1"><div class="li"> If newLenDesc.[[Writable]] is absent or has the value true, let newWritable be true.</div>
</li>
<li class="level1"><div class="li"> Else,</div>
<ol>
<li class="level2"><div class="li"> Need to defer setting the [[Writable]] attribute to false in case any elements cannot be deleted.</div>
</li>
<li class="level2"><div class="li"> Let newWritable be false.</div>
</li>
<li class="level2"><div class="li"> Set newLenDesc.[[Writable]] to true.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> Let succeeded be the result of calling OrdinaryDefineOwnProperty passing A, &ldquo;length&rdquo;, and newLenDesc as arguments.</div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(succeeded).</div>
</li>
<li class="level1"><div class="li"> If succeeded is false, return false.</div>
</li>
<li class="level1"><div class="li"> <u>Call the [[BeginChange]] internal method passing A and &ldquo;splice&rdquo;.</u></div>
</li>
<li class="level1"><div class="li"> <u>Let removedList be a new List.</u></div>
</li>
<li class="level1"><div class="li"> <u>Let status be succeeded.</u></div>
</li>
<li class="level1"><div class="li"> <u>Let numAdded be newLen - oldLen.</u></div>
</li>
<li class="level1"><div class="li"> <u>If numAdded &lt; 0, then let numAdded be 0.</u></div>
</li>
<li class="level1"><div class="li"> <u>While status.[[type]] is normal and newLen &lt; oldLen repeat,</u></div>
<ol>
<li class="level2"><div class="li"> Set oldLen to oldLen – 1.</div>
</li>
<li class="level2"><div class="li"> <u>Let oldValue be the result of Get(A, ToString(oldLen)).</u></div>
</li>
<li class="level2"><div class="li"> <u>Let status be oldValue.</u></div>
</li>
<li class="level2"><div class="li"> <u>If status.[[type]] is normal, then</u></div>
<ol>
<li class="level3"><div class="li"> <u>Add oldValue to the front of removedList.</u></div>
</li>
<li class="level3"><div class="li"> Let deleteSucceeded be the result of calling the [[Delete]] internal method of A passing ToString(oldLen).</div>
</li>
<li class="level3"><div class="li"> <u>Let status be deleteSucceeded.</u></div>
</li>
<li class="level3"><div class="li"> If deleteSucceeded is false, then</div>
<ol>
<li class="level4"><div class="li"> Set newLenDesc.[[Value]] to oldLen+1.</div>
</li>
<li class="level4"><div class="li"> If newWritable is false, set newLenDesc.[[Writable]] to false.</div>
</li>
<li class="level4"><div class="li"> <u>Let status be the result of calling OrdinaryDefineOwnProperty passing A, &ldquo;length&rdquo;, and newLenDesc as arguments.</u></div>
</li>
<li class="level4"><div class="li"> <u>If status.[[type]] is normal, then</u></div>
<ol>
<li class="level5"><div class="li"> Return false.</div>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li class="level1"><div class="li"> <u>If status.[[type]] is normal and newWritable is false, then</u></div>
<ol>
<li class="level2"><div class="li"> Call OrdinaryDefineOwnProperty passing A, &ldquo;length&rdquo;, and Property Descriptor{[[Writable]]: false} as arguments. This call will always return true.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> <u>Call the [[EndChange]] internal passing A and &ldquo;splice&rdquo;.</u></div>
</li>
<li class="level1"><div class="li"> <u>Let removed be the result of ArrayCreateFromList(removedList).</u></div>
</li>
<li class="level1"><div class="li"> <u>Let R be the result of calling [[CreateSpliceChangeRecord]] with arguments: A, newLen, removed and numAdded.</u></div>
</li>
<li class="level1"><div class="li"> <u>Call [[EnqueueChangeRecord]] passing A and R.</u></div>
</li>
<li class="level1"><div class="li"> ReturnIfAbrupt(status)</div>
</li>
<li class="level1"><div class="li"> Return true.</div>
</li>
</ol>

</div>
<!-- SECTION [24533-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/4/469a33d1bd1b64c72f44bc17cd10669d.xhtml used -->
</body>
</html>
