<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=meetings" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#october_19-20_meeting" class="toc">October 19-20 meeting</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#administrivia" class="toc">Administrivia</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#agenda" class="toc">Agenda</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#discussion_-_thursday" class="toc">Discussion - Thursday</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#syntax_for_the_semantics" class="toc">Syntax for the semantics</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#digressiontutorial_on_ml_data_types" class="toc">Digression: Tutorial on ML data types</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#primitivecallcc" class="toc">Primitive: call/cc</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#primitive_data_types_of_the_semantics" class="toc">Primitive data types of the semantics</a></span><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#digression_on_namespaces" class="toc">Digression on namespaces</a></span></li>
</ul>
</li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#primitive_data_types_of_the_semantics_ii" class="toc">Primitive data types of the semantics II</a></span><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#the_machine" class="toc">The machine</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#environment" class="toc">Environment</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#objects_and_properties" class="toc">Objects and properties</a></span></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#sundry_late-thursday_issues" class="toc">Sundry late-Thursday issues</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#new_proposals" class="toc">New proposals?</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#source_code_control" class="toc">Source code control</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#discussion_-_friday" class="toc">Discussion - Friday</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#lars_s_example_expr_evaluator" class="toc">Lars's example (expr evaluator)</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#asts" class="toc">ASTs</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#recent_changes" class="toc">Recent changes</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#proposal_review" class="toc">Proposal review</a></span><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#digressionliterate_programming" class="toc">Digression: Literate programming?</a></span></li>
</ul>
</li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_oct_19_2006&amp;do=export_html.html#proposal_review_ii" class="toc">Proposal review II</a></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<a name="october_19-20_meeting"></a><h1>October 19-20 meeting</h1>
<div class="level1">

</div>
<!-- SECTION [1-37] -->
<a name="administrivia"></a><h2>Administrivia</h2>
<div class="level2">

<p>
 Venue: Adobe Corp, Newton MA
</p>

<p>
Participants:
</p>
<ul>
<li class="level1"><div class="li"> Jeff Dyer, Adobe</div>
</li>
<li class="level1"><div class="li"> Graydon Hoare, Mozilla</div>
</li>
<li class="level1"><div class="li"> Steven Johnson, Adobe</div>
</li>
<li class="level1"><div class="li"> Edwin Smith, Adobe</div>
</li>
<li class="level1"><div class="li"> Brian Crowder, Mozilla</div>
</li>
<li class="level1"><div class="li"> Doug Crockford, Yahoo</div>
</li>
<li class="level1"><div class="li"> Cormac Flanagan, UC Santa Cruz</div>
</li>
<li class="level1"><div class="li"> Paul Betlem, Adobe</div>
</li>
<li class="level1"><div class="li"> Dan Smith, Adobe</div>
</li>
<li class="level1"><div class="li"> Erik Tierney, Adobe</div>
</li>
<li class="level1"><div class="li"> Dave Herman, Northastern University</div>
</li>
<li class="level1"><div class="li"> Brendan Eich, Mozilla</div>
</li>
<li class="level1"><div class="li"> Chris Pine, Opera</div>
</li>
<li class="level1"><div class="li"> Lars Thomas Hansen, Opera</div>
</li>
</ul>

</div>
<!-- SECTION [38-480] -->
<a name="agenda"></a><h2>Agenda</h2>
<div class="level2">

<p>
 Thursday (post-hoc): 
</p>
<ul>
<li class="level1"><div class="li"> Syntax for the semantics</div>
</li>
<li class="level1"><div class="li"> ML data types tutorial</div>
</li>
<li class="level1"><div class="li"> Primitive data types and operations</div>
</li>
<li class="level1"><div class="li"> Sundry</div>
</li>
</ul>

<p>
 Friday: 
</p>
<ul>
<li class="level1"><div class="li"> Go over recent changes and unfinished proposals to get ready for republishing the wiki</div>
</li>
<li class="level1"><div class="li"> More about the abstract machine</div>
</li>
<li class="level1"><div class="li"> Lars&rsquo;s examples</div>
</li>
<li class="level1"><div class="li"> New proposals to debate?</div>
</li>
<li class="level1"><div class="li"> Strategy / task assignments for the next month</div>
</li>
</ul>

</div>
<!-- SECTION [481-867] -->
<a name="discussion_-_thursday"></a><h2>Discussion - Thursday</h2>
<div class="level2">

</div>
<!-- SECTION [868-902] -->
<a name="syntax_for_the_semantics"></a><h3>Syntax for the semantics</h3>
<div class="level3">

<p>
 Jeff and Dave have been putting their heads together to sketch out a proposal.  The current idea is a somewhat rich SSA-like specification language with high-level control flow mechanism (including exceptions) but abstracting away from accidents of syntax in the source language (eg, all the kinds of <code>for</code> loops there are).
</p>

<p>
Something like SSA is good because:
</p>
<ul>
<li class="level1"><div class="li"> the metalanguage is then quasi-functional, hence more readable</div>
</li>
<li class="level1"><div class="li"> it makes all mutation in the source language explicit</div>
</li>
<li class="level1"><div class="li"> it makes order of evaluation requirements very clear</div>
</li>
<li class="level1"><div class="li"> SSA is a good intermediate form for various implementation strategies</div>
</li>
<li class="level1"><div class="li"> it&rsquo;s readable (more so than the <code>goto</code> style of old)</div>
</li>
<li class="level1"><div class="li"> it might make it easier for the compiler writer to see what&rsquo;s compile-time and what&rsquo;s run-time</div>
</li>
</ul>

<p>
 The metalanguage exceptions can be used for modelling most control flow: break, continue, and throw, at least; whether return should be modelled this way is open(?).
</p>

<p>
Cormac: what&rsquo;s called &ldquo;Loop&rdquo; in the current draft is what Scheme calls &ldquo;recur&rdquo;?  Who will like this except from Scheme programmers?
</p>

<p>
Dave: The idea is to express the requirement that SSA &ldquo;calls&rdquo; to the &ldquo;Loop&rdquo; must be tail-recursive.  And it&rsquo;s nice not having to model state in the metalanguage.
</p>

<p>
What do we think of the notation?  Will developers read it?  Should developers be able to read it, or should we just rely on David Flanagan (<a href="http://www.oreilly.com/catalog/jscript4/index.html" class="urlextern" target="_blank" title="http://www.oreilly.com/catalog/jscript4/index.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">http://www.oreilly.com/catalog/jscript4/index.html</a>) being able to read it?  Now we have <code>let</code> and left-arrow, which distinguishes it from the source language; this advantage is also a hindrance to &ldquo;average&rdquo; programmers (who will consider it alien).
</p>

<p>
Maybe left-arrow should be &ldquo;=&rdquo; in a funny font.  (But it&rsquo;s hard to email a funny font.)
</p>

<p>
Brendan: The primary role should be to assist implementors to create interoperable implementations.  (There are secondary goals, too, but.)
</p>

<p>
Dave: The &ldquo;loop&rdquo; is not that alien.  As the name implies, it&rsquo;s just a loop with a funny &ldquo;do it again&rdquo; syntax.
</p>

<p>
Jeff: This is primarily not about accessibility, but about implementability &ndash; the spec must give some guidance in this regard.
</p>

<p>
Brendan: Explicit is good.  The E4X spec is &ldquo;intuitive&rdquo;, but wrong.  Being more explicit reduces the scope for being wrong.
</p>

<p>
Jeff: Should we worry about hitting a wall somewhere?  
</p>

<p>
Brendan: Let&rsquo;s worry about that when we get there.
</p>

<p>
Discussion: We want to factor primitives of the abstract machine, this aids readers and implementors.  We should have <code>ToBoolean</code> as a primitive (even if it is in turn defined in terms of some abstract <code>Convert</code>), because this aids understanding.
</p>

<p>
Metalanguage syntax: parens or not around calls to metafunctions?  Certainly calls to metafunctions should be distinguished syntactically from calls to ecmascript functions.  We can use fonts, but that&rsquo;s a problem for transmitting things through <acronym title="American Standard Code for Information Interchange">ASCII</acronym> (email); uppercase or sigils might work.  And calls to ecmascript functions need to distinguish between nontail and tail calls anyway, probably with some <code>call</code> and <code>tailcall</code> keyword.
</p>

<p>
Jeff: why do we have curly braces when we have indentation?
</p>

<p>
Dave: the braces are used for sequencing and value generation: the last operation generates a value.  And <code>let</code> only appears inside braces.
</p>

<p>
<strong>Decision</strong>: The consensus seems to be that indentation is OK (except that it&rsquo;s sensitive to email bugs (like Python)).
</p>

<p>
Doug: Maybe we should keep the bullets to make it visually distinguished?  (Again, an <acronym title="American Standard Code for Information Interchange">ASCII</acronym> problem.)
</p>

<p>
Jeff: Do we need to have a keyword for generating values from an expression?  (Proposals: <code>return</code>, <code>result</code>, <code>yield</code>, <code>produce</code>).  Consensus seems to be that we don&rsquo;t benefit from this, it doesn&rsquo;t actually add very much.
</p>

<p>
Doug: We&rsquo;re drifting awfully far away from the source language, is this good?  Should we not instead use a kernel ecmascript to describe the full language?
</p>

<p>
Dave: I&rsquo;m concerned about confusing the reader, who has to mentally separate layers of language, whereas with a clearly different metalanguage this is less of an issue.
</p>

<p>
Brendan: I like an expression language.
</p>

<p>
Cormac: now we&rsquo;re defining two languages... maybe this is the way to go, but it seems we could benefit from using an existing (meta)language.
</p>

<p>
Several people want to use a subset of ML... but then the question is, how do we model store, continuations, objects?  And what are the impacts?  Do we end up using encoding tricks that obscure the semantics?  What about type soundness proofs?  Do we gain anything significant?
</p>

<p>
Graydon&rsquo;s ML translation of the <code>while</code> fragment:
</p>
<pre class="code">
let Eval while_loop (e : parenloop expr) (s : substatement) labels = 
  try
    let rec L result =
      let v = Eval e labels in
      let x = Read v in
      let b = Convert x Boolean in
      if Not b
      then
        let current =
        try
          Eval s labels
        with
          Continue lb when inlabels lb labels -&gt; nothing
        in
        let next = (if current = nothing then result else current) in
        L next
      else
        result
    in
      L nothing
  with 
    Break lb when lb in labels -&gt; nothing
</pre>

<p>
<strong>Decision:</strong> we&rsquo;ll try using an ML subset rather than the ad-hoc proposed language.
</p>

<p>
Which subset?  The options are really Standard ML and O&rsquo;Caml.  We could pick a subset that works in both dialects.
</p>

</div>
<!-- SECTION [903-6230] -->
<a name="digressiontutorial_on_ml_data_types"></a><h3>Digression: Tutorial on ML data types</h3>
<div class="level3">

<p>
 Sum types:  
</p>
<pre class="code"> type color = Red 
            | Green
            | Blue of int</pre>

<p>
 (The values of color are Red, Green, or some shade of Blue).
</p>

<p>
Product types: anonymous and named: 
</p>
<pre class="code">(int * int)
{ x: int; y: int }</pre>

<p>
 Aliasing: 
</p>
<pre class="code">type k = (int * int)
type e = {x: int; y: int }</pre>

<p>
 Now we do: 
</p>
<pre class="code">type color = Red of e 
           | Blue of (int*int)</pre>

<p>
 Sum type constructor names (<code>Blue</code>) need to have initial capital letter, and they need to be unique (can&rsquo;t have Red several places).
</p>

<p>
Record types must be distinguishable: can&rsquo;t have two types e and f that look exactly the same.
</p>

<p>
There&rsquo;s no subtyping in Standard ML; O&rsquo;Caml does have something here (but some debate about what exactly...)
</p>

<p>
Construction: 
</p>
<pre class="code">(2,3) is of type k
{ x=10; y=20 } is of type e</pre>
<pre class="code">[]    is same as the word &quot;nil&quot; (?)
x::y  conses an element x onto a list y</pre>

<p>
 Binding: 
</p>
<pre class="code">let e = Red in ...
let e : color = Red in ...</pre>

<p>
 Destructuring: 
</p>
<pre class="code">match e with
  Red -&gt; ...
| Green x -&gt; ...
| Blue (a,b) -&gt; ...</pre>

<p>
 Type variables / parameterized types: 
</p>
<pre class="code">type 'a color = Red
              | Green of 'a
              | Blue of (int * 'a)</pre>
<pre class="code">type 'a 'b pair = ('a * 'b)</pre>

<p>
 Here, <code>int int pair</code> is the same as (int * int) in every regard.
</p>

<p>
Instantiation: 
</p>
<pre class="code">let e : int color = Red in ...</pre>

<p>
 Built-in types: 
</p>
<pre class="code">type 'a list = 'a :: ('a list)
             | []</pre>
<pre class="code">type 'a option = Some 'a
               | None</pre>

<p>
 Reference types: <code>ref</code> is a keyword and used both as type name and value constructor: 
</p>
<pre class="code">type 'a ref = ...</pre>
<pre class="code">let x : int ref = ref 10 in 
    print !x  (* print the value *)
    x := 20   (* update it *)</pre>

<p>
 Some sugar for this: 
</p>
<pre class="code">type foo = { mutable x: int; y: int }  (* data type with mutable field *)</pre>

<p>
 Suppose foo is defined.  Then because there is uniqueness of data types (see above) the x is mutable in the following example: 
</p>
<pre class="code">let k = {x=10 ; y=12} in
  k.x &lt;- 12</pre>

<p>
 Immutable update: 
</p>
<pre class="code">type k = { x: int; y: int }
let e = { x=10; y=12 } in
  { e with y=20 }</pre>

</div>
<!-- SECTION [6231-8253] -->
<a name="primitivecallcc"></a><h3>Primitive: call/cc</h3>
<div class="level3">

<p>
 Discussion: explicit or implicit stack in the abstract machine?  
</p>

<p>
An implicit stack is easier: save machine state in local variables on nontail call; restore it on return.
</p>

<p>
An explicit stack has a ccontinuation register in machine; there is explicit construction of a new frame on this stack on nontail call, with loading of values from the frame on return.  This is more work / hair / detail; we duplicate existing machinery.
</p>

<p>
But an implicit stack makes yield much harder to implement in a transparent way.  We may need to use call/cc or some generator abstraction, or a completion type (effectively CPS).
</p>

<p>
So something like this:
</p>
<pre class="code">
  function count(n) {
    for (let i =0 ; i &lt; n ; i++ )
      yield i
  }
</pre>

<p>
is rewritten as
</p>
<pre class="code">
  function count(n) {
    return generator( function (result) {
                        for (let i =0 ; i &lt; n ; i++ )
                          result(i)
                      } ) 
  }
</pre>

<p>
where <code>generator</code> hides the magic of <code>call-with-current-continuation</code>.
</p>

<p>
The problem now is that ML (be it SML or O&rsquo;Caml) does not have <code>call/cc</code>.  SML/NJ does, and there are patches for O&rsquo;Caml that implement it (on some platforms), but now we&rsquo;re running up against limit of the specification language.
</p>

<p>
Completion types seem hard, because they tend to leak into the spec.  We really want to contain this inside an abstraction.
</p>

<p>
<strong>Decision</strong>: we&rsquo;ll bite the bullet and use <code>call/cc</code>.  This will require a custom version of O&rsquo;Caml; we&rsquo;ll need to put up binaries for this for people (including us) to use.
</p>

</div>
<!-- SECTION [8254-9838] -->
<a name="primitive_data_types_of_the_semantics"></a><h3>Primitive data types of the semantics</h3>
<div class="level3">

<p>
 We should define the data types as ADTs: sets of operations on typed but opaque data.
</p>

<p>
Multinames: can be modeled either as set of open namespaces on the abstract machine along with a simple name, or as a data type that captures the open namespaces at compile time and is passed around at runtime and is used alone to look up properties.  What&rsquo;s better for the spec?
</p>

<p>
Ed: the set of open namespaces mirrors the environment, so can in principle be maintained as part of or in tandem with the environment.  A compiler does that; our definitional interpreter could do this.
</p>

</div>
<!-- SECTION [9839-10459] -->
<a name="digression_on_namespaces"></a><h4>Digression on namespaces</h4>
<div class="level4">

<p>
 Principles at work: 
</p>
<ul>
<li class="level1"><div class="li"> You don&rsquo;t want code to change meaning when you add annotations</div>
</li>
<li class="level1"><div class="li"> You don&rsquo;t want real ambiguities to escape uncaught</div>
</li>
</ul>

<p>
 Thus if you have: 
</p>
<pre class="code">class A { ns1 var x; }
class B extends A { ns2 var x; }
function f(o) { use namespace ns1, ns2; return o.x; }
f(new B)</pre>

<p>
 There is no ambiguity, and annotating o does not change this fact.  (I&rsquo;m going to get <code>ns1::x</code>, and the reason for that is to avoid introducing ambiguity with annotation: if you annotate <code>o</code> as type <code>A</code> you definitely want to find <code>ns1::x</code>.  You want the static types and static namespaces to correlate, to pave the way for compilers.)
</p>

<p>
However, there is an ambiguity in 
</p>
<pre class="code">class B { ns1 var x; ns2 var x; }
function f(o) { use namespace ns1, ns2; return o.x; }</pre>

<p>
 Ditto for the structural counterpart.
</p>

<p>
(Long discussion on cost of this, but agreement in the end to stick with the algorithm that Waldemar defined, which basically searches for the top of the hierarchy for matches.)
</p>

</div>
<!-- SECTION [10460-11475] -->
<a name="primitive_data_types_of_the_semantics_ii"></a><h3>Primitive data types of the semantics II</h3>
<div class="level3">

</div>
<!-- SECTION [11476-11527] -->
<a name="the_machine"></a><h4>The machine</h4>
<div class="level4">

<p>
 Dave: we should avoid using mutation on the semantic data structures except where it is implied by ECMAScript.  This means eg that the machine state should be updated functionally, not by mutation.
</p>

<p>
Doug: why is <code>this</code> seen as a part of the machine and not part of the enviroment?
</p>

<p>
Lars: ES3 implies this.
</p>

<p>
Doug: but it&rsquo;s broken in ES3... we want inner functions to inherit the this from the outer function.
</p>

<p>
Brendan: we agreed to fix that, it&rsquo;s a little subtle: 
</p>
<pre class="code">
  function outer() {
    print(this)
    return function() {
      return this;
    }
  }
  outer()() =&gt; global
  o = { foo: outer }
  o.foo()() =&gt; o
</pre>

<p>
Doug: Then it&rsquo;s natural for <code>this</code> to be in the environment, not in the machine.
</p>

<p>
Lars: Sure, using a private property name to look it up.
</p>

<p>
Jeff: Anything else that goes into the machine than the environment?  The ML machine state certainly is in there, but right now it looks like a classical interpreter.
</p>

<p>
Lars: there are static things, like open namespaces and the rounding mode/precision settings.  They influence whether we use multinames or have a context for primitives?
</p>

<p>
Dave: these are all static things, they could be used for rewriting all the code in a prepass.  Or they go into the environment.
</p>

<p>
Lars: Or they could be passed around as a package.
</p>

<p>
The key seems to be that these things are all environment-like, they are all statically scoped, and at least namespaces are chained in the same sense that environments are &ndash; you need to find multiple values.  And for the numeric type pragmas, they may shadow some parts and other parts not.  Perhaps what&rsquo;s really here is that these values are parts of an attribute set for each <code>Block</code> that needs to be activated when the block is activated, but there&rsquo;s no searching involved at runtime.  So we&rsquo;re back to Dave&rsquo;s prepass, with annotation happening at an intermediate level.
</p>

<p>
Jeff: let&rsquo;s put it all into the environment for now.
</p>

</div>
<!-- SECTION [11528-13475] -->
<a name="environment"></a><h4>Environment</h4>
<div class="level4">

<p>
 Dave/Cormac: updateable environment through <code>setVariableName</code> sort of unusual but not really a problem.
</p>

</div>
<!-- SECTION [13476-13603] -->
<a name="objects_and_properties"></a><h4>Objects and properties</h4>
<div class="level4">

<p>
 The <code>getClassName</code> is the one from ES3.
</p>

<p>
The <code>getPropertyValue</code> should operate only on the object, not on the prototype chain.
</p>

<p>
Cormac: &ldquo;property&rdquo; vs &ldquo;slot&rdquo;?
</p>

<p>
Brendan: &ldquo;slot&rdquo; is internal value storage.  There may be properties without storage (their values are computed every time).  
</p>

<p>
Cormac: worried about overabstraction here...
</p>

<p>
Lars: I think that for the moment we are looking for primitives, abstractions, etc.  It is useful to use functional abstraction for the moment, at least, and perhaps remove some detail once things are clearer.
</p>

<p>
There needs to be a type property on objects.  What does this point to?  Some internal instance type, what ActionScript calls the Traits object (which is immutable). 
</p>
<pre class="code">ClassProto
    ^
    |  &quot;prototype&quot;  &quot;constructor&quot;
  Class &lt;-----------&gt; Proto
    |                  ^
    +---+   ...        |
        |  /           |
        v / [[Super]]  |
      Traits           |
        ^              |
        |              | [[Prototype]]
        +---------- Object
            [[Type]]</pre>

<p>
 Here the Traits object is entirely internal, it does not exist in the language and can&rsquo;t be expressed in any way.
</p>

<p>
Tentatively we name it <code>TypeDescriptor</code>.
</p>

</div>
<!-- SECTION [13604-14852] -->
<a name="sundry_late-thursday_issues"></a><h2>Sundry late-Thursday issues</h2>
<div class="level2">

</div>
<!-- SECTION [14853-14893] -->
<a name="new_proposals"></a><h3>New proposals?</h3>
<div class="level3">

<p>
 Monotyped arrays (for byte arrays, say &ndash; and a <code>byte</code> type).  People needing this now uses strings and <code>charCodeAt</code> but this is not very good.
</p>

<p>
The fear is that if we don&rsquo;t do it now, then we won&rsquo;t be able to do it at all.  But we&rsquo;re way past the proposal deadline.
</p>

</div>
<!-- SECTION [14894-15191] -->
<a name="source_code_control"></a><h3>Source code control</h3>
<div class="level3">

<p>
 Mozilla will host a <acronym title="Concurrent Versions System">CVS</acronym> repository for the definitional interpreter.  It&rsquo;ll be visible to others, but no big deal.  We need to deal with the licensing issue, find a copyright that works for everyone (and for ECMA, and for <acronym title="International Organization for Standardization">ISO</acronym>).
</p>

</div>
<!-- SECTION [15192-15451] -->
<a name="discussion_-_friday"></a><h2>Discussion - Friday</h2>
<div class="level2">

</div>
<!-- SECTION [15452-15484] -->
<a name="lars_s_example_expr_evaluator"></a><h3>Lars's example (expr evaluator)</h3>
<div class="level3">

<p>
 Dave: Should binding objects be real ECMAScript objects with all that baggage?  There are pros and cons, notably all the machinery we have to be careful to avoid for looking things up in lexical ribs.
</p>

<p>
Lars: eval kills a lot of clever optimizations here &ndash; it can introduce new variables that are deletable, for example.  And we can create &ldquo;plain&rdquo; objects for internal use.
</p>

<p>
Dave: Is it good to be destructively updating the binding object?
</p>

<p>
Lars: see above; eval gets you.
</p>

<p>
Cormac: Do we really want both a reference implementation and a spec?  Nice if we get both...
</p>

<p>
Jeff: It feels a little alien but is probably a matter of getting used to.
</p>

<p>
Brendan: Software engineering issues are probably important to make it readable and good.
</p>

<p>
Jeff: Can we define some sort of transformer to make the ML more readable?  (Discussion &ndash; probably removes some of the benefit of using ML in the first place.)
</p>

<p>
Steven: Let&rsquo;s collect some ML references on the wiki, for common use.
</p>

<p>
We must expect to try and fail a few times.  We don&rsquo;t have a budget for this.  We need to pin down the DNA fairly soon but before we are done with that it&rsquo;s hard to throw a lot of people at the problem.  So that&rsquo;s on the critical path.  We should worry about expressiveness, not whether it compiles right now.
</p>

<p>
Brendan: let&rsquo;s cover some hard cases today and see how far we get.
</p>

<p>
What are the hard cases?
</p>

</div>
<!-- SECTION [15485-16902] -->
<a name="asts"></a><h3>ASTs</h3>
<div class="level3">

<p>
 Graydon works on generating ML data types from AST nodes from Lars&rsquo;s java implementation.
</p>

</div>
<!-- SECTION [16903-17009] -->
<a name="recent_changes"></a><h3>Recent changes</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Destructuring assignment: just some notes about things that need to be cleaned up a little.  There is no problem vis-a-vis AS3&rsquo;s annotations (which look like array literals) because they don&rsquo;t appear in assignment statements</div>
</li>
<li class="level1"><div class="li"> Multiple compilation units: now looks like a proposal (but it still seems unfinished)</div>
</li>
<li class="level1"><div class="li"> Getters and setters: the <code>call</code> proposal probably does not have a use case and goes away.  Objects with getters and setters can be typed; the argument of the setter and the return type of the getter must conform to the type declared for the property that has getters/setters.</div>
</li>
</ul>

</div>
<!-- SECTION [17010-17637] -->
<a name="proposal_review"></a><h3>Proposal review</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Grammar: The grammar will contain a mapping from concrete syntax to the AST structures defined in ML.  This mapping will also imply the necessary annotation of some structures during parsing</div>
</li>
<li class="level1"><div class="li"> Type system syntax: Some ML structure... falls out from the AST definition.  The type checker evaluates the ASTs</div>
</li>
<li class="level1"><div class="li"> Abstract machine and syntactic semantics: Goal for today is to have decent first cuts of these (syntactic semantics pretty much goes away because we&rsquo;re using ML).  Perhaps also a style guide, and a description of the subset of ML we&rsquo;re using (if we&rsquo;re using a subset).  A better name for &ldquo;abstract machine&rdquo; might be &ldquo;reference evaluator&rdquo;</div>
</li>
<li class="level1"><div class="li"> Built-in objects: we should just use ECMAScript 4 with some escape clause to a &ldquo;native&rdquo; language (eg ML).</div>
</li>
<li class="level1"><div class="li"> Descriptive prose: we want a simple summary / commentary of what it is that the code defines, connected with the code in some way.  </div>
</li>
</ul>

</div>
<!-- SECTION [17638-18566] -->
<a name="digressionliterate_programming"></a><h4>Digression: Literate programming?</h4>
<div class="level4">

<p>
 How do we keep the prose and the code in sync?  Literate programming does not seem like a workable idea, but with the code under SCM and the text on the wiki we&rsquo;re afraid of losing sync.  Maybe it&rsquo;s not a big deal provided the commentary is fairly high level.  We would like to cross-link from SCM to wiki and back, or make the wiki page include the ML into when it&rsquo;s displayed.
</p>

</div>
<!-- SECTION [18567-18989] -->
<a name="proposal_review_ii"></a><h3>Proposal review II</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Verification: describe this in a separate phase (with separate ML code).  Some code will be similar to the regular evaluator</div>
</li>
<li class="level1"><div class="li"> Multiple compilation units: Still work to be done; Brendan thinks introducing an object in the scope chain may not be the right thing (and does not describe what AS3 currently does).  Perhaps move this from proposal to clarification / guideline status.</div>
</li>
<li class="level1"><div class="li"> Resurrected eval: We drop it.</div>
</li>
<li class="level1"><div class="li"> Slice syntax: it&rsquo;s good, and it&rsquo;s in.</div>
</li>
<li class="level1"><div class="li"> JSON is in, though it still needs some work</div>
</li>
<li class="level1"><div class="li"> Trim should use the same whitespace set as regexes and the lexer generally.</div>
</li>
</ul>

<p>
 We are 100% happy and break for lunch!
</p>

</div>
<!-- SECTION [18990-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/2/24c34b18a7bfd6b276415c53b6ff45f9.xhtml used -->
</body>
</html>
