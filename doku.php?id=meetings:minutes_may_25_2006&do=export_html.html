<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=meetings" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#25_may_2006" class="toc">25 May 2006</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#attending" class="toc">Attending</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#agenda" class="toc">Agenda</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#discussion" class="toc">Discussion</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#phases_of_compilation_static_vs._dynamic" class="toc">Phases Of Compilation / Static vs. Dynamic</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#multiple_compilation_units" class="toc">Multiple Compilation Units</a></span><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#concepts" class="toc">Concepts</a></span></li>
</ul>
</li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#private_and_sealed_packages" class="toc">Private and sealed packages</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#namespace_shadowing" class="toc">Namespace shadowing</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#operators" class="toc">Operators</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#public_review" class="toc">Public review</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#review_of_the_proposal_list" class="toc">Review of the proposal list</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#proposals" class="toc">Proposals</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#day_two" class="toc">Day Two</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#nullability" class="toc">Nullability</a></span><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#non-nullable_locals" class="toc">Non-nullable locals</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#complexity_of_nullability" class="toc">Complexity of nullability</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#lvalues" class="toc">Lvalues</a></span></li>
</ul>
</li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#numbers" class="toc">Numbers</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#to_conversion" class="toc">&quot;to&quot; conversion</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#static_and_dynamic" class="toc">Static and Dynamic</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#meta-objects" class="toc">Meta-Objects</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#contracts" class="toc">Contracts</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#stack_inspection" class="toc">Stack Inspection</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#quick_review_of_proposals" class="toc">Quick review of &quot;!&quot; proposals</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:minutes_may_25_2006&amp;do=export_html.html#next_meeting" class="toc">Next Meeting</a></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<a name="25_may_2006"></a><h1>25 May 2006</h1>
<div class="level1">

<p>
 Meeting time 12pm PDT.
</p>

</div>
<!-- SECTION [1-51] -->
<a name="attending"></a><h2>Attending</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Francis Cheng, Adobe</div>
</li>
<li class="level1"><div class="li"> Michael Daumling, Adobe</div>
</li>
<li class="level1"><div class="li"> Jeff Dyer, Adobe</div>
</li>
<li class="level1"><div class="li"> Gary Grossman, Adobe</div>
</li>
<li class="level1"><div class="li"> Dan Smith, Adobe</div>
</li>
<li class="level1"><div class="li"> Brendan Eich, Mozilla</div>
</li>
<li class="level1"><div class="li"> Dave Herman, Northeastern</div>
</li>
<li class="level1"><div class="li"> Lars Thomas Hansen, Opera</div>
</li>
<li class="level1"><div class="li"> Cormac Flanagan, UC Santa Cruz</div>
</li>
</ul>

<p>
 On phone: 
</p>
<ul>
<li class="level1"><div class="li"> Graydon Hoare, Mozilla</div>
</li>
<li class="level1"><div class="li"> Blake Kaplan, Mozilla</div>
</li>
<li class="level1"><div class="li"> Edwin Smith, Adobe</div>
</li>
</ul>

</div>
<!-- SECTION [52-405] -->
<a name="agenda"></a><h2>Agenda</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <a href="doku.php%3Fid=proposals:strict_and_standard_modes.html" class="wikilink1" title="proposals:strict_and_standard_modes" onclick="return svchk()" onkeypress="return svchk()">static vs dynamic</a> / phases of compilation</div>
</li>
<li class="level1"><div class="li"> <a href="doku.php%3Fid=clarification:multiple_compilation_units.html" class="wikilink1" title="clarification:multiple_compilation_units" onclick="return svchk()" onkeypress="return svchk()">multiple compilation units</a></div>
</li>
<li class="level1"><div class="li"> <code>let</code> at top-level vs. incremental compilation</div>
</li>
<li class="level1"><div class="li"> review all <a href="doku.php%3Fid=proposals:proposals.html" class="wikilink1" title="proposals:proposals" onclick="return svchk()" onkeypress="return svchk()">proposals</a></div>
</li>
<li class="level1"><div class="li"> <a href="doku.php%3Fid=proposals:contracts.html" class="wikilink1" title="proposals:contracts" onclick="return svchk()" onkeypress="return svchk()">contracts</a></div>
</li>
<li class="level1"><div class="li"> <a href="doku.php%3Fid=clarification:formal_type_system.html" class="wikilink1" title="clarification:formal_type_system" onclick="return svchk()" onkeypress="return svchk()">formal type system</a></div>
</li>
<li class="level1"><div class="li"> <a href="doku.php%3Fid=proposals:meta_objects.html" class="wikilink1" title="proposals:meta_objects" onclick="return svchk()" onkeypress="return svchk()">reflection</a>, or how first-class are types?</div>
</li>
<li class="level1"><div class="li"> <a href="doku.php%3Fid=proposals:stack_inspection.html" class="wikilink1" title="proposals:stack_inspection" onclick="return svchk()" onkeypress="return svchk()">stack inspection</a></div>
</li>
<li class="level1"><div class="li"> Date for Oslo meeting / discuss June meeting</div>
</li>
</ul>

</div>
<!-- SECTION [406-879] -->
<a name="discussion"></a><h2>Discussion</h2>
<div class="level2">

</div>
<!-- SECTION [880-903] -->
<a name="phases_of_compilation_static_vs._dynamic"></a><h3>Phases Of Compilation / Static vs. Dynamic</h3>
<div class="level3">

<p>
 Lars wishes to ensure that parse/execution model is compatible with an ahead-of-time compilation solution.  Goal is to pin down the semantics of the draft spec, and define invariants on the phases of compilation. For instance, constant folding always before type checking. Forward references can be assumed to be computed in earlier phase. Optimizations are possible, such as constant folding at runtime, but Lars wants to be able to know that his implementation is correct by matching the behavior of a canonical definition.
</p>

<p>
The spec specifies that verifying is a separate phase, but doesn&rsquo;t specify when type checking, constant folding happen.
</p>

<p>
Jeff figures that type checking and constant folding can be merged.
</p>

<p>
Lars wants to know that A can come before B, but B cannot come before A.
</p>

<p>
Where are compile-time constants required?  Classes, interfaces, const, namespaces, type annotations.
</p>

<p>
The spec currently states that you can write 
</p>
<pre class="code">const C = 3
const D = C</pre>

<p>
 and then D can be used as a compile-time constant wherever.
</p>

<p>
Brendan asks: Is this legal? 
</p>
<pre class="code">function f(const T:Type, a:Array&lt;T&gt;)</pre>

<p>
 Lars: No, that should not be legal.  It seems needlessly complicated. 
</p>
<pre class="code">function f&lt;T&gt;(a:Array&lt;T&gt;)</pre>

<p>
 Dave: It seems awfully intricate for the type checker to be dependent on the constant folding process. 
</p>
<pre class="code">class Foo { ... }
const x:Type = Foo;
new x (...)</pre>

<p>
 Dave would be happy giving this the type dynamic, not giving it the type Foo.  One of the things that bothered him about Waldemar&rsquo;s spec was the multiple phases.
</p>

<p>
Jeff: Is there a usability problem if we know that x is foo?
</p>

<p>
Dave: If you have const x defined in some other module that someone provided you, it&rsquo;s hard to mentally understand what the type system is going to do without going through it in detail in your head. If the type system&rsquo;s rules are simple, then it&rsquo;s easy to see what is going to happen, and it&rsquo;s locally readable without having to mentally compile the whole program.
</p>

<p>
Namespaces, there are statically known namespaces and dynamic ones. But that is not distinguished by the const keyword.  Having namespace declarations inform the type system makes sense, but constant folding, not clear what the value to the user is.
</p>

<p>
Lars: My system has no compilation phase; just parse and execute. No constant folding, but there is constant computation to do type checking at the point of function invocation.
</p>

<p>
Dave: Constant evaluation vs. constant folding: Constant evaluation is looking at const declarations and determining what is a known constant.  Constant folding is looking at 2+4 and determining that it can be replaced with 6.
</p>

<p>
Lars: Right, that was a misstatement in the proposal, we&rsquo;re talking about constant evaluation here.
</p>

<p>
Brendan: This doesn&rsquo;t change the binding of f, due to function hoisting: 
</p>
<pre class="code">alert(f)
function f() { ... }
alert (f)
var f;
if (f)</pre>

<p>
 Do you want to model that as a source transformation?
</p>

<p>
const says that the value of a binding will not change once it is initialized, and you can&rsquo;t delete a const.
</p>

<p>
A const field doesn&rsquo;t have to be initialized with a constant expression, and same with a const variable.  It&rsquo;s a local promise within the scope of a const... a write-once variable.
</p>

<p>
You can have forward references to const things, but they may not be initialized yet.
</p>

<p>
Dave: Waldemar&rsquo;s spec had some notion of a true compile-time constant which basically came down to textual substitution; an efficiency hack.  Is that possible now?
</p>

<p>
Jeff: Yes.  And it can be done in most cases.  But that requires constant evaluation.
</p>

<p>
Brendan: The following code prints undefined: 
</p>
<pre class="code">var x = y;
const y = y2;
print(x);</pre>

<p>
 It is not an error.
</p>

<p>
Michael Daumling: This is a real-world example of incompatible behavior.  With constant folding, the if statement will enter the else block. 
</p>
<pre class="code">function f() {
  if (typeof c == &quot;undefined&quot;)
  ...
  else ...
}
f()
const c = 5;
f()</pre>

<p>
 Dave: Constant evaluation often doesn&rsquo;t seem worth it because to preserve backwards compatibility, the language can&rsquo;t do anything with the information anyway.  I am distinguishing between things declared with &ldquo;const&rdquo;, versus things like &ldquo;namespace&rdquo; and &ldquo;class&rdquo;. It is a given that namespace and class needs to be looked at early, especially for things like mutual recursion.  But const doesn&rsquo;t come with the same guarantees.
</p>

<p>
Lars: Suppose a namespace is declared with a <acronym title="Uniform Resource Identifier">URI</acronym> whose value  is assembled using const declarations.
</p>

<p>
Brendan: Is this what you&rsquo;re talking about? 
</p>
<pre class="code">namespace N = p.s
package p {
  ...
  const s = &quot;foo&quot;
}</pre>

<p>
 Lars: Package needs to be above.
</p>

<p>
Brendan: There&rsquo;s no doubt, then, that that would have a definite value.
</p>

<p>
Dave: What happens if the packages are in separate compilation units?
</p>

<p>
Jeff: That is fine as long as you do last-minute verification.  As long as the value is available at verification time.
</p>

<p>
Cormac: Can we perhaps handle this with thunks?
</p>

<p>
Lars: Spec mechanism, or implementation mechanism?
</p>

<p>
Jeff: Waldemar had a fairly detailed algorithm in the section called compile-time constants, which could perhaps be a candidate proposal. I don&rsquo;t think we need to be as elaborate as he was.  Why don&rsquo;t we leave this as, we need to pin this down soon, which I think was the point.
</p>

</div>
<!-- SECTION [904-6169] -->
<a name="multiple_compilation_units"></a><h3>Multiple Compilation Units</h3>
<div class="level3">

<p>
 In AS3, every compilation unit gets its own global object and implicit namespace.  Toplevel code in a file goes into a file-specific namespace. Unless it is declared public, it would be hidden from outside code. There is an implicit package.  It&rsquo;s not quite the same as just putting a block around the file due to hoisting behavior. 
</p>
<pre class="code">File 1
package p {
  public var x = 10
}</pre>
<pre class="code">File 2
import p.x
print(x)</pre>
<pre class="code">File 3
package p {
  public var y = x
}</pre>
<pre class="code">Scope chain
...
F3 &lt;- this.p
F2
F1</pre>

<p>
 The global objects of all other modules are under the current global object, and get searched for imported definitions.
</p>

<p>
There are some quirks in the current AS3 implementation, like the global builtins are in a separate G global object by themselves. The global builtins are a separate program, essentially. So this.NaN is undefined, but NaN works.  Jeff thinks we need to fix that.
</p>

<p>
Brendan: I was hoping that we could achieve universal functioning of the &ldquo;is&rdquo; operator, even for types in different &ldquo;trust domains&rdquo; that are interoperating.
</p>

<p>
Dave: If there were UUID&rsquo;s associated with type names, then we could be assured that types are truly nominal types.
</p>

<p>
Gary: In AS3, there is an abstract (type) world and a concrete (object) world, and we instantiate the concrete objects from the abstract type information.  But the abstract type information for the builtins is computed at initialization, and then we instantiate that same type information into concrete objects over and over again for each trust domain.  But the &ldquo;is&rdquo; operator would work fine for &ldquo;is Number&rdquo;, etc. between two trust domains that are interoperating because they share the same type description for Number.
</p>

<p>
Brendan: That is important, we want types to be platonic. 
</p>
<pre class="code">class C {
  static public function g() {
    return f;
  }
}</pre>

<p>
 What goes on the right hand of an &ldquo;is&rdquo; is a type expression. &ldquo;is&rdquo; is used to refer to this world of abstract types, where this is only one copy shared across multiple windows, but not shared across virtual machines.
</p>

<p>
Dave: There seems to be an ambiguity here where there could be a type expression or a value expression, if we are to know the type of the result of the new operator statically: 
</p>
<pre class="code">class Foo { ... }
const x:Type = Foo
new x (...)</pre>

<p>
 Brendan: The spec cannot be ambiguous on this point.
</p>

<p>
Dave: One cannot use a structural type in the new operator, like 
</p>
<pre class="code">new {x:String}</pre>

<p>
 It&rsquo;s not a type expression.  Although it does evaluate to an object.
</p>

<p>
Brendan: 
</p>
<pre class="code">new f.&lt;T&gt;(a,b,c)</pre>

<p>
 Graydon had this example in his proposal; a sort function parameterized to a vector-of-int type: 
</p>
<pre class="code">g = f.&lt;int&gt;;</pre>

<p>
 In Edition 3, you can do new on lots of crazy things: 
</p>
<pre class="code">new g(a,b,c)</pre>

<p>
 Dave: New of any expression is allowed since any expression might turn into a function.
</p>

<p>
Brendan: Making sure of one thing.  You don&rsquo;t need parens on new: 
</p>
<pre class="code">new Date</pre>

<p>
 But you can: 
</p>
<pre class="code">new Date()</pre>

<p>
 And then if you add: 
</p>
<pre class="code">new Date().getTime()</pre>

<p>
 The precedence is: 
</p>
<pre class="code">(new Date()).getTime()</pre>

<p>
 Group confirmed that yes, we still preserve this in the E4 spec.
</p>

<p>
Dave: When we have a new, if the thing that follows the new  is an expression, then we don&rsquo;t know the type.  If we recognize that what follows the new is a type expression, then we know the type of the result of the new operator.  When you have a variable that is bound statically to a type, then when you see that expression, you know exactly how it will evaluate. But otherwise, in general, you don&rsquo;t know what type it will evaluate to.  So there is a syntactic subset that you can reason about for the benefit of the type system.
</p>

<p>
Jeff: Watch out, since * allows a free downcast, but Object does not.
</p>

<p>
Brendan: From the AS3 folks, would they be happy with the new operator type being determined or not?
</p>

<p>
Gary: They would be pretty insistent that they get errors when the type of a new mismatches with what it&rsquo;s being assigned to, so they would want the type to be determined wherever possible.
</p>

<p>
Dave: It seems confusing that the user doesn&rsquo;t know, has to take on the additional cognitive load to see what the types are.
</p>

<p>
Gary: We don&rsquo;t currently have const x:Type = Foo, but if we have it, then people would use it to alias types and want the type to be determined.
</p>

<p>
Dave: But that&rsquo;s what &ldquo;type A = B&rdquo; is for; with const it&rsquo;s not as well-defined.  With &ldquo;type A = B&rdquo; it is fine to do that.
</p>

<p>
Brendan: OK, so this is a motion for simplicity in the type system.
</p>

<p>
Lars: Type directives, defining a type T = Blah, the expression Blah needs to have the same rules for evaluation as constant evaluation.  So, it doesn&rsquo;t change much.
</p>

<p>
Brendan: You don&rsquo;t have hoisting, but you were saying about recursion...
</p>

<p>
Lars: We could fix it so that you couldn&rsquo;t do recursive types, and only be able to refer to stuff previously typed.
</p>

<p>
Graydon: That brings on the more general question, what are you going to do about recursive nominal types?  You absolutely have to support a Node type that has a Node type as a child.  So, I don&rsquo;t see why it can&rsquo;t be supported in the structural case.
</p>

<p>
Dave: It&rsquo;s possible to do structural recursive types, but it&rsquo;s a more complicated algorithm.  Newer Palsberg/Schwartzbach is O(n^2), original Amadio/Cardelli is O(exp(n)).  The papers are complicated and difficult to understand, so you&rsquo;re asking a lot of the implementors. Also, when you&rsquo;re doing runtime checks, you&rsquo;re running a N^2 algorithm.  The &ldquo;is&rdquo; operator could be a N^2 algorithm instead of a simple lookup a chain.  My concerns are about efficiency and complexity of implementation.  Obviously, you want recursive nominal types.
</p>

<p>
Maybe we put in the spec a note that in the future, we&rsquo;d allow recursive structural types.
</p>

<p>
Graydon: Think real language use cases... if someone really needs a recursive type, it&rsquo;s not a big deal to go to recursive nominal types.
</p>

</div>
<!-- SECTION [6170-12005] -->
<a name="concepts"></a><h4>Concepts</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> Default Package</div>
</li>
<li class="level1"><div class="li"> Global Object</div>
</li>
<li class="level1"><div class="li"> Default Namespace</div>
</li>
</ul>
<pre class="code">window 1  +-- &lt;html&gt;              --+
          |     &lt;script&gt;            |
shared    |       var x = 10        |
global    |     &lt;/script&gt;           |
shared    |     &lt;script&gt;            | different
default   |       print(x)          | globals
pkg       +--   &lt;/script&gt;           |
                                    | different
          +-- &lt;/html&gt;               | default
window 2  |   &lt;html&gt;                | package
          |     &lt;script&gt;            |
          |       print(window1.x)  |
          |     &lt;/script&gt;           |
          +-- &lt;/html&gt;             --+</pre>

<p>
 Gary: The stacking of global objects is a way of conceiving how AS3 is importing definitions, but we actually are doing more like an imported definition table for performance.
</p>

<p>
Brendan: I would like to avoid a normative description of how this works that involves really deep scope chains.
</p>

</div>
<!-- SECTION [12006-12980] -->
<a name="private_and_sealed_packages"></a><h3>Private and sealed packages</h3>
<div class="level3">

<p>
 Jeff: This is related somewhat to Lars&rsquo;s private package proposal.
</p>

<p>
Also, the sealed package proposal.  My feeling is we punt on &ldquo;final&rdquo; just because it becomes too constrained to be useful.
</p>

<p>
Lars: You could allow it only on packages that have one source.
</p>

<p>
Jeff: But is that going to be useful?
</p>

<p>
Dave: We could leave it up to the implementations.
</p>

<p>
Cormac: What&rsquo;s the motivation?  Security?
</p>

<p>
Brendan: Not so much security, since that&rsquo;s not a very comprehensive security mechanism, but it&rsquo;d be one line of defense.  Mostly it is about integrity of programming in the large.
</p>

<p>
Private packages are not too controversial, but sealed packages poses some challenges, like imposing some rules on loading modules which we&rsquo;ve tried to avoid in the spec effort thus far.
</p>

<p>
So, final, sealed packages are out for now.
</p>

<p>
But local packages are in.
</p>

<p>
We entertained using the keyword &ldquo;local&rdquo;, since we&rsquo;ve been trying to avoid using &ldquo;private&rdquo; outside of classes. But, in the end, we concluded that &ldquo;private&rdquo; is OK for now.
</p>

</div>
<!-- SECTION [12981-14025] -->
<a name="namespace_shadowing"></a><h3>Namespace shadowing</h3>
<div class="level3">
<pre class="code">namespace debug
namespace release
debug function trace() { ... }
release function trace() { ... }
use namespace release
{
  use namespace debug
  trace(&quot;foo&quot;)
}</pre>

<p>
 Today in AS3: ambiguous reference error
</p>

<p>
Desired: shadowing; more useful behavior 
</p>
<pre class="code">use namespace release
function foo() {
  var trace=10
}
{
  use namespace debug
  trace(&quot;foo&quot;)
}</pre>

<p>
 Brendan: This is the fix that I wanted when I made my namespaces slide, so thank you!
</p>

<p>
Jeff: OK, noncontroversial, I guess.
</p>

<p>
Jeff: That would work for imports, too, I guess.
</p>

</div>
<!-- SECTION [14026-14608] -->
<a name="operators"></a><h3>Operators</h3>
<div class="level3">

<p>
 Daumling: Should we permit compound assignment operators to be overridden independently?
</p>

<p>
Graydon: I think there&rsquo;s a solid argument for allowing them to be overridden separately.
</p>

<p>
Brendan: Yes, definitely something like +=, you want to be able to override apart from +.
</p>

</div>
<!-- SECTION [14609-14900] -->
<a name="public_review"></a><h3>Public review</h3>
<div class="level3">

<p>
 We probably want to set up a listserv/usenet group.  Talk pages could get overwhelmed... if you watch Wikipedia talk pages, it&rsquo;s a mess.  A Wiki isn&rsquo;t as good as something built for conversation.
</p>

<p>
We want the cream to rise to the top in our pitcher, not someone else&rsquo;s pitcher.  Lambda the Ultimate can knock itself  out but we should have our own forum.
</p>

<p>
Graydon doesn&rsquo;t think DokuWiki is particularly well-suited to a large number of editors.
</p>

<p>
We could do a Google Group or something.
</p>

<p>
We need to move clarification issues off the front of the  proposals namespace so that someone coming to this stuff fresh doesn&rsquo;t get a mouthful of clarificat
</p>

<p>
ion issues.
</p>

<p>
ACTION ITEM: Graydon will do it later.  (Graydon completed this.)
</p>

<p>
Graydon mentioned this for exporting the site:
</p>

<p>
<a href="http://wiki.splitbrain.org/wiki:export" class="urlextern" target="_blank" title="http://wiki.splitbrain.org/wiki:export" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">http://wiki.splitbrain.org/wiki:export</a>
</p>

</div>
<!-- SECTION [14901-15743] -->
<a name="review_of_the_proposal_list"></a><h3>Review of the proposal list</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Clarification issues</div>
<ul>
<li class="level2"><div class="li"> <a href="doku.php%3Fid=clarification:dispatch_rules.html" class="wikilink1" title="clarification:dispatch_rules" onclick="return svchk()" onkeypress="return svchk()">dispatch_rules</a>: Can move to resolved. Putting happy face.</div>
</li>
<li class="level2"><div class="li"> <a href="doku.php%3Fid=clarification:code_mixing.html" class="wikilink1" title="clarification:code_mixing" onclick="return svchk()" onkeypress="return svchk()">code_mixing</a>: Still an unhappy face.</div>
</li>
<li class="level2"><div class="li"> <a href="doku.php%3Fid=proposals:namespace_shadowing.html" class="wikilink1" title="proposals:namespace_shadowing" onclick="return svchk()" onkeypress="return svchk()">namespace_shadowing</a>: Jeff working on it.</div>
</li>
<li class="level2"><div class="li"> <a href="doku.php%3Fid=clarification:abstract_syntax_tree.html" class="wikilink1" title="clarification:abstract_syntax_tree" onclick="return svchk()" onkeypress="return svchk()">abstract_syntax_tree</a>: Broader question... do we even want to talk about the syntax of AST&rsquo;s in this context?  Or is that implementation-specific?  Lars thinks clear rules for verification, etc. could be written down if we have clear layout of AST.  But it also falls under notation to some extent.  We can use publication syntax like ALGOL 60 did.  We can put this off for a little bit until we are working on notation.</div>
</li>
<li class="level2"><div class="li"> <a href="doku.php%3Fid=proposals:normative_grammar.html" class="wikilink1" title="proposals:normative_grammar" onclick="return svchk()" onkeypress="return svchk()">normative grammar</a>: What does checkable syntax mean?  It probably means different things to different people.</div>
<ul>
<li class="level3"><div class="li"> To Jeff, it meant having a parser available.  But that may not be what others were thinking.</div>
</li>
<li class="level3"><div class="li"> To Graydon, it means not publishing a spec with a grammar that has never been checked against real code.  A surprisingly common feature of language specs is that if you implement it to the letter, it can&rsquo;t parse most programs... you have to tweak it until it works.</div>
</li>
<li class="level3"><div class="li"> Dave has a friend from Utrecht who has a tool called SDF which will tell you if the grammar is a CFG.</div>
</li>
<li class="level3"><div class="li"> Brendan doesn&rsquo;t think we&rsquo;re LL(2), and have some bottom-up issues.  Narcissus switches into LR mode for operator precedence.  It had 3 tokens of lookahead.</div>
</li>
<li class="level3"><div class="li"> Lars: It is probably really hard to formalize what the grammar is, which can be a real problem.</div>
</li>
<li class="level3"><div class="li"> Challenges: <acronym title="Extensible Markup Language">XML</acronym> literals, regular expressions, unary plus, for...in</div>
</li>
<li class="level3"><div class="li"> Brendan would like to use the &ldquo;right&rdquo; formalism.</div>
</li>
<li class="level3"><div class="li"> Dave: It is hard to plug the JavaScript grammar into any formalism.</div>
</li>
<li class="level3"><div class="li"> Lars: You need error productions in Bison just to do semicolon insertion.  Pinning down rules for semicolon insertion would be a step forward.  Jeff: Waldemar tried to tackle that.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <a href="doku.php%3Fid=clarification:compact_profile.html" class="wikilink1" title="clarification:compact_profile" onclick="return svchk()" onkeypress="return svchk()">compact_profile</a>: Lars thinks this has all been resolved.</div>
<ul>
<li class="level3"><div class="li"> Trying to avoid too much profile complexity.  Reflection should be in a library.  Can&rsquo;t throw out compiler.</div>
</li>
<li class="level3"><div class="li"> We don&rsquo;t want compact profile to be a separate spec; want it to be part of the regular spec.</div>
</li>
<li class="level3"><div class="li"> Lars says 21% of scripts use eval.</div>
</li>
<li class="level3"><div class="li"> Gets a happy face.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <a href="doku.php%3Fid=clarification:drop_traits.html" class="wikilink1" title="clarification:drop_traits" onclick="return svchk()" onkeypress="return svchk()">drop_traits</a>: Think Graydon wanted it in some waste-bin.  Graydon: Get rid of it!</div>
<ul>
<li class="level3"><div class="li"> Ed mapped out difficulty of mapping metaslots on to vtables.  Traits is the way to go.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <a href="doku.php%3Fid=clarification:lexical_scope.html" class="wikilink1" title="clarification:lexical_scope" onclick="return svchk()" onkeypress="return svchk()">lexical_scope</a>: Was all Dave&rsquo;s bag of neuroses!  Which have all been quelled or justified.  (A few have been confirmed.)</div>
<ul>
<li class="level3"><div class="li"> Lars: We fixed a lot of these with use_static to kill some of the other problems.</div>
</li>
<li class="level3"><div class="li"> Mostly, Dave was afraid that the places without lexical scope would destroy type soundness, but type dynamic is the escape hatch so he feels fine.</div>
</li>
<li class="level3"><div class="li"> Smiley face.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <a href="doku.php%3Fid=proposals:normative_grammar.html" class="wikilink1" title="proposals:normative_grammar" onclick="return svchk()" onkeypress="return svchk()">normative grammar</a>: Jeff will put a pointer to the grammar he has been making, and that will get baked into the spec at some point.</div>
</li>
<li class="level2"><div class="li"> <a href="doku.php%3Fid=proposals:typeof.html" class="wikilink1" title="proposals:typeof" onclick="return svchk()" onkeypress="return svchk()">typeof</a>: Jeff thought that Brendan&rsquo;s latest proposal was that typeof is broken, and let&rsquo;s leave it alone except for null.</div>
<ul>
<li class="level3"><div class="li"> We don&rsquo;t want to get into expanding typeof with a bunch of new strings... adding typeof xml for E4X probably didn&rsquo;t help.</div>
</li>
<li class="level3"><div class="li"> It feels like int and uint should at least return typeof number?</div>
</li>
<li class="level3"><div class="li"> For class and interface, we could return function for compatibility, but it feels weird.</div>
</li>
<li class="level3"><div class="li"> Summary:</div>
<ul>
<li class="level4"><div class="li"> typeof(null) == &ldquo;null&rdquo;</div>
</li>
<li class="level4"><div class="li"> typeof(int/uint) == &ldquo;number&rdquo;</div>
</li>
<li class="level4"><div class="li"> typeof(class/interface) == &ldquo;function&rdquo;</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <a href="doku.php%3Fid=proposals:syntax_for_pragmas.html" class="wikilink1" title="proposals:syntax_for_pragmas" onclick="return svchk()" onkeypress="return svchk()">syntax_for_pragmas</a></div>
<ul>
<li class="level3"><div class="li"> Let&rsquo;s use the names strict and standard</div>
</li>
<li class="level3"><div class="li"> Get rid of dynamic, get rid of dialect</div>
</li>
<li class="level3"><div class="li"> &ldquo;use default namespace&rdquo; as means of steering which namespace definitions go into</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <a href="doku.php%3Fid=clarification:package_semantics.html" class="wikilink1" title="clarification:package_semantics" onclick="return svchk()" onkeypress="return svchk()">package_semantics</a></div>
<ul>
<li class="level3"><div class="li"> Package name with no dot is allowed in AS3</div>
</li>
<li class="level3"><div class="li"> We should think about how things like Dojo today could migrate into Edition 4 namespace/packages 5 years from now.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <a href="doku.php%3Fid=proposals:reserved_words.html" class="wikilink1" title="proposals:reserved_words" onclick="return svchk()" onkeypress="return svchk()">reserved_words</a></div>
<ul>
<li class="level3"><div class="li"> Prototyped not reserving identifiers after &lsquo;.&rsquo;, &lsquo;..&rsquo; or initializers</div>
</li>
<li class="level3"><div class="li"> Get error via error token and then &ldquo;unreserve&rdquo; it based on context in which it falls</div>
</li>
<li class="level3"><div class="li"> Crockford&rsquo;s proposal would lead to people being able to say &ldquo;var var&rdquo;.  Brendan only wants to go as far as unreserving in property context.</div>
</li>
<li class="level3"><div class="li"> We propose that after &lsquo;.&rsquo;, you can use any reserved word.</div>
</li>
<li class="level3"><div class="li"> &lsquo;goto&rsquo; we will probably never do, contextually reserved word.</div>
</li>
<li class="level3"><div class="li"> &lsquo;enum&rsquo; probably will happen one day, and JScript.NET is close to what we want there</div>
</li>
<li class="level3"><div class="li"> <acronym title="Internet Explorer">IE</acronym> only reserves 4 Java words even though Edition 3 calls for pretty much all Java reserved words.  SpiderMonkey backpedaled and unreserved most things, so one can say &ldquo;var enum = 10&rdquo;</div>
</li>
<li class="level3"><div class="li"> Rhino and ExtendScript reserve everything in Edition 3, but they face not the onslaught that is the Web</div>
</li>
<li class="level3"><div class="li"> Future reserved words is no more.  We&rsquo;re moving goto, enum, and debugger into one of the two other reserved word categories.  And making a comment in the spec on the &lsquo;.&rsquo; context, and property initializers.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> <a href="doku.php%3Fid=clarification:type_hierarchy_for_numbers.html" class="wikilink1" title="clarification:type_hierarchy_for_numbers" onclick="return svchk()" onkeypress="return svchk()">type_hierarchy_for_numbers</a></div>
<ul>
<li class="level3"><div class="li"> Conclusion is that int/uint should not be subtypes of Number</div>
</li>
<li class="level3"><div class="li"> The flat model is easy to deal with and doesn&rsquo;t seem to get in the way</div>
</li>
<li class="level3"><div class="li"> Think we&rsquo;re stuck with lowercase int and uint names</div>
</li>
<li class="level3"><div class="li"> For double, decimal, probably lowercase as well for symmetry with our pragma identifiers</div>
</li>
<li class="level3"><div class="li"> Use union type if you want to use &ldquo;is&rdquo; operator</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
<!-- SECTION [15744-21392] -->
<a name="proposals"></a><h3>Proposals</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> <a href="doku.php%3Fid=proposals:is_as_to.html" class="wikilink1" title="proposals:is_as_to" onclick="return svchk()" onkeypress="return svchk()">is_as_to</a>: Translation path from service dialect.  Type annotations boil away in the core language, although leaving some residue.  The annotated static dialect form translates to the dynamic form that the interpreter actually runs.</div>
<ul>
<li class="level2"><div class="li"> Some objections to wording</div>
</li>
<li class="level2"><div class="li"> Graydon: We don&rsquo;t have two dialects; we have two translation paths from one dialect.  The dialect always supports colon annotations.</div>
</li>
<li class="level2"><div class="li"> The execution environment doesn&rsquo;t have anything like colon annotations, but has inserted code to assert/convert.</div>
</li>
<li class="level2"><div class="li"> Lars: var x:T = y does not mean the same as var x:* = y, because one has a cast and the other does not, at least until the execution path is clarified completely.</div>
</li>
<li class="level2"><div class="li"> Jeff: At runtime they mean the same thing.</div>
</li>
</ul>
</li>
</ul>

<p>
 Lars: The meaning of this is what precisely? 
</p>
<pre class="code">var x:T = e</pre>

<p>
 Presumably, one meaning in both dialects.  Yes, one meaning.
</p>

<p>
The question is when meaning is enforced.
</p>

<p>
These two have the same meaning: 
</p>
<pre class="code">var x:T = e
var x:T; x = e</pre>

<p>
 The idea was to map : out of picture using operator to. 
</p>
<pre class="code">var x = e to T
var x; x = e to T</pre>

<p>
 The bizarre thing is that the &ldquo;to&rdquo; operator goes with the assignment as opposed to the declaration.
</p>

<p>
Imagine you had something like the Edition 3 language and you wanted to convert something like this language to it.  You&rsquo;d have some &ldquo;to&rdquo; type helper, __convert.
</p>

</div>
<!-- SECTION [21393-22764] -->
<a name="day_two"></a><h2>Day Two</h2>
<div class="level2">

</div>
<!-- SECTION [22765-22785] -->
<a name="nullability"></a><h3>Nullability</h3>
<div class="level3">

<p>
 We decided that super() must be the first call in a constructor, and cannot contain any references to fields or methods of &ldquo;this&rdquo;.  This is needed for the soundness of the initializer system.
</p>

<p>
When you construct a C, the first thing it does is run initializers and initialize those fields.  Then super() is the first thing that happens in the constructor body.  In the superclass, you then have the same process to initialize its fields, and so on recursively.
</p>

<p>
Same as the way Java does it, and this is a sound system where no non-nullable field will ever be used before having a value.
</p>

<p>
This requires a restriction on innitializer and super calls that they do not refer to &ldquo;this&rdquo; in any way.
</p>

<p>
Could this be done for nullable fields?  It could, but makes things more messy.
</p>

<p>
Can one do this? 
</p>
<pre class="code">var x = 3;
var y = x;</pre>

<p>
 Prior art for non-nullable types: C# has them, haXe might.
</p>

</div>
<!-- SECTION [22786-23689] -->
<a name="non-nullable_locals"></a><h4>Non-nullable locals</h4>
<div class="level4">

<p>
 Scope of let is easy to understand, with var it&rsquo;s not as easy to understand. We might just not allow non-nullable vars.  You&rsquo;d have to use &ldquo;let&rdquo;, the reformed var.  Variable hoisting of &ldquo;var&rdquo; makes things a lot more complicated.
</p>

<p>
A var in a function has a well-defined scope.  But a var in a global object, may be hard to provide guarantees that it&rsquo;s not used before being referred to.
</p>

</div>
<!-- SECTION [23690-24105] -->
<a name="complexity_of_nullability"></a><h4>Complexity of nullability</h4>
<div class="level4">

<p>
 Dave: What if we did nullability in a more lightweight way, by having it essentially insert assertions?  It becomes a mechanism for doing assertions everywhere very easily, where you would&rsquo;ve had to do a null check in the past.  Avoids the complexity of the static checking.
</p>

<p>
Lars thought that contracts could only be used for enforcement on calls.  Dave says that contracts work for fields, too.  And locals?
</p>

<p>
Brendan: One reason people will want the static check is to avoid the performance penalty of constant null checking.
</p>

<p>
Dave: OK, but if we want static check, it has to be sound.  The alternative is a syntax where you can express a null check with a single character.
</p>

<p>
Brendan: Some of the same problems as const where you might refer to it before initialization and get undefined, due to hoisting.
</p>

<p>
Lars: It seems broken that you could refer to an uninitialized const and not get an error.
</p>

<p>
Brendan: We probably have an opportunity to make that an error.
</p>

<p>
The problem with let, var and const is that you can use these things before initialization due to hoisting.  If any are annotated with a non-nullable type, we propose that such uses before initialization are errors.  (Let as an alternative to var is hoisted to the top of the block.)
</p>

<p>
By the time you mention the name of another class, it has to be completely loaded.
</p>

<p>
Brendan has no problem with excluding globals from non-nullable annotations.
</p>

<p>
There may be builtins that use non-nullable types since they exist before the world starts, but user code can&rsquo;t do it.
</p>

<p>
OK, so globals are out, but statics are in.  Locals, we can live with and a reasonable compiler can do a good job.
</p>

<p>
Jeff wants to confirm that this error is a runtime error, not compile time.
</p>

<p>
Yes, the uninitialized error that you used it before initialization, that is a runtime error.
</p>

<p>
Making it a compile time error, even optionally, would require specifying the data flow analysis in the spec.
</p>

<p>
As soon as you say you can report the error early, you must be able to say &ldquo;under what circumstances.&rdquo;
</p>

<p>
Issues with &ldquo;with&rdquo;, even reformed with: 
</p>
<pre class="code">with (o : {x:Complex!}) {
}</pre>
<pre class="code">with (o : {x:Complex!}) {
  var x = 3
  function f(x) {
    if (b) {
      var x
    }
    print (x);
  }
}</pre>

<p>
 Can you ever say that this is an error? 
</p>
<pre class="code">with (o : {x:Complex!}) {
  var x = 3
  function f(x) {
    if (b) {
      var x : Complex! = c
    }
    print (x);
  }
}</pre>

<p>
 In here, x is not initialized unless b is true, so print(x) would be an error if b is false.  A runtime error.
</p>

<p>
At best you can make a conservative approximation, because there is no way to know whether b is true or false.  In general, it is undecidable.  But a compiler is permitted to be conservative.
</p>

<p>
We want this program to run or not run on all systems.
</p>

</div>
<!-- SECTION [24106-26921] -->
<a name="lvalues"></a><h4>Lvalues</h4>
<div class="level4">

<p>
 JScript in <acronym title="Internet Explorer">IE</acronym> allows lvalues that are not Reference type in certain circumstances. 
</p>
<pre class="code">foo() = 10</pre>

<p>
 foo() returns a reference.
</p>

<p>
The Edition 3 grammar does allow this syntax.  We&rsquo;ve carried forward the syntax, which may be overly general.
</p>

<p>
Syntax error if the implementation does not support references.
</p>

<p>
Would that make sense in some circumstances? 
</p>
<pre class="code">x.foo = 6</pre>

<p>
 How do you tell the difference between that and setter?
</p>

<p>
Setter always wins.
</p>

<p>
Jeff to start a proposal on tightening the grammar to not allow certain kinds of expressions as lvalues.
</p>

<p>
ACTION: Jeff to write lvalue proposal
</p>

<p>
A parenthesized expression can be an lvalue, but a comma expression is an rvalue and cannot appear on the lhs of an assignment.
</p>

<p>
Behavior of the delete operator doesn&rsquo;t prove anything, as delete is a &ldquo;big liar&rdquo; in Edition 3. 
</p>
<pre class="code">delete (x, y)</pre>

<p>
 doesn&rsquo;t do anything. 
</p>
<pre class="code">delete (y)</pre>

<p>
 will actually delete y since parens are part of the lvalue grammar.
</p>

</div>
<!-- SECTION [26922-27870] -->
<a name="numbers"></a><h3>Numbers</h3>
<div class="level3">

<p>
 Flat hierarchy.  Types are double, decimal, int, uint.  Number is an alias for whichever type is specified as the default.
</p>

<p>
Simple syntax for literals introduced to give literals a type. 
</p>
<ul>
<li class="level1"><div class="li"> 10.5m is a decimal literal</div>
</li>
<li class="level1"><div class="li"> 10.5d is a double literal</div>
</li>
<li class="level1"><div class="li"> 37i is an int literal</div>
</li>
<li class="level1"><div class="li"> 42u is a uint literal</div>
</li>
</ul>

<p>
 The &ldquo;m&rdquo; suffix is based on C#, not on IEEE.  Mike noted that others have issues with the &ldquo;m&rdquo; suffix but Graydon says he didn&rsquo;t say he personally dislikes it.
</p>

<p>
Dave: What about 
</p>
<pre class="code">Number = 3</pre>

<p>
 Not possible, we&rsquo;ve made that read only.
</p>

<p>
Because of namespace shadowing, we can have a backwards compatible public binding for Number for Edition 3 code.
</p>

<p>
Weird syntax: 
</p>
<pre class="code">10.m.toString()</pre>

<p>
 Well, 
</p>
<pre class="code">10..toString()</pre>

<p>
 was already weird.
</p>

<p>
The rules are right, but weird code can be constructed.  Most of the time people will have a named variable involved.
</p>

<p>
Not allow this: 
</p>
<pre class="code">0x10m</pre>

<p>
 But we should allow: 
</p>
<pre class="code">0x10u
0x10i</pre>

<p>
 What is 
</p>
<pre class="code">1.23i</pre>

<p>
 It&rsquo;s an error!  It&rsquo;s &ldquo;1.&rdquo; abutted against &ldquo;23i&rdquo;, or it&rsquo;s &ldquo;1.23&rdquo; followed by &ldquo;i&rdquo; which is also an error.
</p>

<p>
That tells Jeff that 
</p>
<pre class="code">0x5m</pre>

<p>
 is also an error.
</p>

<p>
Discussing type conversion between different number types.  There is no subtype relationship.  Lars shows example: 
</p>
<pre class="code">function f( g : function (double):double )
f ( function (x:int) : int )</pre>

<p>
 This is a type error in the strict language, because int and double have no common supertype except Object.
</p>

<p>
This is actually fine: 
</p>
<pre class="code">function f( g:function(int):* )
f( function (x:*):int )</pre>

<p>
 Are these record types compatible? 
</p>
<pre class="code">{x:int} {x:double}</pre>

<p>
 They aren&rsquo;t, because they&rsquo;re mutable.
</p>

<p>
It will get nasty with record types with functions inside them.
</p>

<p>
Two types having the subtype relationship and two types having the coercion relationship are not the same thing.  In particular, coercions don&rsquo;t seem to bubble up through structural types, and there seem to be some cases where they should and some cases where they can&rsquo;t.
</p>

</div>
<!-- SECTION [27871-29795] -->
<a name="to_conversion"></a><h3>&quot;to&quot; conversion</h3>
<div class="level3">

<p>
 We&rsquo;ve found a bug in &ldquo;:&rdquo; as &ldquo;to&rdquo; conversion.  It doesn&rsquo;t allow user-defined &ldquo;to&rdquo;, because Bang doesn&rsquo;t respect the &ldquo;to&rdquo; conversion.  If you want to write a program in Bang that does the conversion, there&rsquo;s no way to do that, like between Number and Complex.  There are two concepts being encoded in one construct. 
</p>
<pre class="code">var c : Complex = 10</pre>

<p>
 Bang would reject this no matter how you define Complex.  It looks at the type lattice, and knows that 10 is not related to Complex.  That&rsquo;s how it  is detailed in the draft spec.
</p>

<p>
If you spoof the strict compiler to let this pass, then it will call Complex&rsquo;s function to. 
</p>
<pre class="code">var n = 10
var c : Complex = n</pre>

<p>
 Free pass to numbers in the type lattice: 
</p>
<pre class="code">var n : int = &quot;10&quot;</pre>

<p>
 But then we&rsquo;re not declaring numbers using the language anymore, which goes against our desires. 
</p>
<pre class="code">var s:String = &quot;10&quot;
var n:int = s</pre>

<p>
 Bang currently makes that an error, too.
</p>

<p>
Strict accepts a proper subset of the language.  The question is, what subset?
</p>

<p>
There is no way to specify, in the language, what the behavior will be in Bang.
</p>

<p>
What would it look like? 
</p>
<pre class="code">Complex
  function to Complex (x:Object)
    :Strict(Numeric)</pre>

<p>
 &ldquo;to&rdquo; called by returning, passing and assignment.
</p>

<p>
We need a strict compatibility lattice and a way to define it in the language.
</p>

<p>
If you allow programmers to write their own &ldquo;to&rdquo;, you are inherently going to have an incoherent type system, since programmers can write their own incompatible conversions.
</p>

<p>
Even though this is defined this way: 
</p>
<pre class="code">class int {
  function to (x:*):int { ... }
}</pre>

<p>
 This is a static type error in Bang: 
</p>
<pre class="code">var n:int = &quot;10&quot;</pre>

<p>
 That seemed absurd until we observed that Strict is a subset of the language.
</p>

<p>
The question is, do we want there to be some way to do this in the strict mode? Is the subset too small a subset?
</p>

<p>
The &ldquo;function to&rdquo; conversion was introduced for two purposes, to be able to write the library in the language, and to describe conversions in a way more primitive than type annotations.
</p>

<p>
Jeff: If Bang doesn&rsquo;t respect &ldquo;to&rdquo;, then the subset becomes too small.  So let&rsquo;s add in a way for it to respect &ldquo;to&rdquo;. 
</p>
<pre class="code">Complex {
  function to Complex(x:Object)
    use strict to (Numeric);
    ...</pre>

<p>
 A pragma.  We need type expressions to work in pragmas, now, we&rsquo;ll work it out.
</p>

</div>
<!-- SECTION [29796-32097] -->
<a name="static_and_dynamic"></a><h3>Static and Dynamic</h3>
<div class="level3">

<p>
 Reviewed <a href="doku.php%3Fid=proposals:strict_and_standard_modes.html" class="wikilink1" title="proposals:strict_and_standard_modes" onclick="return svchk()" onkeypress="return svchk()">strict and standard modes</a>.
</p>

</div>
<!-- SECTION [32098-32178] -->
<a name="meta-objects"></a><h3>Meta-Objects</h3>
<div class="level3">

<p>
 Reviewed <a href="doku.php%3Fid=proposals:meta_objects.html" class="wikilink1" title="proposals:meta_objects" onclick="return svchk()" onkeypress="return svchk()">meta_objects</a>.
</p>

</div>
<!-- SECTION [32179-32240] -->
<a name="contracts"></a><h3>Contracts</h3>
<div class="level3">

<p>
 Contract system in PLT Scheme is there in a way to make up for lack of a type system, so that makes its contract system more complicated.
</p>

<p>
For us, we can say that a contract is a refinement of a type, and that&rsquo;s it.
</p>

<p>
Blame annotations, blame assignment should be relatively easy.
</p>

<p>
Compiler may be able to do efficient implementation by augmenting function calls with additional blame information.  Otherwise, implementation using proxies may degrade performance.
</p>

<p>
May need debugging helpers that are also at schedule risk, like source coordinates.
</p>

</div>
<!-- SECTION [32241-32810] -->
<a name="stack_inspection"></a><h3>Stack Inspection</h3>
<div class="level3">

<p>
 Build a way of saving information on the stack.
</p>

<p>
Here are permissions I have so far, can overwrite with new permissions depending on your particular algebra of security restrictions.
</p>

<p>
If every time you make a function call, you save information on the stack about function call you made, and you&rsquo;re trying to do proper tail calls, you end up saving information on the stack with each tail call which nullifies the goal of proper tail calls.
</p>

<p>
<a href="lib/exe/detail.php%3Fid=meetings%253Aminutes_may_25_2006&amp;cache=cache&amp;media=meetings:ecma-052606-1.png.html" class="media" title="meetings:ecma-052606-1.png" onclick="return svchk()" onkeypress="return svchk()"><img src="lib/exe/fetch.php%3Fw=&amp;h=&amp;cache=cache&amp;media=meetings:ecma-052606-1.png" class="media" alt="" /></a>
</p>

<p>
Another strategy is to put marks above the current frame.  This is less problematic because you can do a proper tail call without clobbering the marks above the current stack frame.
</p>

<p>
<a href="lib/exe/detail.php%3Fid=meetings%253Aminutes_may_25_2006&amp;cache=cache&amp;media=meetings:ecma-052606-2.png.html" class="media" title="meetings:ecma-052606-2.png" onclick="return svchk()" onkeypress="return svchk()"><img src="lib/exe/fetch.php%3Fw=&amp;h=&amp;cache=cache&amp;media=meetings:ecma-052606-2.png" class="media" alt="" /></a>
</p>

<p>
Parent activation object could have a slot in it, and save in there.
</p>

<p>
Or save in a separate stack.
</p>

<p>
These are implementation details but just way Dave conceives mentally of it.
</p>

<p>
We could select granularity of marks at level we want.  Probably most implementations would want it to be at level of procedure activations.
</p>

<p>
&ldquo;Try&rdquo; can be implemented in terms of continuation marks in the abstract, although there are some obstacles for this in JavaScript.  One could go to as fine granularity as having every curly brace block introduce a new frame.
</p>

<p>
<acronym title="Application Programming Interface">API</acronym> for stack inspection: 
</p>
<pre class="code">class ControlInspector {
  annotate
  getCurrentAnnotation
  getAnnotations
}</pre>

<p>
 Happy face OK on stack inspection proposal.
</p>

</div>
<!-- SECTION [32811-34234] -->
<a name="quick_review_of_proposals"></a><h3>Quick review of &quot;!&quot; proposals</h3>
<div class="level3">

<p>
 Iterators and generators: Brendan to rewrite.
</p>

<p>
Multiple compilation units: Jeff taking ownership.
</p>

<p>
Binding of &ldquo;this&rdquo;: 
</p>
<pre class="code">function f() {
  print(this)
  function g() {
    print(this)
  }
  g()
  return g
}</pre>
<pre class="code">h = f() // prints &quot;global&quot; 2x
o = {m:f}
k = o.m() // prints &quot;o&quot; 2x</pre>
<pre class="code">function f
o = { m:f }
o.m()
^
|
+-- this</pre>
<pre class="code">f()
^
|
+-- global</pre>

<p>
 All proposals need to be finished up by Wednesday deadline or should be moved to deferred section.
</p>

<p>
The spec namespace needs a bunch of corrections; Jeff and Francis to work on it.
</p>

<p>
Meeting on Wednesday, perhaps go live with materials on Friday.
</p>

<p>
June 1 has been stated deadline so should aim for &ldquo;goodwill&rdquo; of delivering in a predictable fashion.
</p>

<p>
Unicode: Lars will be in Bangkok next week but will try to make progress.
</p>

<p>
Extend Regex: All agreeable.  Brendan is generally happy with what&rsquo;s here but doesn&rsquo;t seem like enough.  But lack of useful character classes.  However, that introduces a lot of complexity (composition, case folding, etc.) so it might be Hard.  Brendan was interested in a &ldquo;/e&rdquo; RegEx switch which let direct tap into the NFA, but too much to bite off.  Brendan will own this one and make a pass at it.
</p>

<p>
Date: getTimezoneOffset is insufficient, you can&rsquo;t actually determine your time zone in any standard way although often people parse the result of Date.toString to get it. 
</p>
<pre class="code">a[i:j] = b
s[i:j]
s.slice(i, j)
a.splice(i, j-i, b)</pre>

<p>
 slice is OK.  It is awkward that we have this splice which is <acronym title="Practical Extraction and Report Language">Perl</acronym>-ish instead of Pythonic. 
</p>
<pre class="code">interface I { }
I.toString()
var v = I
frob(v)</pre>
<pre class="code">type T=U</pre>
<pre class="code">o = { p:42, q:true }
o.toString</pre>
<pre class="code">type U=(A,B,C)
U.toString()</pre>

<p>
 You can say 
</p>
<pre class="code">function f(A) { return new A }
f(Date)
f(f)</pre>

<p>
 But can you say this, with a structural type? 
</p>
<pre class="code">return new { construct:... }</pre>

<p>
 Consequences for eval. 
</p>
<pre class="code">function frob (T:Type) {
  eval(before + T.toString + after)
}</pre>

<p>
 It looks like we need a Type type, which would be the supertype of Class.
</p>

<p>
<a href="lib/exe/detail.php%3Fid=meetings%253Aminutes_may_25_2006&amp;cache=cache&amp;media=meetings:ecma-052606-3.png.html" class="media" title="meetings:ecma-052606-3.png" onclick="return svchk()" onkeypress="return svchk()"><img src="lib/exe/fetch.php%3Fw=&amp;h=&amp;cache=cache&amp;media=meetings:ecma-052606-3.png" class="media" alt="" /></a>
</p>

<p>
<a href="http://pugscode.org/images/metamodel.png" class="urlextern" target="_blank" title="http://pugscode.org/images/metamodel.png" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">http://pugscode.org/images/metamodel.png</a>
</p>

<p>
Graydon posting a new illustration under <a href="doku.php%3Fid=proposals:meta_objects.html" class="wikilink1" title="proposals:meta_objects" onclick="return svchk()" onkeypress="return svchk()">meta_objects</a>.
</p>

</div>
<!-- SECTION [34235-36401] -->
<a name="next_meeting"></a><h3>Next Meeting</h3>
<div class="level3">

<p>
 Some haggling over dates... Planning tentatively on meeting in Oslo on July 28, 29. 
</p>

</div>
<!-- SECTION [36402-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/9/9ede740ca8c8f989e6921c46ca52f793.xhtml used -->
</body>
</html>
