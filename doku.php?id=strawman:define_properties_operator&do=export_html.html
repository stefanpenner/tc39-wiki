<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=strawman:define_properties_operator&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=strawman" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html#the_operator" class="toc">The := Operator</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html#the_problem" class="toc">The Problem</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html#a_solutionthe_operator" class="toc">A Solution: The := Operator</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html#some_es6_idioms_using" class="toc">Some ES6 Idioms using :</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html#semi-formal_specification_of_operator" class="toc">Semi-formal Specification of := Operator</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html#grammar_extensions" class="toc">Grammar Extensions</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html#semantics" class="toc">Semantics</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html#optimizations" class="toc">Optimizations</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html#design_rationales" class="toc">Design Rationales</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html#why_was_the_symbol_selected" class="toc">Why was the symbol := selected?</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html#why_does_process_multiple_properties_instead_of_just_one" class="toc">Why does := process multiple properties instead of just one?</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html#why_are_private_named_properties_copied" class="toc">Why are private named properties copied?</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html#why_does_rebind_super" class="toc">Why does := rebind super?</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html#why_not_just_provide_object.extend" class="toc">Why not just provide Object.extend?</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html#a_possible_companion_function" class="toc">A possible companion function</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:define_properties_operator&amp;do=export_html.html#history" class="toc">History</a></span></li>
</ul>
</li>
</ul>
</div>
</div>

<a name="the_operator"></a><h1>The := Operator</h1>
<div class="level1">

<p>
 The ECMAScript meta-model for objects has distinct semantics for modifying and adding object properties. The [[Put]] semantics, associated with the <strong><code>=</code></strong> operator, is most commonly used when a programmer intends to update the value of a property but in some situations it will also create a new own property. The [[DefineOwnProperty]] semantics is most commonly used when a programmer&rsquo;s intent is to create a new own property or to modify the definition of an existing own property.  [[DefineOwnProperty]] does not currently have an operator association but it may be accessed by using the Object.defineProperty built-in function. [[DefineOwnProperty]] is the semantics used to create properties defined using Object Literals.
</p>

<p>
This proposal is for a new  <strong><code>:=</code></strong> operator that gives ECMAScript programmer more direct and convenient access to the [[DefineOwnProperty]] semantics. 
</p>

</div>
<!-- SECTION [1-941] -->
<a name="the_problem"></a><h2>The Problem</h2>
<div class="level2">

<p>
 Prior to ES5, the only general-purpose way to add properties to an already existing object was to use the assignment operator:
</p>
<pre class="code javascript"><span class="kw2">var</span> obj = <span class="br0">&#123;</span>
   a: <span class="nu0">1</span>,
   b: <span class="nu0">2</span>
<span class="br0">&#125;</span>;
&nbsp;
obj.<span class="me1">a</span> = -<span class="nu0">1</span>; <span class="co1">// change the value of an existing property</span>
obj.<span class="me1">c</span> = <span class="nu0">3</span>;  <span class="co1">// add a property named 'c' to obj</span>
obj.<span class="me1">toString</span> = <span class="kw2">function</span> <span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="co1">//add a method to obj</span>
   <span class="kw2">var</span> str = <span class="st0">"{ "</span>;
   <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> p <span class="kw1">in</span> <span class="kw1">this</span><span class="br0">&#41;</span> <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">typeof</span> <span class="kw1">this</span><span class="br0">&#91;</span>p<span class="br0">&#93;</span> != <span class="st0">"function"</span><span class="br0">&#41;</span> str += p + <span class="st0">": "</span> + <span class="kw1">this</span><span class="br0">&#91;</span>p<span class="br0">&#93;</span> + <span class="st0">" "</span>;
   <span class="kw1">return</span> str+<span class="st0">"}"</span>
<span class="br0">&#125;</span>;
&nbsp;
console.<span class="me1">log</span><span class="br0">&#40;</span>obj.<span class="me1">toString</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
  <span class="co1">// { a: -1 b: 2 c: 3 }</span></pre>
<p>
ES5 added the ability to define accessor properties and the ability  for ES programmers to create &ldquo;read-only&rdquo; properties.  It also made it easier to create objects with multi-level prototypical inheritance chains. In combination, these features make the assignment operator a less reliable way to add properties to an object.  For example:
</p>
<pre class="code javascript"><span class="kw2">var</span> proto = <span class="br0">&#123;</span>  <span class="co1">//define a prototype object</span>
   a: <span class="nu0">1</span>,
   b: <span class="nu0">2</span>,
   get c<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="nu0">3</span><span class="br0">&#125;</span>  <span class="co1">//an accessor property</span>
<span class="br0">&#125;</span>;
Object.<span class="me1">defineProperty</span><span class="br0">&#40;</span>proto,<span class="st0">"b"</span>, <span class="br0">&#123;</span>writeable: <span class="kw2">false</span><span class="br0">&#125;</span><span class="br0">&#41;</span>; <span class="co1">//make proto.b a read-only property</span>
&nbsp;
<span class="kw2">var</span> obj = Object.<span class="me1">create</span><span class="br0">&#40;</span>proto<span class="br0">&#41;</span>; <span class="co1">//obj is a new object that inherits the properties of proto</span>
&nbsp;
obj.<span class="me1">a</span> = -<span class="nu0">1</span>;  <span class="co1">// adds an own property named 'a' to obj. It shadows the inherited proto.a property</span>
obj.<span class="me1">b</span> = -<span class="nu0">2</span>;  <span class="co1">// does nothing because = won't over-write or shadow a inherited read-only property</span>
obj.<span class="me1">c</span> = -<span class="nu0">3</span>;  <span class="co1">// does nothing because it calls the inherited (default) accessor set function which is a no-op</span></pre>
<p>
ES5 provides <code>Object.defineProperty</code> as a reliable means, that is not affected by inheritance, to define own properties of an object. However, this is a much more verbose and awkward syntax than the simple <code>=</code> operator. Even programmers who understand the risks of using <code>=</code> to define properties continue to do so rather than deal with the verbosity of <code>Object.defineProperty</code>.
</p>

<p>
ES6 will make it even easier to define inheritance hierarchies (using class definitions) and has other complications such as private names and super-referencing methods that will further complicate property creation by assignment and probably make it even less reliable.
</p>

<p>
ECMAScript programmers generally know whether they intend  to define a new own property or to assign a value to an existing property.  The problem is that the  language doesn&rsquo;t provide any concise way from them to express that intent. Instead, they just use <code>=</code> and hope they don&rsquo;t trip over any of the special cases where assignment is not equivalent to property definitions. ES developers need something that approaches the convenience of = for dynamically defining properties. As long as ECMAScript only have a procedural <acronym title="Application Programming Interface">API</acronym> (Object.defineProperty) for dynamic property definition developers  will frequently ignore it for the sake of convenience.  ES6 needs a concise and friendly way to dynamically define properties.  The syntax needs to approach the convenience of = but it needs to bring emphasis to the distinction between assignment and definition.  Without  it,  ES5+ES6 will have collectively resulted in a more confusing and error prone language.
</p>

</div>
<!-- SECTION [942-4083] -->
<a name="a_solutionthe_operator"></a><h2>A Solution: The := Operator</h2>
<div class="level2">

<p>
 As a solution to this problem we can introduce a new operator that is looks like  <code>:=</code>
</p>

<p>
This can be called  the &ldquo;colon-equals&rdquo; or &ldquo;define properties&rdquo; operator or just &ldquo;define&rdquo;.  Both the lefthand-side and righthand-side operands must be objects (or primitive values that are ToObject convertible to objects).  The semantics of <code>:=</code> is to perform a [[DefineOwnProperty]] operation on the left operand object corresponding to each own property of the right operand object. It essentially, defines on the the left operand object a clone of each own property of the right operand object. The property kinds, values,  and attributes of the right operand&rsquo;s properties are replicated on the left operand object.
</p>

<p>
It does this with all own properties. It includes non-enumerable properties and unique/private named properties.  It rebinds methods with RHS super bindings to new methods that are super bound to the LHS.
</p>

<p>
Even though the operands may be arbitrary expressions, frequently the right operand will be expressed as an object literal containing the properties that are intended to be added to the left operand object. For example:
</p>
<pre class="code javascript">obj := <span class="br0">&#123;</span>
   a: <span class="nu0">1</span>,
   b: <span class="nu0">2</span>,
   c: <span class="nu0">3</span>
<span class="br0">&#125;</span>;</pre>
<p>
This is semantically equivalent to: 
</p>
<pre class="code javascript">Object.<span class="me1">defineProperties</span><span class="br0">&#40;</span>obj, <span class="br0">&#123;</span>
   a: <span class="br0">&#123;</span>value: <span class="nu0">1</span>, enumerable: <span class="kw2">true</span>, writable: <span class="kw2">true</span>, configurable: <span class="kw2">true</span><span class="br0">&#125;</span>,
   b: <span class="br0">&#123;</span>value: <span class="nu0">2</span>, enumerable: <span class="kw2">true</span>, writable: <span class="kw2">true</span>, configurable: <span class="kw2">true</span><span class="br0">&#125;</span>,
   c: <span class="br0">&#123;</span>value: <span class="nu0">3</span>, enumerable: <span class="kw2">true</span>, writable: <span class="kw2">true</span>, configurable: <span class="kw2">true</span><span class="br0">&#125;</span>
<span class="br0">&#125;</span>;</pre>
<p>
 Because [[DefineOwnProperty]] semantics is used, the existence of like-named properties on obj&rsquo;s prototype chain does not affect the definition of the properties.  The programmer gets exactly the properties that were expressed on in the right hand operand object literal, but they are defined on the left operand object.  The only time this will not occur is if the left operand object is non-extensible or has corresponding non-configurable properties.  In these cases, exceptions will be thrown, exactly as if <code>Object.defineProperties</code> had been used.  For example:
</p>
<pre class="code javascript">let sealed = Object.<span class="me1">seal</span><span class="br0">&#40;</span><span class="br0">&#123;</span>  <span class="co1">//create a object with two readonly properties</span>
   a: <span class="nu0">1</span>,
   b: <span class="nu0">2</span>
<span class="br0">&#125;</span><span class="br0">&#41;</span>;
&nbsp;
sealed := <span class="br0">&#123;</span>            <span class="co1">//this throws a TypeError exception</span>
   get c<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> -<span class="nu0">3</span><span class="br0">&#125;</span>,<span class="co1">//can't redefine a non-configurable property </span>
   d: <span class="nu0">4</span>,               <span class="co1">//can't define additional property on non-extensible objects</span>
   toString <span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="st0">"[object Sealed Object]"</span><span class="br0">&#125;</span> <span class="co1">//can't add methods</span>
<span class="br0">&#125;</span><span class="br0">&#41;</span>;
&nbsp;</pre>
<p>
The <code>:=</code> operator is similar in intent (but not in exact semantics to the Object.extend function suggested in the <a href="https://docs.google.com/document/d/1JPErnYlBPG26chTuVSnJ_jqW4YkiQhvWn-FxwwsmkEo/edit#heading=h.dz7jv066aa32" class="urlextern" target="_blank" title="https://docs.google.com/document/d/1JPErnYlBPG26chTuVSnJ_jqW4YkiQhvWn-FxwwsmkEo/edit#heading=h.dz7jv066aa32" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">recommendations</a> the JSFixed community group.  Their recommended function could be easily implemented using and in terms of the <code>:=</code> operator:
</p>
<pre class="code javascript">&nbsp;
Object := <span class="br0">&#123;</span>
   extend<span class="br0">&#40;</span>target, ...<span class="me1">sources</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">for</span> <span class="br0">&#40;</span>let src of sources<span class="br0">&#41;</span> target := src;
<span class="br0">&#125;</span>;</pre>
</div>
<!-- SECTION [4084-7128] -->
<a name="some_es6_idioms_using"></a><h3>Some ES6 Idioms using :</h3>
<div class="level3">

<p>
 The := is a convenient syntax to use inside a class constructor to define and initialize per instance properties: 
</p>
<pre class="code javascript"><span class="kw2">class</span> Point <span class="br0">&#123;</span>
   constructor<span class="br0">&#40;</span>x,y<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">this</span> := <span class="br0">&#123;</span>x,y<span class="br0">&#125;</span>  <span class="co1">//define and initialize x and y properties of new object</span>
   <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
Such properties can include methods and accessor properties:
</p>
<pre class="code javascript"><span class="kw2">class</span> Point <span class="br0">&#123;</span>
   constructor<span class="br0">&#40;</span>x,y<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">this</span> := <span class="br0">&#123;</span>
         <span class="co1">//define accessor properties on new object that bind to closure captured private state</span>
         get x<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> x<span class="br0">&#125;</span>,
         set x<span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>x = value<span class="br0">&#41;</span>,
         get y<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> y <span class="br0">&#125;</span>,
         set y<span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>y = value<span class="br0">&#125;</span>,
         moveTo<span class="br0">&#40;</span>newX, newY<span class="br0">&#125;</span> <span class="br0">&#123;</span>
            x = newX;
            y = newY;
         <span class="br0">&#125;</span>
      <span class="br0">&#125;</span>  
   <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
<code>:=</code> is also the easiest way to define &ldquo;class-side&rdquo; properties: 
</p>
<pre class="code javascript">Point := <span class="br0">&#123;</span>
   fromPolar<span class="br0">&#40;</span>rho,theta<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> <span class="kw2">new</span> <span class="kw1">this</span><span class="br0">&#40;</span>rho*Math.<span class="me1">cos</span><span class="br0">&#40;</span>theta<span class="br0">&#41;</span>, rho*Math.<span class="me1">sin</span><span class="br0">&#40;</span>theta<span class="br0">&#41;</span><span class="br0">&#41;</span>
   <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
 The := operator can be used to extend prototypes defined using class definitions: 
</p>
<pre class="code javascript">Point.<span class="me1">prototype</span> := <span class="br0">&#123;</span>
   plus<span class="br0">&#40;</span>aPoint<span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="kw2">new</span> <span class="kw1">this</span>.<span class="me1">constructor</span><span class="br0">&#40;</span><span class="kw1">this</span>.<span class="me1">x</span>+aPoint.<span class="me1">x</span>,<span class="kw1">this</span>.<span class="me1">y</span>+aPoint.<span class="me1">y</span><span class="br0">&#125;</span>,
   get rho<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> Math.<span class="me1">sqrt</span><span class="br0">&#40;</span><span class="kw1">this</span>.<span class="me1">x</span>*<span class="kw1">this</span>.<span class="me1">x</span>+<span class="kw1">this</span>.<span class="me1">y</span>*<span class="kw1">this</span>.<span class="me1">y</span><span class="br0">&#125;</span>
<span class="br0">&#125;</span>;</pre>
</div>
<!-- SECTION [7129-8366] -->
<a name="semi-formal_specification_of_operator"></a><h2>Semi-formal Specification of := Operator</h2>
<div class="level2">

</div>
<!-- SECTION [8367-8420] -->
<a name="grammar_extensions"></a><h3>Grammar Extensions</h3>
<div class="level3">
<pre class="code ebnf">AssignmentExpression :
    LeftHandSideExpression := AssignmentExpression
    ...
</pre>
</div>
<!-- SECTION [8421-8553] -->
<a name="semantics"></a><h3>Semantics</h3>
<div class="level3">

<p>
 Summary: Both the LHS and RHS operands must must evaluate to ToObject convertible values.  The value of the <code>:=</code> operator is the ToObject  value of its <em>LeftHandSideExpression</em>. The semantics is to %<a href="doku.php%3Fid=strawman:defineownproperty.html" class="wikilink2" title="strawman:defineownproperty" onclick="return svchk()" onkeypress="return svchk()">%DefineOwnProperty</a> on the LHS obj a property corresponding to each RHS own property.  I does this with all own properties. It includes non-enumerable own properties as well as  unique and private named properties.  It replaces methods and accessor get/set functions that have super bindings to the RHS object with equivalent functions that are super bound to the LHS object.
</p>

<p>
The evaluation algorithm for <code>:=</code>is:
</p>
<ol>
<li class="level1"><div class="li"> Let <em>target</em> be ToObject(<em>LeftHandSideExpression</em>).</div>
</li>
<li class="level1"><div class="li"> Let <em>src</em> be ToObject(<em>AssignmentExpression</em>).</div>
</li>
<li class="level1"><div class="li"> Let <em>needToThrow</em> be <strong>false</strong>.</div>
</li>
<li class="level1"><div class="li"> For each own property of <em>src</em>, let <em>key</em> be the property key and <em>desc</em> be the property descriptor of the property.</div>
<ol>
<li class="level3"><div class="li"> If <em>desc</em> describe a data property , then</div>
<ol>
<li class="level5"><div class="li"> Let <em>f</em> be <em>desc</em>.[[Value]].</div>
</li>
<li class="level5"><div class="li"> If <em>f</em> is a function with a super binding that is bound to <em>src</em>, then</div>
<ol>
<li class="level6"><div class="li"> Let <em>desc</em>.[[Value]] be a new function will all the same internal properties as <em>f</em> except that its super binding is set to <em>target</em>.</div>
</li>
</ol>
</li>
</ol>
</li>
<li class="level3"><div class="li"> If <em>desc</em> describe an accessor property and has a [[Get]] attribute, then</div>
<ol>
<li class="level5"><div class="li"> Let <em>f</em> be <em>desc</em>.[[Get]].</div>
</li>
<li class="level5"><div class="li"> If <em>f</em> is a function with a super binding that is bound to <em>src</em>, then</div>
<ol>
<li class="level6"><div class="li"> Let <em>desc</em>.[[Get]] be a new function will all the same internal properties as <em>f</em> except that its super binding is set to <em>target</em>.</div>
</li>
</ol>
</li>
</ol>
</li>
<li class="level3"><div class="li"> If <em>desc</em> describe an accessor property and has a [[Set]] attribute, then</div>
<ol>
<li class="level5"><div class="li"> Let <em>f</em> be <em>desc</em>.[[Set]].</div>
</li>
<li class="level5"><div class="li"> If <em>f</em> is a function with a super binding that is bound to <em>src</em>, then</div>
<ol>
<li class="level6"><div class="li"> Let <em>desc</em>.[[Set]] be a new function will all the same internal properties as <em>f</em> except that its super binding is set to <em>target</em>.</div>
</li>
</ol>
</li>
</ol>
</li>
<li class="level3"><div class="li"> Let <em>status</em> be the result of calling the [[DefineOwnProperty]] internal method of <em>target</em> with arguments <em>key</em>, <em>desc</em>, and <strong>true</strong>.</div>
</li>
<li class="level3"><div class="li"> If <em>status</em> is an abrupt conpletion, set <em>needToThrow</em> to <strong>true</strong>;</div>
</li>
</ol>
</li>
<li class="level1"><div class="li"> If <em>needToThrow</em> is <strong>true</strong>, then throw a TypeError exception.</div>
</li>
<li class="level1"><div class="li"> Return <em>target</em></div>
</li>
</ol>

</div>
<!-- SECTION [8554-10908] -->
<a name="optimizations"></a><h3>Optimizations</h3>
<div class="level3">

<p>
Note that when the righthand operand is expressed as an object literal it is not  necessary to actually instantiated it as a distinct object.  Instead an implementation may choose to  directly create the object literal properties on the lefthand-side object.  This would save the creation on an unobservable object and the work of populating it with properties. 
</p>

</div>
<!-- SECTION [10909-11294] -->
<a name="design_rationales"></a><h2>Design Rationales</h2>
<div class="level2">

</div>
<!-- SECTION [11295-11326] -->
<a name="why_was_the_symbol_selected"></a><h3>Why was the symbol := selected?</h3>
<div class="level3">

<p>
 JavaScript programmers widely use <code>=</code> to define new properties and we want to encourage them to change to using a more reliable property definition operator. <code>:=</code> was chosen because it is suggestive of both property definition (the use of <code>:</code> in object literals) and of assignment (the <code>=</code> operator).  <code>:=</code> also has a long history of use as an assignment or definitional operator in programming languages. The visual similarity of = and := should push ES programmers to think about then as situational alternatives whose semantic differences must be carefully considered.  The simple story is that one is used for assigning a value to an existing property and the other is used to define or override the definition of properties. 
</p>

</div>
<!-- SECTION [11327-12111] -->
<a name="why_does_process_multiple_properties_instead_of_just_one"></a><h3>Why does := process multiple properties instead of just one?</h3>
<div class="level3">

<p>
We expect <code>:=</code> to frequently be used in situations where multiple properties are being defined.  We also want it to be used to provide <code>Object.extend</code>-like functionality for copying properties from pre-existing objects such has might be passed to library routines.
</p>

<p>
Pragmatically speaking, we have no way to describe individual properties include accessors or concise methods that can be directly express on the right-hand side of an operator. 
</p>
<pre class="code javascript"><span class="co1">//If := only created a single property, we would need a way to say:</span>
obj1 := get prop<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>...<span class="br0">&#125;</span>;
<span class="co1">//and also probably this:</span>
obj2 := method<span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="kw1">this</span><span class="br0">&#125;</span>;</pre>
<p>
 There would be a number of such new forms and many potential syntactic conflicts with existing forms. But all of these property forms already exist for object literals.  It is much less disruptive to the language to simply require that a pair of { } surrounds these single property cases: 
</p>
<pre class="code javascript">obj1 := <span class="br0">&#123;</span>get prop<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>...<span class="br0">&#125;</span><span class="br0">&#125;</span>;
obj2 := <span class="br0">&#123;</span>method<span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="kw1">this</span><span class="br0">&#125;</span><span class="br0">&#125;</span>;</pre>
</div>
<!-- SECTION [12112-13200] -->
<a name="why_are_private_named_properties_copied"></a><h3>Why are private named properties copied?</h3>
<div class="level3">

<p>
The important characteristic of private names is that they are not guessable. If you don&rsquo;t know a private name, you can not directly access a property with that name.  One of the major motivations for restrictions on reflecting private names is to keep private name secrets secret.  The semantics of <code>:=</code> preserve this requirment.  It never reveals a secret private name.
</p>

<p>
What it does do, however, is copy private property keys from one object to another without revealing the secret.  This is important because &ldquo;public&rdquo; methods may have encapsulated implementation dependencies upon the existence of private named properties on the same object.  These might be private data state properties or internal methods that should not be exposed for public invocation. If such methods with private named property dependencies were copied without also copying the private named properties, the methods would be broken.
</p>

<p>
If it is important to an application that specific private name properties are only valid if they are associated with specific object, a WeakMaps can be used to create an identify-based registration scheme for such objects that can be used limit their use to known objects.
</p>

</div>
<!-- SECTION [13201-14441] -->
<a name="why_does_rebind_super"></a><h3>Why does := rebind super?</h3>
<div class="level3">

<p>
Methods that reference <code>super</code> carry a static binding to an object (typically one that is used as a prototype).  If such methods are directly transferred (via, for example the <code>=</code> operator) their super binding is not modified. In most cases this is probably not what the programmer intended.  <code>:=</code> is replicating actual property definitions and has visibility of both the source and target objects.  This is enough information to recognize that a property of the source object is a method or get/set accessor function that has a super binding to the source object. In this case, the best replica of the function is going to be a algorithmically equivalent function that is super bound to the destination object.
</p>

<p>
For example: 
</p>
<pre class="code javascript"><span class="kw2">class</span> Foo <span class="kw2">extends</span> Bar <span class="br0">&#123;</span>
   m<span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="kw2">super</span>.<span class="me1">m</span><span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span><span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw2">function</span> MyConstructor<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="br0">&#125;</span>;
MyConstructor.<span class="me1">prototype</span> = Object.<span class="me1">create</span><span class="br0">&#40;</span>Baz<span class="br0">&#41;</span>;  <span class="co1">//inherit from Bar, not Foo</span>
MyConstructor.<span class="me1">prototype</span> := Foo.<span class="me1">prototype</span>;  <span class="co1">//but, otherwise borrow methods from Foo</span>
MyConstructor.<span class="me1">prototype</span>.<span class="me1">constructor</span> = MyConstructor;</pre>
<p>
If the <code>:=</code> operator in the second to last line did not create a new super binding for method m, it would not function as intended.
</p>

</div>
<!-- SECTION [14442-15680] -->
<a name="why_not_just_provide_object.extend"></a><h3>Why not just provide Object.extend?</h3>
<div class="level3">

<p>
The <code>:=</code> operator is similar in intent (but not in exact semantics to the Object.extend function suggested in the <a href="https://docs.google.com/document/d/1JPErnYlBPG26chTuVSnJ_jqW4YkiQhvWn-FxwwsmkEo/edit#heading=h.dz7jv066aa32" class="urlextern" target="_blank" title="https://docs.google.com/document/d/1JPErnYlBPG26chTuVSnJ_jqW4YkiQhvWn-FxwwsmkEo/edit#heading=h.dz7jv066aa32" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">recommendations</a> of the JSFixed community group. A major goals of := is to shift JavaScript programmer away form using = as a property definition operator. Any form of property addition that requires an explicit function call is going to be less convenient than the = operator and is unlikely to achieve this goal.
</p>

<p>
The semantics proposed for Object.extend by JSFixed is different from the semantics of the Object.extend semantics used in the Prototype.js framework. Other frameworks and users either provide similar functionality under a different name or use the name &ldquo;extend&rdquo; (often with differing semantics) as a property of some object other than Object. The compatibility impact of a built-in Object.extend function is difficult to project.
</p>

</div>
<!-- SECTION [15681-16705] -->
<a name="a_possible_companion_function"></a><h2>A possible companion function</h2>
<div class="level2">

<p>
While := is a convenient way to express the transfer of all own properties from one object to another, it doesn&rsquo;t provide any way to be more selective about which properties to transfer.  For example, a developer might wish to only transfer properties with string keys and to ignore properties with  unique or private name keys. Such use case are where a procedural interface may be more useful than an operator.  We could support such use cases by providing a function named Object.from with a signature like:
</p>
<pre class="code javascript">Object.<span class="me1">from</span> = <span class="kw2">function</span> <span class="br0">&#40;</span>
    target,                    <span class="co1">// the object that properties will be added to</span>
    src,                       <span class="co1">// the object where properties will be copied from</span>
    options = <span class="br0">&#123;</span>                <span class="co1">// an optional options object</span>
        stringKeys: <span class="kw2">true</span>,      <span class="co1">// copy properties with string keys</span>
        nameKeys: <span class="kw2">true</span>,        <span class="co1">// copy properties with name valued keys</span>
        privateKeys:  <span class="kw2">true</span>,    <span class="co1">// copy properties with private name keys</span>
        onlyEnumerable: <span class="kw2">false</span>, <span class="co1">// only copy enumerable properties</span>
        rebindSuper: <span class="kw2">true</span>,     <span class="co1">// rebind functions that are super bound to src</span>
        inheritanceLevels:<span class="nu0">0</span>,   <span class="co1">// how may inheritance levels to copy, Infinity means all, 0 means own</span>
        filter<span class="br0">&#40;</span>key,desc<span class="br0">&#41;</span> <span class="br0">&#123;</span>     <span class="co1">// filter method that can translate - returning undefined skips</span>
            <span class="kw1">return</span> <span class="br0">&#91;</span>key,desc<span class="br0">&#93;</span>  <span class="co1">// never called for private keyed properties</span>
        <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// implementation elided...</span>
<span class="br0">&#125;</span></pre>
<p>
  The name and the exact set of options to provided such a function will likely engender considerable discussion. The defaults shown above were selected to exactly match the behavior proposed for the := operator.
</p>

</div>
<!-- SECTION [16706-18429] -->
<a name="history"></a><h2>History</h2>
<div class="level2">

<p>
The functionality provided by := is similar to that of the <a href="doku.php%3Fid=harmony:object_literals.html#object_extension_literal" class="wikilink1" title="harmony:object_literals" onclick="return svchk()" onkeypress="return svchk()">object extension literal</a> proposal.  It differs in providing an operator that is similar to = rather than a special form using the dot operator.  := is more general in that it does not limit source properties to being provided in a literal form.
</p>

</div>
<!-- SECTION [18430-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/f/faab740bf2a32c1f6cc4cbd01d0891fb.xhtml used -->
</body>
</html>
