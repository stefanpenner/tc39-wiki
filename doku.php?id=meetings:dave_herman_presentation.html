<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
 lang="en" dir="ltr">
<head>
  <title>meetings:dave_herman_presentation [ES Wiki]</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=meetings:dave_herman_presentation&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=meetings" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=meetings:dave_herman_presentation&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=meetings:dave_herman_presentation&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="date" content="2006-05-31T04:59:29+0000" />
  <meta name="robots" content="index,follow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />

  <link rel="shortcut icon" href="lib/images/favicon.ico" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/tpl/default/layout.css" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/tpl/default/design.css" />

  
  <link rel="stylesheet" media="print" type="text/css" href="lib/tpl/default/print.css" />

  <!--[if gte IE 5]>
  <style type="text/css">
    /* that IE 5+ conditional comment makes this only visible in IE 5+ */
    /* IE bugfix for transparent PNGs */
    //DISABLED   img { behavior: url("/lib/scripts/pngbehavior.htc"); }
  </style>
  <![endif]-->

  </head>

<body>
<div class="dokuwiki">
  
  <div class="stylehead">

    <div class="header">
      <div class="pagename">
        [[<a href="doku.php%3Fid=meetings:dave_herman_presentation&amp;do=backlink.html" onclick="return svchk()" onkeypress="return svchk()">meetings:dave_herman_presentation</a>]]
      </div>
      <div class="logo">
        <a href="doku.php%3Fid=.html" onclick="return svchk()" onkeypress="return svchk()" name="top" accesskey="h" title="[ALT+H]">ES Wiki</a>      </div>
    </div>
  
    
    <div class="bar" id="bar_top">
      <div class="bar-left" id="bar_topleft">
        <form class="button" method="post" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="edit" /><input type="hidden" name="rev" value="" /><input type="hidden" name="id" value="meetings:dave_herman_presentation" /><input type="submit" value="Show pagesource" class="button" title="ALT+V" accesskey="v" /></form>        <form class="button" method="get" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="revisions" /><input type="hidden" name="id" value="meetings:dave_herman_presentation" /><input type="submit" value="Old revisions" class="button" title="ALT+O" accesskey="o" /></form>      </div>
  
      <div class="bar-right" id="bar_topright">
        <form class="button" method="get" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="recent" /><input type="hidden" name="id" value="" /><input type="submit" value="Recent changes" class="button" title="ALT+R" accesskey="r" /></form>        <form action="doku.php%3Fid=.html" accept-charset="utf-8" class="search" name="search" onsubmit="return svchk()"><input type="hidden" name="do" value="search" /><input type="text" id="qsearch_in" accesskey="f" name="id" class="edit" onkeyup="ajax_qsearch.call('qsearch_in','qsearch_out')" /><input type="submit" value="Search" class="button" /><div id="qsearch_out" class="ajax_qsearch" onclick="this.style.display='none'"></div></form>&nbsp;
      </div>
    </div>

        <div class="breadcrumbs">
      Trace: <span class="bcsep">&raquo;</span> <a href="doku.php%3Fid=proposals:with-bound_variables.html" onclick="return svchk()" onkeypress="return svchk()" class="breadcrumbs" title="proposals:with-bound_variables">with-bound_variables</a> <span class="bcsep">&raquo;</span> <a href="doku.php%3Fid=proposals:group_assignment.html" onclick="return svchk()" onkeypress="return svchk()" class="breadcrumbs" title="proposals:group_assignment">group_assignment</a> <span class="bcsep">&raquo;</span> <a href="doku.php%3Fid=proposals:debug_helpers.html" onclick="return svchk()" onkeypress="return svchk()" class="breadcrumbs" title="proposals:debug_helpers">debug_helpers</a> <span class="bcsep">&raquo;</span> <a href="doku.php%3Fid=proposals:type_inference.html" onclick="return svchk()" onkeypress="return svchk()" class="breadcrumbs" title="proposals:type_inference">type_inference</a> <span class="bcsep">&raquo;</span> <span class="curid"><a href="doku.php%3Fid=meetings:dave_herman_presentation.html" onclick="return svchk()" onkeypress="return svchk()" class="breadcrumbs" title="meetings:dave_herman_presentation">dave_herman_presentation</a></span>          </div>
    
  </div>
  
  
  <div class="page">
    <!-- wikipage start -->
    <div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="clear"><ul class="toc">
<li class="clear"><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=meetings:dave_herman_presentation.html#dave_herman_presentation_on_operational_semantics" class="toc">Dave Herman presentation on operational semantics</a></span><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=meetings:dave_herman_presentation.html#intro" class="toc">Intro</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=meetings:dave_herman_presentation.html#walkthrough_of_dave_s_es3_operational_semantics" class="toc">Walkthrough of Dave's ES3 operational semantics</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=meetings:dave_herman_presentation.html#what_s_hard_in_here" class="toc">What's hard in here?</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=meetings:dave_herman_presentation.html#moving_forward" class="toc">Moving forward</a></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<a name="dave_herman_presentation_on_operational_semantics"></a><h3>Dave Herman presentation on operational semantics</h3>
<div class="level3">

</div>

<a name="intro"></a><h4>Intro</h4>
<div class="level4">

<p>
 There are big win possible with formal specifications, especially the more you move towards a typed language. 
</p>
<ul>
<li class="level1"><div class="li"> Type systems are not easy to do and hard to do without bugs.</div>
</li>
<li class="level1"><div class="li"> Sound type systems give formal definition to dynamic behavior and the static type system.</div>
</li>
<li class="level1"><div class="li"> Sound type systems offer proof that all errors that a type system is designed to prevent are guaranteed to never happen at runtime.</div>
</li>
<li class="level1"><div class="li"> Doing one of these proofs tends to drive out a lot of subtle bugs that would be hard to find otherwise.</div>
</li>
</ul>

<p>
 Having formal spec is not just &ldquo;math makes us feel good&rdquo;, but a practical tool for preventing certain types of bugs in the language. Very important when defining a language.  If there is a bug in the def of the lang itself, that multiplies out to every single program.
</p>

<p>
That&rsquo;s one use of formal semantics, formal specifications.  Solidifies static type system.
</p>

<p>
Similar kinds of proof for contract systems.
</p>

<p>
As a tool for helping prog lang implementors know how to correctly implement their particular engines.  In ES3, there is pretty consistent notation in basic style of line numbered statements that is really useful as a way of driving implementation... useful as reference. But it arguably could be clearer in a diff style.
</p>

<p>
Sometimes lost in mucky details of step 6, step 13, etc. and what is purpose of 26-line pseudocode?
</p>

<p>
There are a number of spec approaches out of programming language theory that can be useful.
</p>

<p>
Operational semantics are useful, serve as basis for implementors.
</p>

<p>
How far do you want to go with formal spec?  Do you want every feature of lang specified in semantics?  How much work is it, what does it buy you?
</p>

<p>
You can pick a subset - pieces relevant to type system with greatest likelihood of difficult bugs - get maximum bang for buck.
</p>

<p>
If using to driving an impl, may be useful to be more complete so implementors have complete template for language.
</p>

<p>
For ES4, we are interested in proving type system soundness, and would like to keep it off critical path.
</p>

<p>
One advantage of E3 method is that it is easy to read and easy to write, even for people not versed in semantics.  Is there a way to take a formal language and make it readable to the untrained eye?
</p>

<p>
Waldemar&rsquo;s spec is a translation into another language; it&rsquo;s specified in style of denotational semantics but it&rsquo;s really a meta-language that isn&rsquo;t specified ,so not technically denotational semantics.  He would have to translate into sets, etc. for that.
</p>

<p>
Operational semantics reads much like a simple register machine. People often refer to them as abstract machines.  Program counter describing context of running program.  Particular expression you&rsquo;re evaluating.
</p>

<p>
Not sure how approachable, but historically people find operational much more friendly than denotational semantics.  Helps to have functional programming background since there is fundamentally a set of mutually recursive functions.  Tend to be a lot of meta-functions, etc.
</p>

<p>
But more readable than more theoretical stuff.
</p>

<p>
Jeff worries that it may be hard to write entire spec in formal notation in reasonable time.
</p>

<p>
Operational semantics is one kind of technical specification mechanism.  Any of them are going to be equivalent, defining the same language.  The real hard work is the size of the language.  If you have X number of features, you have some constant factor c*X work to do!
</p>

<p>
When Dave tried to do it for ES3, it was turning out more succinct. Can be clearer, easier to get right, so could be time saver.  Overhead in setting up semantics but Dave has done some legwork already by working on ES3 semantics
</p>

<p>
CEKS operational semantics
</p>

<p>
Older techniques like denotational semantics necessitate starting the whole proof over again when new features are added.
</p>

<p>
There is &lsquo;hair&rdquo; on the E3 operational semantics because the language itself is hairy.
</p>

</div>

<a name="walkthrough_of_dave_s_es3_operational_semantics"></a><h4>Walkthrough of Dave's ES3 operational semantics</h4>
<div class="level4">

<p>
 [<a href="http://www.ccs.neu.edu/home/dherman/javascript/" class="urlextern" target="_blank" title="http://www.ccs.neu.edu/home/dherman/javascript/" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">http://www.ccs.neu.edu/home/dherman/javascript/</a>]
</p>

<p>
Several categories.  Expressions, statements, etc.
</p>

<p>
Sometimes pick subset of expressions and classify as values: when you evaluate an expression, this is the result of that evaluation.
</p>

<p>
Values in <acronym title="JavaScript">JS</acronym> are several flavors: primitive constants, meta-variable k to range over.
</p>

<p>
Or they can be objects, meta-variable o to range over.
</p>

<p>
Or reference type that can be dereferenced or assigned to/updated.
</p>

<p>
ES3 spec talks about fact that many things in language might return reference vs. primitive value.
</p>

<p>
Depending on what expr evaluate to, you may or may not be able to use on lhs of assignment.
</p>

<p>
Throughout spec, there is GetValue function needed to deref references.
</p>

<p>
Way that is expressed here is with meta function called GetValue down in metafunction section.
</p>

<p>
&ldquo;^&rdquo; in &ldquo;ref^&rdquo; is superscript
</p>

<p>
If it&rsquo;s unable to find something in that object, it needs to go up the prototype chain.
</p>

<p>
In PL community, most semantics are written in LaTeX, but also e-mailing snippets of semantics in plain ascii, so there&rsquo;s an ad-hoc pseudo-LaTeX language that PL people are used to looking at.  In a real spec, I would do it in LaTeX/OpenOffice/Word
</p>

<p>
Essentially BNF. If there are any ambiguities, assumed to be resolved in &ldquo;obvious way&rdquo;
</p>

<p>
This particular &ldquo;spec&rdquo; is incomplete and hasn&rsquo;t been turned into a mechanical implementation.
</p>

<p>
PLT RedEx: You can input definitions like these in a machine-executable way and get a dog-slow free interpreter out of it, letting you try out features of the language the moment you put in the definition.
</p>

<p>
Tons of recent papers have flaws … some proofs are as complicated as real programs. How much can you trust a computer program written on paper?  Some profs have the M.O. of going through recent research and patching up holes.
</p>

<p>
Machine-checkable is desirable.
</p>

<p>
Just putting into computer is likely to find internal inconsistencies that we wouldn&rsquo;t have thought of.  Haven&rsquo;t checked anything technical, but mere act of putting into machine made it more reliable.  But should see whether there are actual things we want to prove that the machine could show us?
</p>

<p>
Is there a convenient way to prove CEKS programs?  A tool, environment?
</p>

<p>
Yes, PLT RedEx is a good example.
</p>

<p>
Graydon: There are other packages as well
</p>

<p>
CEKS or CKS Machine
</p>

<p>
C, E, K, S are names of 4 abstract registers of machine.
</p>

<p>
C describes code: particular expression you&rsquo;re looking at, code you&rsquo;re interpreting
</p>

<p>
E is environment: in <acronym title="JavaScript">JS</acronym> terms, scope chain. Current lexical environment in which expression is evaluated.
</p>

<p>
K is for Kontinuation (German)
</p>

<p>
S is Store, which models mutable state of the machine
</p>

<p>
If we are interested in doing machine that models context explicitly, PLT RedEx would be good, because it models context machines well.
</p>

<p>
It is not meta-logical framework so you don&rsquo;t get theorem proving
</p>

<p>
It comes down to actual goal: What are you trying to prove with them?
</p>

<p>
These are not easy systems to work with.
</p>

<p>
Curry-Howard isomorphism encodes all your propositions as types, must invent meta-type system to describe your logic.  That&rsquo;s work!  Theorem provers have never been easy to work with, although not arguing against it.  Should educate ourselves about tools and experiment. Pick small frag of <acronym title="JavaScript">JS</acronym> and do something with it, get some experience.
</p>

<p>
As we&rsquo;re schedule constrained, may need to make trade-offs.
</p>

<p>
Metalogical frameworks come with benefits that may be useful in long-run and maybe not now.  Should see what short-term benefits are needed.
</p>

</div>

<a name="what_s_hard_in_here"></a><h4>What's hard in here?</h4>
<div class="level4">

<p>
 Definition of objects doesn&rsquo;t have complete table of internal properties.  Did a couple, like prototype length, Object sub-parent, [[Call]] internal method
</p>

<p>
Reference to field in store that contains table of mutable properties for this object
</p>

<p>
A lot come with different implementation decisions.  Could do reference into store, could have multiple mutable stores
</p>

<p>
I chose to put everything that is mutable into one single store
</p>

<p>
Environments: written in traditional functional PL style rather than scope chains, got them as association lists
</p>

<p>
Environment is empty list or an environment extended with some binding.  Essentially same thing as scope chain. 
</p>
<pre class="code">r ::= [] | r[x=(l,a)]
[] is empty environment
R[x=l(a)] is r extended with some binding
l is pointer to location in store, a is set of attributes</pre>

<p>
 Attempt to make it look more like a functional spec.
</p>

<p>
Might have been easier to be closer to ES3 spec by saying a frame is an object.
</p>

<p>
One thing I got from doing it this way is saying these are things we know about statically, so didn&rsquo;t model some of the dynamic scoping in the language.
</p>

<p>
Function closures are pairing of function definition and environment (scope chain)
</p>

<p>
&ldquo;\&rdquo; is ascii notation for lambda
</p>

<p>
Left out DontEnum since for-in loops aren&rsquo;t in here
</p>

<p>
Program is variable bindings followed by single statement
</p>

<p>
Minimal encoding that you can encode any <acronym title="JavaScript">JS</acronym> main program by saying single statement is one block
</p>

<p>
Must hoist all variables
</p>

<p>
One useful thing is to say if every compiler must do some basic transformations, treat the target of transformations as the &ldquo;Real JavaScript&rdquo;.  Useful for doing all proofs, since type soundness has to do with language after hoisting has been done, so act like it already has.
</p>

<p>
Applications of primitives: Way of encoding all operators in language like + and *
</p>

<p>
Let p range over all primitive operators
</p>

<p>
Left out dot refs since those can be translated into [] refs
</p>

<p>
All native functions pN are nasty, would do differently now.
</p>

<p>
Internal to spec, like ToString.
</p>

<p>
But can cause <acronym title="JavaScript">JS</acronym> code to be evaluated, meaning had to embed into semantics itself.
</p>

<p>
Instead of littering semantics with tons of these now, I would simply have a single one which says Native.  Native calls out in semantics to some meta-function, for notational clarity.
</p>

<p>
CTX CARLIST:
</p>

<p>
Defines evaluation contexts.
</p>

<p>
Evaluation context corresponds to the slightly more familiar notion of a continuation.
</p>

<p>
Point in program that you&rsquo;re currently at.
</p>

<p>
Think of as Program Counter.
</p>

<p>
You&rsquo;ve gone so far through evaluation of program, and you have so much more to evaluate still.
</p>

<p>
Context says I have evaluated some subexpr of the program or are currently evaluating it, but within context of entire program, and that&rsquo;s what I have left to do after evaluating the subexpr. 
</p>
<pre class="code">2+f(3)</pre>

<p>
 Before evaluating the addition, must evaluate the function call.
</p>

<p>
So evaluate f(3), focus on it as current expr.
</p>

<p>
But evaluating it within context of an addition that must be performed when we&rsquo;re done.
</p>

<p>
Context we describe is 2+a hole
</p>

<p>
Entire program that&rsquo;s left after current expr is 2+whatever our result is
</p>

<p>
That is continuation of f(3)
</p>

<p>
In real interpreter, two different datatype notations of same notion. Could be describing a set of structures, like a real tree structure. In continuation, describing as sequence of function calls. Same notion.
</p>

<p>
To model things like exceptions, whatever I was going to do, going to skip outwards and go outwards in context until I hit nearest exception handler.
</p>

<p>
Very close to way actual implementations which crawl up stack frames. So the context basically is a list of stack frames, and close to the way a C implementation would work.
</p>

<p>
Hairy parts:
</p>

<p>
Context: Parts where we&rsquo;re currently focused on expression, parts where we&rsquo;re currently focused on statement
</p>

<p>
Need to do different stuff in each case
</p>

<p>
&ldquo;o&rdquo; is compose operator - connective for individual stack frames in the context
</p>

<p>
Expression context is list of stack frames chained together with compose operator
</p>

<p>
Look down at definition of f, shows all individual stack frames  that can occur.  Atomic operations in language.
</p>

<p>
Example: Function application. When we finish evaluating this expression, we get a function which we use to apply.
</p>

<p>
FRM CTOR: Constructor call. Once we get value back, that thing should be constructor used to construct new object.
</p>

<p>
Could be lhs of assignment, or rhs.
</p>

<p>
Chain all these together to get a complete program.
</p>

<p>
Here, [] represents a hole not an empty list.
</p>

<p>
.r thrown in everywhere is because we have to hang on to scope chain in various places
</p>

<p>
Must evaluate expressions within some scope chain, so must keep around.  That would be an argument passed around or a local var in an actual interpreter.  In semantics, must keep around long enough so that it&rsquo;ll be there when time to use it.
</p>

<p>
E1.r is dumb syntax for tack that on there too, kind of like pair.
</p>

<p>
Operational semantics is all about manipulations of dumb syntax. Syntax to syntax.
</p>

<p>
As long as I say &ldquo;.r&rdquo;, if I do that consistently everywhere, I&rsquo;ll be able to pull it apart when I need it.
</p>

<p>
If you write it in a machine-checkable form, that can be good because it forces you to write it in a very consistent way.
</p>

<p>
One pain point: A lot of meta-functions can cause <acronym title="JavaScript">JS</acronym> code to execute. So tight mutual recursion between expression reduction semantics and meta-functions.
</p>

<p>
Meta-functions also operate on syntax, producing a new syntactic object.  Defined as mathematical functions.
</p>

<p>
There is a lot of bounce-back (recursion) between evaluation relation and meta-function sections of this spec.
</p>

<p>
All native functions are extra syntax in evaluation relation, so that could be fixed up.
</p>

<p>
Hoisting, etc. could be done in other ways.  Kernel language vs. surface language.  Given BNF for kernel language, could do BNF for surface language in terms of that.  May not be worth it since it may be obvious.
</p>

<p>
Nature of reduction rules in context machine semantics as opposed to other small-step semantics. In a small-step semantics not including the context in evaluation relation itself, we simply add extra rules that say once you finish, plug back in context, get whole program again, then look for next expr to reduce.  Can leave &ldquo;external&rdquo; to evaluation relation itself.
</p>

<p>
In this system, we talk about searching up and down through context for next expr to evaluate.  Captures that system really will be pushing/popping stack frames.  Two basic kinds of reduction steps in semantics: Ones that push context on, and ones that pop context off.
</p>

<p>
Section 1, 2, 3: &ldquo;Push context on&rdquo; rules
</p>

<p>
When we get to compound expr, and look at sub-expr first, we must hold on to context we are in, and focus down on sub-expr.  So we push context frame, knowing that when we&rsquo;re finished we will pop it back off.
</p>

<p>
5, 6, 7: All pop rules.  If we have value, we finished some evaluation, now we pop context and find next thing to do.
</p>

<p>
&ldquo;If&rdquo; expression in section 1.  Test expression e.  Cannot continue evaluation until e is known, so pull e out and focus on it.  Push context frame to say once I&rsquo;m done, need to plug it back into if.
</p>

<p>
Context machine goes step-by-step doing manual push/pop frame.
</p>

<p>
Small-step semantics without context makes that totally external to specification: We have definition of context, every time you finish evaluating expr, plug it back in and look for next thing.  Not encoded.
</p>

<p>
Big-step semantics: Get context out of the shape of semantics itself. Tree of inference rules tells you, to evaluate if expr, must first evaluate test expr.  So in big-step semantics, context is implicit. Affects how proof itself happens.  Need meta-theorems about proof system itself.  Hard to do non-local control.
</p>

<p>
Do people mix the styles?  Not a ton of work on communication between different languages/semantics, but there is some work.
</p>

<p>
There is some work on things like: RegExp has no non-local control, so it could be done with big-step semantics, then embed within <acronym title="JavaScript">JS</acronym> specified with small-step semantics.
</p>

<p>
Whenever you work with contexts ,you probably want to make them explicit.
</p>

<p>
Suppose we put first-class continuations in language. Then I would be adamant that we use small-step semantics: call/cc, shift/reset are easy to express.  If you only have break, return, continue, maybe could get away with it.
</p>

<p>
Brendan is thinking about us doing &ldquo;yield&rdquo;
</p>

</div>

<a name="moving_forward"></a><h4>Moving forward</h4>
<div class="level4">

<p>
 How do you have a larger spec that doesn&rsquo;t use the system?  How do we move towards theoretical ideal without impairing readability?
</p>

<p>
It can be confusing if specification language looks too much like actual language, people get confused as to whether language is &ldquo;real&rdquo; language to implement or  the spec language.
</p>

<p>
One advantage of the ES3 notation is it&rsquo;s hard to make the wrong assumption when doing an implementation.
</p>

<p>
To do exceptions, often you end up returning a completion value everywhere in your semantics.  In Waldemar&rsquo;s spec, there are exceptions built into the meta-language.  In ES3 spec, it is made explicit, so there are no assumptions made about how exceptions should work.  That can be good so there isn&rsquo;t any way to screw it up by making the wrong assumption, assured of doing exactly the right thing. &ldquo;Abrupt completion&rdquo; 
</p>
<pre class="code">try {
  throw 42
} finally {
  return 0
}</pre>

<p>
 Not obvious what should be done from looking at C++ exceptions
</p>

</div>

<!-- no cachefile used, but created -->
    <!-- wikipage stop -->
  </div>

  <div class="clearer">&nbsp;</div>

  
  <div class="stylefoot">

    <div class="meta">
      <div class="user">
              </div>
      <div class="doc">
        meetings/dave_herman_presentation.txt &middot; Last modified: 2006/05/31 04:59 by graydon      </div>
    </div>

   
    <div class="bar" id="bar_bottom">
      <div class="bar-left" id="bar_bottomleft">
        <form class="button" method="post" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="edit" /><input type="hidden" name="rev" value="" /><input type="hidden" name="id" value="meetings:dave_herman_presentation" /><input type="submit" value="Show pagesource" class="button" title="ALT+V" accesskey="v" /></form>        <form class="button" method="get" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="revisions" /><input type="hidden" name="id" value="meetings:dave_herman_presentation" /><input type="submit" value="Old revisions" class="button" title="ALT+O" accesskey="o" /></form>      </div>
      <div class="bar-right" id="bar_bottomright">
                        <form class="button" method="get" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="login" /><input type="hidden" name="id" value="meetings:dave_herman_presentation" /><input type="submit" value="Login" class="button" /></form>        <form class="button" method="get" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="index" /><input type="hidden" name="id" value="meetings:dave_herman_presentation" /><input type="submit" value="Index" class="button" title="ALT+X" accesskey="x" /></form>        <a href="doku.php%3Fid=meetings:dave_herman_presentation.html#top"><input type="button" class="button" value="Back to top" onclick="window.scrollTo(0, 0)" /></a>&nbsp;
      </div>
    </div>

  </div>

</div>

<div align="center" class="footerinc">
  <a target="_blank" href="feed.php" title="Recent changes RSS feed"><img src="lib/tpl/default/images/button-rss.png" width="80" height="15" alt="Recent changes RSS feed" border="0" /></a>

  <a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.0/" rel="license" title="Creative Commons License"><img src="lib/tpl/default/images/button-cc.gif" width="80" height="15" alt="Creative Commons License" border="0" /></a>

  <a target="_blank" href="https://www.paypal.com/xclick/business=andi%40splitbrain.org&amp;item_name=DokuWiki+Donation&amp;no_shipping=1&amp;no_note=1&amp;tax=0&amp;currency_code=EUR&amp;lc=US" title="Donate"><img src="lib/tpl/default/images/button-donate.gif" alt="Donate" border="0" /></a>

  <a target="_blank" href="http://www.php.net" title="Powered by PHP"><img src="lib/tpl/default/images/button-php.gif" width="80" height="15" alt="Powered by PHP" border="0" /></a>

  <a target="_blank" href="http://validator.w3.org/check/referer" title="Valid XHTML 1.0"><img src="lib/tpl/default/images/button-xhtml.png" width="80" height="15" alt="Valid XHTML 1.0" border="0" /></a>

  <a target="_blank" href="http://jigsaw.w3.org/css-validator/check/referer" title="Valid CSS"><img src="lib/tpl/default/images/button-css.png" width="80" height="15" alt="Valid CSS" border="0" /></a>

  <a target="_blank" href="http://wiki.splitbrain.org/wiki:dokuwiki" title="Driven by DokuWiki"><img src="lib/tpl/default/images/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" border="0" /></a>



<!--

<rdf:RDF xmlns="http://web.resource.org/cc/"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="">
   <dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
   <license rdf:resource="http://creativecommons.org/licenses/by-nc-sa/2.0/" />
</Work>

<License rdf:about="http://creativecommons.org/licenses/by-nc-sa/2.0/">
   <permits rdf:resource="http://web.resource.org/cc/Reproduction" />
   <permits rdf:resource="http://web.resource.org/cc/Distribution" />
   <requires rdf:resource="http://web.resource.org/cc/Notice" />
   <requires rdf:resource="http://web.resource.org/cc/Attribution" />
   <prohibits rdf:resource="http://web.resource.org/cc/CommercialUse" />
   <permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" />
   <requires rdf:resource="http://web.resource.org/cc/ShareAlike" />
</License>

</rdf:RDF>

-->
</div>

<img src="lib/exe/indexer.php%3Fid=meetings%253Adave_herman_presentation&amp;1454276684" width="1" height="1" alt=""  /></body>
</html>
