<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=discussion:strict_and_standard_modes&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=discussion" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=discussion:strict_and_standard_modes&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=discussion:strict_and_standard_modes&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=discussion:strict_and_standard_modes&amp;do=export_html.html#rejected_modification_---_pragma_for_limiting_type_compatibility_of_assignment" class="toc">Rejected modification --- Pragma for limiting type compatibility of assignment</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=discussion:strict_and_standard_modes&amp;do=export_html.html#earlier_discussion_---_strawmannotes_on_compilation_phases" class="toc">Earlier Discussion --- Strawman: Notes on compilation phases</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:strict_and_standard_modes&amp;do=export_html.html#parsing" class="toc">Parsing</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:strict_and_standard_modes&amp;do=export_html.html#constant_computation" class="toc">Constant computation</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:strict_and_standard_modes&amp;do=export_html.html#constraints" class="toc">Constraints</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:strict_and_standard_modes&amp;do=export_html.html#algorithm_sketch" class="toc">Algorithm sketch</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:strict_and_standard_modes&amp;do=export_html.html#type_checking" class="toc">Type checking</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:strict_and_standard_modes&amp;do=export_html.html#standard_language" class="toc">Standard language</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:strict_and_standard_modes&amp;do=export_html.html#strict_language" class="toc">Strict language</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:strict_and_standard_modes&amp;do=export_html.html#evaluation" class="toc">Evaluation</a></span></li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=discussion:strict_and_standard_modes&amp;do=export_html.html#discussion" class="toc">Discussion</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:strict_and_standard_modes&amp;do=export_html.html#notes" class="toc">Notes</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:strict_and_standard_modes&amp;do=export_html.html#interaction_with_scoping" class="toc">Interaction with Scoping</a></span></li>
</ul>
</li>
</ul>
</div>
</div>

<a name="rejected_modification_---_pragma_for_limiting_type_compatibility_of_assignment"></a><h1>Rejected modification --- Pragma for limiting type compatibility of assignment</h1>
<div class="level1">

<p>
 [Since the purpose of this pragma is limited to fixing some quirks in the builtin conversions, we decided to write the rules direclty into the definition of strict verification  &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/06/07 11:10</em>]
</p>

<p>
What is the ideal pragma identifier for restricting type compatiblity of assignment?
</p>

<p>
The pragma mentioned in passing is <code>strict to</code>, as in
</p>
<pre class="code javascript">   <span class="kw2">use</span> strict to Number</pre>
<p>
The problem with <code>strict to</code> is that the pragma doesn&rsquo;t actually affect the behavior of the <code>to</code> operator, but only the behavior of assignment.
</p>

<p>
I don&rsquo;t know the answer to the above question but here is a simple <em>gedanken</em> experiment that the right person might use to come up with it: 
</p>
<ul>
<li class="level1"><div class="li"> what does the pragma mean?</div>
</li>
</ul>
<pre class="code">
    allow strict assignment from Number
</pre>
<ul>
<li class="level1"><div class="li"> write it in pragma form</div>
</li>
</ul>
<pre class="code">
    use allow strict assignment from Number
</pre>
<ul>
<li class="level1"><div class="li"> drop <code>allow</code> because we already have a required verb, <code>use</code></div>
</li>
<li class="level1"><div class="li"> drop <code>strict</code> because it is true in standard mode too</div>
</li>
</ul>
<pre class="code">
    use assignment from Number  
</pre>
<ul>
<li class="level1"><div class="li"> shorten words where possible (e.g. assignment to assign)</div>
</li>
</ul>
<pre class="code">
    use assign from Number
</pre>
<ul>
<li class="level1"><div class="li"> make non-essential words optional</div>
</li>
</ul>
<pre class="code">
    use from Number
    use assign from Number, from String
</pre>

<p>
Anyone get a different result? 
</p>
<hr noshade="noshade" size="1" />

<p>
I don&rsquo;t understand that this is an issue of assignment.  <acronym title="If I remember correctly">IIRC</acronym> the situation we are discussing is this: 
</p>
<pre class="code">  var s : String = 10</pre>

<p>
 and we agreed after much discussion that this is entirely equivalent in both standard and strict languages to: 
</p>
<pre class="code">  var s : String;
  s = 10;</pre>

<p>
 which can be phrased in terms of an explicit &ldquo;to&rdquo; operator use: <code>var s; s = 10 to String</code>.
</p>

<p>
Here the &ldquo;to&rdquo; refers to any conversion defined on String objects to coerce a value to String (since the entire language is expressible in the language).
</p>

<p>
My point is that that the assignment is irrelevant now, everything centers on the conversion <code>10 to String</code>.
</p>

<p>
String must have a &ldquo;to&rdquo; operator whose argument type is &ldquo;*&rdquo;.  This is required for compatibility.  But in the strict subset this is too permissive.  Therefore we want to say that the &ldquo;to&rdquo; operator on String is more restrictive in strict mode.
</p>

<p>
Thus what we are looking for is perhaps 
</p>
<pre class="code">  restrict the to operator on String to input type String</pre>

<p>
 but since this annotation is on the String class it&rsquo;s more easily written as 
</p>
<pre class="code">  restrict the to operator to input type String</pre>

<p>
 which can be shortened as an imperative  
</p>
<pre class="code">  use restricted to (String)</pre>

<p>
 ??
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/06/05 05:23</em>
</p>

<p>
It was not clear to me that we wanted to also restrict the explicit use of the <code>to</code> operator in strict mode. If that is the case, then I withdraw my complaint about <code>strict to</code>. Is that the case?
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/06/06 15:01</em>
</p>

<p>
I think that if the meaning of <code>var x : String = y</code> is defined as <code>var x = y to String</code> (as <a href="doku.php%3Fid=proposals:is_as_to.html" class="wikilink1" title="proposals:is_as_to" onclick="return svchk()" onkeypress="return svchk()">is as to</a> has it) then we shouldn&rsquo;t have a contextual meaning of <code>to</code> so that the meaning of that phrase is different from <code>var x; x = y to String</code>.  I think <code>to</code> needs to mean the same everywhere.  If there is a restriction operator on <code>to</code> then that should apply to all uses in strict mode.
</p>

<p>
It&rsquo;s possible that the meaning of <code>var x : String = y</code> is really something else, though, like <code>var x = y restricted_to String</code> or something like that, ie, we&rsquo;re being confused by <code>to</code> semantics.  
</p>

<p>
Once again we should also remember that the <code>strict</code>/<code>restrict</code>/<code>allow</code> pragma is useful almost exclusively for the built-in classes, in order to fix certain bugs in the 3rd Edition.  I think you are trying to capture ActionScript&rsquo;s behavior where only certain conversions are illegal, and I suspect that does not mesh well with rewriting the phrase using a general operator in the language.   
</p>

<p>
Need to think some more about this, but I&rsquo;m starting to think that it&rsquo;s the rule in <a href="doku.php%3Fid=proposals:is_as_to.html" class="wikilink1" title="proposals:is_as_to" onclick="return svchk()" onkeypress="return svchk()">is as to</a> that is wrong.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/06/07 00:16</em>
</p>

<p>
I think the <a href="doku.php%3Fid=proposals:is_as_to.html" class="wikilink1" title="proposals:is_as_to" onclick="return svchk()" onkeypress="return svchk()">is as to</a> rule is correct. Operator <code>to</code>&lsquo;s primary purpose is to allow the E3 auto conversion semantics to be expressed in the language. The proposed strict mode restriction on assignment is independent of the type system (<code>var i : int = &ldquo;hello&rdquo;</code> is just as safe as <code>var i = &ldquo;hello&rdquo; to int</code>). It is simply an extra check to avoid stupid programming errors. We could let this strict mode restriction apply to <code>to</code> in general, but that would make some explicit conversions harder to express.
</p>

<p>
I just wish it wasn&rsquo;t so hard to say all this in a pragma <img src="lib/images/smileys/icon_smile.gif" align="middle" alt=":-)" />
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/06/07 09:36</em>
</p>

</div>
<!-- SECTION [1-4779] -->
<a name="earlier_discussion_---_strawmannotes_on_compilation_phases"></a><h1>Earlier Discussion --- Strawman: Notes on compilation phases</h1>
<div class="level1">

<p>
 Here I am trying to separate and order the phases a program goes through as it is being evaluated.  This has several purposes: 
</p>
<ul>
<li class="level1"><div class="li"> The language spec talks about &ldquo;compile-time constants&rdquo;.  We need to know which these are and when they are computed</div>
</li>
<li class="level1"><div class="li"> We need to know exactly how computation depends on type checking, type checking on constant evaluation, and constant evaluation on parsing</div>
</li>
<li class="level1"><div class="li"> Forward references are allowed from some phrases to entities defined &ldquo;below&rdquo; those phrases in some contexts.  Forward references are easily understood as references to values computed in an evaluation phase preceding the phase evaluating the reference.</div>
</li>
</ul>

<p>
 There are four phases: parsing, constant computation, type checking, and evaluation.   (It is possible that evaluation should be broken down into two phases, &ldquo;loading&rdquo; and &ldquo;execution&rdquo;.)  The succession of phases is seen as building, interpreting, and refining a data structure representing the program, adding information to it and  asserting new invariants in each phase.
</p>

<p>
Once we have separated and specified the phases we will also understand  to which extent it is possible to merge phases for optimization purposes.
</p>

<p>
According to the following (still very informal) spec I believe it is possible  to merge constant computation, type checking, and evaluation, if one is careful. This would allow for a fully &ldquo;dynamic&rdquo; implementation that pretty much consists of parsing and fully dynamically typed execution.
</p>

</div>
<!-- SECTION [4780-6319] -->
<a name="parsing"></a><h2>Parsing</h2>
<div class="level2">

<p>
 Parsing: Parse the program into an abstract representation.   
</p>
<ul>
<li class="level1"><div class="li"> Input: Source text.</div>
</li>
<li class="level1"><div class="li"> Output: Abstract syntax tree</div>
</li>
<li class="level1"><div class="li"> Definition: Grammar plus processing rules mapping source into AST.  </div>
</li>
<li class="level1"><div class="li"> Output invariants:</div>
<ul>
<li class="level2"><div class="li"> the program is correct according to the context-free grammar (obviously)</div>
</li>
<li class="level2"><div class="li"> no duplicate class or interface names in a package</div>
</li>
<li class="level2"><div class="li"> no use of the &lsquo;super&rsquo; statement outside a constructor</div>
</li>
<li class="level2"><div class="li"> no use of the &lsquo;super&rsquo; expression outside an instance method</div>
</li>
<li class="level2"><div class="li"> no duplicate labels in a statement nest</div>
</li>
<li class="level2"><div class="li"> every referenced package is known to exist</div>
</li>
<li class="level2"><div class="li"> (probably many more)</div>
</li>
</ul>
</li>
</ul>

<p>
 The AST probably does not represent the source text directly but will  contain collections of related phrases; for example, the representation  of a function will contain all hoisted variables and constants (though initialization of these hoisted variables can only occur in their original positions).
</p>

</div>
<!-- SECTION [6320-7244] -->
<a name="constant_computation"></a><h2>Constant computation</h2>
<div class="level2">

<p>
 Constant computation phase: Compute the values of all &ldquo;constant expressions&rdquo;. 
</p>
<ul>
<li class="level1"><div class="li"> Input: Abstract syntax tree</div>
</li>
<li class="level1"><div class="li"> Output: Same tree, with constant-defining phrases annotated with their constant values</div>
</li>
<li class="level1"><div class="li"> Definition: Computation (abstract interpretation) on the AST</div>
</li>
<li class="level1"><div class="li"> Output invariants:</div>
<ul>
<li class="level2"><div class="li"> every name defining a compile-time constant value holds that value</div>
</li>
<li class="level2"><div class="li"> every name that <em>must</em> have a compile-time constant value is checked to ensure that it has one, this includes classes, interfaces, types, namespaces</div>
</li>
<li class="level2"><div class="li"> there are no ambiguous references (eg no definitions of a::x and b::x in a scope</div>
</li>
</ul>
</li>
</ul>

<p>
      where a and b are both open and there is a plain reference to x)
</p>

<p>
Make a pass over the program simulating its execution in  terms of evaluating constant expressions for directives and definitions  that create named constants, at least these: 
</p>
<ul>
<li class="level1"><div class="li"> <code>const x = v</code></div>
</li>
<li class="level1"><div class="li"> <code>let const x=v</code></div>
</li>
<li class="level1"><div class="li"> <code>namespace x</code> and <code>namespace x = y</code></div>
</li>
<li class="level1"><div class="li"> <code>class C { ... }</code> (with <code>extends</code> and <code>implements</code>)</div>
</li>
<li class="level1"><div class="li"> <code>interface N { ... }</code> (with <code>extends</code>)</div>
</li>
<li class="level1"><div class="li"> <code>type t = T</code></div>
</li>
</ul>

</div>
<!-- SECTION [7245-8349] -->
<a name="constraints"></a><h3>Constraints</h3>
<div class="level3">

<p>
 Expressions in the following contexts must have a known value as computed by constant evaluation: 
</p>
<ul>
<li class="level1"><div class="li"> namespace initialiser</div>
</li>
<li class="level1"><div class="li"> class and interface inheritance clause</div>
</li>
<li class="level1"><div class="li"> namespace attribute</div>
</li>
<li class="level1"><div class="li"> <code>use namespace</code> pragma</div>
</li>
</ul>

<p>
Expressions that have a known value are: 
</p>
<ul>
<li class="level1"><div class="li"> Literal expressions</div>
</li>
<li class="level1"><div class="li"> Expressions that depend on a constant definition that has a known value and dominates (see below) the current expression</div>
</li>
</ul>

<p>
Notes: 
</p>
<ul>
<li class="level1"><div class="li"> Class and interface definitions must dominate the end of the program</div>
</li>
<li class="level1"><div class="li"> Namespace definitions must dominate the end of the program or the end of a class. A namespace definition inside of a class introduces a slot into the class object by default as though it was declared with the <code>static</code> attribute</div>
</li>
</ul>

<p>
 <strong>Dominates</strong>
</p>

<p>
<em>[from the Netscape proposal]</em>
</p>

<p>
A statement A dominates statement B if any of the following conditions are met: 
</p>
<ul>
<li class="level1"><div class="li"> A and B are the same statement.</div>
</li>
<li class="level2"><div class="li"> A and B are in the same block, with A before B and no case or default labels between them.</div>
</li>
<li class="level2"><div class="li"> Statement B is enclosed inside statement C and A dominates C.</div>
</li>
<li class="level2"><div class="li"> Statement A is enclosed inside a block C, C is not prefixed by an attribute that evaluates to false, and C dominates B.</div>
</li>
</ul>

<p>
 Note that the above definition is conservative. If statement A dominates statement B, then it is guaranteed that, if B is executed then A must have been executed earlier; however, there may be some other statements A&rsquo; that also are guaranteed to have been executed before B but which do not dominate B by the above definition.
</p>

</div>
<!-- SECTION [8350-9900] -->
<a name="algorithm_sketch"></a><h3>Algorithm sketch</h3>
<div class="level3">

<p>
 A precise spec of the abstract interpretation remains to be written, but the purpose can be stated as computing the values of those constants that always have values, and to keep track of what those values are at a given point in the program.
</p>

<p>
Here are some of the steps taken by the computation.
</p>

<p>
Package content must be known when doing constant computation, so referenced packages  must be loaded into the evaluation environment for the constant computation.
</p>

<p>
When processing a class definition, any name referenced from <code>extends</code> or <code>implements</code>  clauses must already have its compile-time constant value, or the program is in error.
</p>

<p>
Names introduced by other binding constructs than the ones listed above (<code>var</code>,  <code>function</code>, <code>let</code>, or <code>const</code> where the value is not defined in the  binding statement itself) are assigned a value <code>&lt;unknown&gt;</code>.
</p>

<p>
For a given constant-defining expression, substitute known values for names.  Use <code>&lt;unknown&gt;</code> for unknown names.  If a value <code>v</code> comes from a <code>T</code>-typed <code>const</code> binding then represent it as <code>cast T(v)</code> in the expression.  Evaluate the resulting expression: Any <code>&lt;unknown&gt;</code> value is propagated through all operators.   Type mismatches during evaluation (whether in <code>cast</code> or in the application of the operators themselves) are detected by the normal run-time typing mechanisms in expression evaluation and result in <code>&lt;unknown&gt;</code> values.  <code>to</code> operators are never consulted. This results in either a value of the correct type or <code>&lt;unknown&gt;</code>.
</p>

</div>
<!-- SECTION [9901-11451] -->
<a name="type_checking"></a><h2>Type checking</h2>
<div class="level2">

<p>
 Type checking phase: test that the program is well typed. 
</p>
<ul>
<li class="level1"><div class="li"> Input: Abstract syntax tree</div>
</li>
<li class="level1"><div class="li"> Output: Same tree, annotated and updated</div>
</li>
<li class="level1"><div class="li"> Definition: Computation (abstract interpretation) on the AST</div>
</li>
<li class="level1"><div class="li"> Output invariants:</div>
<ul>
<li class="level2"><div class="li"> The program is well-typed, modulo certain classes of run-time errors</div>
</li>
<li class="level2"><div class="li"> <code>const</code> fields of an instance must all be guaranteed to be initialized when the constructor returns normally</div>
</li>
</ul>
</li>
</ul>

<p>
 (I note that my understanding of some of the mechanics of this phase are not yet  good, so there may be misunderstandings here.)
</p>

<p>
This phase does several things: 
</p>
<ul>
<li class="level1"><div class="li"> computes expression types</div>
</li>
<li class="level1"><div class="li"> introduces type conversions as allowed by the language where necessary to make the program well-typed</div>
</li>
<li class="level1"><div class="li"> introduces type &ldquo;Dynamic&rdquo; where allowed (see below)</div>
</li>
<li class="level1"><div class="li"> determines whether the program is actually well-typed</div>
</li>
</ul>

</div>
<!-- SECTION [11452-12309] -->
<a name="standard_language"></a><h3>Standard language</h3>
<div class="level3">

<p>
 In the Standard language, the following occur: 
</p>
<ul>
<li class="level1"><div class="li"> a &ldquo;Dynamic&rdquo; type can be introduced in certain contexts to allow the program to type check</div>
</li>
<li class="level1"><div class="li"> references to undefined variables are not errors, but merely assume that those variables have type &ldquo;*&rdquo;</div>
</li>
<li class="level1"><div class="li"> <code>with</code> (except <a href="doku.php%3Fid=discussion:reformed_with.html" class="wikilink1" title="discussion:reformed_with" onclick="return svchk()" onkeypress="return svchk()">reformed with</a>) introduces a scope in which nothing is known about variables bound outside that scope</div>
</li>
<li class="level1"><div class="li"> (other things?)</div>
</li>
</ul>

</div>
<!-- SECTION [12310-12734] -->
<a name="strict_language"></a><h3>Strict language</h3>
<div class="level3">

<p>
 In the Strict language there should not be any use of &ldquo;Dynamic&rdquo;; any uses  of the type &ldquo;*&rdquo; will be allowed only where expressions of that type match the receiver type, or where the language allows for checked conversion from &ldquo;*&rdquo; to the receiver type.  <code>with</code> (except <a href="doku.php%3Fid=discussion:reformed_with.html" class="wikilink1" title="discussion:reformed_with" onclick="return svchk()" onkeypress="return svchk()">reformed with</a>) and <code>eval</code> are illegal except in scopes that contain <code>use standard</code>.
</p>

</div>
<!-- SECTION [12735-13123] -->
<a name="evaluation"></a><h2>Evaluation</h2>
<div class="level2">

<p>
 Evaluation phase: Run the program. 
</p>
<ul>
<li class="level1"><div class="li"> Input: Abstract syntax tree</div>
</li>
<li class="level1"><div class="li"> Output: Values and effects on the environment</div>
</li>
<li class="level1"><div class="li"> Defininition: Computation (concrete interpretation) on the AST</div>
</li>
</ul>

<p>
 Some implementations will wish to split this into code generation and later execution; to each his own.
</p>

</div>
<!-- SECTION [13124-13439] -->
<a name="discussion"></a><h1>Discussion</h1>
<div class="level1">

<p>
 As one important application area for the dynamic dialect is small systems, I would like the dialect to address needs of those systems.  In particular: 
</p>
<ul>
<li class="level1"><div class="li"> The dynamic dialect should be compilable in a single forward pass without building syntax trees for statements (though not necessarily without using a little cleverness)</div>
</li>
<li class="level1"><div class="li"> In the dynamic dialect it should ideally be possible to ignore <strong>all</strong> type annotations and apply type checking only in operators, just as in 3rd Edition.  Such a constraint precludes type-directed conversions at assignment time (notably Number &rarr; int).</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/03/10 11:12</em>
</p>

</div>
<!-- SECTION [13440-14111] -->
<a name="notes"></a><h2>Notes</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <code>use strict</code> is a hint. browsers can ignore it</div>
</li>
<li class="level1"><div class="li"> need to define constant evaluation</div>
</li>
<li class="level1"><div class="li"> need to define type compatibility rules</div>
</li>
<li class="level1"><div class="li"> need to specify the semantics of <code>use strict to</code> pragma</div>
</li>
<li class="level1"><div class="li"> rename to &ldquo;standard and strict&rdquo;</div>
</li>
</ul>

</div>
<!-- SECTION [14112-14367] -->
<a name="interaction_with_scoping"></a><h2>Interaction with Scoping</h2>
<div class="level2">

<p>
What should the interpretation of the following function be?
</p>
<pre class="code">
function foo(a)
{
  if (a)
  {
    var b:String = bar();
  }
  else
  {
    var b:Number = 11;
  }
}
</pre>

<p>
If b is hoisted it would end up with two different types!:
</p>
<pre class="code">
function foo(a)
{
  var b:String;
  var b:Number;
  if (a)
  {
    b = bar();
  }
  else
  {
    b = 11;
  }
}
</pre>

<p>
[Since the two hoisted definitions of <code>var b</code> are incompatible, this is a compile-time error &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/11/28 11:13</em> ]
</p>

<p>
What about consts?
</p>
<pre class="code">
function foo(a)
{
  if (a)
  {
    const b = 5;
  }
  else
  {
    const b = 11;
  }
}
</pre>

<p>
should not become:
</p>
<pre class="code">
function foo(a)
{
  const b;
  if (a)
  {
    b = 5;
  }
  else
  {
    b = 11;
  }
}
</pre>

<p>
Proposed rules:
</p>
<ul>
<li class="level1"><div class="li"> var declarations without a type and in standard mode should be hoisted to the top of a function. [jd: agreed]</div>
</li>
<li class="level1"><div class="li"> var declarations with a type should not be hoisted. [jd: incompatible with AS3]</div>
</li>
<li class="level1"><div class="li"> const declarations should not be hoisted. [jd: ditto]</div>
</li>
<li class="level1"><div class="li"> declarations in strict mode should not be hoisted. [jd: strict mode should not change the standard mode meaning of programs that compile]</div>
</li>
<li class="level1"><div class="li"> a block nested inside another block within a function should redeclare a local variable. [jd: i don&rsquo;t understand; can you restate this assertion? maybe give an example]</div>
</li>
<li class="level1"><div class="li"> If a block declares a local variable named x, then an outer block in the same function should not refer to a global variable named x. Thus, the following code should be rejected because the return statement is not permitted to refer to the global x:</div>
</li>
</ul>
<pre class="code">
var x = 3;
function foo(a)
{
  if (a)
  {
    var x:Number = 5;
  }
  return x;
}
</pre>

<p>
[<code>const</code> and <code>var</code> hoist for backward compatibility with ES3 and AS3. <code>let</code> and <code>let const</code> are scoped to the current block. If <code>let</code> was used instead of <code>var</code> in this example, then <code>return x</code> would refer to the global <code>var x</code>, since it has no visibility to the inner <code>let x</code>. Are you suggesting that unhoisted bindings should have a hoisted shadow self that cause errors when referenced? What about this case
</p>
<pre class="code">

function f() 
{
    var x = 10
    {
       {
          let x = 20
       }
       return x
    }
}

</pre>

<p>
Error, or no?
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/11/28 11:30</em>
</p>

<p>
No error, the preceding function f() should return 10. &mdash; <em><a href="mailto:%26%23x66%3B%26%23x63%3B%26%23x68%3B%26%23x65%3B%26%23x6e%3B%26%23x67%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x66;&#x63;&#x68;&#x65;&#x6e;&#x67;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Francis Cheng</a> 2007/05/17 15:23</em>
</p>

<p>
 ]
</p>

<p>
  &mdash; <em><a href="mailto:%26%23x70%3B%26%23x72%3B%26%23x61%3B%26%23x74%3B%26%23x61%3B%26%23x70%3B%26%23x6c%3B%26%23x40%3B%26%23x6d%3B%26%23x69%3B%26%23x63%3B%26%23x72%3B%26%23x6f%3B%26%23x73%3B%26%23x6f%3B%26%23x66%3B%26%23x74%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x70;&#x72;&#x61;&#x74;&#x61;&#x70;&#x6c;&#x40;&#x6d;&#x69;&#x63;&#x72;&#x6f;&#x73;&#x6f;&#x66;&#x74;&#x2e;&#x63;&#x6f;&#x6d;">Pratap Lakshman</a> 2006/11/28 10:13</em> 
</p>

</div>
<!-- SECTION [14368-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/d/d306675009b2df6b1e54a058c9609063.xhtml used -->
</body>
</html>
