<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=strawman:modules_harmonic&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=strawman" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=strawman:modules_harmonic&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=strawman:modules_harmonic&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:modules_harmonic&amp;do=export_html.html#introduction" class="toc">Introduction</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:modules_harmonic&amp;do=export_html.html#syntax" class="toc">Syntax</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:modules_harmonic&amp;do=export_html.html#informal_semantics" class="toc">Informal semantics</a></span></li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:modules_harmonic&amp;do=export_html.html#dependency_injection_level" class="toc">Dependency injection level</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:modules_harmonic&amp;do=export_html.html#syntax" class="toc">Syntax</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:modules_harmonic&amp;do=export_html.html#informal_semantics" class="toc">Informal semantics</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:modules_harmonic&amp;do=export_html.html#entry_points" class="toc">Entry points</a></span></li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:modules_harmonic&amp;do=export_html.html#sandbox_level" class="toc">Sandbox level</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:modules_harmonic&amp;do=export_html.html#syntax" class="toc">Syntax</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:modules_harmonic&amp;do=export_html.html#informal_semantics" class="toc">Informal semantics</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:modules_harmonic&amp;do=export_html.html#entry_points" class="toc">Entry points</a></span></li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:modules_harmonic&amp;do=export_html.html#todo" class="toc">TODO</a></span></li>
</ul>
</div>
</div>

<a name="introduction"></a><h1>Introduction</h1>
<div class="level1">

<p>
 This is a proposal for modular programming support in ECMAScript, and is presented as two levels satisfying distinct programming styles. 
</p>
<ul>
<li class="level1"><div class="li"> The <em>dependency injection</em> level provides purely injected dependencies and strict isolation between components.</div>
</li>
<li class="level1"><div class="li"> The <em>sandbox</em> level provides convenient interaction between a set of mutually cooperating modules following an idiomatic style.</div>
</li>
</ul>

</div>
<!-- SECTION [1-419] -->
<a name="syntax"></a><h2>Syntax</h2>
<div class="level2">

<p>
 We define a <em><code>Module</code></em> production to describe the format of a modular compilation unit.
</p>
<pre class="code">
Module ::= (ImportDeclaration | RequireDeclaration)* ModuleElement*

ModuleElement ::= Statement
               |  FunctionDeclaration
               |  ExportDeclaration
</pre>

<p>
Note that, under this scheme, any ECMAScript <em><code>Program</code></em> is also a legal <em><code>Module</code></em>. We define <em><code>ImportDeclaration</code></em>, <em><code>RequireDeclaration</code></em> and <em><code>ExportDeclaration</code></em> below.
</p>

<p>
Under this proposal, all modular code is interpreted as though with the directive <code>use lexical scope</code>.
</p>

<p>
It is a significant element of this proposal that, to facilitate traversing the dependencies of a module via a shallow parse, the <em><code>ImportDeclaration</code></em>s and <em><code>RequireDeclaration</code></em>s must appear at the top of the module, and these and the <em><code>ExportDeclaration</code></em>s must appear in the module&rsquo;s outermost lexical scope.
</p>

</div>
<!-- SECTION [420-1346] -->
<a name="informal_semantics"></a><h2>Informal semantics</h2>
<div class="level2">

<p>
 We will define the semantics of our proposal by desugaring. In our desugared form, we will use the following function:
</p>
<pre class="code javascript"><span class="kw2">function</span> $get$<span class="br0">&#40;</span>o, p<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">if</span> <span class="br0">&#40;</span>!Object.<span class="me1">prototype</span>.<span class="me1">hasOwnProperty</span>.<span class="me1">call</span><span class="br0">&#40;</span>o, p<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">throw</span> <span class="kw2">new</span> ReferenceError<span class="br0">&#40;</span><span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>
  <span class="kw1">return</span> o<span class="br0">&#91;</span>p<span class="br0">&#93;</span>;
<span class="br0">&#125;</span></pre>
<p>
For <code>$get$</code> and all other identifiers surrounded by <code>$</code>, we assume some unexplained hygienic renaming scheme so we need not worry about collisions with the program being desugared.
</p>

</div>
<!-- SECTION [1347-1841] -->
<a name="dependency_injection_level"></a><h1>Dependency injection level</h1>
<div class="level1">

<p>
 At this level, a modular compilation unit is represented at runtime as a <em>module function</em>. A module function has no free variables. It closes over its implicit and explicit references to the language primordials (<code>Object</code>, <code>Array</code>, ...) with which it was created.
</p>

<p>
The value returned from calling a module function is an <em>instance</em> of that module. Unless the caller of the module arranges otherwise, successively created instances of the same module are isolated from one another, again except for their references to the primordials.
</p>

</div>
<!-- SECTION [1842-2428] -->
<a name="syntax"></a><h2>Syntax</h2>
<div class="level2">
<pre class="code">
ImportDeclaration ::= 'import' ModuleSpecifier ImportSpecifier ';'

ModuleSpecifier ::= StringLiteral

ImportSpecifier ::= ModuleFunctionImportSpecifier
                 |  InstanceImportSpecifier

ModuleFunctionImportSpecifier ::= 'as' Identifier

InstanceImportSpecifier ::= 'as' LeftHandSideExpression 'with' Expression

ExportDeclaration ::= 'export' VariableStatement
                   |  'export' FunctionDeclaration
</pre>

<p>
We expect we can simplify the progamming work somewhat by eliminating extraneous <code>const</code> and <code>function</code> keywords. For example, the declarations:
</p>
<pre class="code javascript"><span class="kw2">export</span> <span class="kw2">const</span> foo = <span class="nu0">3</span>;
<span class="kw2">export</span> <span class="kw2">function</span> bar<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="br0">&#125;</span>;</pre>
<p>
can be simplified to:
</p>
<pre class="code javascript"><span class="kw2">export</span> foo = <span class="nu0">3</span>;
<span class="kw2">export</span> bar<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="br0">&#125;</span>;</pre>
</div>
<!-- SECTION [2429-3196] -->
<a name="informal_semantics"></a><h2>Informal semantics</h2>
<div class="level2">

<p>
 As an example, consider a module stored as <code>util/points.js</code> which contains:
</p>
<pre class="code javascript"><span class="kw2">import</span> <span class="st0">'util/quanta'</span> <span class="kw1">as</span> <span class="br0">&#123;</span>quantize<span class="br0">&#125;</span> <span class="kw1">with</span> <span class="br0">&#123;</span>resolution: pixelSize<span class="br0">&#125;</span>;
&nbsp;
<span class="coMULTI">/* Constructor for Cartesian points */</span>
<span class="kw2">export</span> <span class="kw2">function</span> Cartesian<span class="br0">&#40;</span>x, y<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  x = quantize<span class="br0">&#40;</span>x<span class="br0">&#41;</span>; y = quantize<span class="br0">&#40;</span>y<span class="br0">&#41;</span>;
  <span class="kw1">return</span> <span class="br0">&#123;</span>
    getX: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> x; <span class="br0">&#125;</span>,
    getY: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> y; <span class="br0">&#125;</span>,
    getM: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> Math.<span class="me1">sqrt</span><span class="br0">&#40;</span>x * x + y * y<span class="br0">&#41;</span>; <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="coMULTI">/* Constructor for polar points */</span>
<span class="kw2">export</span> <span class="kw2">function</span> Polar<span class="br0">&#40;</span>r, t<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  r = quantize<span class="br0">&#40;</span>r<span class="br0">&#41;</span>;
  <span class="kw1">return</span> <span class="br0">&#123;</span>
    getR: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> r; <span class="br0">&#125;</span>,
    getT: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> t; <span class="br0">&#125;</span>,
    getM: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> r; <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>;
<span class="br0">&#125;</span></pre>
<p>
This code has a free variable <code>pixelSize</code>; refers to a module <code>util/quanta</code> and the language primordial <code>Math</code>; and <em>exports</em> the symbols <code>Cartesian</code> and <code>Polar</code>. The code can read the value of <code>pixelSize</code> but cannot assign to it; <code>pixelSize</code> acts as as though it were a <code>const</code> declaration injected by the module framework. The module <code>util/quanta.js</code> contains:
</p>
<pre class="code javascript"><span class="kw2">export</span> <span class="kw2">function</span> quantize<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">return</span> Math.<span class="me1">floor</span><span class="br0">&#40;</span>v / resolution<span class="br0">&#41;</span> * resolution;
<span class="br0">&#125;</span>
&nbsp;
<span class="kw2">export</span> <span class="kw2">function</span> isQuantized<span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">return</span> quantize<span class="br0">&#40;</span>v<span class="br0">&#41;</span> === v;
<span class="br0">&#125;</span></pre>
<p>
This code has a free variable <code>resolution</code>; refers to the language primordial <code>Math</code>, and exports the symbols <code>quantize</code> and <code>isQuantized</code>. The statement:
</p>
<pre class="code javascript"><span class="kw2">import</span> <span class="st0">'util/points'</span> <span class="kw1">as</span> Points;</pre>
<p>
assigns the value of the module function of <code>util/points</code> to the variable <code>Points</code> as though by a <code>const</code> declaration. The statement:
</p>
<pre class="code javascript"><span class="kw2">import</span> <span class="st0">'util/points'</span> <span class="kw1">as</span> Points3 <span class="kw1">with</span> <span class="br0">&#123;</span>pixelSize: <span class="nu0">3</span><span class="br0">&#125;</span>;</pre>
<p>
assigns an <em>instance</em> of the <code>util/points</code> module, with variable <code>pixelSize</code> bound to the value <code>3</code>, to the variable <code>Points3</code>. The statement:
</p>
<pre class="code javascript"><span class="kw2">import</span> <span class="st0">'util/points'</span> <span class="kw1">as</span> <span class="br0">&#123;</span>Cartesian, Polar<span class="br0">&#125;</span> <span class="kw1">with</span> <span class="br0">&#123;</span>pixelSize: <span class="nu0">3</span><span class="br0">&#125;</span>;</pre>
<p>
destructures the instance of <code>util/points</code>, assigning its <code>Cartesian</code> and <code>Polar</code> member, respectively, to the newly declared <code>const</code> variables <code>Cartesian</code> and <code>Polar</code>. The statement:
</p>
<pre class="code javascript"><span class="kw2">import</span> <span class="st0">'util/points'</span> <span class="kw1">as</span> <span class="br0">&#123;</span>Cartesian: C, Polar: P<span class="br0">&#125;</span> <span class="kw1">with</span> <span class="br0">&#123;</span>pixelSize: <span class="nu0">3</span><span class="br0">&#125;</span>;</pre>
<p>
does a similar destructuring, but assigning to newly declared <code>const</code> variables <code>C</code> and <code>P</code>, respectively.
</p>

<p>
The module function of <code>util/points</code> can be defined by desugaring as being roughly the result of the interpreter calling the following function with <code>$moduleFunctions$</code> initialized to contain the module functions that this module depends on:
</p>
<pre class="code javascript"><span class="kw2">function</span> moduleMaker<span class="br0">&#40;</span>$importedModuleFunctions$<span class="br0">&#41;</span> <span class="br0">&#123;</span>
&nbsp;
  <span class="kw2">const</span> $module_<span class="nu0">0</span>$ = $importedModuleFunctions$<span class="br0">&#40;</span><span class="st0">'util/quanta'</span><span class="br0">&#41;</span>;
&nbsp;
  <span class="kw2">const</span> $moduleFcn$ = <span class="kw2">function</span><span class="br0">&#40;</span>$bindings$<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">const</span> $exports$ = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
    <span class="kw2">const</span> pixelSize = $get$<span class="br0">&#40;</span>$bindings$, <span class="st0">'pixelSize'</span><span class="br0">&#41;</span>;
    <span class="kw2">const</span> <span class="br0">&#123;</span>quantize<span class="br0">&#125;</span> = $module_<span class="nu0">0</span>$<span class="br0">&#40;</span><span class="br0">&#123;</span>resolution: pixelSize<span class="br0">&#125;</span><span class="br0">&#41;</span>;
    $exports$.<span class="me1">Cartesian</span> = <span class="kw2">function</span> Cartesian<span class="br0">&#40;</span>x, y<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="coMULTI">/* ... */</span> <span class="br0">&#125;</span>;
    $exports$.<span class="me1">Polar</span> = <span class="kw2">function</span> Polar<span class="br0">&#40;</span>r, t<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="coMULTI">/* ... */</span> <span class="br0">&#125;</span>;
    <span class="kw1">return</span> Object.<span class="me1">freeze</span><span class="br0">&#40;</span>$exports$<span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>;
&nbsp;
  $moduleFcn$.<span class="me1">exportedSymbols</span> = Object.<span class="me1">freeze</span><span class="br0">&#40;</span><span class="br0">&#91;</span><span class="st0">'Cartesian'</span>, <span class="st0">'Polar'</span><span class="br0">&#93;</span><span class="br0">&#41;</span>;
  <span class="kw1">return</span> Object.<span class="me1">freeze</span><span class="br0">&#40;</span>$moduleFcn$<span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre>
<p>
The symbols <code>$bindings$</code>, <code>$exports$</code> and <code>$importedModuleFunctions$</code> are conceptually unmentionable variables inserted by the interpreter: 
</p>
<ul>
<li class="level1"><div class="li"> The variable <code>$bindings$</code> holds the variables bindings (of free variables in the original module source) expected to be introduced by the module&rsquo;s caller. Specifically, the entry <code>$bindings$[&rsquo;pixelSize&rsquo;]</code> is the binding for the module free variable <code>pixelSize</code>.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> The variable <code>$export$</code> holds the exported value of the module. The exported symbols <code>Cartesian</code> and <code>Polar</code> are assigned to it, then it is frozen.</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> The variable <code>$importedModuleFunctions$</code> holds the module functions of code that is statically recognized by the interpreter based on its recognition of the <code>import</code> special form in the code. The entry <code>$moduleFunction$(&rsquo;util/quantize&rsquo;)</code> is a reference to the module function of the <code>util/quantize</code> module.</div>
</li>
</ul>

<p>
 The module function is annotated with the array <code>exportedSymbols</code> to allow the sandbox layer to pre-wire module symbols in order to resolve dependency cycles.
</p>

<p>
Code which gains direct access to a module function, like the following:
</p>
<pre class="code javascript"><span class="kw2">import</span> <span class="st0">'util/points'</span> <span class="kw1">as</span> Points<span class="st0">'; </span></pre>
<p>
desugars to:
</p>
<pre class="code javascript"><span class="kw2">function</span> moduleMaker<span class="br0">&#40;</span>$importedModuleFunctions$<span class="br0">&#41;</span> <span class="br0">&#123;</span>
&nbsp;
  <span class="kw2">const</span> $module_<span class="nu0">0</span>$ = $importedModuleFunctions$<span class="br0">&#40;</span><span class="st0">'util/points'</span><span class="br0">&#41;</span>;
&nbsp;
  <span class="kw2">const</span> $moduleFcn$ = <span class="kw2">function</span><span class="br0">&#40;</span>$bindings$<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">const</span> $exports$ = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
    <span class="kw2">const</span> Points = $module_<span class="nu0">0</span>$;
    <span class="kw1">return</span> Object.<span class="me1">freeze</span><span class="br0">&#40;</span>$exports$<span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>;
&nbsp;
  $moduleFcn$.<span class="me1">exportedSymbols</span> = Object.<span class="me1">freeze</span><span class="br0">&#40;</span><span class="br0">&#91;</span><span class="br0">&#93;</span><span class="br0">&#41;</span>;
  <span class="kw1">return</span> Object.<span class="me1">freeze</span><span class="br0">&#40;</span>$moduleFcn$<span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre>
</div>
<!-- SECTION [3197-7948] -->
<a name="entry_points"></a><h2>Entry points</h2>
<div class="level2">

<p>
 An ECMAScript platform will provide one or more module importing functions, which we call <em>platform import-module</em> or <code>pim</code>. Each such function takes a module identifier and returns, asynchronously, a module function:
</p>
<pre class="code javascript">pim<span class="br0">&#40;</span><span class="st0">'util/points'</span>, <span class="kw2">function</span><span class="br0">&#40;</span>moduleFunction<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="co1">// receive module function</span>
<span class="br0">&#125;</span><span class="br0">&#41;</span>;</pre>
<p>
The return value will typically be asynchronous since, in the general case, the <code>pim</code> function must perform I/O to locate the dependencies of the loaded modules.
</p>

<p>
The returned module function is statically bound to the entire graph of <code>import</code>-ed module functions upon which it depends. This graph is, in turn, statically bound to a given set of language primordials (<code>Object</code>, <code>Math</code>, ...). A variant of the <code>pim</code> function may allow the caller to supply an alternate set of primordials:
</p>
<pre class="code javascript"><span class="kw2">const</span> primordials = <span class="coMULTI">/* manufacture new primordials */</span>;
pim<span class="br0">&#40;</span><span class="st0">'util/points'</span>, primordials, <span class="kw2">function</span><span class="br0">&#40;</span>moduleFunction<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="co1">// receive module function</span>
<span class="br0">&#125;</span><span class="br0">&#41;</span>;</pre>
<p>
Once the module function is available, it can be called with bindings for its free variables. The returned result is a frozen object containing the module&rsquo;s exports:
</p>
<pre class="code javascript"><span class="kw2">const</span> instance = moduleFunction<span class="br0">&#40;</span><span class="br0">&#123;</span>pixelSize: <span class="nu0">3</span><span class="br0">&#125;</span><span class="br0">&#41;</span>;
<span class="coMULTI">/* Can now use ... */</span>
instance.<span class="me1">Cartesian</span>, instance.<span class="me1">Polar</span>;</pre>
<p>
To refer to one another unambiguously, modules may wish to use some packaging scheme similar to <a href="doku.php%3Fid=strawman:modules_packages.html" class="wikilink1" title="strawman:modules_packages" onclick="return svchk()" onkeypress="return svchk()">modules_packages</a>. The salient property of such a scheme is that each module specifies a naming context within which a short name that can be conveniently embedded in the source code (like <code>util/points</code>) is resolved to an exact location (like <code><a href="https://m.example.com/rel/3.7.1a/pkg/dist/util/points.js" class="urlextern" target="_blank" title="https://m.example.com/rel/3.7.1a/pkg/dist/util/points.js" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">https://m.example.com/rel/3.7.1a/pkg/dist/util/points.js</a></code>). In resolving dependencies, the <code>pim</code> function needs to be aware of the specific module&rsquo;s naming context. This can be done in two ways: 
</p>
<ul>
<li class="level1"><div class="li"> By designing the <code>pim</code> function implementation to be aware of the specific naming mechanism &ndash; e.g., by providing built-in support for a packaging scheme; or</div>
</li>
<li class="level1"><div class="li"> By building the <code>pim</code> function such that it calls back to its invoker to resolve identifiers found in the source code, or even to fetch the text of modules given their identifiers, thus allowing the invoker to implement whatever naming scheme they wish.</div>
</li>
</ul>

<p>
 We propose for the interface of a module function to be standardized. We leave open the question of whether one or more forms of a <code>pim</code> function should be standardized.
</p>

</div>
<!-- SECTION [7949-10429] -->
<a name="sandbox_level"></a><h1>Sandbox level</h1>
<div class="level1">

<p>
 At this level, there exists an implicit environment, a <em>sandbox</em>, which contains a singleton instance of each distinct module. These singletons refer to one another&rsquo;s exports freely. The sandbox, and bindings for free variables of module code, are injected into the modules implicitly.
</p>

</div>
<!-- SECTION [10430-10747] -->
<a name="syntax"></a><h2>Syntax</h2>
<div class="level2">
<pre class="code">
RequireDeclaration ::= 'require' ModuleSpecifier 'as' LeftHandSideExpression ';'
</pre>

<p>
We define <code>require</code> to be a contextually reserved word for this statement form, but do not otherwise reserve it in other locations in the language.
</p>

</div>
<!-- SECTION [10748-11015] -->
<a name="informal_semantics"></a><h2>Informal semantics</h2>
<div class="level2">

<p>
 A <em><code>RequireDeclaration</code></em> desugars to an invocation of the free variable <code>require</code> on the module function of the named module. So for example, the code:
</p>
<pre class="code javascript">require <span class="st0">'util/points'</span> <span class="kw1">as</span> <span class="br0">&#123;</span>Cartesian, Polar<span class="br0">&#125;</span>;
<span class="kw2">import</span> <span class="st0">'util/points'</span> <span class="kw1">as</span> PointModule;
<span class="kw2">export</span> <span class="kw2">const</span> thePoint = Cartesian<span class="br0">&#40;</span>xCoord, yCoord<span class="br0">&#41;</span>;</pre>
<p>
requests an ambient instance of the <code>util/points</code> module, then returns a <code>Cartesian</code> object based on free variables <code>xCoord</code> and <code>yCoord</code>. This would desugar to the following:
</p>
<pre class="code javascript"><span class="kw2">function</span> moduleMaker<span class="br0">&#40;</span>$importedModuleFunctions$, $requiredModuleFunctions$<span class="br0">&#41;</span> <span class="br0">&#123;</span>
&nbsp;
  <span class="kw2">const</span> $module_<span class="nu0">0</span>$ = $requiredModuleFunctions$<span class="br0">&#40;</span><span class="st0">'util/points'</span><span class="br0">&#41;</span>;
  <span class="kw2">const</span> $module_<span class="nu0">1</span>$ = $importedModuleFunctions$<span class="br0">&#40;</span><span class="st0">'util/points'</span><span class="br0">&#41;</span>;
&nbsp;
  <span class="kw2">const</span> $moduleFcn$ = <span class="kw2">function</span><span class="br0">&#40;</span>$bindings$, $require$<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">const</span> $exports$ = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
    <span class="kw2">const</span> xCoord = $get$<span class="br0">&#40;</span>$bindings$, <span class="st0">'xCoord'</span><span class="br0">&#41;</span>;
    <span class="kw2">const</span> yCoord = $get$<span class="br0">&#40;</span>$bindings$, <span class="st0">'yCoord'</span><span class="br0">&#41;</span>;
    <span class="kw2">const</span> <span class="br0">&#123;</span>Cartesian, Polar<span class="br0">&#125;</span> = $require$<span class="br0">&#40;</span>$module_<span class="nu0">0</span>$<span class="br0">&#41;</span>;
    <span class="kw2">const</span> PointModule = $module_<span class="nu0">1</span>$;
    $exports$.<span class="me1">thePoint</span> = Cartesian<span class="br0">&#40;</span>xCoord, yCoord<span class="br0">&#41;</span>;
    $exports$.<span class="me1">Polar</span> = <span class="kw2">function</span> Polar<span class="br0">&#40;</span>r, t<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="coMULTI">/* ... */</span> <span class="br0">&#125;</span>;
    <span class="kw1">return</span> Object.<span class="me1">freeze</span><span class="br0">&#40;</span>$exports$<span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>;
&nbsp;
  $moduleFcn$.<span class="me1">exportedSymbols</span> = Object.<span class="me1">freeze</span><span class="br0">&#40;</span><span class="br0">&#91;</span><span class="st0">'thePoint'</span><span class="br0">&#93;</span><span class="br0">&#41;</span>;
  <span class="kw1">return</span> Object.<span class="me1">freeze</span><span class="br0">&#40;</span>$moduleFcn$<span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre>
<p>
The second argument of the module function is assumed to point to a &ldquo;sandbox&rdquo; which memoizes instances of each module by identity. It is the responsibility of the sandbox, when invoking module functions, to pass bindings for the free variables. As such, a group of modules seeking to occupy the same sandbox will have the same set of free variables. For example, a set of modules expecting to occupy a Web page might have the free variables <code>document</code> and <code>navigator</code>.
</p>

<p>
Note that we look up module names in two separate namespaces: the <em>imported</em> and <em>required</em>. This is because, conceptually, an <code>import</code> is resolved relative to a namespace under the control of the <code>import</code>-ing module (e.g., perhaps, some &ldquo;package&rdquo; that the module a came in), whereas a <code>require</code> is resolved relative to a namespace under the control of the sandbox, and the code building a sandbox must arrange for the modules in the sandbox to <em>share</em> the same mapping. This ensures that, if two modules <code>require</code> the singleton instance of a module they call <code>util/points</code>, what they get is deterministically indeed a singleton, not a different instance depending on their local mapping.
</p>

<p>
For circularly dependent modules, consider <code>util/even</code> containing:
</p>
<pre class="code javascript">require <span class="st0">''</span>util/odd<span class="st0">''</span> <span class="kw1">as</span> <span class="br0">&#123;</span>odd<span class="br0">&#125;</span>;
<span class="kw2">export</span> <span class="kw2">function</span> even<span class="br0">&#40;</span>n<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">return</span> n == <span class="nu0">0</span> || odd<span class="br0">&#40;</span>n - <span class="nu0">1</span><span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre>
<p>
and <code>util/odd</code> containing: 
</p>
<pre class="code javascript">require <span class="st0">''</span>util/even<span class="st0">''</span> <span class="kw1">as</span> <span class="br0">&#123;</span>even<span class="br0">&#125;</span>;
<span class="kw2">export</span> <span class="kw2">function</span> odd<span class="br0">&#40;</span>n<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">return</span> n != <span class="nu0">0</span> &amp;&amp; even<span class="br0">&#40;</span>n - <span class="nu0">1</span><span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre>
<p>
This is easily supported: because the desugaring of each module function lists its exports, a sandbox can pre-wire the symbols using proxies, then resolve the proxies as modules complete their execution.
</p>

</div>
<!-- SECTION [11016-14026] -->
<a name="entry_points"></a><h2>Entry points</h2>
<div class="level2">

<p>
 A sandbox is constructed by supplying: 
</p>
<ul>
<li class="level1"><div class="li"> A module identifier for the root-most module to be instantiated in the sandbox;</div>
</li>
<li class="level1"><div class="li"> A set of mappings from short names to exact module identifiers;</div>
</li>
<li class="level1"><div class="li"> A set of bindings for free variables of all modules in the sandbox; and</div>
</li>
<li class="level1"><div class="li"> Optionally, a set of language primordials to be used by the modules in the sandbox.</div>
</li>
</ul>

<p>
 As with the dependency injection <code>pim</code> function, the module functions created by this process are statically bound to one another&rsquo;s dependencies and to the supplied primordials.
</p>

<p>
An example of invoking the sandbox builder, which we call <code>sbx</code>, is:
</p>
<pre class="code javascript">sbx<span class="br0">&#40;</span>
  <span class="st0">'util/points'</span>,
  nameMappings,
  <span class="br0">&#123;</span>pixelSize: <span class="nu0">3</span><span class="br0">&#125;</span>,
  <span class="kw2">function</span><span class="br0">&#40;</span>moduleInstance<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="co1">// receive module instance</span>
  <span class="br0">&#125;</span><span class="br0">&#41;</span>;</pre>
<p>
As with the case of <code>pim</code> at the dependency injection level, the <code>sbx</code> function may instead receive a callback to the invoker to resolve identifiers or even fetch the text of modules. Similarly, we leave open the question of whether some forms of the <code>sbx</code> function should be standardized.
</p>

</div>
<!-- SECTION [14027-15108] -->
<a name="todo"></a><h1>TODO</h1>
<div class="level1">
<ul>
<li class="level1"><div class="li"> Integration into <acronym title="HyperText Markup Language">HTML</acronym></div>
</li>
</ul>

</div>
<!-- SECTION [15109-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/d/d128497fc8362ebd92f6bb98957d00a1.xhtml used -->
</body>
</html>
