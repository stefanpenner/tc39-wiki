<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=harmony:virtual_object_api&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="http://wiki.ecmascript.org/feed.php?mode=list&amp;ns=harmony" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#proxy_handler_apis" class="toc">Proxy Handler APIs</a></span><ul class="toc">
<li class="clear"><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#the_problem" class="toc">The Problem</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#handler_class_hierarchy" class="toc">Handler class hierarchy</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#delegatinghandler" class="toc">DelegatingHandler</a></span><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#example" class="toc">Example</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#details" class="toc">Details</a></span></li>
</ul>
</li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#forwardinghandler" class="toc">ForwardingHandler</a></span><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#example" class="toc">Example</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#details" class="toc">Details</a></span></li>
</ul>
</li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#virtualhandler" class="toc">VirtualHandler</a></span><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#example" class="toc">Example</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#details" class="toc">Details</a></span></li>
</ul>
</li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#why_isn_t_this_just_a_javascript_library" class="toc">Why isn't this just a JavaScript library?</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#non-normative_implementation" class="toc">Non-normative implementation</a></span><ul class="toc">
<li class="clear"><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#delegatinghandler" class="toc">DelegatingHandler</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#forwardinghandler" class="toc">ForwardingHandler</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#virtualhandler" class="toc">VirtualHandler</a></span></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#prototype_implementations" class="toc">Prototype implementations</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:virtual_object_api&amp;do=export_html.html#history" class="toc">History</a></span></li>
</ul>
</li>
</ul>
</div>
</div>

<a name="proxy_handler_apis"></a><h1>Proxy Handler APIs</h1>
<div class="level1">

<p>
 The goal of the below <acronym title="Application Programming Interface">API</acronym> is to help developers write correct Proxy abstractions.
</p>

</div>
<!-- SECTION [1-117] -->
<a name="the_problem"></a><h3>The Problem</h3>
<div class="level3">

<p>
 The direct proxies <acronym title="Application Programming Interface">API</acronym> makes it easy to define lightweight handlers because all traps are optional: if a proxy handler does not define a trap, the default is to simply forward the intercepted operation to the target object.
</p>

<p>
While this is a convenient and simple default, it requires quite a bit more attention to write handlers that remain &ldquo;self-consistent&rdquo;. This is because many operations in JavaScript have subtle dependencies on each other. For example:
</p>
<pre class="code javascript"><span class="kw2">var</span> obj = <span class="br0">&#123;</span>foo:<span class="nu0">42</span><span class="br0">&#125;</span>;
<span class="kw2">var</span> desc = Object.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>obj,<span class="st0">"foo"</span><span class="br0">&#41;</span> <span class="co1">// desc = {value:42,...}</span>
obj.<span class="me1">foo</span> <span class="co1">// 42</span>
<span class="st0">"foo"</span> <span class="kw1">in</span> obj <span class="co1">// true</span></pre>
<p>
In other words, for any normal ECMAScript object <code>obj</code>, if <code>Object.getOwnPropertyDescriptor(obj,&rdquo;foo&rdquo;)</code> returns <code>{value:42}</code>, then: 
</p>
<ul>
<li class="level1"><div class="li"> <code>obj.foo</code> returns <code>42</code>, the value of the data property.</div>
</li>
<li class="level1"><div class="li"> <code>&ldquo;foo&rdquo; in obj</code> returns <code>true</code>, because &ldquo;foo&rdquo; exists as an &ldquo;own&rdquo; data property.</div>
</li>
</ul>

<p>
 Now consider the following proxy:
</p>
<pre class="code javascript"><span class="kw2">var</span> target = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
<span class="kw2">var</span> proxy = <span class="kw2">new</span> Proxy<span class="br0">&#40;</span>target, <span class="br0">&#123;</span>
  getOwnPropertyDescriptor: <span class="kw2">function</span><span class="br0">&#40;</span>target, <span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#123;</span> value: <span class="nu0">42</span> <span class="br0">&#125;</span>;
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span><span class="br0">&#41;</span>;
&nbsp;
<span class="kw2">var</span> desc = Object.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>proxy,<span class="st0">"foo"</span><span class="br0">&#41;</span>; <span class="co1">// desc = {value:42,...}</span>
proxy.<span class="me1">foo</span> <span class="co1">// undefined!?</span>
<span class="st0">"foo"</span> <span class="kw1">in</span> proxy <span class="co1">// false!?</span></pre>
<p>
In this case, since the proxy handler only implements the <code>getOwnPropertyDescriptor</code> trap, <code>Object.getOwnPropertyDescriptor(proxy,&rdquo;foo&rdquo;)</code> will return a descriptor with <code>{value:42}</code> but: 
</p>
<ul>
<li class="level1"><div class="li"> <code>proxy.foo</code> will return <code>undefined</code>, because the <code>get</code> trap was not overridden in a consistent way. Instead, <code>get</code> by default forwards to target, and <code>target.foo</code> is <code>undefined</code>.</div>
</li>
<li class="level1"><div class="li"> <code>&ldquo;foo&rdquo; in proxy</code> will return <code>false</code>, because the <code>has</code> trap was not overridden in a consistent way. Instead, <code>has</code> by default forwards to target, and <code>&ldquo;foo&rdquo; in target</code> is <code>false</code>.</div>
</li>
</ul>

<p>
 We therefore propose a number of standard proxy handler classes that users can subclass to inherit more sensible default implementations of all traps:
</p>
<pre class="code javascript"><span class="kw2">import</span> DelegatingHandler from std.<span class="me1">reflect</span>;
&nbsp;
<span class="kw2">var</span> target = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
<span class="kw2">var</span> proxy = <span class="kw2">new</span> Proxy<span class="br0">&#40;</span>target, <span class="kw2">new</span> <span class="kw2">class</span> <span class="kw2">extends</span> DelegatingHandler <span class="br0">&#123;</span>
  getOwnPropertyDescriptor<span class="br0">&#40;</span>target, <span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#123;</span> value: <span class="nu0">42</span> <span class="br0">&#125;</span>;
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span><span class="br0">&#41;</span>;
&nbsp;
<span class="kw2">var</span> desc = Object.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>proxy,<span class="st0">"foo"</span><span class="br0">&#41;</span>; <span class="co1">// desc = {value:42,...}</span>
proxy.<span class="me1">foo</span> <span class="co1">// 42</span>
<span class="st0">"foo"</span> <span class="kw1">in</span> proxy <span class="co1">// true</span></pre>
<p>
By having the proxy handler inherit from a class called <code>DelegatingHandler</code>, the handler inherits more sensible default implementations: 
</p>
<ul>
<li class="level1"><div class="li"> <code>proxy.foo</code> will return <code>42</code> because the <code>get</code> trap inherited from <code>DelegatingHandler</code> is implemented in terms of the (overridden) <code>getOwnPropertyDescriptor</code> trap.</div>
</li>
<li class="level1"><div class="li"> <code>&ldquo;foo&rdquo; in proxy</code> will return <code>true</code> because the <code>has</code> trap inherited from <code>DelegatingHandler</code> is likewise implemented in terms of the (overridden) <code>getOwnPropertyDescriptor</code> trap.</div>
</li>
</ul>

<p>
 Finally, the <code>DelegatingHandler</code> class defines a static factory method that makes it slightly less verbose to create a proxy with a <code>DelegatingHandler</code> instance:
</p>
<pre class="code javascript"><span class="kw2">class</span> MyHandler <span class="kw2">extends</span> DelegatingHandler <span class="br0">&#123;</span>
  <span class="co1">// override some traps</span>
<span class="br0">&#125;</span>
<span class="kw2">var</span> target = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
&nbsp;
<span class="co1">// normally, we would write:</span>
<span class="co1">//  proxy = new Proxy(target, new MyHandler());</span>
&nbsp;
<span class="co1">// we can also write the shorter form:</span>
<span class="kw2">var</span> proxy = MyHandler.<span class="me1">proxyFor</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span>;</pre>
</div>
<!-- SECTION [118-3430] -->
<a name="handler_class_hierarchy"></a><h3>Handler class hierarchy</h3>
<div class="level3">

<p>
 We propose three standard proxy handler classes: 
</p>
<ul>
<li class="level1"><div class="li"> <strong>DelegatingHandler</strong>: subclass this handler if your proxy wraps a target object, and you want your proxy to be able to serve as a prototype for other objects. Intercepted property gets, sets and method invocations are forwarded to the target with <code>this</code> bound to the original &ldquo;receiver&rdquo; object (which may be the proxy object).</div>
</li>
<li class="level1"><div class="li"> <strong>ForwardingHandler</strong>: subclass this handler if your proxy wraps a target object, and you want to ensure that <code>this</code> is always bound to the target object inside forwarded method calls or accessors, never to the proxy object. Proxies using this handler should not be used as prototypes, as they ignore the initial receiver object upon forwarding.</div>
</li>
<li class="level1"><div class="li"> <strong>VirtualHandler</strong>: subclass this handler if your proxy does not actually wrap a target object. In other words, your proxy represents a &ldquo;virtual object&rdquo; that does not have a useful backing <code>target</code> object. A <code>VirtualHandler</code> never forwards operations to its target.</div>
</li>
</ul>

<p>
 These handler classes are related in a simple inheritance hierarchy. Below is a class diagram of the hierarchy. Details about the methods defined on each handler are explained in the next section.
</p>

<p>
<a href="lib/exe/detail.php%3Fid=harmony%253Avirtual_object_api&amp;cache=cache&amp;media=proposals:handlerapi.jpg.html" class="media" title="proposals:handlerapi.jpg" onclick="return svchk()" onkeypress="return svchk()"><img src="lib/exe/fetch.php%3Fw=400&amp;h=&amp;cache=cache&amp;media=proposals:handlerapi.jpg" class="mediacenter" title="handlerapi.jpg" alt="handlerapi.jpg" width="400" /></a>
</p>

<p>
We will refer to a proxy handler that does <em>not</em> subclass any of these three handlers a <em>raw</em> handler (e.g. using an object literal as a handler counts as a raw handler). The behavior of an empty raw handler corresponds most closely to the behavior of the <code>DelegatingHandler</code>, which is why this one forms the &ldquo;root&rdquo; of the handler class hierarchy.
</p>

</div>
<!-- SECTION [3431-5065] -->
<a name="delegatinghandler"></a><h3>DelegatingHandler</h3>
<div class="level3">

</div>
<!-- SECTION [5066-5095] -->
<a name="example"></a><h4>Example</h4>
<div class="level4">
<pre class="code javascript"><span class="kw2">class</span> Logger <span class="kw2">extends</span> DelegatingHandler <span class="br0">&#123;</span>
  defineProperty<span class="br0">&#40;</span>target, <span class="kw3">name</span>, desc<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    console.<span class="me1">log</span><span class="br0">&#40;</span><span class="st0">"updated: "</span>+<span class="kw3">name</span><span class="br0">&#41;</span>; <span class="co1">// log the update</span>
    <span class="kw1">return</span> <span class="kw2">super</span>.<span class="me1">defineProperty</span><span class="br0">&#40;</span>target, <span class="kw3">name</span>, desc<span class="br0">&#41;</span>; <span class="co1">// perform update on wrapped target</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw2">var</span> p = Logger.<span class="me1">proxyFor</span><span class="br0">&#40;</span><span class="br0">&#123;</span>
  foo: <span class="nu0">42</span>,
  bar: <span class="kw2">function</span><span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">this</span>.<span class="me1">foo</span> = v; <span class="br0">&#125;</span>
<span class="br0">&#125;</span><span class="br0">&#41;</span>;
&nbsp;
<span class="co1">// triggers &quot;defineProperty&quot; trap, logs the update:</span>
Object.<span class="me1">defineProperty</span><span class="br0">&#40;</span>p, <span class="st0">"foo"</span>, <span class="br0">&#123;</span>value:<span class="nu0">43</span><span class="br0">&#125;</span><span class="br0">&#41;</span>; <span class="co1">// updated: &quot;foo&quot;</span>
&nbsp;
<span class="co1">// triggers the &quot;set&quot; trap, which in turn calls &quot;defineProperty&quot;,</span>
<span class="co1">// so this update is logged as well:</span>
p.<span class="me1">foo</span> = <span class="nu0">44</span>; <span class="co1">// updated: &quot;foo&quot;</span>
&nbsp;
<span class="co1">// DelegatingHandler binds |this| inside the bar() method to p,</span>
<span class="co1">// so the property update inside that method is logged as well:</span>
p.<span class="me1">bar</span><span class="br0">&#40;</span><span class="nu0">45</span><span class="br0">&#41;</span>; <span class="co1">// updated: &quot;foo&quot;</span></pre>
</div>
<!-- SECTION [5096-5854] -->
<a name="details"></a><h4>Details</h4>
<div class="level4">

<p>
 Below is the class definition for <code>DelegatingHandler</code>. We show only the signature of the methods. We also cluster the methods of <code>DelegatingHandler</code> into two groups: 
</p>
<ul>
<li class="level1"><div class="li"> Fundamental traps: these are traps that do not depend on any other trap. Their default behavior is simply to forward the operation to the target object (exactly as if you would have used a raw handler with a missing trap).</div>
</li>
<li class="level1"><div class="li"> Derived traps: these are traps that <em>do</em> depend on one or more other traps. Their default behavior is to call back on the fundamental traps (via self-sends) to implement the operation.</div>
</li>
</ul>

<p>
  The intent is for clients to subclass <code>DelegatingHandler</code>, override just the fundamental traps, and inherit all or most of the derived trap implementations &ldquo;for free&rdquo;. The benefit is that all derived operations will remain consistent with the fundamental operations. There is less chance of forgetting to implement a trap, and also less chance in overriding two or more dependent traps in an inconsistent way. Clients are still free to override the derived traps as well (usually to provide a more efficient implementation).
</p>
<pre class="code javascript"><span class="kw2">class</span> DelegatingHandler <span class="br0">&#123;</span>
  <span class="co1">// static factory methods</span>
  static proxyFor<span class="br0">&#40;</span>target, ...<span class="me1">args</span><span class="br0">&#41;</span>;
  static revocableProxyFor<span class="br0">&#40;</span>target, ...<span class="me1">args</span><span class="br0">&#41;</span>;
&nbsp;
  <span class="co1">// fundamental traps (forward to target)</span>
  getOwnPropertyDescriptor<span class="br0">&#40;</span>target, <span class="kw3">name</span><span class="br0">&#41;</span>;
  getOwnPropertyNames<span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
  getOwnPropertyKeys<span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
  getPrototypeOf<span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
  setPrototypeOf<span class="br0">&#40;</span>target, newProto<span class="br0">&#41;</span>;
  defineProperty<span class="br0">&#40;</span>target, <span class="kw3">name</span>, desc<span class="br0">&#41;</span>;
  deleteProperty<span class="br0">&#40;</span>target, <span class="kw3">name</span><span class="br0">&#41;</span>;
  preventExtensions<span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
  isExtensible<span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
  apply<span class="br0">&#40;</span>target, thisBinding, args<span class="br0">&#41;</span>;
 
  <span class="co1">// derived traps</span>
  has<span class="br0">&#40;</span>target, <span class="kw3">name</span><span class="br0">&#41;</span>; <span class="co1">// depends on: getOwnPropertyDescriptor, getPrototypeOf</span>
  hasOwn<span class="br0">&#40;</span>target, <span class="kw3">name</span><span class="br0">&#41;</span>; <span class="co1">// depends on: getOwnPropertyDescriptor</span>
  get<span class="br0">&#40;</span>target, <span class="kw3">name</span>, receiver<span class="br0">&#41;</span>; <span class="co1">// depends on: getOwnPropertyDescriptor, getPrototypeOf</span>
  set<span class="br0">&#40;</span>target, <span class="kw3">name</span>, value, receiver<span class="br0">&#41;</span>; <span class="co1">// depends on: getOwnPropertyDescriptor, getPrototypeOf, defineProperty</span>
  invoke<span class="br0">&#40;</span>target, <span class="kw3">name</span>, args, receiver<span class="br0">&#41;</span>; <span class="co1">// depends on: get</span>
  enumerate<span class="br0">&#40;</span>target<span class="br0">&#41;</span>; <span class="co1">// depends on: getOwnPropertyNames, getOwnPropertyDescriptor, getPrototypeOf</span>
  keys<span class="br0">&#40;</span>target<span class="br0">&#41;</span>; <span class="co1">// depends on: getOwnPropertyNames, getOwnPropertyDescriptor</span>
&nbsp;
  <span class="co1">// potentially deprecated</span>
  construct<span class="br0">&#40;</span>target, args<span class="br0">&#41;</span>; <span class="co1">// depends on: apply, get</span>
&nbsp;
  <span class="co1">// deprecated traps</span>
  <span class="co1">//seal(target); // depends on: preventExtensions, getOwnPropertyNames, defineProperty</span>
  <span class="co1">//freeze(target); // depends on: preventExtensions, getOwnPropertyNames, getOwnPropertyDescriptor, defineProperty</span>
  <span class="co1">//isSealed(target); // depends on: isExtensible, getOwnPropertyNames, getOwnPropertyDescriptor</span>
  <span class="co1">//isFrozen(target); // depends on: isExtensible, getOwnPropertyNames, getOwnPropertyDescriptor</span>
<span class="br0">&#125;</span></pre>
<p>
In the case of the <code>get</code>, <code>set</code> and <code>invoke</code> traps, there is a choice to be made when forwarding the property get/set or the invoked method: should the value of <code>this</code> in a target&rsquo;s accessor or method be set to the proxy object or to the target object? Either choice can be sensible, depending on your application.
</p>

<p>
The <code>DelegatingHandler</code> implements <code>get</code>, <code>set</code> and <code>invoke</code> in such a way that <code>this</code> inside forwarded accessors or method invocations remains bound to the <code>receiver</code> argument. Proxies using the <code>DelegatingHandler</code> can thus be used as prototypes for other objects: they leave the <code>this</code>-binding intact upon forwarding.
</p>

</div>
<!-- SECTION [5855-9279] -->
<a name="forwardinghandler"></a><h3>ForwardingHandler</h3>
<div class="level3">

</div>
<!-- SECTION [9280-9308] -->
<a name="example"></a><h4>Example</h4>
<div class="level4">
<pre class="code javascript"><span class="kw2">class</span> Logger <span class="kw2">extends</span> ForwardingHandler <span class="br0">&#123;</span>
  defineProperty<span class="br0">&#40;</span>target, <span class="kw3">name</span>, desc<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    console.<span class="me1">log</span><span class="br0">&#40;</span><span class="st0">"updated: "</span>+<span class="kw3">name</span><span class="br0">&#41;</span>; <span class="co1">// log the update</span>
    <span class="kw1">return</span> <span class="kw2">super</span>.<span class="me1">defineProperty</span><span class="br0">&#40;</span>target, <span class="kw3">name</span>, desc<span class="br0">&#41;</span>; <span class="co1">// perform update on wrapped target</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw2">var</span> p = Logger.<span class="me1">proxyFor</span><span class="br0">&#40;</span><span class="br0">&#123;</span>
  foo: <span class="nu0">42</span>,
  bar: <span class="kw2">function</span><span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">this</span>.<span class="me1">foo</span> = v; <span class="br0">&#125;</span>
<span class="br0">&#125;</span><span class="br0">&#41;</span>;
&nbsp;
<span class="co1">// triggers &quot;defineProperty&quot; trap, logs the update:</span>
Object.<span class="me1">defineProperty</span><span class="br0">&#40;</span>p, <span class="st0">"foo"</span>, <span class="br0">&#123;</span>value:<span class="nu0">43</span><span class="br0">&#125;</span><span class="br0">&#41;</span>; <span class="co1">// updated: &quot;foo&quot;</span>
&nbsp;
<span class="co1">// triggers the &quot;set&quot; trap, which in turn calls &quot;defineProperty&quot;,</span>
<span class="co1">// so this update is logged as well:</span>
p.<span class="me1">foo</span> = <span class="nu0">44</span>; <span class="co1">// updated: &quot;foo&quot;</span>
&nbsp;
<span class="co1">// ForwardingHandler binds |this| inside the bar() method to the target,</span>
<span class="co1">// so the property update inside that method will not be logged:</span>
p.<span class="me1">bar</span><span class="br0">&#40;</span><span class="nu0">45</span><span class="br0">&#41;</span>; <span class="co1">// update not logged</span></pre>
</div>
<!-- SECTION [9309-10080] -->
<a name="details"></a><h4>Details</h4>
<div class="level4">

<p>
 As mentioned above, when forwarding intercepted property gets/sets or method calls, there is a choice to be made whether to bind <code>this</code> to the proxy object or to the target object inside forwarded methods or accessors. When using the <code>DelegatingHandler</code> class, the default is to leave the <code>this</code> value unmodified, which means that <code>this</code> will often be bound to the proxy object.
</p>

<p>
This can sometimes lead to awkward behavior, for instance:
</p>
<pre class="code javascript"><span class="kw2">var</span> target = <span class="kw2">new</span> Date<span class="br0">&#40;</span><span class="br0">&#41;</span>;
<span class="kw2">var</span> proxy = <span class="kw2">new</span> Proxy<span class="br0">&#40;</span>target, <span class="br0">&#123;</span><span class="br0">&#125;</span><span class="br0">&#41;</span>; <span class="co1">// or new Proxy(target,new DelegatingHandler())</span>
proxy.<span class="me1">getFullYear</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="co1">// error: not a Date</span></pre>
<p>
What&rsquo;s going on here? The proxy by default forwards the intercepted method call to its target, i.e. it will call <code>Date.prototype.getFullYear</code> method on the target <code>Date</code> object. When this function is subsequently called, the default is to provide the proxy itself as the <code>this</code>-binding of the function. This is where things go wrong: the <code>Date.prototype.getFullYear</code> method is not generic and expects its <code>this</code>-binding to be a genuine <code>Date</code> object, which the proxy is not.
</p>

<p>
What this example shows is that sometimes it is useful to always re-bind <code>this</code> to the target object. The <code>ForwardingHandler</code> class defined below caters to exactly this use case:
</p>
<pre class="code javascript"><span class="kw2">var</span> target = <span class="kw2">new</span> Date<span class="br0">&#40;</span><span class="br0">&#41;</span>;
<span class="kw2">var</span> proxy = <span class="kw2">new</span> Proxy<span class="br0">&#40;</span>target, <span class="kw2">new</span> <span class="kw2">class</span> <span class="kw2">extends</span> ForwardingHandler <span class="br0">&#123;</span><span class="br0">&#125;</span><span class="br0">&#41;</span>;
proxy.<span class="me1">getFullYear</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="co1">// returns 2013</span></pre>
<p>
Note that <code>ForwardingHandler</code> does not automatically bind function-valued data properties on extraction, so the following pattern will not work (as is the case for normal objects):
</p>
<pre class="code javascript"><span class="kw2">var</span> target = <span class="kw2">new</span> Date<span class="br0">&#40;</span><span class="br0">&#41;</span>;
<span class="kw2">var</span> proxy = <span class="kw2">new</span> Proxy<span class="br0">&#40;</span>target, <span class="kw2">new</span> <span class="kw2">class</span> <span class="kw2">extends</span> ForwardingHandler <span class="br0">&#123;</span><span class="br0">&#125;</span><span class="br0">&#41;</span>;
proxy.<span class="me1">getFullYear</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="co1">// returns 2013</span>
<span class="kw2">var</span> getFullYear = proxy.<span class="me1">getFullYear</span>;
getFullYear<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="co1">// error: undefined is not a Date (in strict mode)</span></pre>
<p>
<code>ForwardingHandler</code> is itself a subclass of <code>DelegatingHandler</code> (so it comes with an appropriate default implementation for all Proxy traps). It overrides the <code>get</code>, <code>set</code> and <code>invoke</code> traps so that forwarded accessors or method calls get run with <code>this</code> set to the target object:
</p>
<pre class="code javascript"><span class="kw2">class</span> ForwardingHandler <span class="kw2">extends</span> DelegatingHandler <span class="br0">&#123;</span>
  get<span class="br0">&#40;</span>target, <span class="kw3">name</span>, receiver<span class="br0">&#41;</span>; <span class="co1">// depends on: getOwnPropertyDescriptor, getPrototypeOf</span>
  set<span class="br0">&#40;</span>target, <span class="kw3">name</span>, value, receiver<span class="br0">&#41;</span>; <span class="co1">// depends on: getOwnPropertyDescriptor, getPrototypeOf, defineProperty</span>
  invoke<span class="br0">&#40;</span>target, <span class="kw3">name</span>, args, receiver<span class="br0">&#41;</span>; <span class="co1">// depends on: get</span>
<span class="br0">&#125;</span></pre>
</div>
<!-- SECTION [10081-12628] -->
<a name="virtualhandler"></a><h3>VirtualHandler</h3>
<div class="level3">

</div>
<!-- SECTION [12629-12656] -->
<a name="example"></a><h4>Example</h4>
<div class="level4">

<p>
 Say we want to develop a &ldquo;LazyObject&rdquo; abstraction that only instantiates an object the first time it is accessed:
</p>
<pre class="code javascript"><span class="co1">// thunk will be called to initialize the object the first</span>
<span class="co1">// time it is accessed:</span>
<span class="kw2">var</span> thunk = <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="br0">&#123;</span>foo:<span class="nu0">42</span><span class="br0">&#125;</span>; <span class="br0">&#125;</span>;
&nbsp;
<span class="co1">// create a LazyObject proxy with the thunk, and an empty target object</span>
<span class="co1">// (the target object is irrelevant for this abstraction):</span>
<span class="kw2">var</span> dummyTarget = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
<span class="kw2">var</span> p = LazyObject.<span class="me1">proxyFor</span><span class="br0">&#40;</span>dummyTarget, thunk<span class="br0">&#41;</span>;
&nbsp;
p.<span class="me1">foo</span> <span class="co1">// calls thunk() to initialize the object, then returns 42</span></pre>
<p>
We might implement the <code>LazyObject</code> handler as a simple subclass of <code>DelegatingHandler</code>:
</p>
<pre class="code javascript"><span class="kw2">class</span> LazyObject <span class="kw2">extends</span> DelegatingHandler <span class="br0">&#123;</span>
  constructor<span class="br0">&#40;</span>thunk<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">this</span>.<span class="me1">thunk</span> = thunk;
    <span class="kw1">this</span>.<span class="me1">val</span> = undefined;
  <span class="br0">&#125;</span>
&nbsp;
  force<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">this</span>.<span class="me1">thunk</span> !== <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">this</span>.<span class="me1">val</span> = <span class="kw1">this</span>.<span class="me1">thunk</span>.<span class="me1">call</span><span class="br0">&#40;</span>undefined<span class="br0">&#41;</span>;
      <span class="kw1">this</span>.<span class="me1">thunk</span> = <span class="kw2">null</span>;
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
&nbsp;
  getOwnPropertyDescriptor<span class="br0">&#40;</span>target, <span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">this</span>.<span class="me1">force</span><span class="br0">&#40;</span><span class="br0">&#41;</span>; <span class="co1">// ensure the object is initialized</span>
    <span class="co1">// forward the operation not to the dummy target, but to the</span>
    <span class="co1">// initialized object stored in this.val:</span>
    <span class="kw1">return</span> Reflect.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span><span class="kw1">this</span>.<span class="me1">val</span>, <span class="kw3">name</span><span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
This code works fine for property accesses, which are internally based on <code>getOwnPropertyDescriptor</code>. However, to our surprise, property update appears broken:
</p>
<pre class="code javascript"><span class="kw2">var</span> thunk = <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="br0">&#123;</span>foo:<span class="nu0">42</span><span class="br0">&#125;</span>; <span class="br0">&#125;</span>;
<span class="kw2">var</span> dummyTarget = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
<span class="kw2">var</span> p = LazyObject.<span class="me1">proxyFor</span><span class="br0">&#40;</span>dummyTarget, thunk<span class="br0">&#41;</span>;
&nbsp;
p.<span class="me1">foo</span> = <span class="nu0">43</span>;
p.<span class="me1">foo</span> <span class="co1">// 42 !?</span>
&nbsp;
dummyTarget.<span class="me1">foo</span> <span class="co1">// 43 !?</span></pre>
<p>
What happened? The expression <code>p.foo = 43</code> triggered the proxy&rsquo;s <code>set</code> trap. Since <code>LazyObject</code> is a subclass of <code>DelegatingHandler</code>, it inherits that handler&rsquo;s default implementation for <code>set</code>, which is defined in terms of <code>defineProperty</code>. Since <code>defineProperty</code> was not overridden by our <code>LazyObject</code> class, the default implementation is used, which is to forward to the target. Hence, the &ldquo;foo&rdquo; property will be defined on <code>dummyTarget</code> and our lazy object does not even get initialized. When we subsequently ask what the value of <code>p.foo</code> is, the proxy does initialize the object and returns <code>42</code>, because <code>getOwnPropertyDescriptor</code> was correctly overridden and reroutes the request to the initialized object.
</p>

<p>
The <code>VirtualHandler</code> exists to prevent subtle bugs such as these. <code>VirtualHandler</code> is basically a subclass of <code>DelegatingHandler</code> that overrides all fundamental traps such that they don&rsquo;t forward by default, but instead throw an error, signaling to the programmer that he or she probably forgot to override a method:
</p>
<pre class="code javascript"><span class="kw2">class</span> LazyObject <span class="kw2">extends</span> VirtualHandler <span class="br0">&#123;</span>
  <span class="co1">// as before</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw2">var</span> thunk = <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="br0">&#123;</span>foo:<span class="nu0">42</span><span class="br0">&#125;</span>; <span class="br0">&#125;</span>;
<span class="kw2">var</span> dummyTarget = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
<span class="kw2">var</span> p = LazyObject.<span class="me1">proxyFor</span><span class="br0">&#40;</span>dummyTarget, thunk<span class="br0">&#41;</span>;
&nbsp;
p.<span class="me1">foo</span> = <span class="nu0">43</span>; <span class="co1">// error: &quot;getPrototypeOf&quot;/&quot;defineProperty&quot; not implemented</span></pre>
<p>
To make the <code>LazyObject</code> abstraction work reliably, the author must override all fundamental traps and make sure they are all &ldquo;rerouted&rdquo; to the initialized object instead of the dummy target:
</p>
<pre class="code javascript"><span class="kw2">class</span> LazyObject <span class="kw2">extends</span> VirtualHandler <span class="br0">&#123;</span>
  constructor<span class="br0">&#40;</span>thunk<span class="br0">&#41;</span> <span class="br0">&#123;</span> ... <span class="br0">&#125;</span> <span class="co1">// as before</span>
  force<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> ... <span class="br0">&#125;</span> <span class="co1">// as before</span>
&nbsp;
  getOwnPropertyDescriptor<span class="br0">&#40;</span>target, <span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">this</span>.<span class="me1">force</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
    <span class="kw1">return</span> Reflect.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span><span class="kw1">this</span>.<span class="me1">val</span>, <span class="kw3">name</span><span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>
  defineProperty<span class="br0">&#40;</span>target, <span class="kw3">name</span>, desc<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">this</span>.<span class="me1">force</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
    <span class="kw1">return</span> Reflect.<span class="me1">defineProperty</span><span class="br0">&#40;</span><span class="kw1">this</span>.<span class="me1">val</span>, <span class="kw3">name</span>, desc<span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>
  getPrototypeOf<span class="br0">&#40;</span>target<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">this</span>.<span class="me1">force</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
    <span class="kw1">return</span> Reflect.<span class="me1">getPrototypeOf</span><span class="br0">&#40;</span><span class="kw1">this</span>.<span class="me1">val</span><span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>
  ... <span class="co1">// and so on for all other fundamental traps</span>
<span class="br0">&#125;</span></pre>
</div>
<!-- SECTION [12657-16283] -->
<a name="details"></a><h4>Details</h4>
<div class="level4">

<p>
 The direct proxies <acronym title="Application Programming Interface">API</acronym> is tailored at writing proxies that wrap existing target objects, and somehow augment or adapt the behavior of the wrapped object. For instance, think about a logger or an access control proxy.
</p>

<p>
Sometimes, it may be useful to define proxies that do not really wrap an existing target object, i.e. whose state is not derived from an existing JavaScript object. Think about a test mock-up object, or a promise/future/delay-like abstraction that represents a value that is not yet computed. There is no value to &ldquo;wrap&rdquo;. We call such abstractions &ldquo;virtual objects&rdquo;.
</p>

<p>
It is possible to create virtual objects using <a href="doku.php%3Fid=harmony:direct_proxies.html" class="wikilink1" title="harmony:direct_proxies" onclick="return svchk()" onkeypress="return svchk()">direct_proxies</a>, by using an empty object as the target of a proxy and by consistently overriding *all* traps so that none of them defaults to forwarding to the target. As long as the proxy does not expose non-configurable properties or becomes non-extensible, the target object will then be fully ignored (except to acquire internal properties such as [[Class]]).
</p>

<p>
The <code>VirtualHandler</code> class helps programmers to implement virtual objects because it never simply forwards an operation to the target object. In fact, it tries to ignore the target object as much as possible. It does so by overriding all fundamental traps such that they throw an error rather than forward to the target. In other words, it turns all fundamental traps into &ldquo;abstract&rdquo; operations that subclasses must implement.
</p>
<pre class="code javascript"><span class="kw2">class</span> VirtualHandler <span class="kw2">extends</span> DelegatingHandler <span class="br0">&#123;</span>
  <span class="co1">// overrides all fundamental traps and makes them abstract (throw on error)</span>
  getOwnPropertyDescriptor<span class="br0">&#40;</span>target, <span class="kw3">name</span><span class="br0">&#41;</span>;
  getOwnPropertyNames<span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
  getOwnPropertyKeys<span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
  getPrototypeOf<span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
  setPrototypeOf<span class="br0">&#40;</span>target, newProto<span class="br0">&#41;</span>;
  defineProperty<span class="br0">&#40;</span>target, <span class="kw3">name</span>, desc<span class="br0">&#41;</span>;
  deleteProperty<span class="br0">&#40;</span>target, <span class="kw3">name</span><span class="br0">&#41;</span>;
  preventExtensions<span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
  isExtensible<span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
  apply<span class="br0">&#40;</span>target, thisBinding, args<span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre>
</div>
<!-- SECTION [16284-18224] -->
<a name="why_isn_t_this_just_a_javascript_library"></a><h3>Why isn't this just a JavaScript library?</h3>
<div class="level3">

<p>
 All three handler classes can be implemented entirely in JavaScript itself without magic (as we demonstrate below by providing a non-normative self-hosted implementation).
</p>

<p>
By providing these APIs as part of the spec however, we can update these APIs in sync with the Proxy <acronym title="Application Programming Interface">API</acronym> in future editions of the language. If a later edition of ECMAScript supports a new operation on objects and proxies (e.g. <code>Object.observe</code> is slated for inclusion in ES7), then we will add a sensible default implementation to the <code>DelegatingHandler</code> class. If your proxy handler inherits from the <code>DelegatingHandler</code> class, it will automatically benefit from this sensible default implementation.
</p>

</div>
<!-- SECTION [18225-18960] -->
<a name="non-normative_implementation"></a><h2>Non-normative implementation</h2>
<div class="level2">

<p>
 Below are non-normative self-hosted implementations of all three handler classes. Any references to methods defined on <code>Object</code>, <code>Function.prototype</code> or <code>Array.prototype</code> are assumed to refer to the built-in implementations). The function <code>normalizeAndCompletePropertyDescriptor</code> is defined <a href="doku.php%3Fid=harmony:proxies_semantics.html#utilities" class="wikilink1" title="harmony:proxies_semantics" onclick="return svchk()" onkeypress="return svchk()">here</a>.
</p>

</div>
<!-- SECTION [18961-19348] -->
<a name="delegatinghandler"></a><h4>DelegatingHandler</h4>
<div class="level4">
<pre class="code javascript"><span class="kw2">function</span> <span class="kw3">forward</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">return</span> <span class="kw2">function</span><span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> Reflect<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span><span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="kw2">function</span> DelegatingHandler<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="br0">&#125;</span>;
DelegatingHandler.<span class="me1">proxyFor</span> = <span class="kw2">function</span><span class="br0">&#40;</span>target,...<span class="me1">args</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">return</span> <span class="kw2">new</span> Proxy<span class="br0">&#40;</span>target, <span class="kw2">new</span> <span class="kw1">this</span><span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
<span class="br0">&#125;</span>;
DelegatingHandler.<span class="me1">revocableProxyFor</span> = <span class="kw2">function</span><span class="br0">&#40;</span>target,...<span class="me1">args</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">return</span> Proxy.<span class="me1">revocable</span><span class="br0">&#40;</span>target, <span class="kw2">new</span> <span class="kw1">this</span><span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
<span class="br0">&#125;</span>;
&nbsp;
DelegatingHandler.<span class="me1">prototype</span> = <span class="br0">&#123;</span>
  <span class="co1">// fundamental traps</span>
  getOwnPropertyDescriptor: <span class="kw3">forward</span><span class="br0">&#40;</span><span class="st0">"getOwnPropertyDescriptor"</span><span class="br0">&#41;</span>,
  getOwnPropertyNames:      <span class="kw3">forward</span><span class="br0">&#40;</span><span class="st0">"getOwnPropertyNames"</span><span class="br0">&#41;</span>,
  getOwnPropertyKeys:       <span class="kw3">forward</span><span class="br0">&#40;</span><span class="st0">"getOwnPropertyKeys"</span><span class="br0">&#41;</span>,
  getPrototypeOf:           <span class="kw3">forward</span><span class="br0">&#40;</span><span class="st0">"getPrototypeOf"</span><span class="br0">&#41;</span>,
  setPrototypeOf:           <span class="kw3">forward</span><span class="br0">&#40;</span><span class="st0">"setPrototypeOf"</span><span class="br0">&#41;</span>,
  defineProperty:           <span class="kw3">forward</span><span class="br0">&#40;</span><span class="st0">"defineProperty"</span><span class="br0">&#41;</span>,
  deleteProperty:           <span class="kw3">forward</span><span class="br0">&#40;</span><span class="st0">"deleteProperty"</span><span class="br0">&#41;</span>,
  preventExtensions:        <span class="kw3">forward</span><span class="br0">&#40;</span><span class="st0">"preventExtensions"</span><span class="br0">&#41;</span>,
  apply:                    <span class="kw3">forward</span><span class="br0">&#40;</span><span class="st0">"apply"</span><span class="br0">&#41;</span>,
&nbsp;
  <span class="co1">// derived traps</span>
  has: <span class="kw2">function</span><span class="br0">&#40;</span>target, <span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> desc = <span class="kw1">this</span>.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>target, <span class="kw3">name</span><span class="br0">&#41;</span>;
    desc = normalizeAndCompletePropertyDescriptor<span class="br0">&#40;</span>desc<span class="br0">&#41;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>desc !== undefined<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> <span class="kw2">true</span>;
    <span class="br0">&#125;</span>
    <span class="kw2">var</span> proto = <span class="kw1">this</span>.<span class="me1">getPrototypeOf</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>proto === <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> <span class="kw2">false</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> Reflect.<span class="me1">has</span><span class="br0">&#40;</span>proto, <span class="kw3">name</span><span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>,
  hasOwn: <span class="kw2">function</span><span class="br0">&#40;</span>target,<span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> desc = <span class="kw1">this</span>.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>target,<span class="kw3">name</span><span class="br0">&#41;</span>;
    desc = normalizeAndCompletePropertyDescriptor<span class="br0">&#40;</span>desc<span class="br0">&#41;</span>;
    <span class="kw1">return</span> desc !== undefined;
  <span class="br0">&#125;</span>,
  get: <span class="kw2">function</span><span class="br0">&#40;</span>target, <span class="kw3">name</span>, receiver<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> desc = <span class="kw1">this</span>.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>target, <span class="kw3">name</span><span class="br0">&#41;</span>;
    desc = normalizeAndCompletePropertyDescriptor<span class="br0">&#40;</span>desc<span class="br0">&#41;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>desc === undefined<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">var</span> proto = <span class="kw1">this</span>.<span class="me1">getPrototypeOf</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
      <span class="kw1">if</span> <span class="br0">&#40;</span>proto === <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> undefined;
      <span class="br0">&#125;</span>
      <span class="kw1">return</span> Reflect.<span class="me1">get</span><span class="br0">&#40;</span>proto, <span class="kw3">name</span>, receiver<span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>isDataDescriptor<span class="br0">&#40;</span>desc<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> desc.<span class="me1">value</span>;
    <span class="br0">&#125;</span>
    <span class="kw2">var</span> getter = desc.<span class="me1">get</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>getter === undefined<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> undefined;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> desc.<span class="me1">get</span>.<span class="me1">call</span><span class="br0">&#40;</span>receiver<span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>,
  set: <span class="kw2">function</span><span class="br0">&#40;</span>target, <span class="kw3">name</span>, value, receiver<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> ownDesc = <span class="kw1">this</span>.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>target, <span class="kw3">name</span><span class="br0">&#41;</span>;
    ownDesc = normalizeAndCompletePropertyDescriptor<span class="br0">&#40;</span>ownDesc<span class="br0">&#41;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>isDataDescriptor<span class="br0">&#40;</span>ownDesc<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>!ownDesc.<span class="me1">writable</span><span class="br0">&#41;</span> <span class="kw1">return</span> <span class="kw2">false</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>isAccessorDescriptor<span class="br0">&#40;</span>ownDesc<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span><span class="br0">&#40;</span>ownDesc.<span class="me1">set</span> === undefined<span class="br0">&#41;</span> <span class="kw1">return</span> <span class="kw2">false</span>;
      ownDesc.<span class="me1">set</span>.<span class="me1">call</span><span class="br0">&#40;</span>receiver, value<span class="br0">&#41;</span>;
      <span class="kw1">return</span> <span class="kw2">true</span>;
    <span class="br0">&#125;</span>
    <span class="kw2">var</span> proto = <span class="kw1">this</span>.<span class="me1">getPrototypeOf</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>proto === <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">var</span> receiverDesc = Object.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>receiver, <span class="kw3">name</span><span class="br0">&#41;</span>;
      <span class="kw1">if</span> <span class="br0">&#40;</span>isAccessorDescriptor<span class="br0">&#40;</span>receiverDesc<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">if</span><span class="br0">&#40;</span>receiverDesc.<span class="me1">set</span> === undefined<span class="br0">&#41;</span> <span class="kw1">return</span> <span class="kw2">false</span>;
        receiverDesc.<span class="me1">set</span>.<span class="me1">call</span><span class="br0">&#40;</span>receiver, value<span class="br0">&#41;</span>;
        <span class="kw1">return</span> <span class="kw2">true</span>;
      <span class="br0">&#125;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>isDataDescriptor<span class="br0">&#40;</span>receiverDesc<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>!receiverDesc.<span class="me1">writable</span><span class="br0">&#41;</span> <span class="kw1">return</span> <span class="kw2">false</span>;
        Object.<span class="me1">defineProperty</span><span class="br0">&#40;</span>receiver, <span class="kw3">name</span>, <span class="br0">&#123;</span>value: value<span class="br0">&#125;</span><span class="br0">&#41;</span>;
        <span class="kw1">return</span> <span class="kw2">true</span>;
      <span class="br0">&#125;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>!Object.<span class="me1">isExtensible</span><span class="br0">&#40;</span>receiver<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="kw1">return</span> <span class="kw2">false</span>;
      Object.<span class="me1">defineProperty</span><span class="br0">&#40;</span>receiver, <span class="kw3">name</span>,
        <span class="br0">&#123;</span> value: value,
          writable: <span class="kw2">true</span>,
          enumerable: <span class="kw2">true</span>,
          configurable: <span class="kw2">true</span> <span class="br0">&#125;</span><span class="br0">&#41;</span>;
      <span class="kw1">return</span> <span class="kw2">true</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> Reflect.<span class="me1">set</span><span class="br0">&#40;</span>proto, <span class="kw3">name</span>, value, receiver<span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>,
  invoke: <span class="kw2">function</span><span class="br0">&#40;</span>target, <span class="kw3">name</span>, args, receiver<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> callable = <span class="kw1">this</span>.<span class="me1">get</span><span class="br0">&#40;</span>target, <span class="kw3">name</span>, receiver<span class="br0">&#41;</span>;
    <span class="kw1">return</span> <span class="kw2">Function</span>.<span class="me1">prototype</span>.<span class="me1">apply</span>.<span class="me1">call</span><span class="br0">&#40;</span>callable, receiver, args<span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>,
  enumerate: <span class="kw2">function</span>* <span class="br0">&#40;</span>target<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> trapResult = <span class="kw1">this</span>.<span class="me1">getOwnPropertyNames</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
    <span class="kw2">var</span> l = +trapResult.<span class="me1">length</span>;
    <span class="kw2">var</span> result = <span class="br0">&#91;</span><span class="br0">&#93;</span>;
    <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> i = <span class="nu0">0</span>; i &lt; l; i++<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">var</span> <span class="kw3">name</span> = String<span class="br0">&#40;</span>trapResult<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span>;
      <span class="kw2">var</span> desc = <span class="kw1">this</span>.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span>;
      desc = normalizeAndCompletePropertyDescriptor<span class="br0">&#40;</span>desc<span class="br0">&#41;</span>;
      <span class="kw1">if</span> <span class="br0">&#40;</span>desc !== undefined &amp;&amp; desc.<span class="me1">enumerable</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        yield <span class="kw3">name</span>;
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
    <span class="kw2">var</span> proto = <span class="kw1">this</span>.<span class="me1">getPrototypeOf</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>proto === <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span>;
    <span class="br0">&#125;</span>
    yield* Reflect.<span class="me1">enumerate</span><span class="br0">&#40;</span>proto<span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>,
  keys: <span class="kw2">function</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> trapResult = <span class="kw1">this</span>.<span class="me1">getOwnPropertyNames</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
    <span class="kw2">var</span> l = +trapResult.<span class="me1">length</span>;
    <span class="kw2">var</span> result = <span class="br0">&#91;</span><span class="br0">&#93;</span>;
    <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> i = <span class="nu0">0</span>; i &lt; l; i++<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">var</span> <span class="kw3">name</span> = String<span class="br0">&#40;</span>trapResult<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span>;
      <span class="kw2">var</span> desc = <span class="kw1">this</span>.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span>;
      desc = normalizeAndCompletePropertyDescriptor<span class="br0">&#40;</span>desc<span class="br0">&#41;</span>;
      <span class="kw1">if</span> <span class="br0">&#40;</span>desc !== undefined &amp;&amp; desc.<span class="me1">enumerable</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        result.<span class="me1">push</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> result;
  <span class="br0">&#125;</span>,
  construct: <span class="kw2">function</span><span class="br0">&#40;</span>target, args<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> proto = <span class="kw1">this</span>.<span class="me1">get</span><span class="br0">&#40;</span>target, <span class="st0">'prototype'</span>, target<span class="br0">&#41;</span>;
    <span class="kw2">var</span> instance;
    <span class="kw1">if</span> <span class="br0">&#40;</span>Object<span class="br0">&#40;</span>proto<span class="br0">&#41;</span> === proto<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      instance = Object.<span class="me1">create</span><span class="br0">&#40;</span>proto<span class="br0">&#41;</span>;        
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
      instance = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
    <span class="br0">&#125;</span>
    <span class="kw2">var</span> res = <span class="kw1">this</span>.<span class="me1">apply</span><span class="br0">&#40;</span>target, instance, args<span class="br0">&#41;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>Object<span class="br0">&#40;</span>res<span class="br0">&#41;</span> === res<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> res;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> instance;
  <span class="br0">&#125;</span>,
&nbsp;
  <span class="co1">// deprecated traps:</span>
&nbsp;
  seal: <span class="kw2">function</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> success = <span class="kw1">this</span>.<span class="me1">preventExtensions</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
    success = !!success; <span class="co1">// coerce to Boolean</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>success<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">var</span> props = <span class="kw1">this</span>.<span class="me1">getOwnPropertyNames</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
      <span class="kw2">var</span> l = +props.<span class="me1">length</span>;
      <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> i = <span class="nu0">0</span>; i &lt; l; i++<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw2">var</span> <span class="kw3">name</span> = props<span class="br0">&#91;</span>i<span class="br0">&#93;</span>;
        success = success &amp;&amp; <span class="kw1">this</span>.<span class="me1">defineProperty</span><span class="br0">&#40;</span>target,<span class="kw3">name</span>,<span class="br0">&#123;</span>configurable:<span class="kw2">false</span><span class="br0">&#125;</span><span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> success;
  <span class="br0">&#125;</span>,
  freeze: <span class="kw2">function</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> success = <span class="kw1">this</span>.<span class="me1">preventExtensions</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
    success = !!success; <span class="co1">// coerce to Boolean</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>success<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">var</span> props = <span class="kw1">this</span>.<span class="me1">getOwnPropertyNames</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
      <span class="kw2">var</span> l = +props.<span class="me1">length</span>;
      <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> i = <span class="nu0">0</span>; i &lt; l; i++<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw2">var</span> <span class="kw3">name</span> = props<span class="br0">&#91;</span>i<span class="br0">&#93;</span>;
        <span class="kw2">var</span> desc = <span class="kw1">this</span>.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>target,<span class="kw3">name</span><span class="br0">&#41;</span>;
        desc = normalizeAndCompletePropertyDescriptor<span class="br0">&#40;</span>desc<span class="br0">&#41;</span>;
        <span class="kw1">if</span> <span class="br0">&#40;</span>IsAccessorDescriptor<span class="br0">&#40;</span>desc<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
          success = success &amp;&amp;
            <span class="kw1">this</span>.<span class="me1">defineProperty</span><span class="br0">&#40;</span>target,<span class="kw3">name</span>,<span class="br0">&#123;</span>writable:<span class="kw2">false</span>,configurable:<span class="kw2">false</span><span class="br0">&#125;</span><span class="br0">&#41;</span>;
        <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>desc !== undefined<span class="br0">&#41;</span> <span class="br0">&#123;</span>
          success = success &amp;&amp;
            <span class="kw1">this</span>.<span class="me1">defineProperty</span><span class="br0">&#40;</span>target,<span class="kw3">name</span>,<span class="br0">&#123;</span>configurable:<span class="kw2">false</span><span class="br0">&#125;</span><span class="br0">&#41;</span>;
        <span class="br0">&#125;</span>
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> success;
  <span class="br0">&#125;</span>,
  isSealed: <span class="kw2">function</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">this</span>.<span class="me1">isExtensible</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> <span class="kw2">false</span>;
    <span class="br0">&#125;</span>
    <span class="kw2">var</span> props = <span class="kw1">this</span>.<span class="me1">getOwnPropertyNames</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
    <span class="kw1">return</span> props.<span class="me1">every</span><span class="br0">&#40;</span><span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> !<span class="kw1">this</span>.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>target,<span class="kw3">name</span><span class="br0">&#41;</span>.<span class="me1">configurable</span>;
    <span class="br0">&#125;</span>, <span class="kw1">this</span><span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>,
  isFrozen: <span class="kw2">function</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">this</span>.<span class="me1">isExtensible</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> <span class="kw2">false</span>;
    <span class="br0">&#125;</span>
    <span class="kw2">var</span> props = <span class="kw1">this</span>.<span class="me1">getOwnPropertyNames</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
    <span class="kw1">return</span> props.<span class="me1">every</span><span class="br0">&#40;</span><span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">var</span> desc = <span class="kw1">this</span>.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>target,<span class="kw3">name</span><span class="br0">&#41;</span>;
      <span class="kw1">return</span> !desc.<span class="me1">configurable</span> &amp;&amp; <span class="br0">&#40;</span><span class="st0">"writable"</span> <span class="kw1">in</span> desc ? !desc.<span class="me1">writable</span> : <span class="kw2">true</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>, <span class="kw1">this</span><span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>,
<span class="br0">&#125;</span></pre>
</div>
<!-- SECTION [19349-26002] -->
<a name="forwardinghandler"></a><h4>ForwardingHandler</h4>
<div class="level4">

<p>
 The <code>ForwardingHandler</code> overrides <code>get</code>, <code>set</code> and <code>invoke</code> to ignore the <code>receiver</code> argument, instead always passing <code>target</code> as the <code>this</code>-binding:
</p>
<pre class="code javascript"><span class="kw2">function</span> ForwardingHandler<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  DelegatingHandler.<span class="me1">call</span><span class="br0">&#40;</span><span class="kw1">this</span><span class="br0">&#41;</span>; <span class="co1">// not strictly necessary</span>
<span class="br0">&#125;</span>
ForwardingHandler.<span class="me1">prototype</span> = Object.<span class="me1">create</span><span class="br0">&#40;</span>DelegatingHandler.<span class="me1">prototype</span><span class="br0">&#41;</span>;
ForwardingHandler.<span class="me1">prototype</span>.<span class="me1">get</span> = <span class="kw2">function</span><span class="br0">&#40;</span>target, <span class="kw3">name</span>, receiver<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw2">var</span> desc = <span class="kw1">this</span>.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>target, <span class="kw3">name</span><span class="br0">&#41;</span>;
  desc = normalizeAndCompletePropertyDescriptor<span class="br0">&#40;</span>desc<span class="br0">&#41;</span>;
  <span class="kw1">if</span> <span class="br0">&#40;</span>desc === undefined<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> proto = <span class="kw1">this</span>.<span class="me1">getPrototypeOf</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>proto === <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> undefined;
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> Reflect.<span class="me1">get</span><span class="br0">&#40;</span>proto, <span class="kw3">name</span>, receiver<span class="br0">&#41;</span>; <span class="co1">// leave receiver unchanged for proto-climbing</span>
  <span class="br0">&#125;</span>
  <span class="kw1">if</span> <span class="br0">&#40;</span>isDataDescriptor<span class="br0">&#40;</span>desc<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> desc.<span class="me1">value</span>;
  <span class="br0">&#125;</span>
  <span class="kw2">var</span> getter = desc.<span class="me1">get</span>;
  <span class="kw1">if</span> <span class="br0">&#40;</span>getter === undefined<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> undefined;
  <span class="br0">&#125;</span>
  <span class="kw1">return</span> desc.<span class="me1">get</span>.<span class="me1">call</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span>; <span class="co1">// note: target instead of receiver</span>
<span class="br0">&#125;</span>;
ForwardingHandler.<span class="me1">prototype</span>.<span class="me1">set</span> = <span class="kw2">function</span><span class="br0">&#40;</span>target, <span class="kw3">name</span>, value, receiver<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw2">var</span> ownDesc = <span class="kw1">this</span>.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>target, <span class="kw3">name</span><span class="br0">&#41;</span>;
  ownDesc = normalizeAndCompletePropertyDescriptor<span class="br0">&#40;</span>ownDesc<span class="br0">&#41;</span>;
  <span class="kw1">if</span> <span class="br0">&#40;</span>isDataDescriptor<span class="br0">&#40;</span>ownDesc<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>!ownDesc.<span class="me1">writable</span><span class="br0">&#41;</span> <span class="kw1">return</span> <span class="kw2">false</span>;
  <span class="br0">&#125;</span>
  <span class="kw1">if</span> <span class="br0">&#40;</span>isAccessorDescriptor<span class="br0">&#40;</span>ownDesc<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">if</span><span class="br0">&#40;</span>ownDesc.<span class="me1">set</span> === undefined<span class="br0">&#41;</span> <span class="kw1">return</span> <span class="kw2">false</span>;
    ownDesc.<span class="me1">set</span>.<span class="me1">call</span><span class="br0">&#40;</span>target, value<span class="br0">&#41;</span>; <span class="co1">// note: target instead of receiver</span>
    <span class="kw1">return</span> <span class="kw2">true</span>;
  <span class="br0">&#125;</span>
  <span class="kw2">var</span> proto = <span class="kw1">this</span>.<span class="me1">getPrototypeOf</span><span class="br0">&#40;</span>target<span class="br0">&#41;</span>;
  <span class="kw1">if</span> <span class="br0">&#40;</span>proto === <span class="kw2">null</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> receiverDesc = Object.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>receiver, <span class="kw3">name</span><span class="br0">&#41;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>isAccessorDescriptor<span class="br0">&#40;</span>receiverDesc<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span><span class="br0">&#40;</span>receiverDesc.<span class="me1">set</span> === undefined<span class="br0">&#41;</span> <span class="kw1">return</span> <span class="kw2">false</span>;
      receiverDesc.<span class="me1">set</span>.<span class="me1">call</span><span class="br0">&#40;</span>target, value<span class="br0">&#41;</span>; <span class="co1">// note: target instead of receiver</span>
      <span class="kw1">return</span> <span class="kw2">true</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>isDataDescriptor<span class="br0">&#40;</span>receiverDesc<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>!receiverDesc.<span class="me1">writable</span><span class="br0">&#41;</span> <span class="kw1">return</span> <span class="kw2">false</span>;
      Object.<span class="me1">defineProperty</span><span class="br0">&#40;</span>receiver, <span class="kw3">name</span>, <span class="br0">&#123;</span>value: value<span class="br0">&#125;</span><span class="br0">&#41;</span>;
      <span class="kw1">return</span> <span class="kw2">true</span>;
    <span class="br0">&#125;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>!Object.<span class="me1">isExtensible</span><span class="br0">&#40;</span>receiver<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="kw1">return</span> <span class="kw2">false</span>;
    Object.<span class="me1">defineProperty</span><span class="br0">&#40;</span>receiver, <span class="kw3">name</span>,
      <span class="br0">&#123;</span> value: value,
        writable: <span class="kw2">true</span>,
        enumerable: <span class="kw2">true</span>,
        configurable: <span class="kw2">true</span> <span class="br0">&#125;</span><span class="br0">&#41;</span>;
    <span class="kw1">return</span> <span class="kw2">true</span>;
  <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> Reflect.<span class="me1">set</span><span class="br0">&#40;</span>proto, <span class="kw3">name</span>, value, receiver<span class="br0">&#41;</span>; <span class="co1">// note: leave receiver unmodified for proto lookup</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span>;
ForwardingHandler.<span class="me1">prototype</span>.<span class="me1">invoke</span> = <span class="kw2">function</span><span class="br0">&#40;</span>target, <span class="kw3">name</span>, args, receiver<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw2">var</span> callable = <span class="kw1">this</span>.<span class="me1">get</span><span class="br0">&#40;</span>target, <span class="kw3">name</span>, receiver<span class="br0">&#41;</span>;
  <span class="kw1">return</span> <span class="kw2">Function</span>.<span class="me1">prototype</span>.<span class="me1">apply</span>.<span class="me1">call</span><span class="br0">&#40;</span>callable, target, args<span class="br0">&#41;</span>;
<span class="br0">&#125;</span>;</pre>
</div>
<!-- SECTION [26003-28522] -->
<a name="virtualhandler"></a><h4>VirtualHandler</h4>
<div class="level4">

<p>
 The <code>VirtualHandler</code> overrides all fundamental traps so that they don&rsquo;t forward to the <code>target</code> object anymore. Since there is no other sensible default behavior, the traps simply throw an error. Hence, think of these traps as &ldquo;abstract&rdquo; methods that must be overridden by subclasses.
</p>
<pre class="code javascript"><span class="kw2">function</span> abstract<span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">return</span> <span class="kw2">function</span><span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">throw</span> <span class="kw2">new</span> TypeError<span class="br0">&#40;</span><span class="kw3">name</span> + <span class="st0">" not implemented"</span><span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>;
<span class="br0">&#125;</span>
<span class="kw2">function</span> VirtualHandler<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  DelegatingHandler.<span class="me1">call</span><span class="br0">&#40;</span><span class="kw1">this</span><span class="br0">&#41;</span>; <span class="co1">// not strictly necessary</span>
<span class="br0">&#125;</span>
VirtualHandler.<span class="me1">prototype</span> = <span class="br0">&#123;</span>
  __proto__: DelegatingHandler.<span class="me1">prototype</span>,
  getOwnPropertyDescriptor: abstract<span class="br0">&#40;</span><span class="st0">"getOwnPropertyDescriptor"</span><span class="br0">&#41;</span>,
  getOwnPropertyNames:      abstract<span class="br0">&#40;</span><span class="st0">"getOwnPropertyNames"</span><span class="br0">&#41;</span>,
  getOwnPropertyKeys:       abstract<span class="br0">&#40;</span><span class="st0">"getOwnPropertyKeys"</span><span class="br0">&#41;</span>,
  getPrototypeOf:           abstract<span class="br0">&#40;</span><span class="st0">"getPrototypeOf"</span><span class="br0">&#41;</span>,
  setPrototypeOf:           abstract<span class="br0">&#40;</span><span class="st0">"setPrototypeOf"</span><span class="br0">&#41;</span>,
  defineProperty:           abstract<span class="br0">&#40;</span><span class="st0">"defineProperty"</span><span class="br0">&#41;</span>,
  deleteProperty:           abstract<span class="br0">&#40;</span><span class="st0">"deleteProperty"</span><span class="br0">&#41;</span>,
  preventExtensions:        abstract<span class="br0">&#40;</span><span class="st0">"preventExtensions"</span><span class="br0">&#41;</span>,
  apply:                    abstract<span class="br0">&#40;</span><span class="st0">"apply"</span><span class="br0">&#41;</span>
<span class="br0">&#125;</span>;</pre>
</div>
<!-- SECTION [28523-29655] -->
<a name="prototype_implementations"></a><h2>Prototype implementations</h2>
<div class="level2">

<p>
 All the code and examples on this wiki were tested using <a href="https://github.com/tvcutsem/harmony-reflect" class="urlextern" target="_blank" title="https://github.com/tvcutsem/harmony-reflect" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">reflect.js</a>. A prototype <a href="https://github.com/tvcutsem/harmony-reflect/blob/master/handlers.js" class="urlextern" target="_blank" title="https://github.com/tvcutsem/harmony-reflect/blob/master/handlers.js" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">implementation</a> is available, as well as a <a href="https://github.com/tvcutsem/harmony-reflect/blob/master/test/testHandlers.js" class="urlextern" target="_blank" title="https://github.com/tvcutsem/harmony-reflect/blob/master/test/testHandlers.js" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">test suite</a> covering the examples.
</p>

</div>
<!-- SECTION [29656-30053] -->
<a name="history"></a><h2>History</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Originally the <code>DelegatingHandler</code> was called <code>VirtualHandler</code> and it was the only of three proposed handler classes. The fundamental traps of the <code>VirtualHandler</code> were &ldquo;abstract&rdquo; methods that threw an exception when called. At the July &lsquo;12 TC39 Meeting TomVC proposed to change the fundamental traps into forwarding methods, the advantage being that &ldquo;subclasses&rdquo; can then just override those fundamental traps they are interested in. All derived traps will then use the overridden version. Non-overridden fundamental traps keep doing the same thing as on a normal handler that doesn&rsquo;t inherit from <code>Handler.prototype</code>.</div>
</li>
<li class="level1"><div class="li"> <code>VirtualHandler</code> was then renamed to just <code>Handler</code>.</div>
</li>
<li class="level1"><div class="li"> At the May &lsquo;13 TC39 meeting it was decided to add an additional handler class to deal with the problem of <code>this</code>-binding when wrapping objects with private state (such as in the <code>Date</code> example above). TomVC and AllenWB eventually came up with the hierarchy proposed on the current page (DelegatingHandler, ForwardingHandler, VirtualHandler).</div>
</li>
</ul>

</div>
<!-- SECTION [30054-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/1/18f48b4c126c68f56d4637e62df3c314.xhtml used -->
</body>
</html>
