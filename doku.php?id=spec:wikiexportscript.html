<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
 lang="en" dir="ltr">
<head>
  <title>spec:wikiexportscript [ES Wiki]</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=spec:wikiexportscript&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="http://wiki.ecmascript.org/feed.php?mode=list&amp;ns=spec" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=spec:wikiexportscript&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=spec:wikiexportscript&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="date" content="2007-06-25T20:10:40+0000" />
  <meta name="robots" content="index,follow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />

  <link rel="shortcut icon" href="lib/images/favicon.ico" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/tpl/default/layout.css" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/tpl/default/design.css" />

  
  <link rel="stylesheet" media="print" type="text/css" href="lib/tpl/default/print.css" />

  <!--[if gte IE 5]>
  <style type="text/css">
    /* that IE 5+ conditional comment makes this only visible in IE 5+ */
    /* IE bugfix for transparent PNGs */
    //DISABLED   img { behavior: url("/lib/scripts/pngbehavior.htc"); }
  </style>
  <![endif]-->

  </head>

<body>
<div class="dokuwiki">
  
  <div class="stylehead">

    <div class="header">
      <div class="pagename">
        [[<a href="doku.php%3Fid=spec:wikiexportscript&amp;do=backlink.html" onclick="return svchk()" onkeypress="return svchk()">spec:wikiexportscript</a>]]
      </div>
      <div class="logo">
        <a href="doku.php%3Fid=.html" onclick="return svchk()" onkeypress="return svchk()" name="top" accesskey="h" title="[ALT+H]">ES Wiki</a>      </div>
    </div>
  
    
    <div class="bar" id="bar_top">
      <div class="bar-left" id="bar_topleft">
        <form class="button" method="post" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="edit" /><input type="hidden" name="rev" value="" /><input type="hidden" name="id" value="spec:wikiexportscript" /><input type="submit" value="Show pagesource" class="button" title="ALT+V" accesskey="v" /></form>        <form class="button" method="get" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="revisions" /><input type="hidden" name="id" value="spec:wikiexportscript" /><input type="submit" value="Old revisions" class="button" title="ALT+O" accesskey="o" /></form>      </div>
  
      <div class="bar-right" id="bar_topright">
        <form class="button" method="get" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="recent" /><input type="hidden" name="id" value="" /><input type="submit" value="Recent changes" class="button" title="ALT+R" accesskey="r" /></form>        <form action="doku.php%3Fid=.html" accept-charset="utf-8" class="search" name="search" onsubmit="return svchk()"><input type="hidden" name="do" value="search" /><input type="text" id="qsearch_in" accesskey="f" name="id" class="edit" onkeyup="ajax_qsearch.call('qsearch_in','qsearch_out')" /><input type="submit" value="Search" class="button" /><div id="qsearch_out" class="ajax_qsearch" onclick="this.style.display='none'"></div></form>&nbsp;
      </div>
    </div>

        <div class="breadcrumbs">
      Trace: <span class="bcsep">&raquo;</span> <a href="doku.php%3Fid=proposals:bound_this.html" onclick="return svchk()" onkeypress="return svchk()" class="breadcrumbs" title="proposals:bound_this">bound_this</a> <span class="bcsep">&raquo;</span> <a href="doku.php%3Fid=proposals:self_type.html" onclick="return svchk()" onkeypress="return svchk()" class="breadcrumbs" title="proposals:self_type">self_type</a> <span class="bcsep">&raquo;</span> <a href="doku.php%3Fid=proposals:oopkoolaid.html" onclick="return svchk()" onkeypress="return svchk()" class="breadcrumbs" title="proposals:oopkoolaid">oopkoolaid</a> <span class="bcsep">&raquo;</span> <a href="doku.php%3Fid=proposals:operators.html" onclick="return svchk()" onkeypress="return svchk()" class="breadcrumbs" title="proposals:operators">operators</a> <span class="bcsep">&raquo;</span> <span class="curid"><a href="doku.php%3Fid=spec:wikiexportscript.html" onclick="return svchk()" onkeypress="return svchk()" class="breadcrumbs" title="spec:wikiexportscript">wikiexportscript</a></span>          </div>
    
  </div>
  
  
  <div class="page">
    <!-- wikipage start -->
    
<p>
DO NOT EXPORT
</p>
<pre class="file">

#====================================================================
# Name: ExportES4Wiki.pl
#
# Purpose: Grabs Wiki HTML and creates MS-Word compatible HTML file
#
# Author: Francis Cheng
# Date: October 2006
#
# Script notes: This script runs on Perl 5.8 (ActiveState installation)
# and requires the following modules (which can be installed using 
# Perl Package Manager):
# -&gt; ppm install WWW::Mechanize
# -&gt; ppm install http://theoryx5.uwinnipeg.ca/ppms/Net_SSLeay.pm.ppd
# -&gt; ppm install http://theoryx5.uwinnipeg.ca/ppms/IO-Socket-SSL.ppd
# -&gt; ppm install http://theoryx5.uwinnipeg.ca/ppms/Crypt-SSLeay.ppd
# -&gt; ppm install spreadsheet-parseexcel
# -&gt; ppm install OLE::Storage_Lite
# -&gt; ppm install IO::Scalar
#
# If you have problems with the DLLs needed by the SSL modules, download
# and install the latest openSSL installer (for Windows):
# http://www.openssl.org/related/binaries.html

use strict;
use warnings;
use WWW::Mechanize;  # for scraping wiki html
use HTTP::Cookies;
use HTML::Form;      # for LoginToWiki()
use Spreadsheet::ParseExcel; # for parsing grammar.xls file


# === CONFIGURATION SECTION ====
my $baseURL = 'https://intranet.mozilla.org';
my $url = $baseURL . '/ECMA/wiki/doku.php?do=login&amp;id=start';
my $grammarFile = 'grammar.xls';
my $smlSourceDir = '';  # command line arg ($ARGV[2])
my @smlFiles = (&quot;defn.sml&quot;, &quot;verify.sml&quot;, &quot;eval.sml&quot;);
my @funcList = ();
our ($mech, %grammar, @grammarList, $username, $password, %smlHash);  # globals

# === Read in command line arguments
if ($ARGV[0] ne &quot;&quot;) {
  $username = $ARGV[0];
}
else {
  print &quot;ERROR: You must specify a username for the wiki.\n&quot;;
  exit(0);
}

if ($ARGV[1] ne &quot;&quot;) {
  $password = $ARGV[1];
}
else {
  print &quot;ERROR: You must specify a password for the wiki.\n&quot;;
  exit(0);
}

if ($ARGV[2] ne &quot;&quot;) {
  $smlSourceDir = $ARGV[2];
}
else {
  print &quot;ERROR: You must specify the sml source directory path.\n&quot;;
  exit(0);
}


# === Create the Mechanize object for web crawling ===
$mech = WWW::Mechanize-&gt;new();
$mech-&gt;cookie_jar(HTTP::Cookies-&gt;new());
$mech-&gt;get($url);

ParseGrammar($smlSourceDir, $grammarFile);

PrintGrammarToFile();

CreateSMLHash();

PrintSMLHash();

LoginToWiki();

GetWikiText();

ParseWikiText();


# =========== SUBROUTINES ==============


# ===============
# Subroutine ParseGrammar
# Purpose: Parse Grammar.xls and place grammar into data structures that will
# be merged with wiki source
# Data Structures:
# 1. The grammar is stored in a single hash.
# Each hashkey is the &quot;left-hand side&quot; (lhs) of a production rule in the
# surface syntax and points to a list of values:
# $lhsContent =&gt; [ numSurfaceSyntaxElements,
#                  [listOfrhsSurfaceSyntaxElements],
#                  [listOfAbstractSyntaxElements] ]
#
# Where [listOfrhsSurfaceSyntaxElements] is a list that includes each element on
# the right-hand side (rhs) of the production, and where
# [listOfAbstractSyntaxElements] is a list that includes all of the absract
# syntax elements. These lists do not retain their individuality in the hash.
# In other words, the arrays are assigned to the hash by value, not by
# reference, so the contents of each array is appended to the list. However,
# you can use the first element of the array as an offset for the beginning
# of the abstract syntax elements.
#
# 2. A separate list tracks the order in which each hashkey appears so
# that the order can be reproduced for reproduction of the entire grammar.
# The list variable is named $grammarList
#
# ================
sub ParseGrammar {
   my ($grammarPath, $grammarFileName) = @_;
   my $grammarXLS = $grammarPath . '/doc/' . $grammarFileName;
   my $myBook = Spreadsheet::ParseExcel::Workbook-&gt;Parse($grammarXLS);
   my $ES4Worksheet = $myBook-&gt;Worksheet('ES4');
   my $maxRow = $ES4Worksheet-&gt;{MaxRow};
   my @lexemes = ();  # array to hold list of lexemes

   my $iCol = 7;  # initial value of $iCol is 7 (column H in the spreadsheet)
   %grammar = (); # hash to hold contents of grammar (must be global)
   my @noAbstractSyntax = ();  # track entries without Abstract Syntax
   my @missingAbstractSyntax = (); # entries with missing Abstract Syntax
   for (my $iRow = 1; $iRow &lt;= $maxRow; $iRow++) {
       my $cell = $ES4Worksheet-&gt;{Cells}[$iRow][$iCol];

       # if $cell is defined and a value exists, there is valid lhs content.
       # Otherwise move on to next iteration of the for loop.
       if ( $cell &amp;&amp; $cell-&gt;Value ) {
         my $lhsContent = AddFormattingTags($cell);

         # check whether this is header content, which occurs only in initial
         # column. If yes, change tags to &lt;h1&gt; and skip to next iteration
         if ($lhsContent =~ /^&lt;strong&gt;[A-Z ]+&lt;\/strong&gt;/) {
           $lhsContent =~ s/strong&gt;/h1&gt;/g;
           push (@grammarList, $lhsContent);
           next;
         }

         # build list of lexemes to use later to differentiate lexemes from
         # terminals (both are in bold format in the .xls file)
         if ($lhsContent =~ /^&lt;strong&gt;(.*)&lt;\/strong&gt;/) {
           push (@lexemes, $1);
         }

         push (@grammarList, $lhsContent);

         # Parse the rhs elements in this production and count them
         my @rhs = ();   # array containing rhs elements
         my $num = 0;
         while ($ES4Worksheet-&gt;{Cells}[$iRow+1+$num][$iCol+1] &amp;&amp;
                $ES4Worksheet-&gt;{Cells}[$iRow+1+$num][$iCol+1]-&gt;Value) {
           my $rhsContent = AddFormattingTags($ES4Worksheet-&gt;{Cells}[$iRow+1+$num][$iCol+1]);
           push(@rhs, $rhsContent);
           $num++;
         }
         # Place the Abstract Syntax into a list
         my @abstractSyntax;
         # First line of abstract syntax has two-column offset
         my $abstractHeaderCell = $ES4Worksheet-&gt;{Cells}[$iRow][$iCol+2];
         if ($abstractHeaderCell &amp;&amp; $abstractHeaderCell-&gt;Value) {
           push(@abstractSyntax, $abstractHeaderCell-&gt;Value);
         }
         # Remainder of abstract syntax has three-column offset
         my $aNum = 0;
         while ($ES4Worksheet-&gt;{Cells}[$iRow+1+$aNum][$iCol+3] &amp;&amp;
                $ES4Worksheet-&gt;{Cells}[$iRow+1+$aNum][$iCol+3]-&gt;Value) {
           push(@abstractSyntax, $ES4Worksheet-&gt;{Cells}[$iRow+1+$aNum][$iCol+3]-&gt;Value);
           # For some reason, instances of ... in the .xls file get converted to
           # ampersand so we need to convert lone instances of ampersand to ...
           if ($abstractSyntax[$#abstractSyntax] =~ /^&amp;$/) {
             $abstractSyntax[$#abstractSyntax] = '...';
           }
           $aNum++;
         }

         # Create entries for error log
         if ($num &gt; 0 &amp;&amp; $aNum == 0 ) {
           push (@noAbstractSyntax, $cell-&gt;Value);
         }
         elsif ($num &gt; 0 &amp;&amp; $num != $aNum) {
           push (@missingAbstractSyntax, $cell-&gt;Value);
         }
         # Create key-value pair in %grammar hash
         $grammar{ $lhsContent } = [ $num, @rhs, @abstractSyntax ];

        } # end of if ( $cell ... statement
   }

   ModifyTerminalTags(@lexemes);

   # Error log file
   open (F, &quot;&gt;errorLog.txt&quot;);
   print F &quot;The following entries have no Abstract Syntax:\n&quot;;
   foreach (@noAbstractSyntax) {
     print F &quot;$_\n&quot;;
   }
   print F &quot;\nThe following entries may be missing Abstract Syntax:\n&quot;;
   foreach (@missingAbstractSyntax) {
     print F &quot;$_\n&quot;;
   }
   print F &quot;\nList of lexemes:\n&quot;;
   foreach my $lex(@lexemes) {
     print F &quot;$lex\n&quot;;
   }
   close F;
}


# ===============
# Subroutine PrintGrammarToFile
# Purpose: Print Grammar to a text file for testing purposes
# ================
sub PrintGrammarToFile {
  open (GFILE, &quot;&gt;Grammar.txt&quot;);

  foreach my $prod ( @grammarList ) {
     # print surface syntax lhs content
     print GFILE $prod . &quot;\n&quot;;
     
     # if there are any other contents, print them
     if (defined $grammar{$prod}[0]) {
       my $numSurfaceSyntaxElements = $grammar{$prod}[0];
       for (my $i=1; $i &lt;= $numSurfaceSyntaxElements; $i++) {
         print GFILE &quot;\t&quot; . $grammar{$prod}[$i] . &quot;\n&quot;;
       }
       print GFILE &quot;\n&quot;;

       # print abstract syntax
       my $length = @ {$grammar{$prod}};
       my $abstractSyntaxHeaderIndex = $numSurfaceSyntaxElements + 1;
       if (defined $grammar{$prod}[$abstractSyntaxHeaderIndex]) {
         print GFILE $grammar{$prod}[$abstractSyntaxHeaderIndex] . &quot;\n&quot;;
         for (my $j = $abstractSyntaxHeaderIndex+1; $j &lt; $length; $j++) {
           print GFILE &quot;\t&quot; . $grammar{$prod}[$j] . &quot;\n&quot;;
         }
         print GFILE &quot;\n&quot;;
       }
       print GFILE &quot;\n&quot;;
    }
  }

  close GFILE;
}

# ===============
# Subroutine AddFormattingTags
# Purpose: Add XHTML formatting tags to grammar elements that need it
# Methodology: The madness to this method is due to the tools provided by the
# Spreadsheet::ParseExcel module, which provides rich text information
# about a character only when it differs in some rich text formatting aspect
# from the character that immediately precedes it.
#
# Process the string sequentially and place tags and substrings into
# an array. Having tags and substrings broken down into array elements makes
# it easier to check the integrity of the tags and make adjustments
# before constructing the output string.
# 1. Check for Bold, Superscript, or FontName formatting applied to entire cell
#    and push appropriate tag if found.
# 2. Check whether there was any rich text formatting applied to the string.
#    a. If so, iterate through the rich text array for the formatting deltas.
#       Parse the string, pushing substrings and tags into the array.
#       After iterating, push any remaining text and go to step 3.
#    b. If not, push the input string to the array.
# 3. Push any necessary closing tags.
# 4. Verify that tags are in proper order
# 5. Construct output string using array, then return the result.
#
# Note: Converts a, b, g, w to their HTML entity codes (e.g. &amp;alpha;, etc.)
#       at three points in the code. 1) when adding &lt;/sup&gt;; 2) when font
#       face changes from Symbol to Arial; 3) at end of string that has
#       font set to Symbol.
#
# Still To Do:
# 1. Verify that tags are in proper order before constructing output string.
# ================
sub AddFormattingTags {
  my ($cell) = @_;
  my $cellValue = $cell-&gt;Value;

  my $formattedString = '';
  my @formatArray = ();
  my $lastPos = 0;

  # set initial values of Bold, Font, and Super
  my $bold = ($cell-&gt;{Format}-&gt;{Font}-&gt;{Bold});
  my $font = ($cell-&gt;{Format}-&gt;{Font}-&gt;{Name});
  my $super = ($cell-&gt;{Format}-&gt;{Font}-&gt;{Super});
  my $em = 0;

  # 1. Check for Bold, Superscript, or FontName formatting
  if ($bold) {
    push (@formatArray, '&lt;strong&gt;');
  }
  else {
    push (@formatArray, '&lt;em&gt;');
    $em = 1;
  }

  if ($super == 1) {
    push (@formatArray, '&lt;sup&gt;');
  }
  elsif ($super == 2) {
    push (@formatArray, '&lt;sub&gt;');
  }

  # 2. check for rich text formatting
  if ($cell-&gt;{Rich}) {
    foreach my $richTextArray (@{$cell-&gt;{Rich}}) {
      my $pos = $richTextArray-&gt;[0];
      my $fontObj  = $richTextArray-&gt;[1];

      my $sub = substr($cellValue, $lastPos, $pos - $lastPos);
      push (@formatArray, $sub);
      $cellValue = $cell-&gt;Value;  # restore full string
      $lastPos = $pos;              # move position pointer

      # Check for change in superscript format
      if ( $super != $fontObj-&gt;{Super} ) {
        if ($super) {
          my $str = $formatArray[$#formatArray]; # $#formatArray gives last index
          $str =~ s/\b(a)\b/&amp;alpha;/g;
          $str =~ s/\b(b)\b/&amp;beta;/g;
          $str =~ s/\b(g)\b/&amp;gamma;/g;
          $str =~ s/\b(w)\b/&amp;omega;/g;
          $formatArray[$#formatArray] = $str;

          if ($super == 1) {
            push (@formatArray, '&lt;/sup&gt;');
          }
          elsif ($super == 2) {
            push (@formatArray, '&lt;/sub&gt;');
          }
        }
        elsif ($fontObj-&gt;{Super} == 1) {  # changing from 0 to 1
          push (@formatArray, '&lt;sup&gt;');
        }
        elsif ($fontObj-&gt;{Super} == 2) {  # changing from 0 to 2
          push (@formatArray, '&lt;sub&gt;');
        }
        $super = $fontObj-&gt;{Super};    # toggle $super
      }
      # Check for change in bold format
      if ( $bold != $fontObj-&gt;{Bold} ) {
        if ($bold) {
          push (@formatArray, '&lt;/strong&gt;');
          push (@formatArray, '&lt;em&gt;');
          $em = 1;
        }
        else {
          if ($em) {
            push (@formatArray, '&lt;/em&gt;');
            $em = 0;
          }
          push (@formatArray, '&lt;strong&gt;');
        }
        $bold = ($bold + 1) % 2;      # toggle $bold
      }
      #Check for change in font face
      if ( $font ne $fontObj-&gt;{Name} ) {
        if ( ( $font eq 'Symbol' ) &amp;&amp; ( $fontObj-&gt;{Name} eq 'Arial') ) {
          # if Symbol font turns to Arial, we need to convert the char
          # to HTML entity code
          my $str = $formatArray[$#formatArray];  # $#formatArray gives last index
          $str =~ s/\b(a)\b/&amp;alpha;/g;
          $str =~ s/\b(b)\b/&amp;beta;/g;
          $str =~ s/\b(g)\b/&amp;gamma;/g;
          $str =~ s/\b(w)\b/&amp;omega;/g;
          $formatArray[$#formatArray] = $str;

          $font = $fontObj-&gt;{Name};
        }
        if ( ( $font eq 'Arial' ) &amp;&amp; ( $fontObj-&gt;{Name} eq 'Symbol') ) {
          $font = $fontObj-&gt;{Name};
        }
      }
    }

    # after foreach loop is done, chances are that there is still part of
    # the string left to process
    my $len = length $cellValue;
    my $subFinal = substr($cellValue, $lastPos, $len - $lastPos);
    push (@formatArray, $subFinal);

  }
  else { # lack of rich text info means entire string has same format
    # append plain text string
    push (@formatArray, $cellValue);
  }

  # Check for any chars in symbol font that need to be changed to HTML
  if ($font eq 'Symbol') {
    my $str = $formatArray[$#formatArray];  # $#formatArray gives last index
    $str =~ s/\b(a)\b/&amp;alpha;/g;
    $str =~ s/\b(b)\b/&amp;beta;/g;
    $str =~ s/\b(g)\b/&amp;gamma;/g;
    $str =~ s/\b(w)\b/&amp;omega;/g;
    $formatArray[$#formatArray] = $str;
  }


  # 3. append any necessary closing tags
  if ($super == 1) {
    push (@formatArray, '&lt;/sup&gt;');
  }
  elsif ($super == 2) {
    push (@formatArray, '&lt;/sub&gt;');
  }
  if ($bold) {   # entire string is bold
    push (@formatArray, '&lt;/strong&gt;');
  }
  else {         # string is em
    push (@formatArray, '&lt;/em&gt;');
  }
  # 5. patch together the string
  foreach my $substring (@formatArray) {
    $formattedString .= $substring;
  }
  # remove empty &lt;sup&gt; tags
  $formattedString =~ s/&lt;sup&gt;(\s*?)&lt;\/sup&gt;//g;
  
  # remove any extra spaces inside &lt;sup&gt; tags
  $formattedString =~ s/&lt;sup&gt;(.*?)\s+&lt;\/sup&gt;/&lt;sup&gt;$1&lt;\/sup&gt;/g;  # post spaces
  $formattedString =~ s/&lt;sup&gt;\s+(.*?)&lt;\/sup&gt;/&lt;sup&gt;$1&lt;\/sup&gt;/g;  # pre spaces
  
  return $formattedString;
}


# ===============
# Subroutine ModifyTerminalTags
# Purpose: Change HTML tags for terminals from &lt;strong&gt; to &lt;code&gt;
#          in surface syntax
# ================
sub ModifyTerminalTags {
  my @lexemes = @_;
  foreach my $prod ( @grammarList ) {
     # iterate through surface syntax elements
     if (defined $grammar{$prod}[0]) {
       for (my $i = 1; $i &lt;= $grammar{$prod}[0]; $i++) {
         # Use the @matches array to convert &lt;strong&gt; to &lt;code&gt; where needed
         # make a list of all &lt;strong&gt; tag content (don't include tags)
         my @matches = ( $grammar{$prod}[$i] =~ /&lt;strong&gt;(.*?)&lt;\/strong&gt;/g);

         # compare contents to @lexemes. If no match, change &lt;strong&gt; to &lt;code&gt;
         # use \Q to quote $element to avoid &quot;nested quantifiers in regex&quot; error
         # grep used here in scalar context, so it returns number of matches
         foreach my $element (@matches) {
           if ( grep (/\Q$element/, @lexemes) == 0)  {
             $grammar{$prod}[$i] =~ s/&lt;strong&gt;\Q$element&lt;\/strong&gt;/&lt;code&gt;$element&lt;\/code&gt;/;
           }
         }
       } # end for loop through rhs contents
     } # end if (defined...
  } # end &quot;foreach my $prod&quot; loop
}


# ===============
# Subroutine CreateSMLHash
# Purpose: Create hash with SML function names as keys and
#          function bodies as values.
# ===============
sub CreateSMLHash {
  # iterate through each source file in the @smlFiles array
  foreach my $srcFile (@smlFiles) {
    my $srcPath = $smlSourceDir . '\\' . $srcFile;
    my $funcName = '';
    my $codeBuffer = '';
    my $commentFlag = 0;
    open (SRC_FILE, &quot;$srcPath&quot;);
    while (&lt;SRC_FILE&gt;) {
      # Do not change the order of these if and elsif statements
      # unless you know what you are doing. The tail statements
      # assume that comments are not an option
      if (/^(fun|and) (\w+)/) {
        if ($funcName eq '') {
          $funcName = $2;
          $codeBuffer = $_;
        }
        else { # create previous hash entry then reset values
          $smlHash{$funcName} = $codeBuffer;
          push (@funcList, $funcName);
          # reset values
          $funcName = $2;
          $codeBuffer = $_; # start new codeBuffer
        }
      }
      elsif (/^\s*\(\*/) {  # start of comment
        if ($_ =! /\*\)/) { # if end of comment not found, set comment flag
          $commentFlag = 1;
        }
      }
      elsif (/\*\)/) { # end of multi-line comment
        $commentFlag = 0;
      }
      elsif ( (/^\w+/) &amp;&amp; ($commentFlag == 0) ) { # start of new expression
        if ($funcName ne '') {
          $smlHash{$funcName} = $codeBuffer;
          push (@funcList, $funcName);
          $funcName = '';
          $codeBuffer = '';
        }
      }
      else {
        if ($commentFlag == 0) {
          $codeBuffer .= $_;
        }
      }

    } # end while SRC_FILE loop

    close SRC_FILE;
  } # end foreach loop

} # end sub CreateSMLHash


sub PrintSMLHash {

  open (HASH_FILE, &quot;&gt;smlhash.txt&quot;);
  foreach my $func (@funcList) {
    print HASH_FILE &quot;$func =&gt; $smlHash{$func}\n&quot;;
  }
  close HASH_FILE;
}


# ================
# Subroutine LoginToWiki
# Purpose: Submit username and password
# ================
sub LoginToWiki {
  my @forms = $mech-&gt;forms;
  my $numForms = @forms;

  for (my $i = 1; $i &lt;= $numForms; $i++) {            # Loop to find right form
     my $form = $mech-&gt;form_number($i);               # HTML::Form object
     my $input = $form-&gt;find_input('p', 'password');  # Find form with password
     if ($input) {                                    # Skip rest if found
       last;
     }
  }

  $mech-&gt;field(u =&gt; $username);
  $mech-&gt;field(p =&gt; $password);
  $mech-&gt;click();
}


# ================
# Subroutine GetWikiText
# Purpose: retrieve wiki text and place into file
# ================
sub GetWikiText {
  # === Move to Spec namespace on Wiki ===
  $mech-&gt;follow_link( text =&gt; &quot;The 'spec:' namespace&quot;);

  # === Find all chapter links and write to startBuffer ===
  my @links = $mech-&gt;find_all_links( text_regex =&gt; qr/Chapter/);
  my $startBuffer = '';
  my $numLinks = @links;
  for (my $i=0; $i&lt; $numLinks; $i++) {
     my $chapterURL = $baseURL . $links[$i]-&gt;url();
     $mech-&gt;get($chapterURL);
     $startBuffer .= $mech-&gt;content();
  }

  # === Clean up tags, ensure each is on separate line ===
  $startBuffer =~ s/(.)&lt;ul&gt;/$1\n&lt;ul&gt;/g;
  
  # === Replace symbols with html entity codes ===
  $startBuffer =~ s/\x{c2}\x{ab}/&amp;#171;/g;  # angle quotation mark (left)
  $startBuffer =~ s/\x{c2}\x{bb}/&amp;#187;/g;  # angle quotation mark (right)
  $startBuffer =~ s/\x{e2}\x{80}\x{93}/-/g; # angle quotation mark (right)
  $startBuffer =~ s/\x{e2}\x{80}\x{94}/&amp;#8212;/g; # mdash
  $startBuffer =~ s/\x{c2}\x{a0}//g;        # utf-8 non breaking space
  $startBuffer =~ s/&amp;amp;alpha;/&amp;#945;/g;   # Greek small letter alpha
  $startBuffer =~ s/&amp;amp;beta;/&amp;#946;/g;    # Greek small letter beta
  $startBuffer =~ s/&amp;amp;omega;/&amp;#969;/g;   # Greek small letter omega

  # === Write startBuffer to file ===
  open (SFILE, &quot;&gt;startBuffer.txt&quot;);
  print SFILE $startBuffer;
  close SFILE;
}



# ===============
# Subroutine ParseWikiText
# Purpose: Read text in from file and parse
# ================
sub ParseWikiText {
  my $endBuffer = &quot;&lt;html&gt;\n&quot;;
  my $tableBuffer = '';     # buffer for table text
  my $inParagraph = 0;      # flag when inside paragraph
  my $inOList = 0;          # flag when inside &lt;ol&gt;&lt;/ol&gt;
  my $inUList = 0;          # flag when inside &lt;ul&gt;&lt;/ul&gt;
  my $inTable = 0;          # flag when inside table
  my $inGrammar = 0;        # flag when inside grammar production table
  my $inPreTag = 0;         # flag when inside pre tag
  my $chapterTitle = '';
  open (BFILE, &quot;startBuffer.txt&quot;);
    while(&lt;BFILE&gt;) {
     if ( $_ =~ /&lt;title&gt;spec:chapter_\d+_(.+) \[ES4 Wiki\]&lt;\/title&gt;/) {
       $chapterTitle = $1;
       $chapterTitle =~ s/_/ /g;
       $chapterTitle =~ s/^(.)/\u$1/;      # Upper case first letter
       $endBuffer .= &quot;&lt;h1&gt;&quot; . $chapterTitle . &quot;&lt;/h1&gt;\n&quot;;
     }
     elsif ( $_ =~ /&lt;h1&gt;(.+)&lt;\/h1&gt;/) {
       if ($1 ne $chapterTitle) {
         $endBuffer .= &quot;&lt;h2&gt;&quot; . $1 . &quot;&lt;/h2&gt;\n&quot;;
       }
     }
     elsif ( $_ =~ /&lt;h2&gt;(.+)&lt;\/h2&gt;/) {
       $endBuffer .= &quot;&lt;h3&gt;&quot; . $1 . &quot;&lt;/h3&gt;\n&quot;;
     }
     elsif ( $_ =~ /&lt;h3&gt;(.+)&lt;\/h3&gt;/) {
       $endBuffer .= &quot;&lt;h4&gt;&quot; . $1 . &quot;&lt;/h4&gt;\n&quot;;
     }
     elsif ( $_ =~ /&lt;h4&gt;(.+)&lt;\/h4&gt;/) {
       $endBuffer .= &quot;&lt;h5&gt;&quot; . $1 . &quot;&lt;/h5&gt;\n&quot;;
     }
     elsif ( $_ =~ /&lt;p&gt;/) {
       $endBuffer .= $_;
       $inParagraph = 1;
     }
     elsif ( $inParagraph ) {
       # check for grammar production, $inParagraph must be exactly 1
       if ( ($inParagraph == 1)
                &amp;&amp;  ( ($_ =~ /&lt;em&gt;.+&lt;\/em&gt;.+&amp;rarr;/)
                   || ($_ =~ /&lt;strong&gt;.+&lt;\/strong&gt;.+&amp;rarr;/)  ) ){
         $inGrammar = 1;
       }
       elsif ($inGrammar) {
         if ($inParagraph == 2) {
           $_ =~ s/^(.*)/&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$1/;
         }
         else {
           $_ =~ s/(&lt;code&gt;\|.*&lt;\/code&gt;)/&amp;nbsp;&amp;nbsp;&amp;nbsp;$1/;
         }
       }
       
       # increment $inParagraph for line nums or reset if closing tag found
       if ( $_ =~ /&lt;\/p&gt;/) {
         $inParagraph = 0;
         $inGrammar = 0;
       }
       else {
         $inParagraph++;
       }
       
       # convert curly quotes and write to buffer
       my $line = CurlyToHTMLCurly($_);
       $endBuffer .= $line;
     }
     elsif ( $_ =~ /&lt;ul&gt;/) {
       $endBuffer .= $_;
       $inUList++;           # increment to handle nested lists
     }
     elsif ( $inUList ) {
       if ( $_ =~ /&lt;\/ul&gt;/) {
         $inUList--;
       }
       my $line = CurlyToHTMLCurly($_);
       $endBuffer .= $line;
     }
     elsif ( $_ =~ /&lt;ol&gt;/) {
       $endBuffer .= $_;
       $inOList++;           # increment to handle nested lists
     }
     elsif ( $inOList ) {
       if ( $_ =~ /&lt;\/ol&gt;/) {
         $inOList--;
       }
       my $line = CurlyToHTMLCurly($_);
       $endBuffer .= $line;
     }
     elsif ( $_ =~ /&lt;table/) {
       $tableBuffer .= $_;              # place current line in table buffer
       $inTable = 1;                    # set $inTable flag
     }
     elsif ( $inTable ) {
       # check for end of table, clean up if found
       if ( $_ =~ /&lt;\/table/) {
         # add table border
         $tableBuffer =~ s/&lt;table/&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;3&quot;/;
         $tableBuffer .= $_;
         $endBuffer .= $tableBuffer;    # write table to general buffer
         $tableBuffer = '';             # reset tableBuffer
         $inTable = 0;                  # reset table flag
        }
       # if not end of table, write line to table buffer
       else {
         my $line = CurlyToHTMLCurly($_);
         $tableBuffer .= $line;
       }
     }
     # merge grammar
     elsif ( $_ =~ /&lt;pre class=&quot;code grammar&quot;&gt;/ ) {
       my $text = $_;
       my @lhsContents = ();
       
       # parse string and place tag contents into array
       while ( length($text) ) {
         if ( $text =~ /&lt;pre class=&quot;code grammar&quot;&gt;(.*?)&lt;\/pre&gt;/) {
           push (@lhsContents, $1);
           $text = $';
         }
         else {
           $text = '';
         }
       }
       
       # Add grammar for each element of the array
       foreach my $item (@lhsContents) {
         $item = '&lt;em&gt;' . $item . '&lt;/em&gt;';
         $item =~ s/&amp;lt;/&lt;/g;
         $item =~ s/&amp;gt;/&gt;/g;
         $item =~ s/&amp;#945;/&amp;alpha;/g;   # Greek small letter alpha
         $item =~ s/&amp;#946;/&amp;beta;/g;    # Greek small letter beta
         $item =~ s/&amp;#969;/&amp;omega;/g;   # Greek small letter omega

         my $grammar = GenerateGrammar($item);
         if ($grammar ne '') {
           $endBuffer .= $grammar;
         }
       }

     }
     # print out complete grammar summary
     elsif ( $_ =~ /&lt;pre class=&quot;code grammarSummary&quot;&gt;/ ) {

       # Add grammar for each element of the array
       foreach my $prod (@grammarList) {
         if (defined $grammar{$prod}[0]) {
           $endBuffer .= GenerateGrammar($prod);
         }
         else { # If first element of hash array undef, this is a header
           if ($prod =~ /SURFACE SYNTAX/) {
             $endBuffer .= &quot;&lt;h2&gt;LEXICAL STRUCTURE&lt;/h2&gt;\n&quot;;
           }
           elsif ($prod =~ /EXPRESSIONS/) {
             $endBuffer .= &quot;&lt;h2&gt;SYNTACTIC STRUCTURE&lt;/h2&gt;\n&lt;h3&gt;EXPRESSIONS&lt;/h3&gt;\n&quot;;
           }
           else {
             $prod =~ s/h1&gt;/h3&gt;/g;
             $endBuffer .= $prod;
           }
         }
       }

     }
     # print out section of grammar
     elsif ( $_ =~ /&lt;pre class=&quot;code grammarSection&quot;&gt;/ ) {
       # ascertain which section (should be tag contents)
       if ($_ =~ /&lt;pre class=&quot;code grammarSection&quot;&gt;(.*?)&lt;\/pre&gt;/ ) {
         my $section = $1;
         my $inSectionFlag = 0; # currently processing selected section
         # iterate through grammar list
         foreach my $prod (@grammarList) {
           # If first element of hash array undef, this is a header
           if (!defined $grammar{$prod}[0]) {
             if ($prod =~ /$section/i) {
                $inSectionFlag = 1;
             }
             else {
                $inSectionFlag = 0;
             }
           }
           elsif ($inSectionFlag) {
             $endBuffer .= GenerateGrammar($prod);
           }
         }
       }
     }
     # merge smlnj code
     elsif ( $_ =~ /&lt;pre class=&quot;code insert_ml&quot;&gt;/ ) {
       my $text = $_;
       my @funcNames = ();

       # parse string and place tag contents into array
       while ( length($text) ) {
         if ( $text =~ /&lt;pre class=&quot;code insert_ml&quot;&gt;(.*?)&lt;\/pre&gt;/) {
           push (@funcNames, $1);
           $text = $';
         }
         else {
           $text = '';
         }
       }

       # Add sml code for each element of the array
       foreach my $item (@funcNames) {
         if (defined $smlHash{$item}) {
           my $code = $smlHash{$item};
           $code =~ s/ /&amp;nbsp;/g;
           $code =~ s/\n/&lt;br\/&gt;/g;
           $endBuffer .= &quot;&lt;code&gt;$code&lt;/code&gt;&quot;;
         }
       }

     }
     elsif ( $_ =~ /&lt;pre/) {
       my $line = CurlyToStraight($_);
       $endBuffer .= $line;
       if ($_ !~ /&lt;\/pre/) {    # set $inPreTag if line has no closing &lt;/pre&gt;
         $inPreTag = 1;
       }
     }
     elsif ( $inPreTag ) {
       if ( $_ =~ /&lt;\/pre/) {
         $inPreTag = 0;
       }
       my $line = CurlyToStraight($_);
       $endBuffer .= $line;
     }
     elsif ( $_ =~ /^&lt;br \/&gt;/ ) {
       $endBuffer .= $_;
     }
 }
  $endBuffer .= '&lt;/html&gt;';
  close BFILE;
  
  # === Write buffer to file ===
  open (DFILE, &quot;&gt;wikiExport.doc&quot;);
  print DFILE $endBuffer;
  close DFILE;
}

# ===============
# Subroutine CurlyToStraight
# Purpose: Convert &quot;curly&quot; quotes to straight quotes inside &lt;pre /&gt; tags
# ================

sub CurlyToStraight {
  my ($line) = @_;
  $line =~ s/\x{e2}\x{80}\x{99}/\'/g;
  $line =~ s/\x{e2}\x{80}\x{98}/\'/g;
  $line =~ s/\x{e2}\x{80}\x{9c}/\&quot;/g;
  $line =~ s/\x{e2}\x{80}\x{9d}/\&quot;/g;
  return $line;
}

# ===============
# Subroutine CurlyToHTMLCurly
# Purpose: Convert &quot;curly&quot; quotes to HTML curly quotes
# ================

sub CurlyToHTMLCurly {
  my ($line) = @_;
  $line =~ s/\x{e2}\x{80}\x{99}/&amp;#8217;/g;
  $line =~ s/\x{e2}\x{80}\x{98}/&amp;#8216;/g;
  $line =~ s/\x{e2}\x{80}\x{9c}/&amp;#8220;/g;
  $line =~ s/\x{e2}\x{80}\x{9d}/&amp;#8221;/g;
  return $line;
}

# ===============
# Subroutine GenerateGrammar
# Purpose: return surface syntax and abstract syntax for a given production
# ================
sub GenerateGrammar {
  my ($item) = @_;
  my $endBuffer = '';
  my $numSurfaceSyntax = 0;
  my $indent = &quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;;

  $numSurfaceSyntax = $grammar{$item}[0];
  
  if (defined $numSurfaceSyntax) {

    my $totalSyntax = @{$grammar{$item}};

    # lhs of surface syntax
    $endBuffer .= $item;
    if ($item !~ /=\s+\{.*\}/) {  # add arrow if item is not &quot;a = {isNot, }&quot; etc.
      $endBuffer .= &quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;rarr; &quot;;
    }
    $endBuffer .= &quot;&lt;br/&gt;\n&quot;;

    # first element on rhs of surface syntax (no | symbol)
    if (defined $grammar{$item}[1]) {
      $endBuffer .= &quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot; . $grammar{$item}[1] . &quot;&lt;br/&gt;\n&quot;;

      # remaining surface syntax elements
      for (my $k = 2; $k &lt;= $numSurfaceSyntax; $k++) {
        $endBuffer .= &quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;|&lt;/code&gt;&amp;nbsp;&quot; . $grammar{$item}[$k] . &quot;&lt;br/&gt;\n&quot;;
      }
      $endBuffer .= &quot;&lt;br/&gt;\n&quot;;
    }

    # skip to next item if current item contains no abstract syntax elements
    if (defined $grammar{$item}[$numSurfaceSyntax + 1]) {

      # abstract syntax header
      $endBuffer .= &quot;$indent&lt;code&gt;$grammar{$item}[$numSurfaceSyntax + 1]&lt;/code&gt;&lt;br/&gt;\n&quot;;

      # remaining abstract syntax elements
      for (my $j = $numSurfaceSyntax + 2; $j &lt; $totalSyntax; $j++) {
        $endBuffer .= &quot;$indent&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;&quot; . $grammar{$item}[$j] . &quot;&lt;/code&gt;&lt;br/&gt;\n&quot;;
      }
      $endBuffer .= &quot;&lt;br/&gt;\n&lt;br/&gt;\n&quot;;
     }
  }
  return $endBuffer;
}



</pre>

<!-- no cachefile used, but created -->
    <!-- wikipage stop -->
  </div>

  <div class="clearer">&nbsp;</div>

  
  <div class="stylefoot">

    <div class="meta">
      <div class="user">
              </div>
      <div class="doc">
        spec/wikiexportscript.txt &middot; Last modified: 2007/06/25 20:10 by fcheng      </div>
    </div>

   
    <div class="bar" id="bar_bottom">
      <div class="bar-left" id="bar_bottomleft">
        <form class="button" method="post" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="edit" /><input type="hidden" name="rev" value="" /><input type="hidden" name="id" value="spec:wikiexportscript" /><input type="submit" value="Show pagesource" class="button" title="ALT+V" accesskey="v" /></form>        <form class="button" method="get" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="revisions" /><input type="hidden" name="id" value="spec:wikiexportscript" /><input type="submit" value="Old revisions" class="button" title="ALT+O" accesskey="o" /></form>      </div>
      <div class="bar-right" id="bar_bottomright">
                        <form class="button" method="get" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="login" /><input type="hidden" name="id" value="spec:wikiexportscript" /><input type="submit" value="Login" class="button" /></form>        <form class="button" method="get" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="index" /><input type="hidden" name="id" value="spec:wikiexportscript" /><input type="submit" value="Index" class="button" title="ALT+X" accesskey="x" /></form>        <a href="doku.php%3Fid=spec:wikiexportscript.html#top"><input type="button" class="button" value="Back to top" onclick="window.scrollTo(0, 0)" /></a>&nbsp;
      </div>
    </div>

  </div>

</div>

<div align="center" class="footerinc">
  <a target="_blank" href="feed.php" title="Recent changes RSS feed"><img src="lib/tpl/default/images/button-rss.png" width="80" height="15" alt="Recent changes RSS feed" border="0" /></a>

  <a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.0/" rel="license" title="Creative Commons License"><img src="lib/tpl/default/images/button-cc.gif" width="80" height="15" alt="Creative Commons License" border="0" /></a>

  <a target="_blank" href="https://www.paypal.com/xclick/business=andi%40splitbrain.org&amp;item_name=DokuWiki+Donation&amp;no_shipping=1&amp;no_note=1&amp;tax=0&amp;currency_code=EUR&amp;lc=US" title="Donate"><img src="lib/tpl/default/images/button-donate.gif" alt="Donate" border="0" /></a>

  <a target="_blank" href="http://www.php.net" title="Powered by PHP"><img src="lib/tpl/default/images/button-php.gif" width="80" height="15" alt="Powered by PHP" border="0" /></a>

  <a target="_blank" href="http://validator.w3.org/check/referer" title="Valid XHTML 1.0"><img src="lib/tpl/default/images/button-xhtml.png" width="80" height="15" alt="Valid XHTML 1.0" border="0" /></a>

  <a target="_blank" href="http://jigsaw.w3.org/css-validator/check/referer" title="Valid CSS"><img src="lib/tpl/default/images/button-css.png" width="80" height="15" alt="Valid CSS" border="0" /></a>

  <a target="_blank" href="http://wiki.splitbrain.org/wiki:dokuwiki" title="Driven by DokuWiki"><img src="lib/tpl/default/images/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" border="0" /></a>



<!--

<rdf:RDF xmlns="http://web.resource.org/cc/"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="">
   <dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
   <license rdf:resource="http://creativecommons.org/licenses/by-nc-sa/2.0/" />
</Work>

<License rdf:about="http://creativecommons.org/licenses/by-nc-sa/2.0/">
   <permits rdf:resource="http://web.resource.org/cc/Reproduction" />
   <permits rdf:resource="http://web.resource.org/cc/Distribution" />
   <requires rdf:resource="http://web.resource.org/cc/Notice" />
   <requires rdf:resource="http://web.resource.org/cc/Attribution" />
   <prohibits rdf:resource="http://web.resource.org/cc/CommercialUse" />
   <permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" />
   <requires rdf:resource="http://web.resource.org/cc/ShareAlike" />
</License>

</rdf:RDF>

-->
</div>

<img src="lib/exe/indexer.php%3Fid=spec%253Awikiexportscript&amp;1454276565" width="1" height="1" alt=""  /></body>
</html>
