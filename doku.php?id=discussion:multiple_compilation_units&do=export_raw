====== Older discussion ======

Both the 3rd Edition and the 4th Edition Draft define only the meaning of a single Program executing in a single global environment (where "Program" is the initial nonterminal in the language grammar).  However, all major implementations of the language will likely need to consider interpretation of "complete programs" consisting of multiple, separately compiled such Programs, often interacting in multiple global environments.  If the spec does not address these complexities then it is left up to each implementation to define the meaning of such "complete programs".

At a minimum we need to define what it means to load and execute a program consisting of set of multiple Program units in a single global environment.  We should also address any complexities that arise with multiple global environments.

We should do this both for 3rd Edition code and (obviously) for 4th Edition code.

===== Common behavior =====

The following is true for both editions.

A //complete program// consists of a potentially unbounded totally ordered set of program fragments, each of which is a ''Program'' as per section 14 of the 3rd Edition / section 17.7 of the 4th Edition January Draft.  This set is evaluated in an on-line fashion in the context of a global environment that is freshly created before the evaluation of the first Program.  Each Program is evaluated fully before the next Program's evaluation begins.  //[That last bit is actually a little iffy in the context of a web browser, since it is possible for an event handler to interrupt an already running event handlers.]//

If the evaluation of a Program throws an exception that is not caught by the Program or by any other mechanism, then the Program's evaluation is aborted.  If one Program's evaluation is aborted, the implementation may choose whether it will abort the evaluation of the complete program.

Functions are statically scoped with respect to their global environment.  //[The 3rd Edition spec implies this somewhere, but I am too lazy to look right now.]//  This is true for built-in functions as well as user-defined functions.

Two complete programs can interact by manipulating data and functions in each others' global environments, each of which can be considered simply an Object.  Apart from constraints in the implementation, there are no restrictions on accesses from one global environment to another.

It is implementation-defined whether an object of a standard type created in one global environment is an instance of the constructor for that type taken from another global environment.  //[I'd like to say that ''instanceof'' should return ''true'' here, but I don't know if I can get away with that.  Certainly it's not true in Opera.]//

Observe that the sequential evaluation of two Programs P1 and P2 does not necessarily yield the same result as evaluating their concatentation P1P2.  An implementation that compiles (a prefix of) the complete program ahead-of-time must preserve the semantics of evaluating all the Programs sequentially as described above.

===== 3rd Edition =====

The 3rd Edition language is nicely dynamic and fairly simple, so there aren't too many surprises.

Observe that the evaluation of any Program requires no knowledge of any previous Program, and apart from sorting all functions before all statements, the top-level forms of a Program can be evaluated in complete isolation from each other.


===== 4th Edition =====

The 4th Edition language has a substantial static (compile-time) context.  Some aspects of this context are unknown at this time.  The following is a preliminary proposal, not yet vetted vis-a-vis the spec.

Consider two Programs P1 and P2, considered in that order.  (For "variable" read "var or const".)

  * If P1 defines a top-level package, class, interface, namespace, or variable then that item is visible statically in P2 just as it is in P1
  * P2 may add definitions to a package P defined in P1 by also defining P.  All classes, interfaces, namespaces, and variables defined in P in P1 are visible when P is compiled in P2, and conflicts are resolved as if all the definitions came from the same Program.
  * P2 may not redefine (at top level) any classes, interfaces, or namespaces defined in P1
  * P2 may redefine (at top level) a variable defined in P1 provided it is type-compatible, and if it is a ''const'' only if it does not have an initializer in P2
  * If P1 defines a ''const'' then it must contain code that definitely leaves that constant initialized when P1's evaluatation terminates (though see Open Issues below)
  * P1 may not contain references to packages, classes, namespaces or interfaces defined in P2, and in the static language it may also not reference variables defined in P2
  * A namespace or package opened in P1 will not be automatically opened in P2

Open issues:

  * It's unclear whether "default xml namespace" is scoped inside a Program, since that's really some sort of assignment statement
  * The rules about ''const'' break down if the implementation allows one Program to be terminated by an error and the next program to be evaluated anyway.  //[Anyhow ''const'' already has some initialization issues with regard to non-nullable types.]//
  * If we accept enum types they'll be like classes

----
Notes on CLR Appdomains

ApplicationDomains (AppDomains) on the CLR in a way help achieve scalability.

If you take a normal process, it takes a while to create and kill a process, and when you want really high performance you want that one process to be used for many things - this is what transaction processing systems typically do. We wanted to get the same kind of idea with an easier programming model. So we created this thing called an AppDomain and the idea is that you can have as many AppDomains as you like inside of a single operating system process, and a combination of our security system and the design of the instruction set (i.e. CIL) guarantees that programs running in one AppDomain cannot read or write the memory being used by another AppDomain. That means they can run in the same operating system process together without hurting each other's memory. So that lets you scale tremendously; we can have hundreds of appdomains in a single process, hundreds of processes on a single machine, and so on. The other point to note is that processes are separated from each other with assistance from the hardware. No hardware assistance is required to deploy AppDomains. The isolation between appdomains within a process is imposed and policed by software (CLR).

Assemblies (the unit of deployment on the CLR) are always loaded within the context of an AppDomain, and the types that result are scoped by their AppDomain. For e.g. static variables defined in an assembly are allocated and stored within the AppDomain. If the same assembly is loaded into three different domains, three different copies of the typeâ€™s data for that assembly are allocated.

When loading a type by name, typeName can be a simple type name, a type name that includes a namespace, or a complex name that includes an assembly name specification. If typeName includes only the name of the Type, we look up first in the calling object's assembly, then in the system assembly. If typeName is fully qualified with the partial or complete assembly name, we lookup in the specified assembly.

 --- //[[pratapl@microsoft.com|Pratap Lakshman]] 2006/05/17 10:24//