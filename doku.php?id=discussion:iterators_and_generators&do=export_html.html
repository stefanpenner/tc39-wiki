<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=discussion" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=export_html.html#recent_comments_and_questions" class="toc">Recent comments and questions</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=export_html.html#doubts_about_the_enumerator_example" class="toc">Doubts about the Enumerator example</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=export_html.html#yield_syntax" class="toc">yield syntax</a></span></li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=export_html.html#other_recent_comments_and_questions" class="toc">Other recent comments and questions</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=export_html.html#iterators_and_generators" class="toc">Iterators and Generators</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=export_html.html#generators" class="toc">Generators</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=export_html.html#array_comprehensions" class="toc">Array comprehensions</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=export_html.html#generator_expressions" class="toc">Generator expressions</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=export_html.html#iterators" class="toc">Iterators</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=export_html.html#value_iteration_and_shadowing" class="toc">Value Iteration and Shadowing</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=export_html.html#value_iteration_proposal" class="toc">Value Iteration Proposal</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=export_html.html#type_safety" class="toc">Type Safety</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=export_html.html#clarifications" class="toc">Clarifications</a></span></li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=discussion:iterators_and_generators&amp;do=export_html.html#comments_on_reference_code" class="toc">Comments on reference code</a></span></li>
</ul>
</div>
</div>

<p>
See <a href="doku.php%3Fid=proposals:iterators_and_generators.html" class="wikilink1" title="proposals:iterators_and_generators" onclick="return svchk()" onkeypress="return svchk()">iterators and generators</a> for the re-drafted proposal based on this discussion.
</p>

<a name="recent_comments_and_questions"></a><h1>Recent comments and questions</h1>
<div class="level1">

</div>
<!-- SECTION [100-144] -->
<a name="doubts_about_the_enumerator_example"></a><h2>Doubts about the Enumerator example</h2>
<div class="level2">

<p>
 I think the type system says that 
</p>
<pre class="code">
   class C {
      function f() : T {}
   }
</pre>

<p>
is not a subtype of
</p>
<pre class="code">
   type X = { f: function() : T }
</pre>

<p>
because the method signatures are not compatible.  The type of the <code>f</code> of <code>C</code> is
</p>
<pre class="code">
  F1 = (function (this C) () #f T)
</pre>

<p>
and the type of the <code>f</code> of <code>X</code> is 
</p>
<pre class="code">
  F2 = (function (this Object) () #f T)
</pre>

<p>
The <a href="doku.php%3Fid=spec:type_system.html" class="wikilink1" title="spec:type_system" onclick="return svchk()" onkeypress="return svchk()">type system</a> page states that for <code>F1 &lt;: F2</code>, which we want here, we must have the bound <code>this</code> of F2 be a subtype of the ditto of F1; this is not the case.
</p>

<p>
Therefore it does not seem that <code>Enumerator</code> implements either <code>IteratorType</code> or <code>IterableType</code>.
</p>

<p>
(Or maybe conversion saves you?  That seems sort of evil.)
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/10/02 07:12</em>
</p>

</div>
<!-- SECTION [145-990] -->
<a name="yield_syntax"></a><h2>yield syntax</h2>
<div class="level2">

<p>
 The current grammar allows:
</p>

<p>
<strong>yield yield yield 5;</strong>
</p>

<p>
Is this right?  Relevant productions:
</p>
<pre class="code">YieldExpression:
  yield
  yield AssignmentExpression</pre>
<pre class="code">AssignmentExpression:
  ...
  YieldExpression</pre>

<p>
If yield is an expression, this is allowed, but is somewhat obscure.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6d%3B%26%23x6f%3B%26%23x62%3B%26%23x40%3B%26%23x6d%3B%26%23x62%3B%26%23x65%3B%26%23x64%3B%26%23x74%3B%26%23x68%3B%26%23x69%3B%26%23x73%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6d;&#x6f;&#x62;&#x40;&#x6d;&#x62;&#x65;&#x64;&#x74;&#x68;&#x69;&#x73;&#x2e;&#x63;&#x6f;&#x6d;">Michael O'Brien</a> 2006/09/05 13:58</em> 
</p>
<hr noshade="noshade" size="1" />

<p>
This is incorrect, sorry about that.  The grammar is more restrictive: 
</p>
<ul>
<li class="level1"><div class="li"> There needs to be a <code>[no <em>LineTerminator</em> here]</code> between <code>yield</code> and <em>AssignmentExpression</em>, as in Edition 3&rsquo;s grammar.</div>
</li>
<li class="level1"><div class="li"> <code>yield yield</code> and the like must be an error.</div>
</li>
<li class="level1"><div class="li"> A <em>YieldExpression</em> must be parenthesized unless used as an expression statement or as the right-hand side of an assignment operator.</div>
</li>
</ul>

<p>
 There are several ways to specify these restrictions.  One way is to produce <em>YieldExpression</em> from both <em>Expression</em> and from the right-hand side of assignment.  I&rsquo;m happy to help, but I have not read Jeff&rsquo;s grammar.  Thoughts on how to proceed?
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/09/05 21:52</em>
</p>

<p>
Your description above seem to include compatibility restrictions imposed on Python, which do no apply to ES. Quoting PEP 342:
</p>
<pre class="code">

    New syntax: Yield Expressions

    The yield-statement will be allowed to be used on the right-hand
    side of an assignment; in that case it is referred to as
    yield-expression.  The value of this yield-expression is None
    unless send() was called with a non-None argument; see below.

    A yield-expression must always be parenthesized except when it
    occurs at the top-level expression on the right-hand side of an
    assignment.  So

        x = yield 42
        x = yield
        x = 12 + (yield 42)
        x = 12 + (yield)
        foo(yield 42)
        foo(yield)

    are all legal, but

        x = 12 + yield 42
        x = 12 + yield
        foo(yield 42, 12)
        foo(yield, 12)

   are all illegal.  (Some of the edge cases are motivated by the
   current legality of &quot;yield 12, 42&quot;.)

</pre>

<p>
So how about we treat &lsquo;yield&rsquo; as a high precedence (unary-like) operator and not make the arbitrary requirement for parens. Then all of the illegal cases above would have a positive interpretation in ES4.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/09/13 17:26</em>
</p>

<p>
To be specific, this is the change I have in mind:
</p>
<pre class="code">
YieldExpression	                [add these productions]
	UnaryExpression
        yield
	yield  [no line break]  UnaryExpression
	
MultiplicativeExpression	[replace current productions with these]
	YieldExpression    
	MultiplicativeExpression  *  YieldExpression
	MultiplicativeExpression  /  YieldExpression
	MultiplicativeExpression  %  YieldExpression
</pre>

<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/09/14 14:13</em>
</p>

<p>
No, we don&rsquo;t want <em>UnaryExpression</em> as the <code>yield</code> optional operand non-terminal, because that means <code>yield x + y</code> is <code>(yield x) + y</code>.  This isn&rsquo;t a Python restriction, it&rsquo;s a usability argument: <code>yield</code> is like <code>return</code> in that its operand can be almost any expression, and if you want to use the result of evaluating such a <code>yield</code> expression, you have to parenthesize the whole thing.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/09/19 23:39</em>
</p>

<p>
Agreement was reached to break with Python and follow Brendan&rsquo;s original grammar, which allows &lsquo;yield yield yield ...&rsquo;. One influence is &lsquo;yield&rsquo;s similarity with our &lsquo;let&rsquo; expressions which now also takes an <em>AssignmentExpression</em>.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/09/21 15:50</em>
</p>

<p>
This means that <code>yield a, b</code> is <code>(yield a), b</code>.  Note how in the final grammar agreed upon today, <code>f(yield a, b)</code> calls <code>f</code> with two arguments, whereas in Python 2.5 and JavaScript 1.7 (in Firefox 2) it is a syntax error.  Unfortunately, in both of those programs <code>f((yield a, b))</code> (required to avoid the syntax error) means <code>f((yield (a, b)))</code>, which is not compatible with the final ES4 grammar.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/09/22 21:26</em>
</p>

<p>
Hold on! My trouble with the Python rules for <code>yield</code> is that they aren&rsquo;t consistent with ES4, but with a small tweak that might not be the case. There are other cases where a user has to introduce a syntactic context to get the meaning he wants for a construct. For example, {} means block statement at the top level and not object initialiser. Consider <em>LetStatement</em> and <em>YieldStatement</em> to be peers in the sense that they both have expression counterparts and both end with a <em>ListExpression</em>. Users may expect that the expression form would also end with a <em>ListExpression</em>, as Python and JS1.7 say they should. But then we have the ambiguity in syntactic contexts where <code>,</code> might be thought to associate with the outer context rather than the inner <code>yield</code> or <code>let</code> expression. To avoid this, how about if we make <code>yield x</code> and <code>let(x) x</code> a syntax error in those contexts only? This is less restrictive than the Pythonic rule and allows ES4 to be more internally consistent. So for example,
</p>
<pre class="code">
        x = 12 + yield 42
        x = 12 + yield
        foo(yield, 12)
        foo(12, yield 42)
</pre>

<p>
would all be legal, but
</p>
<pre class="code">
        foo(yield 42, 12)
</pre>

<p>
would not.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/09/24 10:21</em>
</p>

<p>
The problem with <code>x = 12 + yield 42</code> is that if you commute, you get a very different expression: <code>x = yield 42 + 12</code> which is <code>x = yield 54</code>.
</p>

<p>
Likewise, sometimes actual argument lists in existing call sites grow over time, requiring <code>foo(12, yield 42)</code> to become <code>foo(12, (yield 42), 43)</code>.
</p>

<p>
There is no low-precedence unary operator in the language on which users might model <code>yield</code>.  Always parenthesizing except on the right-hand side of assignment is simpler than requiring parentheses if there are operators on the right, or extra arguments after the yield expression.  What is more, by always requiring parenthesization, users must say what they mean at the price of extra bracketing characters.
</p>

<p>
I&rsquo;m still of the opinion that Python made the right usability vs. safety call, because with what you propose, the first sign of trouble is likely to be a wrong value, not necessarily even a run-time error.  I agree that <code>let</code> asymmetry is an issue.  The &ldquo;safety first&rdquo; argument probably applies to both <code>let</code> and <code>yield</code> equally.
</p>

<p>
But your new proposal is a superset of JS1.7 and <em>mutatis mutandis</em> Python2.5 as far as well-formed yield expression syntax goes.  JS1.7 forbids even <code>foo(yield 42)</code>, requiring <code>foo((yield 42))</code>, but JS2/ES4 allows the former and the latter, and does not change the meaning of <code>foo((yield 42, 43))</code> either &ndash; it still means <code>foo((yield (42, 43)))</code> when fully parenthesized, and in your proposal could be written <code>foo(yield (42, 43))</code> too.
</p>

<p>
Your new proposal is to use <em>ListExpression</em> as the non-terminal on the right of the <code>let</code> head, and as the optional operand of <code>yield</code>, but to add an error check in larger comma-separated expression contexts, if I understand correctly.
</p>

<p>
Let me know if this comment agrees with what you are proposing.  Thanks,
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/09/25 19:02</em> 
</p>
<blockquote>
Your new proposal is to use <em>ListExpression</em> as the non-terminal on the right of the <code>let</code> head, and as the optional operand of <code>yield</code>, but to add an error check in larger comma-separated expression contexts, if I understand correctly</blockquote>

<p>
 This is correct. It doesn&rsquo;t solve the problem with <code>x = 12 + yield 42</code> vs <code>x = yield 42 + 12</code>, but requiring parens doesn&rsquo;t help much there either. <code>x = (12 + yield 42)</code> and <code>x = (yield 42 + 12)</code> are still different. True, the parens indicate that the user has thought about it, but if the language forces the parens then maybe the user didn&rsquo;t think about it after all, and just parenthesized until it compiled!
</p>

<p>
My concern is to not punish users who write unambiguous code, just to keep users who don&rsquo;t safe.
</p>

<p>
To illustrate further, the following would be true with what I propose
</p>
<pre class="code">
foo(12, yield 42)       // no problem, unambiguous
</pre>
<pre class="code">
foo(12, yield 42, 43)   // **syntax error**, two arguments or three? grammar says two, user might think three
</pre>
<pre class="code">
foo(12, (yield 42), 43) // problem solved, clearly three arguments
</pre>
<pre class="code">
foo(12, (yield 42, 43)) // problem solved, clearly two arguments
</pre>

<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/09/26 11:58</em>
</p>

<p>
The problem with <code>x = 12 + yield 42</code> vs. <code>x = yield 42 + 12</code> *is* solved by requiring parens as Python2.5 and JS1.7 do, because <code>x = 12 + yield 42</code> is a syntax error &ndash; it must be <code>x = 12 + (yield 42)</code>, and then commuting with parentheses preserved *does* mean the same thing.
</p>

<p>
It&rsquo;s true that <code>x = yield 42 + 12</code> is legal in Python2.5 and JS1.7, and that you can&rsquo;t commute without both parenthesizing and changing the meaning.  But that follows from <code>yield</code> being a low-precedence unary operator, which follows from its statement form: <code>yield 42 + 12;</code> is <code>yield (42 + 12);</code>.
</p>

<p>
Your proposal avoids punishing users who do not embed <code>yield</code> (or <code>let</code>, I presume? [ <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/09/26 12:44</em> &mdash; yes, <code>let</code> too]) expressions inside comma expressions in an ambiguous way, but it still leaves this &ldquo;commutativity hazard&rdquo;.  But I like it as a forward compatible superset grammar, and I agree the comma operator (broadly construed &ndash; actual argument lists definitely included) is the likeliest source of confusion, not the commutative binary operators.
</p>

<p>
Can you express this restriction by factoring the grammar, instead of adding a semantic check?  I can think of ways to do it, but I haven&rsquo;t reviewed the grammar yet.  It would be great to enforce this syntax error syntactically <img src="lib/images/smileys/icon_wink.gif" align="middle" alt=";-)" />.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/09/26 12:13</em> 
</p>
<blockquote>
 Can you express this restriction by factoring the grammar, instead of adding a semantic check?</blockquote>

<p>
 The <a href="doku.php%3Fid=proposals:normative_grammar.html" class="wikilink1" title="proposals:normative_grammar" onclick="return svchk()" onkeypress="return svchk()">normative grammar</a> is updated to produce a syntax error when <code>yield ListExpression</code> or <code>let(...) ListExpression</code> is used before a comma, except in a <em>ListExpression</em>
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/09/26 19:01</em>
</p>

<p>
I&rsquo;ll have a look, thanks.  Since parsing is usually greedy, the <em>ListExpression</em> non-terminal after <code>yield</code> or <code>let(...)</code> would swallow any comma after it, so there couldn&rsquo;t be an &ldquo;except in a <em>ListExpression</em> exception &ndash; if you see what I mean.  But I may just be quibbling with your description here!
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/09/30 15:15</em>
</p>

</div>
<!-- SECTION [991-11559] -->
<a name="other_recent_comments_and_questions"></a><h1>Other recent comments and questions</h1>
<div class="level1">

<p>
 IteratorType appears to be a recursive structural type, something we do not support.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/08/23 09:08</em>
</p>

<p>
Right, fixed.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/09/19 23:44</em>
</p>

<p>
Nice to see this coming along.  <acronym title="In my opinion">IMO</acronym> it needs some work before it can go into the &ldquo;ready for public review&rdquo; section.  Here are just some brief comments, though:
</p>

<p>
Iterators: The bit about the use of the <code>intrinsic</code> namespace worries me, because nowhere else in the language is there a need for more than one namespace on any property (but here we have <code>public intrinsic</code>) and anyway ISTR that we decided to stick with simple syntax for field names in object initializers, not full qualified identifiers.  Is this just a notational device or do you really mean it that way?
</p>

<p>
Generators: The type of a generator that takes parameter types P1..Pn and returns R is <code>function (P1,...,Pn) : GeneratorType.&lt;R,?,?&gt;</code>.  From where do we obtain the types for the second and third arguments here?  What is the purpose of &ldquo;send&rdquo; and &ldquo;close&rdquo;?
</p>

<p>
It appears the iteration work is more fundamental than the generator work (and comprehensions).  I suspect this should perhaps be three separate proposals.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/06/05 04:34</em>
</p>

</div>
<!-- SECTION [11560-12884] -->
<a name="iterators_and_generators"></a><h1>Iterators and Generators</h1>
<div class="level1">

<p>
 Given the years of development in Python and similarities to ECMAScript in application domains and programmer communities, we would rather follow than lead.  By standing on Python&rsquo;s shoulders we reuse developer knowledge as well as design and implementation experience.  The trick then becomes not borrowing too much from Python, just enough to gain the essential benefits: structured value-generating continuations and a general iteration protocol.  The proposal in brief follows.
</p>

</div>
<!-- SECTION [12885-13407] -->
<a name="generators"></a><h2>Generators</h2>
<div class="level2">

<p>
 Copy proposal <a href="http://www.python.org/peps/pep-0255.html" class="urlextern" target="_blank" title="http://www.python.org/peps/pep-0255.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">PEP 255</a>, which is part of standard Python now. Example that prints the first ten Fibonacci numbers:
</p>
<pre class="code javascript"><span class="kw2">function</span> fib<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  let i = <span class="nu0">0</span>, j = <span class="nu0">1</span>;
  <span class="kw1">while</span> <span class="br0">&#40;</span><span class="kw2">true</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    yield i;
    <span class="br0">&#91;</span>i, j<span class="br0">&#93;</span> = <span class="br0">&#91;</span>j, i + j<span class="br0">&#93;</span>;
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw2">var</span> g = fib<span class="br0">&#40;</span><span class="br0">&#41;</span>;
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> i = <span class="nu0">0</span>; i &lt; <span class="nu0">10</span>; i++<span class="br0">&#41;</span>
  <span class="kw3">print</span><span class="br0">&#40;</span>g.<span class="me1">next</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;</pre>
<p>
function containing <code>yield</code> is a generator, which when called binds formal parameters to actual arguments but evaluates no part of its body.  Instead, it returns a generator-iterator.  Each call to the <code>next</code> method of this iterator resumes evaluation of the generator function and returns the result of the next <code>yield</code>.
</p>

</div>
<!-- SECTION [13408-14109] -->
<a name="array_comprehensions"></a><h3>Array comprehensions</h3>
<div class="level3">

<p>
 Copy proposal <a href="http://www.python.org/peps/pep-0202.html" class="urlextern" target="_blank" title="http://www.python.org/peps/pep-0202.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">PEP 202</a> as well, for array comprehensions: 
</p>
<pre class="code">var ten_squares = [i*i for i in range(10)]</pre>

<p>
 Notes:
</p>
<ul>
<li class="level1"><div class="li"> The loop variable <code>i</code> is lexically scoped by the brackets.</div>
</li>
<li class="level1"><div class="li"> <code>range</code> is an <code>Array</code> constructor patterned after Python&rsquo;s <code>range</code>.</div>
<ul>
<li class="level2"><div class="li"> Is <code>range</code> too likely a name collision candidate?</div>
</li>
<li class="level2"><div class="li"> We can&rsquo;t use <code>Range</code> because of the <a href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113/ranges.html" class="urlextern" target="_blank" title="http://www.w3.org/TR/2000/REC-DOM-Level-2-Traversal-Range-20001113/ranges.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">DOM Range function</a>.</div>
</li>
<li class="level2"><div class="li"> Being different from Python just makes for confusion, so <code>range</code> should take <code>int</code> arguments of the form ([<em>start</em>, ]<em>stop</em>[, <em>step</em>]).</div>
</li>
<li class="level2"><div class="li"> Should there be a literal notation for ranges?  See the rejected <a href="http://www.python.org/peps/pep-0204.html" class="urlextern" target="_blank" title="http://www.python.org/peps/pep-0204.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">PEP 204</a>.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> No parenthesization as in a <code>for-in</code> loop is required.</div>
<ul>
<li class="level2"><div class="li"> This is easy on eyes and wrists, but it doesn&rsquo;t reuse existing syntax, so users and implementors can&rsquo;t reuse knowledge and parsing code.  Would it be better to use a more concise, Math-y syntax?</div>
</li>
</ul>
</li>
</ul>
<hr noshade="noshade" size="1" />

<p>
Array comprehensions looks like surface syntax that should perhaps be broken out as a separate proposal.  The meaning of the above is 
</p>
<pre class="code">
    var ten_squares =
        (function () { 
            var a = new Array;
            for ( i=0 ; i &lt; 10 ; i++ )
              a[i] = i*i;
            return a;
         })()
</pre>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/04/07 06:17</em>
</p>

<p>
Array comprehensions are definitely surface syntax, but not over a three-part <code>for</code> &ndash; rather over a <code>for-in</code> loop.  The lexical scope for the loop variable comes for free &ndash; no <code>let</code> required.  And the right operand of <code>in</code> is iterated using the standard iteration protocol, so it could be an array, a generator, an iterator itself, or any object.
</p>

<p>
This proposal needs to be re-drafted, but I&rsquo;d like to keep array comprehensions here, to line up with the other Pythonic elements.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/04/07 13:41</em>
</p>

</div>
<!-- SECTION [14110-16150] -->
<a name="generator_expressions"></a><h3>Generator expressions</h3>
<div class="level3">

<p>
 Consider copying proposal <a href="http://www.python.org/peps/pep-0289.html" class="urlextern" target="_blank" title="http://www.python.org/peps/pep-0289.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">PEP 289</a> too, for generator expressions: 
</p>
<pre class="code">sum(i*i for i in range(10))</pre>

<p>
 See the PEP for motivation, beware grammatical and variable binding issues:
</p>
<ul>
<li class="level1"><div class="li"> A generator expression must be parenthesized unless it is the only argument to a function call.</div>
</li>
<li class="level1"><div class="li"> Python late-binds free variables in generator expressions, so if the generator is not iterated until after the free variable changes, the later value will be used, contrary to lexical order.</div>
</li>
<li class="level1"><div class="li"> This is akin to a loop capturing but not calling ECMAScript closures that use the loop variable, then calling after the loop &ndash; the final value of the loop variable will be used for all calls.</div>
</li>
</ul>

</div>
<!-- SECTION [16151-16895] -->
<a name="iterators"></a><h2>Iterators</h2>
<div class="level2">

<p>
 Pythonic generators build on Python&rsquo;s iteration protocol, <a href="http://www.python.org/peps/pep-0234.html" class="urlextern" target="_blank" title="http://www.python.org/peps/pep-0234.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">PEP 234</a>. A minimum working subset translated to ECMAScript might include: 
</p>
<ul>
<li class="level1"><div class="li"> A new <code>Iterator</code> constructor callable with or without operator <code>new</code>.</div>
<ul>
<li class="level2"><div class="li"> <code>Iterator(obj)</code> calls <code>obj.__iterator__()</code> to create an iterator for <code>obj</code>.</div>
</li>
<li class="level2"><div class="li"> <code>Object.prototype.__iterator__</code> returns an iterator over enumerable property identifiers in its <code>this</code> parameter.</div>
</li>
<li class="level2"><div class="li"> Again, why be different from Python at all?  Why not <code>iter</code> for the constructor-function and <code>__iter__</code> for the object hook?</div>
<ul>
<li class="level3"><div class="li"> Counter-arguments:</div>
<ul>
<li class="level4"><div class="li"> We don&rsquo;t support the <code>iter(callable, sentinel)</code> in this proposal.</div>
</li>
<li class="level4"><div class="li"> The slippery slope to Python emulation turns into a cliff very soon.  <acronym title="JavaScript">JS</acronym> has <code>String</code> not <code>str</code>, <code>null</code> not <code>None</code>, etc.</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Arguments in favor:</div>
<ul>
<li class="level4"><div class="li"> <code>__iter__</code> is not a constructor, it returns the object on which it is called if that object is an iterator.  See <a href="http://www.python.org/peps/pep-0234.html" class="urlextern" target="_blank" title="http://www.python.org/peps/pep-0234.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">PEP 234</a> (note that we are not proposing the older <code>__getitem__</code> protocol).</div>
</li>
<li class="level4"><div class="li"> To be consistently Pythonic, we <strong>should</strong> support <code>iter(callable, sentinel)</code> and <code>range</code>, without name changes.</div>
</li>
<li class="level4"><div class="li"> The <code>iter</code> name-form is a bit terse for <acronym title="JavaScript">JS</acronym>/ES, but not fatally so given <code>RegExp</code>, <code>exec</code>, etc.</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> Resolution: we have to draw a line between <acronym title="JavaScript">JS</acronym>/ES and Python somewhere not too far down the slippery slope, and just stylistically speaking, the constructor/converter function and its <code>__</code>-bracketed internal method look like the best place.</div>
<ul>
<li class="level4"><div class="li"> <code>Iterator</code> not <code>iter</code>, but see below for elaboration on the protocol to handle prototypes and value iteration.</div>
</li>
<li class="level4"><div class="li"> <code>obj.__iterator__()</code> is the internal method delegated to by <code>Iterator(obj)</code>.</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> A single iteration protocol to iterate over an object <code>obj</code> in response to a <code>for-in</code> loop, array comprehension, or generator expression:</div>
<ul>
<li class="level2"><div class="li"> Let <code>iter = Iterator(obj)</code>.</div>
</li>
<li class="level2"><div class="li"> Call <code>iter.next()</code> for each iteration</div>
<ul>
<li class="level3"><div class="li"> If <code>iter.next()</code> returns normally, its result is the next value in the iteration.</div>
</li>
<li class="level3"><div class="li"> If <code>iter.next()</code> throws an exception:</div>
<ul>
<li class="level4"><div class="li"> If <code>StopIteration</code> or an object derived from it is thrown, stop iterating with normal completion.</div>
</li>
<li class="level4"><div class="li"> Else propagate all other exceptions, aborting the iteration.</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

</div>
<!-- SECTION [16896-19322] -->
<a name="value_iteration_and_shadowing"></a><h3>Value Iteration and Shadowing</h3>
<div class="level3">

<p>
 How to specify <code>for-each-in</code> loops in terms of the protocol?
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x65%3B%26%23x64%3B%26%23x77%3B%26%23x73%3B%26%23x6d%3B%26%23x69%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x65;&#x64;&#x77;&#x73;&#x6d;&#x69;&#x74;&#x68;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Edwin Smith</a> 2006/02/16 12:05</em> Maybe take a page from the other newly exposed function hooks:
</p>
<pre class="code">
    class C {
       function for in C() { ... yield name ... }
       function for each in C() { ... yield value ... }
    }
</pre>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/02/23 22:05</em> While this works, we should avoid specifying primitive iteration in terms of generators, since generators implement the iteration protocol.  Rather, we merely need <code>Object.prototype.__iterator__()</code>, when called via <code>obj.__iterator__()</code> from <code>Iterator(obj)</code> from <code>for (name in obj)</code>, to return an object whose <code>next</code> method iterates over enumerable properties of <code>obj</code> (and only <code>obj</code>, not its prototypes).
</p>

<p>
The problem with <code>for-each-in</code> as sketched above using extended class constructor function syntax is that each iteration must return the property name as well as the value, so that prototype properties can be shadowed correctly by the common <code>for-each-in</code> loop logic.  Otherwise, we would have to delegate prototype iteration and shadowing to each iterator implementation, which is redundant and hazardous (some may fail to follow the Edition 3 shadowing rule), and which also requires an extra argument (the original or &ldquo;starting&rdquo; object along whose prototype chain another object may contain a property that &ldquo;shadows&rdquo; the currently visited prototype property).
</p>

<p>
The same consideration applies to <code>for-in</code> loops: the logic to handle shadowing (ECMA-262 Edition 3 section 12.6, last paragraph) should be common among all iterator implementations.  An iterator enumerates only its directly referenced target object.  An iterator does not enumerate the unshadowed properties of the target&rsquo;s prototype, or of other objects (grand-prototypes, great-grand-protos, etc., or entirely unrelated objects).
</p>

</div>
<!-- SECTION [19323-21290] -->
<a name="value_iteration_proposal"></a><h3>Value Iteration Proposal</h3>
<div class="level3">

<p>
 Suppose we define <code>Iterator(obj, true)</code> to mean create an iterator over property values, not property names, in obj.  This forwards to <code>obj.__iterator__(true)</code> as expected.  Then the returned iterator&rsquo;s <code>next</code> method should return successive values, not names, of enumerable properties in <code>obj</code>.
</p>

<p>
But lacking a cheap (defined as not requiring an object allocation per iteration step) way to return a <code>(name, value)</code> pair from such an iterator, how will the common <code>for-each-in</code> loop logic check for shadowing, and skip shadowed properties as it iterates over prototypes of the original or &ldquo;starting&rdquo; object named as the right operand of <code>in</code> in the loop head?
</p>

<p>
One way would be to set <code>iter.lastPropertyName</code> from <code>iter.next()</code> to tell the name of the property whose value was last returned by <code>iter.next</code>.  This requires another property than <code>next</code> to be implemented by all would-be iterator objects.  It also programs by side-effects on <code>iter</code>, which precludes what <a href="http://www.lua.org/" class="urlextern" target="_blank" title="http://www.lua.org/" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Lua</a> calls <a href="http://www.lua.org/pil/7.3.html" class="urlextern" target="_blank" title="http://www.lua.org/pil/7.3.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">stateless iterators</a>.  Mutating <code>iter</code> seems very wrong here.  Functional purity demands that value-iterators return a pair <code>(name, value)</code>.
</p>

<p>
So let&rsquo;s allow <code>(name, value)</code> <a href="doku.php%3Fid=proposals:group_assignment.html" class="wikilink1" title="proposals:group_assignment" onclick="return svchk()" onkeypress="return svchk()">group return</a>.  Then we could simplify <code>Iterator(obj)</code> and the underlying <code>obj.__iterator__()</code> protocol to require <code>(name, value)</code> pair return from the iterator&rsquo;s <code>next</code> method.  Or if performance of <code>for-in</code> would be degraded too much by this simplification, we can stick with the <code>Iterator(obj, true)</code> definition.
</p>

</div>
<!-- SECTION [21291-22934] -->
<a name="type_safety"></a><h2>Type Safety</h2>
<div class="level2">

<p>
 The Pythonic protocol sketched here does not allow us to use <a href="doku.php%3Fid=proposals:type_parameters.html" class="wikilink1" title="proposals:type_parameters" onclick="return svchk()" onkeypress="return svchk()">type parameters</a> to good effect.  We might rather use <code>Iterator&lt;T&gt;</code> for iterable type <code>T</code>, in order to find or create an iterator whose <code>next</code> method had the signature 
</p>
<pre class="code">function next() : T</pre>

<p>
 More thought required here.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/02/23 19:40</em>
</p>

</div>
<!-- SECTION [22935-23324] -->
<a name="clarifications"></a><h2>Clarifications</h2>
<div class="level2">

<p>
 Let&rsquo;s forget Python for now and figure out what the various concepts of interator and generator mean in ecmascript.
</p>

<p>
Here is my understanding: 
</p>
<ul>
<li class="level1"><div class="li"> generator - a function that generates values or throws an exception if none are available</div>
</li>
<li class="level1"><div class="li"> iterator - a function that generates values or throws an exception if none are avaiable</div>
</li>
<li class="level1"><div class="li"> generator definition - a function definition containing at least one yield statement, which results in a generator factory</div>
</li>
<li class="level1"><div class="li"> generator factory - a function that returns a generator</div>
</li>
</ul>
<pre class="code">
  function fib() {  // define generator factory
    var i = 0, j = 1
    while (true) {
      yield i
      var t = i
      i = j
      j += t
    }
  }
  
  var gen = fib()  // make a generator
  for (var i = 0; i &lt; 10; i++)
    print(gen())  // call a generator, notice I erased .next()
</pre>
<ul>
<li class="level1"><div class="li"> iterators are generators; it is only useful to talk about generators when we talk about how iterators are defined via yield functions</div>
</li>
<li class="level1"><div class="li"> for-in and for-each-in call the iterator factories KeyIterator(o) and ValueIterator(o) respectively, where o is the expression on the rhs of <code>in</code></div>
</li>
<li class="level1"><div class="li"> iterators are any callable objects (no next method) that throws an exception when it has no more values to return</div>
</li>
</ul>

<p>
 &lt;meeting time, I&rsquo;ll resume editing later&gt;
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/03/03 11:24</em> 
</p>
<hr noshade="noshade" size="1" />

<p>
First, I think it&rsquo;s a mistake to ignore Python.  I know you wrote &ldquo;for now&rdquo;, but redefining terms from PEP-255 doesn&rsquo;t help clarify why not to follow much of PEP-255.
</p>

<p>
In general, there&rsquo;s no point forgetting Python if it has covered the same thought-space and recorded the arguments, which the PEP process has done in a pretty thorough way.
</p>

<p>
In particular, although the trade-off between <code>.next()</code> and <code>()</code> is a close call, the design whereby <code>yield</code> making a generator function that returns a generator-iterator looks like the right one to us, and I&rsquo;ve heard no counter-proposals.  It also seems we agree on the economic wins and the low-level mechanics of throwing the <code>StopIteration</code> singleton from an iterator once it is exhausted.
</p>

<p>
From this completely Pythonic design, we have some freedom to develop an iteration protocol.  The iteration protocol should hide the <code>StopIteration</code> exception and the <code>.next()</code> vs. <code>()</code> issue behind <code>for-in</code> loop syntax.  We&rsquo;re still tracing Python&rsquo;s steps, and there&rsquo;s no point in ignoring its evolutionary history when we agree with this much of it, and we may want to jump to an end-point.  I argue that given this much similarity, there is no point in preferring <code>()</code> over <code>.next()</code>.
</p>

<p>
Second, iterators are not generators.  Generators are a factory for a kind of iterator, but iteration is lower-level as I argued in the conference call.  We acknowledged that iteration is more primitive: 
</p>
<ul>
<li class="level1"><div class="li"> Iteration does not require a generator or any kind of coroutine.</div>
</li>
<li class="level1"><div class="li"> Iteration pre-exists in Edition 3 without generators, but combined with prototype shadowing.</div>
</li>
<li class="level1"><div class="li"> Iteration consists of <code>for-in</code> syntax and common prototype shadowing logic layered on top of a meta-object protocol, of which generators are but one implementation.</div>
</li>
<li class="level1"><div class="li"> An <code>iter</code> (Python) or <code>Iterator</code> (ES4 proposed) function is a converter, not a factory &ndash; it delegates to a MOP method on the passed-in object, in order to let iterators return themselves.</div>
</li>
<li class="level1"><div class="li"> The MOP method, <code>__iter__</code> (Python) or <code>__iterator__</code> (ES4 proposed, tentatively!) is primitive too in that it does not handle prototype shadowing, or necessarily iterate over the enumerable properties of any object other than its <code>this</code> parameter.</div>
</li>
</ul>

<p>
 It&rsquo;s worth reiterating (heh) that I am proposing a standard ES4 MOP on which <code>for-in</code> loops and array comprehensions depend.  This is not reflection, which we are trying to make optional.  It&rsquo;s a <em>bona-fide</em> meta-object protocol.
</p>

<p>
Third, as pointed out in this proposal, and in the meeting, <code>ValueIterator</code> or anything like it needs to return each enumerable property&rsquo;s key as well as value, so that common <code>for-in</code> loop runtime code can handle prototype shadowing.  But this does not mean that the iteration protocol should delegate shadowing to each iterator implementation.  Doing so is redundant, hazardous and anti-modular.  Each iterator should worry about one object only.
</p>

<p>
Where we have trouble following Python is not in <code>.next()</code> vs. <code>()</code>.  Rather, we would like to address the following gaps: 
</p>
<ul>
<li class="level1"><div class="li"> Type-safety: Python doesn&rsquo;t have type annotations (or didn&rsquo;t at the time of PEP-202).</div>
</li>
<li class="level1"><div class="li"> Backward-compatibility: we can&rsquo;t iterate keys of an <code>Array</code> as Python does for its similar lists.</div>
</li>
<li class="level1"><div class="li"> Backward-compatibility: we need to return key and value from any value iterator, so <code>for-each-in</code> can do its prototype shadowing thing.</div>
</li>
</ul>

<p>
 Given these issues, ES4 must differ from Python at some point, or dividing line rather, in the design space.  But not in all ways.
</p>

<p>
More in a bit with some proposed solutions to bridge these gaps.  Comments welcome on anything and everything.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/03/03 20:19</em>
</p>

</div>
<!-- SECTION [23325-28416] -->
<a name="comments_on_reference_code"></a><h1>Comments on reference code</h1>
<div class="level1">
<pre class="code javascript"><span class="co1">// DAH: should this be (string|Name) or (double|string|Name)</span>
type EnumerableId      = <span class="br0">&#40;</span>string, <span class="kw3">Name</span><span class="br0">&#41;</span>;
<span class="co1">// DAH: now spelled  [...EnumerableId]</span>
type EnumerableIdArray = <span class="br0">&#91;</span>EnumerableId<span class="br0">&#93;</span>;
&nbsp;
<span class="kw2">class</span> Enumerator.&lt;T&gt; <span class="br0">&#123;</span>
  type ResultFun = <span class="kw2">function</span><span class="br0">&#40;</span>EnumerableId, Object!<span class="br0">&#41;</span> : T;
&nbsp;
  <span class="co1">// DAH: both ResultFun and e are non-nullable, so must be set in settings</span>
  <span class="kw2">function</span> Enumerator<span class="br0">&#40;</span>v, f : ResultFun, e : boolean = <span class="kw2">false</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    initial_obj = <span class="br0">&#40;</span>v <span class="kw1">is</span> Object<span class="br0">&#41;</span> ? v : <span class="kw2">null</span>;
    current_obj = initial_obj;
    current_ids = magic::getEnumerableIds<span class="br0">&#40;</span>initial_obj<span class="br0">&#41;</span>;
    result_fun = f;
    enumerate = e;
  <span class="br0">&#125;</span>
&nbsp;
  <span class="co1">// DAH: shouldn't this also take a ResultFun and boolean to pass to the constructor?</span>
  meta static <span class="kw2">function</span> invoke<span class="br0">&#40;</span>v<span class="br0">&#41;</span> : Iterator.&lt;T&gt;
    <span class="kw2">new</span> Enumerator<span class="br0">&#40;</span>v<span class="br0">&#41;</span>;
&nbsp;
  iterator <span class="kw2">function</span> get<span class="br0">&#40;</span>e : boolean = <span class="kw2">false</span><span class="br0">&#41;</span> : Iterator.&lt;T&gt;
    <span class="br0">&#40;</span>e == enumerate<span class="br0">&#41;</span> ? <span class="kw1">this</span> : <span class="kw2">new</span> Enumerator.&lt;T&gt;<span class="br0">&#40;</span>inital_obj, result_fun, e<span class="br0">&#41;</span>;
&nbsp;
  <span class="kw2">public</span> <span class="kw2">function</span> next<span class="br0">&#40;</span><span class="br0">&#41;</span> : T <span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>current_obj === <span class="kw2">null</span><span class="br0">&#41;</span>
      <span class="kw1">throw</span> StopIteration;
&nbsp;
  loop:
    <span class="kw1">while</span> <span class="br0">&#40;</span><span class="kw2">true</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="co1">// DAH: this needs to be *while* (current_index === current_ids.length) to skip *all* empty enumerable arrays in chain</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>current_index === current_ids.<span class="me1">length</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>!enumerate<span class="br0">&#41;</span>
          <span class="kw1">throw</span> StopIteration;
&nbsp;
        current_obj = magic::getPrototype<span class="br0">&#40;</span>current_obj<span class="br0">&#41;</span>;
        <span class="kw1">if</span> <span class="br0">&#40;</span>current_obj === <span class="kw2">null</span><span class="br0">&#41;</span>
          <span class="kw1">throw</span> StopIteration;
 
        current_ids = magic::getEnumerableIds<span class="br0">&#40;</span>current_obj<span class="br0">&#41;</span>;
        current_index = <span class="nu0">0</span>;
      <span class="br0">&#125;</span>
&nbsp;
      let id : EnumerableId = current_ids<span class="br0">&#91;</span>current_index++<span class="br0">&#93;</span>;
&nbsp;
      <span class="kw1">for</span> <span class="br0">&#40;</span>let obj : Object = initial_obj; obj !== current_obj; obj = magic::getPrototype<span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>magic::hasOwnProperty<span class="br0">&#40;</span>obj, id<span class="br0">&#41;</span><span class="br0">&#41;</span>
          <span class="kw1">continue</span> loop;
      <span class="br0">&#125;</span>
 
      <span class="kw1">if</span> <span class="br0">&#40;</span>magic::hasOwnProperty<span class="br0">&#40;</span>current_obj, id<span class="br0">&#41;</span><span class="br0">&#41;</span>
        <span class="kw1">return</span> result_fun<span class="br0">&#40;</span>id, initial_obj<span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>
&nbsp;
  <span class="kw2">private</span> <span class="kw2">var</span> initial_obj   : Object,
              current_obj   : Object,
              current_ids   : EnumerableIdArray,
              <span class="co1">// DAH: uint no longer exists. double?</span>
              current_index : uint,
              result_fun    : ResultFun,
              enumerate     : boolean;
<span class="br0">&#125;</span>
&nbsp;
<span class="kw2">const</span> <span class="kw2">function</span> DEFAULT_GET<span class="br0">&#40;</span>start: Object!, deep: boolean = <span class="kw2">false</span><span class="br0">&#41;</span>: Iterator.&lt;string&gt;
  <span class="kw2">new</span> Enumerator.&lt;string&gt;<span class="br0">&#40;</span>start,
                          <span class="co1">// DAH: should be function (id: EnumerableId, obj: Object!): string</span>
                          <span class="kw2">function</span> <span class="br0">&#40;</span>id: string, obj: Object!<span class="br0">&#41;</span>: string
                            <span class="br0">&#40;</span>id <span class="kw1">is</span> <span class="kw3">Name</span><span class="br0">&#41;</span> ? id.<span class="me1">identifier</span> : string<span class="br0">&#40;</span>id<span class="br0">&#41;</span>,
                          deep<span class="br0">&#41;</span>;</pre>
</div>
<!-- SECTION [28417-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/9/9d58ff9e7e5da2785fa4432217fb250b.xhtml used -->
</body>
</html>
