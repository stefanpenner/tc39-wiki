====== Type Language ======

<code>
T ::=
   (T,..,T)       union type
   [T,..,T]       array type (last type can be repeated 0 or more times)
   {l:T,..,l:T}   structural object type, each l is a label
   function(U,S1,..,Sn, Sn+1=,..,Sm=)       function type, no rest args
   function(U,S1,..,Sn, Sn+1=,..,Sm=,...T)  function type with rest arguments
   ...
</code>

====== Well-Formed Types ======

^Notation^Meaning^
|''|- T ''|//type ''T'' is well-formed//|

Note that we do not make the typing environment explicit here. Most of the rules about well-formed types are standard and fairly straightforward. 

One exception is that, in function types, the rest args **must** be an array that supports zero-or-more elements.

====== Type Relationships ======

There are four different relations between types: //equality// (''T = U''), //subtyping// (''T <: U''), //compatibility// (''T ~: U''), and //convertibility// (''T ~~> U'').
These are defined in [[spec:type_relations]].

For clarity, these rules are presented more in a declarative style than algorithmic, and this presentation is focused more on being expository than complete, since we always have the reference implementation for completeness.

====== Resolved ======

  * We have separate notions of program variables and type variables, but type variables exist at runtime and can be used where program variables are expected. The converse does not hold - program variables may not appear in a type context.
  * [[meetings:minutes_feb_21_2007#alpha-renaming]] (renaming bound variable to avoid collision). This is required in the language, we just need to say somewhere in the English spec that alpha-renaming is implicitly performed where needed, and then everywhere else we can ignore the problem. This is the standard approach in the PL literature.

====== Questions ======

  * Trac 122: ''Set.<*> ~: Set.<int>''
  * Trac 127: Is ''*'' a top type? micro.sml argues yes for performance.
  * Relationship between nominal and structural types, for subtyping and compatibility.
  * E4X types and expression forms
  * translation of non-nullable types? (treat nullable built-ins ''T'' as sugar for ''T?'' and treat ''T!'' as the "real" type?)
  * combined optional args and rest args? - blocked on bounds proposal
  * bug? every class is a subtype of the structural type containing its fixtures; but we also have ''Object = {}'' even though ''Object'' has some fixtures. Perhaps these fixtures are implicit in ''{}'', and in other structural object types.

====== Still missing... ======

  * typing of prototypes
  * parameterized types (these are still crystallizing)
    * typedefs
  * scope of type parameters
    * limited in class initialization (initializers, settings)
    * limited in inheritance specifiers (see [[discussion:type_parameters]])
  * types ''null'' and ''undefined'' don't allow object operations (formalize this via compatibility rules?)
  * nominal subtyping details
  * runtime types and conversions

Type checking:

  * this should all be specified with **fixtures** -- I'm not sure - CF
  * is the ''Reference'' type constructor the right thing?
  * restricted uses of name ''eval''
  * optional arguments for function types (see [[meetings:minutes_feb_21_2007#function types with initializers]])
  * definition of âŠ“
  * adding fields
  * lookup(D,Ident,I) = T
  * method decls
  * namespaces, statically vs. dynamically bound identifiers
  * ''mustReturn'', a predicate on statements and blocks
  * numbers and other built-ins
  * overloaded ''+''
  * other operator overloading
  * many forms of "callable"
    * classes
    * objects with special call method
  * ''new e'' where ''e'' has type ''Class'', vs. ''new I'' where ''I'' is a statically known class name
  * conversion between class types and object types? (''public'' properties only)
  * generator functions <=> return type
  * generator functions <=> ''yield'' syntactic restrictions
  * need to formalize the notion of "statically known name" and compile-time name resolution
  * more sophisticated representation of class information to deal with
    * constructor settings
    * rest args
    * etc.
  * no partially instantiated parameterized types (only either uninstantiated or totally instantiated)
  * nullables as unions? what about union ordering?



====== Runtime type checking ======

Our overall approach to gradual typing, the type ''*'', the ''strict'' and ''standard'' modes, etc is summarized for a small language in the file ''playground/micro.sml'' under monotone, and included below.

We summarize some key issues here.
We have two modes, ''strict'' (which may report type errors at type-checking time),
and ''standard'' (which doesn't).

In both modes, we feed the input program through a verifier (aka type checker)
that possibly reports type errors (though not in ''standard'' mode),
and which outputs a verified program. The verified program is well-typed in that it only relies on subtyping: for an assignment ''x = e'', the type of ''e'' is guaranteed to be a subtype of the slot ''x''.

The verification process may insert casts to achieve this guarantee.
If a value ''v'' of dynamic type ''S'' is being casted to type ''T'',
then the behavior of the cast depends on the relationship between ''S'' and ''T''.
  * If ''S'' is a subtype of ''T'', then ''v' is returned as the result of the cast.
  * If ''S'' is compatible with ''T'', then ''v' is returned as the result of the cast but its safety bit is set, meaning that the relationship between the dynamic type ''S'' of ''v'' and its static view may now be just compatibility, instead of subtyping.
  * If ''S'' is *not* compatible with ''T'', then a run-time error is signaled.

Various operations on values (function invocation, array dereference, etc) need to inspect this bit and handle it appropriately.

===== playground/micro.sml =====

<code>
(* -*- mode: sml; mode: font-lock; tab-width: 60; insert-tabs-mode: nil; indent-tabs-mode: nil -*- *)
(* vim: set ts=4 sw=4 et: *)

(* This is an implementation of a toy language to express and clarify
 * a number of issues relating to the ES4 type system in a simpler
 * context, and may also help to shake out bugs in the type system earlier. 
 * - Cormac
 *)

(*********** environments ***********)
(* variable names are just strings,
 * environments are polymorphic to support both value and type environments
 *)

exception UnboundVariable of string

type 'a ENV = (string * 'a) list

fun extend (env:'a ENV) (x:string) (v:'a) : 'a ENV =
    (x,v)::env

fun lookup (env:'a ENV) (x:string) : 'a =
    case env of
        [] => raise UnboundVariable x
      | (y,v)::r => if (x=y) then v else lookup r x

(*********** Types, subtyping, and compatibility ***********)

datatype TYPE =
         AnyType  (* the type "*" *)
       | IntType
       | FunType of TYPE * TYPE
       | RefType of TYPE

(* Q: Is AnyType the top type? *)

fun subtype (t1:TYPE) (t2:TYPE) : bool =
    case (t1,t2) of
        (AnyType,AnyType) => true
      | (IntType,IntType) => true
      | (FunType(s1,t1), FunType(s2,t2)) =>
        (subtype s2 s1) andalso (subtype t1 t2)
      | (RefType s, RefType t) => (subtype s t) andalso (subtype t s)
      | _ => false

fun compatible (t1:TYPE) (t2:TYPE) : bool =
    case (t1,t2) of
        (_,AnyType) => true
      | (AnyType,_) => true
      | (IntType,IntType) => true
      | (FunType(s1,t1), FunType(s2,t2)) =>
        (compatible s2 s1) andalso (compatible t1 t2)
      | (RefType s, RefType t) =>
        (compatible s t) andalso (compatible t s)
      | _ => false

(*********** The expression language **********)

datatype EXPR =
         IntExpr of int
       | VarExpr of string
       | LetExpr of string * TYPE * EXPR * EXPR
       | FunExpr of string * TYPE * TYPE * EXPR  (* arg and result types *)
       | CastExpr of TYPE * EXPR
       | AppExpr of EXPR * EXPR
       | RefExpr of TYPE * EXPR     (* allocate, dereference, and update ref cells *)
       | GetExpr of EXPR
       | SetExpr of EXPR * EXPR
       | ExpectedType of TYPE * EXPR

(*********** Verify routines ***********)

(* some type errors *)

exception BadFunExpr of EXPR * TYPE
exception BadRefExpr of EXPR * TYPE
exception StaticTypeError of (EXPR * TYPE * TYPE)

datatype MODE =
         Standard
       | Strict

(* The expression "e" of type "s" is being converted to type "t" in mode "mode".
 * This function either returns "e" itself, raises a type error,
 * or wraps "e" in a cast to "t", as appropriate.
 *)

fun check (mode:MODE) (e:EXPR) (s:TYPE) (t:TYPE) : EXPR =
    if (subtype s t)
    then e
    else if (compatible s t) orelse mode=Standard
    then CastExpr (t,e)
    else raise StaticTypeError (e,s,t)

(* Type checks expression "e" in type environment "n" and mode "mode",
 * and returns a pair of 
 * an expression (which is "e" with extra casts where necessary)
 * and the inferred type of "e".
 *
 * The resulting expression satisfies the invariant that if an expression of type "s"
 * is bound to a variable of type "t", then "s" is a subtype of "t" - this invariant
 * is ensured via dynamic casts if necessary, both in Strict and Standard mode.
 *)
       
fun verify (mode:MODE) (n:TYPE ENV) (e:EXPR) : (EXPR * TYPE) =
    case e of
        IntExpr n => (e,IntType)
      | VarExpr x => (e, lookup n x)
      | LetExpr (x,t,e,body) => 
        let val e' = verifyAndCheck mode n e t
            val n' = extend n x t
            val (body',bodyTy) = verify mode n' body
        in
            (LetExpr (x, t, e', body'), bodyTy)
        end
      | FunExpr (x,t1,t2,e) => 
        let val e' = verifyAndCheck mode (extend n x t1) e t2
        in
            (FunExpr(x,t1,t2,e'), FunType(t1,t2))
        end
      | CastExpr (ty,e) =>
        let val (e',ty) = verify mode n e 
        in
            (CastExpr(ty,e'), ty)
        end
      | AppExpr (e1,e2) =>
        let val (e1',ty1) = verify mode n e1
        in
        case ty1 of
            FunType (argty,resty) =>
            (ExpectedType (resty, 
                           AppExpr(e1', 
                                   verifyAndCheck mode n e2 argty)), 
             resty)
          | AnyType =>
            (ExpectedType (AnyType, 
                           AppExpr( CastExpr( FunType(AnyType,AnyType), e1'),
                                    verifyAndCheck mode n e2 AnyType)),
             AnyType)
          | _ => raise BadFunExpr (e1',ty1)
        end
      | RefExpr (t,e) =>
        (RefExpr (t, verifyAndCheck mode n e t), RefType t)
      | GetExpr e =>
        let val (e',t) = verify mode n e in
            (ExpectedType (t, GetExpr e'), t)
        end
      | SetExpr (e1, e2) =>
        let val (e1',t1) = verify mode n e1
        in
            case t1 of
                RefType s =>
                (SetExpr (e1', 
                          verifyAndCheck mode n e2 s),
                 s)
              | AnyType =>
                (SetExpr (CastExpr(RefType AnyType, e1'), 
                          verifyAndCheck mode n e2 AnyType),
                 AnyType)
              | _ => raise BadRefExpr (e1',t1)
        end

and verifyAndCheck (mode:MODE) (n:TYPE ENV) (e:EXPR) (t:TYPE) =
    let val (e',t') = verify mode n e in
        check mode e' t' t
    end


(*********** Evaluation, run-time values, and conversion ***********)

(* Every closure has a "safe" bit. 
 * This Safe bit, together with the Strict/Standard mode, constrain the relationship between
 * the dynamic type of the closure  and the static type of the reference to the closure,
 * as follows:
 * 
 * SAFEBIT     MODE                    typing relation
 * Safe        Strict or Standard      subtyping
 * Unsafe      Strict                  compatibility
 * Unsafe      Standard                no constraint
 *)

datatype SAFEBIT =
         Safe
       | Unsafe

datatype VAL =
         IntVal of int
       | ClosureVal of string * TYPE * TYPE * EXPR * VAL ENV * SAFEBIT
       | RefVal of TYPE * VAL ref * SAFEBIT

exception NotAClosure of VAL
exception NotARef of VAL
exception ConversionError of (VAL * TYPE)

fun typeOfVal (v:VAL) : TYPE =
    case v of
        IntVal _ => IntType
      | ClosureVal (_,t1,t2,_,_,_) => FunType (t1,t2)      
      | RefVal (t,_,_) => RefType t

fun markUnsafe (v:VAL) : VAL =
    case v of
        IntVal _ => v
      | ClosureVal (x,t1,t2,body,env,_) => ClosureVal(x,t1,t2,body,env,Unsafe)
      | RefVal (t,v,_) => RefVal(t,v,Unsafe)

(* Converts a value "v" to type "t", 
 * raising an error if the type of "v" is not compatible with "t",
 * and setting the unsafe bit if the type of "v" is not a subtype of "t".
 *)

fun convert (v:VAL) (t:TYPE) : VAL =
    let val s = typeOfVal v in
        if subtype s t
        then v
        else if compatible s t
        then markUnsafe v
        else raise ConversionError (v,t)
    end

fun eval (n:VAL ENV) (e:EXPR) : VAL =
    case e of
        IntExpr n => IntVal n
      | VarExpr x => lookup n x
      | LetExpr (x,t,e,body) => eval (extend n x (eval n e)) body
      | FunExpr (x,t1,t2,e) => ClosureVal (x,t1,t2,e,n,Safe)
      | CastExpr (ty,e) => convert (eval n e) ty        
      | ExpectedType (retTy, AppExpr (e1,e2)) =>
        let in
            case (eval n e1) of
                ClosureVal (x,argTy,_,body,n2,safebit) =>
                let val argVal  = (eval n e2)
                    val argVal' = case safebit of Safe => argVal | Unsafe => convert argVal argTy
                    val resVal  = eval (extend n2 x argVal') body
                    (* tail call issues here *)
                    val resVal' = case safebit of Safe => resVal | Unsafe => convert resVal retTy
                in
                    resVal'
                end
              | v => raise NotAClosure v
        end
      | RefExpr (t,e) => RefVal(t, ref (eval n e), Safe)
      | ExpectedType (t, GetExpr e) =>
        let in
            case eval n e of
                RefVal (_,r,Safe) => !r
              | RefVal (s,r,Unsafe) => convert (!r) t
        end
      | SetExpr (e1,e2) =>
        let in
            case eval n e1 of
                RefVal (t,r,safebit) =>
                let val v = eval n e2 in
                    case safebit of 
                        Safe => r := v 
                      | Unsafe => r := convert v t;
                    v
                end
              | v => raise NotARef v
        end
        
(*********** Tests **********)

fun go (mode:MODE) (e:EXPR) : (EXPR*VAL) =
    let val (e',ty) = verify mode [] e 
        val v = eval [] e'
    in 
        (e',v)
    end

fun go2 (e:EXPR) =
    (go Standard e, go Strict e)

val idint : EXPR = FunExpr("x",IntType,IntType,VarExpr "x")
val idany : EXPR = FunExpr("x",AnyType,AnyType,VarExpr "x")
val idbad : EXPR = FunExpr("x",AnyType,IntType,VarExpr "x");

(*
(go2 idint);
(go2 idany);
(go2 idbad);
*)

(go2
     (LetExpr ("f" ,AnyType, idint,
               (AppExpr (VarExpr "f", 
                         IntExpr 4 
)))))
</code>


Function applications may require stacking to checks on the stack, leading to problems with tail recursion - see [[clarification:runtime_types_and_conversions]].

Some additional notes are at:
  * Type conversions and tail calls 
  * [[meetings:minutes_jul_27_2006]]
  * [[meetings:minutes_dec_13_2006]]
  * [[meetings:minutes_jan_24_2007]]


====== Miscellaneous Notes ======

  * ''const'' does not affect typing
  * patterns are desugared before type checking
  * hoisting is performed before type checking
  * ''v is T'' is defined to perform the subtyping algorithm
  * ''v to T'' performs the ''to''-method corresponding to the convertibility rules, or is a no-op if ''v'' is trivially convertible to ''T'' (i.e., it's already compatible with ''T''); the operation throws a ''TypeError'' if ''v'' is not convertible to ''T''
  * any global bindings in the host environment's library that the type checker knows about must be ''DontDelete'' and have a runtime type constraint
  * runtime restrictions for [[proposals:reformed_with]], [[proposals:resurrected_eval]], and reformed eval (see [[meetings:minutes_jan_24_2007]] and [[meetings:minutes_feb_06_2007]])
  * for now, ''()'' is illegal syntax, empty unions are verboten (see the relevant [[https://members.ecma-international.org/archives/tc39-tg1-545900/frm00829.html|TG1 mailing list thread]])
    * perhaps useful in future to restrict function bodies to forbid termination



==== A note on interfaces ====

  * interfaces allow method redeclaration with appropriate subtyping (covariant return, contravariant arg)
  * this might result in unimplementable interfaces, e.g. if two superinterfaces have versions of a method with unrelated return types; but this is legal, only on implementing will you see an error


===== Travel guide =====

Other pages of interest to the type system include:

^Section^Page^
|[[discussion:discussions]]|[[discussion:is_as_to]]|
|[[discussion:discussions]]|[[discussion:type_parameters]]|
|[[discussion:discussions]]|[[discussion:nullability]]|
|[[discussion:discussions]]|[[discussion:strict_and_standard_modes]]|
|[[spec:spec]]|[[spec:chapter_6_types]]|
|[[spec:spec]]|[[spec:type_system]] '' '' <- you are here|
|[[proposals:proposals]]|[[proposals:type_parameters]]|
|[[proposals:proposals]]|[[proposals:structural_types_and_typing_of_initializers]]|
|[[proposals:proposals]]|[[proposals:is_as_to]]|
|[[proposals:proposals]]|[[proposals:nullability]]|
|[[proposals:proposals]]|[[proposals:strict_and_standard_modes]]|
|[[proposals:proposals]]|[[proposals:switch_class]]|
|[[proposals:proposals]]|[[proposals:type_definitions]]|
|[[proposals:proposals]]|[[proposals:syntax_for_type_expressions]]|
|[[clarification:clarifications]]|[[clarification:type_system]]|
|[[clarification:clarifications]]|[[clarification:formal_type_system]]|
|[[clarification:clarifications]]|[[clarification:drop_traits]]|
|[[clarification:clarifications]]|[[clarification:runtime_types_and_conversions]]|
