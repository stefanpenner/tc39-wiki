<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=strawman:async_functions&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=strawman" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=strawman:async_functions&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#async_functions" class="toc">Async Functions</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#example" class="toc">Example</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#details" class="toc">Details</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#rewrite" class="toc">Rewrite</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#spawning" class="toc">Spawning</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#syntax" class="toc">Syntax</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#await" class="toc">await*</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#awaiting_non_-_promise" class="toc">Awaiting Non - Promise</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#surface_syntax" class="toc">Surface syntax</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#arrows" class="toc">Arrows</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#notes_on_types" class="toc">Notes on Types</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#api" class="toc">API</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#bigger_example" class="toc">Bigger example</a></span></li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#old_-_async_functions" class="toc">OLD - Async Functions</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#asynchronous_programming" class="toc">Asynchronous Programming</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#async_functions" class="toc">Async Functions</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#returning_values_from_async_functions" class="toc">Returning Values From Async Functions</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#throwing_from_async_functions" class="toc">Throwing From Async Functions</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#reference_implementation" class="toc">Reference Implementation</a></span></li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:async_functions&amp;do=export_html.html#see" class="toc">See</a></span></li>
</ul>
</div>
</div>

<a name="async_functions"></a><h1>Async Functions</h1>
<div class="level1">

<p>
 [Note - this proposal is also on <a href="https://github.com/lukehoban/ecmascript-asyncawait" class="urlextern" target="_blank" title="https://github.com/lukehoban/ecmascript-asyncawait" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">https://github.com/lukehoban/ecmascript-asyncawait</a> which may be more up to date] 
</p>

<p>
The introduction of Promises and Generators in ECMAScript presents an opportunity to dramatically improve the language - level model for writing asynchronous code in ECMAScript.
</p>

<p>
A similar proposal was made with [Defered Functions](<a href="doku.php%3Fid=strawman:deferred_functions.html" class="urlextern" target="_blank" title="http://wiki.ecmascript.org/doku.php?id=strawman:deferred_functions" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">http://wiki.ecmascript.org/doku.php?id=strawman:deferred_functions</a>) during ES6 discussions.  The proposal here supports the same use cases, using similar or the same syntax, but directly building upong generators and promises instead of defining custom mechanisms.
</p>

</div>
<!-- SECTION [1-645] -->
<a name="example"></a><h2>Example</h2>
<div class="level2">

<p>
 Take the following example, first written using Promises.This code chains a set of animations on an element, stopping when there is an exceptionin an animation, and returning the value produced by the final successfully executed animation.
</p>
<pre class="code javascript"><span class="kw2">function</span> chainAnimationsPromise<span class="br0">&#40;</span>elem, animations<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> ret = <span class="kw2">null</span>;
    <span class="kw2">var</span> p = currentPromise;
    <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> anim <span class="kw1">in</span> animations<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        p = p.<span class="me1">then</span><span class="br0">&#40;</span><span class="kw2">function</span> <span class="br0">&#40;</span>val<span class="br0">&#41;</span> <span class="br0">&#123;</span>
            ret = val;
            <span class="kw1">return</span> anim<span class="br0">&#40;</span>elem<span class="br0">&#41;</span>;
        <span class="br0">&#125;</span><span class="br0">&#41;</span>
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> p.<span class="kw1">catch</span><span class="br0">&#40;</span><span class="kw2">function</span> <span class="br0">&#40;</span>e<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="coMULTI">/* ignore and keep going */</span>
    <span class="br0">&#125;</span><span class="br0">&#41;</span>.<span class="me1">then</span><span class="br0">&#40;</span><span class="kw2">function</span> <span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> ret;
    <span class="br0">&#125;</span><span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre>
<p>
Already with promises, the code is much improved from a straight callback style, where this sort of looping and exception handling is challenging.
</p>

<p>
[Task.js](<a href="http://taskjs.org/" class="urlextern" target="_blank" title="http://taskjs.org/" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">http://taskjs.org/</a>) and similar libraries offer a way to use generators to further simplify the code maintaining the same meaning:
</p>
<pre class="code javascript"><span class="kw2">function</span> chainAnimationsGenerator<span class="br0">&#40;</span>elem, animations<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> spawn<span class="br0">&#40;</span><span class="kw2">function</span> *<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw2">var</span> ret = <span class="kw2">null</span>;
        <span class="kw1">try</span> <span class="br0">&#123;</span>
            <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> anim <span class="kw1">in</span> animations<span class="br0">&#41;</span> <span class="br0">&#123;</span>
                ret = yield anim<span class="br0">&#40;</span>elem<span class="br0">&#41;</span>;
            <span class="br0">&#125;</span>
        <span class="br0">&#125;</span> <span class="kw1">catch</span> <span class="br0">&#40;</span>e<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="coMULTI">/* ignore and keep going */</span> <span class="br0">&#125;</span>
        <span class="kw1">return</span> ret;
    <span class="br0">&#125;</span><span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre>
<p>
This is a marked improvement.All of the promise boilerplate above and beyond the semantic content of the code is removed, and the body of the inner function represents user intent.However, there is an outer layer of boilerplate to wrap the code in an additional generator function and pass it to a library to convert to a promise.This layer needs to be repeated in every function that uses this mechanism to produce a promise.This is so common in typical async Javascript code, that there is value in removing the need for the remaining boilerplate.
</p>

<p>
With async functions, all the remaining boiler plate is removed, leaving only the semantically meaningfully code in the program text:
</p>
<pre class="code javascript">async <span class="kw2">function</span> chainAnimationsAsync<span class="br0">&#40;</span>elem, animations<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> ret = <span class="kw2">null</span>;
    <span class="kw1">try</span> <span class="br0">&#123;</span>
        <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> anim <span class="kw1">in</span> animations<span class="br0">&#41;</span> <span class="br0">&#123;</span>
            ret = await anim<span class="br0">&#40;</span>elem<span class="br0">&#41;</span>;
        <span class="br0">&#125;</span>
    <span class="br0">&#125;</span> <span class="kw1">catch</span> <span class="br0">&#40;</span>e<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="coMULTI">/* ignore and keep going */</span> <span class="br0">&#125;</span>
    <span class="kw1">return</span> ret;
<span class="br0">&#125;</span></pre>
<p>
This is morally similar to generators, which are a function form that produces a Generator object.This new async function form prduces a Promise object.
</p>

</div>
<!-- SECTION [646-3030] -->
<a name="details"></a><h2>Details</h2>
<div class="level2">

<p>
 Async functions are a thin sugar over generators and a `spawn` function which converts generators into promise objects.The internal generator object is never exposed directly to user code, so the rewrite below can be optimized significantly.
</p>

</div>
<!-- SECTION [3031-3294] -->
<a name="rewrite"></a><h3>Rewrite</h3>
<div class="level3">
<pre class="code">
async function &lt;name&gt;?&lt;argumentlist&gt;&lt;body&gt;

=&gt;

function &lt;name&gt;? &lt;argumentlist&gt;{ return spawn(function *() &lt; body&gt;); }
</pre>

</div>
<!-- SECTION [3295-3448] -->
<a name="spawning"></a><h3>Spawning</h3>
<div class="level3">

<p>
 The `spawn` used in the above desugaring is a call to the following algorithm.This algorithm does not need to be exposed directly as an <acronym title="Application Programming Interface">API</acronym> to user code, it is part of the semantics of async functions.
</p>
<pre class="code javascript"><span class="kw2">function</span> spawn<span class="br0">&#40;</span>genF<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="kw2">new</span> Promise<span class="br0">&#40;</span><span class="kw2">function</span> <span class="br0">&#40;</span>resovle, reject<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw2">var</span> gen = genF<span class="br0">&#40;</span><span class="br0">&#41;</span>;
        <span class="kw2">function</span> step<span class="br0">&#40;</span>nextF<span class="br0">&#41;</span> <span class="br0">&#123;</span>
            <span class="kw2">var</span> next;
            <span class="kw1">try</span> <span class="br0">&#123;</span>
                next = nextF<span class="br0">&#40;</span><span class="br0">&#41;</span>;
            <span class="br0">&#125;</span> <span class="kw1">catch</span> <span class="br0">&#40;</span>e<span class="br0">&#41;</span> <span class="br0">&#123;</span>
                <span class="co1">// finished with failure, reject the promise</span>
                reject<span class="br0">&#40;</span>next<span class="br0">&#41;</span>;
                <span class="kw1">return</span>;
            <span class="br0">&#125;</span>
            <span class="kw1">if</span> <span class="br0">&#40;</span>next.<span class="me1">done</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
                <span class="co1">// finished with success, resolve the promise</span>
                resolve<span class="br0">&#40;</span>next.<span class="me1">value</span><span class="br0">&#41;</span>;
                <span class="kw1">return</span>;
            <span class="br0">&#125;</span>
            <span class="co1">// not finished, chain off the yielded promise and `step` again</span>
            Promise.<span class="me1">cast</span><span class="br0">&#40;</span>next.<span class="me1">value</span><span class="br0">&#41;</span>.<span class="me1">then</span><span class="br0">&#40;</span><span class="kw2">function</span> <span class="br0">&#40;</span>v<span class="br0">&#41;</span> <span class="br0">&#123;</span>
                step<span class="br0">&#40;</span><span class="kw2">function</span> <span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> gen.<span class="me1">next</span><span class="br0">&#40;</span>v<span class="br0">&#41;</span>; <span class="br0">&#125;</span><span class="br0">&#41;</span>;
            <span class="br0">&#125;</span>, <span class="kw2">function</span> <span class="br0">&#40;</span>e<span class="br0">&#41;</span> <span class="br0">&#123;</span>
                    step<span class="br0">&#40;</span><span class="kw2">function</span> <span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> gen.<span class="kw1">throw</span><span class="br0">&#40;</span>e<span class="br0">&#41;</span>; <span class="br0">&#125;</span><span class="br0">&#41;</span>;
                <span class="br0">&#125;</span><span class="br0">&#41;</span>;
        <span class="br0">&#125;</span>
        step<span class="br0">&#40;</span><span class="kw2">function</span> <span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> gen.<span class="me1">next</span><span class="br0">&#40;</span>undefined<span class="br0">&#41;</span> <span class="br0">&#125;</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span><span class="br0">&#41;</span>
<span class="br0">&#125;</span></pre>
</div>
<!-- SECTION [3449-4606] -->
<a name="syntax"></a><h3>Syntax</h3>
<div class="level3">

<p>
 The set of syntax forms are the same as for generators.
</p>
<pre class="code">
AsyncMethod:
    async PropertyName(StrictFormalParameters) { FunctionBody }
AsyncDeclaration:
    function async BindingIdentifier(FormalParameters) { FunctionBody }
AsyncExpression:
    function async BindingIdentifier? (FormalParameters) { FunctionBody }

// If needed - see syntax options below
AwaitExpression:
    await [Lexical goal InputElementRegExp]   AssignmentExpression
</pre>

</div>
<!-- SECTION [4607-5080] -->
<a name="await"></a><h3>await*</h3>
<div class="level3">

<p>
 In generators, both `yield` and `yield*` can be used.In async functions, only `await` is allowed.  `await*` does not directly have a useful meaning.It could be considered to treat `await*` as Promise.all.This would accept an value that is an array or Promises, and would(asynchronously) return an array of values returned by the promises.This is slightly inconsistent from a typing perspective though.
</p>

</div>
<!-- SECTION [5081-5501] -->
<a name="awaiting_non_-_promise"></a><h3>Awaiting Non - Promise</h3>
<div class="level3">

<p>
 When the value passed to `await` is a Promise, the completion of the async function is scheduled on completion of the Promise.For non - promises, behaviour aligns with Promise conversation rules according to the proposed semantic polyfill.
</p>

</div>
<!-- SECTION [5502-5776] -->
<a name="surface_syntax"></a><h3>Surface syntax</h3>
<div class="level3">

<p>
Instead of `async function`/`await`, the following are options: - `function^`/`await` - `function!`/`yield` - `function!`/`await` - `function^`/`yield`
</p>

</div>
<!-- SECTION [5777-5954] -->
<a name="arrows"></a><h3>Arrows</h3>
<div class="level3">

<p>
The same approach can apply to arrow functions.For example, assuming the `async function` syntax:   `async() &rArr; yield fetch(&rsquo;<a href="http://www.bing.com" class="urlextern" target="_blank" title="http://www.bing.com" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">www.bing.com</a>&lsquo;)` or `async(z) &rArr; yield z*z` or `async() &rArr; { yield 1; return 1; }`.
</p>

</div>
<!-- SECTION [5955-6180] -->
<a name="notes_on_types"></a><h3>Notes on Types</h3>
<div class="level3">

<p>
For generators, an `Iterable &lt; T&gt;` is always returned, and the type of each yield argument must be `T`.  Return should not be passed any argument.
</p>

<p>
For async functions, a `Promise &lt; T&gt;` is returned, and the type of return expressions must be `T`.  Yield&rsquo;s arguments are `any`.
</p>

</div>
<!-- SECTION [6181-6483] -->
<a name="api"></a><h3>API</h3>
<div class="level3">

<p>
 It may make sense to make the <acronym title="Application Programming Interface">API</acronym> supporting this sugar directly available.  This could be published as `Promise.async` bound to either the spawn function above, or to  
</p>
<pre class="code javascript">    Promise.<span class="me1">async</span> = <span class="kw2">function</span><span class="br0">&#40;</span>genF<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="kw2">function</span><span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> spawn<span class="br0">&#40;</span><span class="br0">&#40;</span><span class="br0">&#41;</span> =&gt; genF.<span class="me1">apply</span><span class="br0">&#40;</span><span class="kw1">this</span>, args<span class="br0">&#41;</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span> <span class="br0">&#125;</span></pre>
</div>
<!-- SECTION [6484-6809] -->
<a name="bigger_example"></a><h2>Bigger example</h2>
<div class="level2">
<pre class="code javascript">&nbsp;
<span class="kw2">var</span> http = require<span class="br0">&#40;</span><span class="st0">'http'</span><span class="br0">&#41;</span>;
<span class="kw2">var</span> Q = require<span class="br0">&#40;</span><span class="st0">'q'</span><span class="br0">&#41;</span>;
<span class="kw2">var</span> request = require<span class="br0">&#40;</span><span class="st0">'./request.js'</span><span class="br0">&#41;</span>;
<span class="kw2">var</span> headers = <span class="br0">&#123;</span> <span class="st0">'User-Agent'</span>: <span class="st0">'lukehoban'</span>, <span class="st0">'Authorization'</span>: <span class="st0">'token 665021d813ad67942206d94c47d7947716d27f66'</span> <span class="br0">&#125;</span>;
&nbsp;
<span class="co1">// Promise-returning asynchronous function</span>
async <span class="kw2">function</span> getCollaboratorImages<span class="br0">&#40;</span>full_name<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="co1">// any exceptions thrown here will propogate into try/catch in callers - same as synchronous</span>
  <span class="kw2">var</span> url = <span class="st0">'https://api.github.com/repos/'</span> + full_name + <span class="st0">'/collaborators'</span>;
  <span class="co1">// await a promise-returning async HTTP GET - same as synchronous </span>
  <span class="kw2">var</span> <span class="br0">&#91;</span>response, body<span class="br0">&#93;</span> = await request<span class="br0">&#40;</span><span class="br0">&#123;</span>url: url, headers: headers<span class="br0">&#125;</span><span class="br0">&#41;</span>; 
  <span class="kw1">return</span> JSON.<span class="me1">parse</span><span class="br0">&#40;</span>body<span class="br0">&#41;</span>.<span class="me1">map</span><span class="br0">&#40;</span><span class="kw2">function</span><span class="br0">&#40;</span>collab<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> collab.<span class="me1">avatar_url</span>;
  <span class="br0">&#125;</span><span class="br0">&#41;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="co1">// can use a `async function` here because createServer doesn't care what this returns</span>
http.<span class="me1">createServer</span><span class="br0">&#40;</span>async <span class="kw2">function</span> <span class="br0">&#40;</span>req, res<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  console.<span class="me1">log</span><span class="br0">&#40;</span><span class="st0">'starting...'</span><span class="br0">&#41;</span>
  <span class="kw2">var</span> url = <span class="st0">'https://api.github.com/search/repositories?per_page=100&amp;q='</span> + <span class="st0">'tetris'</span>;
  <span class="kw2">var</span> items = <span class="br0">&#91;</span><span class="br0">&#93;</span>;
  <span class="co1">// write a normal 'synchronous' while loop</span>
  <span class="kw1">while</span><span class="br0">&#40;</span><span class="kw2">true</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> 
    console.<span class="me1">log</span><span class="br0">&#40;</span><span class="st0">'Got '</span> + items.<span class="me1">length</span> + <span class="st0">' items total.  Next: '</span> + url<span class="br0">&#41;</span>;
    <span class="co1">// use normal exception handling</span>
    <span class="kw1">try</span> <span class="br0">&#123;</span> 
      <span class="co1">// promise-returning async HTTP GET</span>
      <span class="kw2">var</span> <span class="br0">&#91;</span>response, body<span class="br0">&#93;</span> = await request<span class="br0">&#40;</span><span class="br0">&#123;</span>url: url, headers: headers<span class="br0">&#125;</span><span class="br0">&#41;</span>;
      <span class="kw2">var</span> items = JSON.<span class="me1">parse</span><span class="br0">&#40;</span>body<span class="br0">&#41;</span>.<span class="me1">items</span>;
      <span class="co1">// nested parallel work is still possible with Q.all (could be future await* ?)</span>
      <span class="kw2">var</span> newItems = Q.<span class="me1">all</span><span class="br0">&#40;</span>items.<span class="me1">map</span><span class="br0">&#40;</span>async <span class="br0">&#40;</span><span class="kw1">item</span><span class="br0">&#41;</span> =&gt; <span class="br0">&#40;</span><span class="br0">&#123;</span> 
        full_name: <span class="kw1">item</span>.<span class="me1">full_name</span>, 
        collabs_images: await getCollaboratorImages<span class="br0">&#40;</span><span class="kw1">item</span>.<span class="me1">full_name</span><span class="br0">&#41;</span>
      <span class="br0">&#125;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
      items = items.<span class="me1">concat</span><span class="br0">&#40;</span>await newItems<span class="br0">&#41;</span>;
      url = <span class="br0">&#40;</span>/&lt;<span class="br0">&#40;</span>.*<span class="br0">&#41;</span>&gt;; rel=<span class="st0">"next"</span>/.<span class="me1">exec</span><span class="br0">&#40;</span>response.<span class="me1">headers</span>.<span class="me1">link</span><span class="br0">&#41;</span> || <span class="br0">&#91;</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span>;
      <span class="co1">// break once there is no 'next' link</span>
      <span class="kw1">if</span><span class="br0">&#40;</span>!url<span class="br0">&#41;</span> <span class="kw1">break</span>; 
    <span class="br0">&#125;</span> <span class="kw1">catch</span><span class="br0">&#40;</span>err<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      console.<span class="me1">log</span><span class="br0">&#40;</span><span class="st0">'backing off... '</span> + err<span class="br0">&#41;</span>;
      <span class="co1">// backoff on any error</span>
      await Q.<span class="me1">timeout</span><span class="br0">&#40;</span><span class="nu0">1000</span><span class="br0">&#41;</span>; 
      <span class="co1">// then try again</span>
      <span class="kw1">continue</span>;  
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
  <span class="co1">// when done, write response - appears in the usual synchronous 'at the end' </span>
  console.<span class="me1">log</span><span class="br0">&#40;</span><span class="st0">'Done. Got '</span> + items.<span class="me1">length</span> + <span class="st0">' items total.'</span><span class="br0">&#41;</span>;
  res.<span class="me1">writeHead</span><span class="br0">&#40;</span><span class="nu0">200</span>, <span class="br0">&#123;</span> <span class="st0">'Content-Type'</span>: <span class="st0">'application/json'</span> <span class="br0">&#125;</span><span class="br0">&#41;</span>;
  res.<span class="me1">end</span><span class="br0">&#40;</span>JSON.<span class="me1">stringify</span><span class="br0">&#40;</span>items<span class="br0">&#41;</span><span class="br0">&#41;</span>;    
<span class="br0">&#125;</span><span class="br0">&#41;</span>.<span class="me1">listen</span><span class="br0">&#40;</span>process.<span class="me1">env</span>.<span class="me1">port</span> || <span class="nu0">1337</span><span class="br0">&#41;</span>;
console.<span class="me1">log</span><span class="br0">&#40;</span><span class="st0">"Listening on http://127.0.0.1:"</span> + <span class="br0">&#40;</span>process.<span class="me1">env</span>.<span class="me1">port</span> || <span class="nu0">1337</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
&nbsp;</pre>
<p>
These sweet.js macros can be prepended to the above to test today.
</p>
<pre class="code javascript">&nbsp;
<span class="co1">// macros ----------------------------------------</span>
&nbsp;
let async = macro <span class="br0">&#123;</span>
  <span class="kw1">case</span> <span class="br0">&#123;</span>_ <span class="kw2">function</span> $name <span class="br0">&#40;</span>$params ...<span class="br0">&#41;</span> <span class="br0">&#123;</span> $body ...<span class="br0">&#125;</span> <span class="br0">&#125;</span> =&gt; <span class="br0">&#123;</span>
    <span class="kw1">return</span> #<span class="br0">&#123;</span> <span class="kw2">var</span> $name = require<span class="br0">&#40;</span><span class="st0">'q'</span><span class="br0">&#41;</span>.<span class="me1">async</span><span class="br0">&#40;</span><span class="kw2">function</span> * $name <span class="br0">&#40;</span>$params ...<span class="br0">&#41;</span> <span class="br0">&#123;</span> $body ... <span class="br0">&#125;</span><span class="br0">&#41;</span> <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
  <span class="kw1">case</span> <span class="br0">&#123;</span>_ <span class="kw2">function</span> <span class="br0">&#40;</span>$params ...<span class="br0">&#41;</span> <span class="br0">&#123;</span> $body ...<span class="br0">&#125;</span> <span class="br0">&#125;</span> =&gt; <span class="br0">&#123;</span>
    <span class="kw1">return</span> #<span class="br0">&#123;</span> require<span class="br0">&#40;</span><span class="st0">'q'</span><span class="br0">&#41;</span>.<span class="me1">async</span><span class="br0">&#40;</span><span class="kw2">function</span> * <span class="br0">&#40;</span>$params ...<span class="br0">&#41;</span> <span class="br0">&#123;</span> $body ... <span class="br0">&#125;</span><span class="br0">&#41;</span> <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
  <span class="kw1">case</span> <span class="br0">&#123;</span>_ <span class="br0">&#40;</span>$params ...<span class="br0">&#41;</span> =&gt; $body <span class="br0">&#125;</span> =&gt; <span class="br0">&#123;</span>
    <span class="kw1">return</span> #<span class="br0">&#123;</span> require<span class="br0">&#40;</span><span class="st0">'q'</span><span class="br0">&#41;</span>.<span class="me1">async</span><span class="br0">&#40;</span><span class="kw2">function</span> * <span class="br0">&#40;</span>$params ...<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> $body; <span class="br0">&#125;</span><span class="br0">&#41;</span> <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
macro await <span class="br0">&#123;</span>
  <span class="kw1">case</span> <span class="br0">&#123;</span>_ $e:expr <span class="br0">&#125;</span> =&gt; <span class="br0">&#123;</span>
    <span class="kw1">return</span> #<span class="br0">&#123;</span> yield $e <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
let <span class="kw2">var</span> = macro <span class="br0">&#123;</span>
  rule <span class="br0">&#123;</span> $name:ident = $value:expr <span class="br0">&#125;</span> =&gt; <span class="br0">&#123;</span>
    <span class="kw2">var</span> $name = $value
  <span class="br0">&#125;</span>
 
  rule <span class="br0">&#123;</span> <span class="br0">&#123;</span>$name:ident <span class="br0">&#40;</span>,<span class="br0">&#41;</span> ...<span class="br0">&#125;</span> = $value:expr <span class="br0">&#125;</span> =&gt; <span class="br0">&#123;</span>
    <span class="kw2">var</span> object = $value
    $<span class="br0">&#40;</span>, $name = object.$name<span class="br0">&#41;</span> ...
  <span class="br0">&#125;</span>
 
  rule <span class="br0">&#123;</span> <span class="br0">&#91;</span>$name:ident <span class="br0">&#40;</span>,<span class="br0">&#41;</span> ...<span class="br0">&#93;</span> = $value:expr <span class="br0">&#125;</span> =&gt; <span class="br0">&#123;</span>
    <span class="kw2">var</span> array = $value, index = <span class="nu0">0</span>
    $<span class="br0">&#40;</span>, $name = array<span class="br0">&#91;</span>index++<span class="br0">&#93;</span><span class="br0">&#41;</span> ...
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;</pre>
</div>
<!-- SECTION [6810-10127] -->
<a name="old_-_async_functions"></a><h1>OLD - Async Functions</h1>
<div class="level1">

<p>
 TEXT BELOW IS FROM AN OLDER VARIANT OF THIS PROPOSAL - IT SPECIFIES ONLY THE <acronym title="Application Programming Interface">API</acronym> PORTION
</p>

<p>
This page is a revision of <a href="doku.php%3Fid=strawman:deferred_functions.html" class="wikilink1" title="strawman:deferred_functions" onclick="return svchk()" onkeypress="return svchk()">deferred_functions</a> to explain how to express it as a library in terms of the <a href="doku.php%3Fid=strawman:concurrency.html" class="wikilink1" title="strawman:concurrency" onclick="return svchk()" onkeypress="return svchk()">concurrency</a> strawman and the <a href="doku.php%3Fid=harmony:generators.html" class="wikilink1" title="harmony:generators" onclick="return svchk()" onkeypress="return svchk()">generators</a> proposal, and as an enhancement to the Q <acronym title="Application Programming Interface">API</acronym> from the <a href="doku.php%3Fid=strawman:concurrency.html" class="wikilink1" title="strawman:concurrency" onclick="return svchk()" onkeypress="return svchk()">concurrency</a> strawman.
</p>

<p>
Async functions ease the burden of asynchronous programming.
</p>

</div>
<!-- SECTION [10128-10589] -->
<a name="asynchronous_programming"></a><h2>Asynchronous Programming</h2>
<div class="level2">

<p>
 Ecmascript programming environments typically are single threaded and pausing execution for long periods is undesirable. ES host environments use callbacks for operations which may take a long time like network IO or system timers. 
</p>

<p>
For Example:
</p>
<pre class="code javascript">  <span class="kw2">function</span> animate<span class="br0">&#40;</span>element, callback<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> i = -<span class="nu0">1</span>;
    <span class="kw2">function</span> loop<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      i++;
      <span class="kw1">if</span> <span class="br0">&#40;</span>i &lt; <span class="nu0">100</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        element.<span class="me1">style</span>.<span class="me1">left</span> = i;
        window.<span class="me1">setTimeout</span><span class="br0">&#40;</span>loop, <span class="nu0">20</span><span class="br0">&#41;</span>;
      <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        callback<span class="br0">&#40;</span><span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
    loop<span class="br0">&#40;</span><span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>;
  animate<span class="br0">&#40;</span>document.<span class="me1">getElementById</span><span class="br0">&#40;</span><span class="st0">'box'</span><span class="br0">&#41;</span>, 
          <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw3">alert</span><span class="br0">&#40;</span><span class="st0">'Done!'</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span><span class="br0">&#41;</span>;</pre>
<p>
The <a href="doku.php%3Fid=strawman:concurrency.html" class="wikilink1" title="strawman:concurrency" onclick="return svchk()" onkeypress="return svchk()">concurrency</a> strawman provides a Q <acronym title="Application Programming Interface">API</acronym> for defining and manipulating promises, that avoid the inversion of control necessitated by such callback-oriented programming.
</p>
<pre class="code javascript"><span class="kw2">const</span> delay<span class="br0">&#40;</span>millis, answer = undefined<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">const</span> deferredResult = Q.<span class="me1">defer</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
    setTimeout<span class="br0">&#40;</span><span class="kw2">const</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> deferredResult.<span class="me1">resolve</span><span class="br0">&#40;</span>answer<span class="br0">&#41;</span>; <span class="br0">&#125;</span>, millis<span class="br0">&#41;</span>;
    <span class="kw1">return</span> deferredResult.<span class="me1">promise</span>;
  <span class="br0">&#125;</span>
&nbsp;
  <span class="kw2">function</span> asyncAnimate<span class="br0">&#40;</span>element<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> i = -<span class="nu0">1</span>;
    <span class="kw2">var</span> deferred = Q.<span class="me1">defer</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
    <span class="kw2">function</span> loop<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      i++;
      <span class="kw1">if</span> <span class="br0">&#40;</span>i &lt; <span class="nu0">100</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        element.<span class="me1">style</span>.<span class="me1">left</span> = i;
        Q<span class="br0">&#40;</span>delay<span class="br0">&#40;</span><span class="nu0">20</span><span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">then</span><span class="br0">&#40;</span>loop<span class="br0">&#41;</span>;
      <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        deferred.<span class="me1">resolve</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
    loop<span class="br0">&#40;</span><span class="br0">&#41;</span>;
    <span class="kw1">return</span> deferred.<span class="me1">promise</span>;
  <span class="br0">&#125;</span>;
  Q<span class="br0">&#40;</span>asyncAnimate<span class="br0">&#40;</span>document.<span class="me1">getElementById</span><span class="br0">&#40;</span><span class="st0">'box'</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">then</span><span class="br0">&#40;</span>
    <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw3">alert</span><span class="br0">&#40;</span><span class="st0">'Done!'</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span><span class="br0">&#41;</span>;</pre>
<p>
Programming with promises improves composability of callback patterns, but there are still drawbacks in programming in this style. The completion of the computation must be enclosed in a callback function passed to the &lsquo;Q(p).then&rsquo; function. 
</p>

<p>
Authoring the callback function has proved difficult for some ES programmers. Control flow constructs (if, while, for, try) do not compose across function boundaries. The programmer must manually twist the control flow into continuation passing style. The callback function does not by default have the same &lsquo;this&rsquo; binding as the enclosing function which is a frequent source of programmer error.
</p>

</div>
<!-- SECTION [10590-12672] -->
<a name="async_functions"></a><h2>Async Functions</h2>
<div class="level2">

<p>
 Async functions allow asynchronous code to be written using existing control flow constructs. They are expressed by composing the <code>Q.async</code> method proposed by this strawman with <a href="doku.php%3Fid=harmony:generators.html" class="wikilink1" title="harmony:generators" onclick="return svchk()" onkeypress="return svchk()">generators</a>.
</p>
<pre class="code javascript">  <span class="kw2">const</span> asyncAnimate = Q.<span class="me1">async</span><span class="br0">&#40;</span><span class="kw2">function</span>*<span class="br0">&#40;</span>element<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> i = <span class="nu0">0</span>; i &lt; <span class="nu0">100</span>; ++i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      element.<span class="me1">style</span>.<span class="me1">left</span> = i;
      yield delay<span class="br0">&#40;</span><span class="nu0">20</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span><span class="br0">&#41;</span>;
  Q<span class="br0">&#40;</span>asyncAnimate<span class="br0">&#40;</span>document.<span class="me1">getElementById</span><span class="br0">&#40;</span><span class="st0">'box'</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">then</span><span class="br0">&#40;</span>
    <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw3">alert</span><span class="br0">&#40;</span><span class="st0">'Done!'</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span><span class="br0">&#41;</span>;</pre>
<p>
This strawman adds the <code>Q.async</code> method to the <code>Q</code> <acronym title="Application Programming Interface">API</acronym>. When <code>Q.async</code> is called with a generator function, it returns an <em>async function</em>. A yield expression within the body of the generator function argument is an <em>await expression</em>.
</p>

<p>
The await expression evaluates the expression after the <code>yield</code>. The result of evaluating the expression in an await expression is a <em>promised value</em>. The promised value is either a promise or a normal value. After computing the promised value the await expression suspends execution of the current function, attaches the continuation of the current function to the promised value by calling the <code>Q(p).then</code> method, and then returns what that <code>Q(p).then</code> returns. 
</p>

<p>
<code>Q(p).then</code> queues callbacks to be called later, in a separate turn, once the promised value is resolved. If the promised value is either not a promise or is a resolved promise, then <code>Q(p).then</code> queues calls to these callbacks in the general event queue &ndash; the same one used by setTimeout, etc. If the promised value is an unresolved promise, <code>Q(p).then</code> queues the callback within the promise, to be requeued once the promise is resolved. <code>Q(p).then</code> immediately returns a promise for what the queued callback will eventually return. 
</p>

<p>
The value of the await expression as a whole is thus the resolution of the promised value, i.e., the value that was promised. And the return value of a call to an async function is thus a promise for the value that the completion of the function will eventually return. Callbacks to <code>Q(p).then</code> on that promise will eventually be called with the value that the completion of the async function eventually does return.
</p>

</div>
<!-- SECTION [12673-14866] -->
<a name="returning_values_from_async_functions"></a><h2>Returning Values From Async Functions</h2>
<div class="level2">

<p>
 When the completion of an async function completes by returning a value, the returned value is passed as the argument when invoking callbacks registered on the promise returned by the returned function. The value of an await expression is the value of the argument passed to the callback registered on the promised value.
</p>
<pre class="code javascript">  <span class="kw2">function</span> asyncXHR<span class="br0">&#40;</span>url<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> deferred = Q.<span class="me1">defer</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
    <span class="kw2">var</span> request = <span class="kw2">new</span> XMLHttpRequest<span class="br0">&#40;</span><span class="br0">&#41;</span>;
    request.<span class="kw3">open</span><span class="br0">&#40;</span><span class="st0">'GET'</span>, url, <span class="kw2">true</span><span class="br0">&#41;</span>;
    request.<span class="me1">send</span><span class="br0">&#40;</span><span class="kw2">null</span><span class="br0">&#41;</span>;
    request.<span class="me1">onreadystatechange</span> = <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>request.<span class="me1">readyState</span> == <span class="nu0">4</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="co1">// call all registered callbacks with 'request' as argument</span>
        deferred.<span class="me1">resolve</span><span class="br0">&#40;</span>request<span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>;
    <span class="kw1">return</span> deferred.<span class="me1">promise</span>;
  <span class="br0">&#125;</span>
&nbsp;
  <span class="kw2">const</span> asyncLoadRedirectUrl = Q.<span class="me1">async</span><span class="br0">&#40;</span><span class="kw2">function</span>*<span class="br0">&#40;</span>redirectUrl<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="co1">// redirectUrl contains another url</span>
    <span class="kw2">var</span> urlXHR = yield asyncXHR<span class="br0">&#40;</span>redirectUrl<span class="br0">&#41;</span>;
    <span class="kw2">var</span> url = urlXHR.<span class="me1">responseText</span>;
&nbsp;
    <span class="kw2">var</span> valueXHR = yield asyncXHR<span class="br0">&#40;</span>url<span class="br0">&#41;</span>;
    <span class="co1">// call all registered callbacks with 'valueXHR.responseText' as argument</span>
    <span class="kw1">return</span> valueXHR.<span class="me1">responseText</span>;
  <span class="br0">&#125;</span><span class="br0">&#41;</span>:
&nbsp;
  <span class="co1">// alert the value of the redirected url</span>
  Q<span class="br0">&#40;</span>asyncLoadRedirectUrl<span class="br0">&#40;</span><span class="st0">'http://lolcatz.com/redirect'</span><span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">then</span><span class="br0">&#40;</span>
    <span class="kw2">function</span><span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw3">alert</span><span class="br0">&#40;</span>value<span class="br0">&#41;</span>; <span class="br0">&#125;</span><span class="br0">&#41;</span>;</pre>
</div>
<!-- SECTION [14867-16155] -->
<a name="throwing_from_async_functions"></a><h2>Throwing From Async Functions</h2>
<div class="level2">

<p>
 <code>Q(p).then</code> takes two arguments. The <code>p</code> argument is the promised value (promise or regular value), whose resolution we&rsquo;re interested in. The first argument is the <em>callback</em> to be invoked if the promise becomes fulfilled with a value. The second is the <em>errback</em> to be invoked if the promise becomes broken. When an async function completes by throwing an exception, its returned promise becomes broken with the thrown exception as the <em>reason</em>, and so the registered errbacks are invoked with the thrown exception as the argument.
</p>
<pre class="code javascript">  <span class="co1">// alert the value of the redirected url</span>
  Q<span class="br0">&#40;</span>asyncLoadRedirectUrl<span class="br0">&#40;</span><span class="st0">'http://lolcatz.com/redirect'</span><span class="br0">&#41;</span><span class="br0">&#41;</span>.<span class="me1">then</span><span class="br0">&#40;</span>
    <span class="kw2">function</span><span class="br0">&#40;</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw3">alert</span><span class="br0">&#40;</span><span class="st0">'Success: '</span> + value<span class="br0">&#41;</span>; <span class="br0">&#125;</span>,
    <span class="kw2">function</span><span class="br0">&#40;</span>err<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw3">alert</span><span class="br0">&#40;</span><span class="st0">'Failure: '</span> + err<span class="br0">&#41;</span>; <span class="br0">&#125;</span><span class="br0">&#41;</span>;</pre>
<p>
Similarly, when an awaited on expression completes with an error - ie. its errback is invoked - the result of the await expression is to throw the error value.
</p>

</div>
<!-- SECTION [16156-17143] -->
<a name="reference_implementation"></a><h2>Reference Implementation</h2>
<div class="level2">
<pre class="code javascript">  Q.<span class="me1">async</span> = <span class="kw2">function</span><span class="br0">&#40;</span>generatorFunc<span class="br0">&#41;</span> <span class="br0">&#123;</span>
&nbsp;
    <span class="kw1">return</span> <span class="kw2">function</span> asyncFunc<span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">const</span> generator = generatorFunc.<span class="me1">apply</span><span class="br0">&#40;</span><span class="kw1">this</span>, args<span class="br0">&#41;</span>;
      <span class="kw2">const</span> callback = continuer.<span class="me1">bind</span><span class="br0">&#40;</span><span class="kw1">void</span> <span class="nu0">0</span>, <span class="st0">'send'</span><span class="br0">&#41;</span>;
      <span class="kw2">const</span> errback = continuer.<span class="me1">bind</span><span class="br0">&#40;</span><span class="kw1">void</span> <span class="nu0">0</span>, <span class="st0">'throw'</span><span class="br0">&#41;</span>;
&nbsp;
      <span class="kw2">function</span> continuer<span class="br0">&#40;</span>verb, valueOrErr<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        let promisedValue;
        <span class="kw1">try</span> <span class="br0">&#123;</span>
          promisedValue = generator<span class="br0">&#91;</span>verb<span class="br0">&#93;</span><span class="br0">&#40;</span>valueOrErr<span class="br0">&#41;</span>;
        <span class="br0">&#125;</span> <span class="kw1">catch</span> <span class="br0">&#40;</span>err<span class="br0">&#41;</span> <span class="br0">&#123;</span>
          <span class="kw1">if</span> <span class="br0">&#40;</span>isStopIteration<span class="br0">&#40;</span>err<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> Q<span class="br0">&#40;</span>err.<span class="me1">value</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span>
          <span class="kw1">return</span> Q.<span class="me1">reject</span><span class="br0">&#40;</span>err<span class="br0">&#41;</span>;
        <span class="br0">&#125;</span>
        <span class="kw1">return</span> Q<span class="br0">&#40;</span>promisedValue<span class="br0">&#41;</span>.<span class="me1">then</span><span class="br0">&#40;</span>callback, errback<span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>
&nbsp;
      <span class="kw1">return</span> callback<span class="br0">&#40;</span><span class="kw1">void</span> <span class="nu0">0</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>;
  <span class="br0">&#125;</span>;</pre>
</div>
<!-- SECTION [17144-17834] -->
<a name="see"></a><h1>See</h1>
<div class="level1">

<p>
 <a href="doku.php%3Fid=strawman:concurrency.html" class="wikilink1" title="strawman:concurrency" onclick="return svchk()" onkeypress="return svchk()">concurrency</a>
</p>

<p>
<a href="doku.php%3Fid=harmony:generators.html" class="wikilink1" title="harmony:generators" onclick="return svchk()" onkeypress="return svchk()">generators</a>
</p>

<p>
<a href="doku.php%3Fid=strawman:deferred_functions.html" class="wikilink1" title="strawman:deferred_functions" onclick="return svchk()" onkeypress="return svchk()">deferred_functions</a>
</p>

<p>
<a href="https://gist.github.com/1040714" class="urlextern" target="_blank" title="https://gist.github.com/1040714" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Tom's prototype</a> using Firefox&rsquo;s current non-standard generators and <a href="https://github.com/kriskowal/q-comm/" class="urlextern" target="_blank" title="https://github.com/kriskowal/q-comm/" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Kris Kowal's qcomm</a> implementation of <code>Q</code>. 
</p>

</div>
<!-- SECTION [17835-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/7/728c03a59c46f2a8a70133dc614252e7.xhtml used -->
</body>
</html>
