<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
 lang="en" dir="ltr">
<head>
  <title>discussion:nullability [ES Wiki]</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=discussion:nullability&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=discussion" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=discussion:nullability&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=discussion:nullability&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="date" content="2006-06-02T05:52:05+0000" />
  <meta name="robots" content="index,follow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />

  <link rel="shortcut icon" href="lib/images/favicon.ico" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/tpl/default/layout.css" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/tpl/default/design.css" />

  
  <link rel="stylesheet" media="print" type="text/css" href="lib/tpl/default/print.css" />

  <!--[if gte IE 5]>
  <style type="text/css">
    /* that IE 5+ conditional comment makes this only visible in IE 5+ */
    /* IE bugfix for transparent PNGs */
    //DISABLED   img { behavior: url("/lib/scripts/pngbehavior.htc"); }
  </style>
  <![endif]-->

  </head>

<body>
<div class="dokuwiki">
  
  <div class="stylehead">

    <div class="header">
      <div class="pagename">
        [[<a href="doku.php%3Fid=discussion:nullability&amp;do=backlink.html" onclick="return svchk()" onkeypress="return svchk()">discussion:nullability</a>]]
      </div>
      <div class="logo">
        <a href="doku.php%3Fid=.html" onclick="return svchk()" onkeypress="return svchk()" name="top" accesskey="h" title="[ALT+H]">ES Wiki</a>      </div>
    </div>
  
    
    <div class="bar" id="bar_top">
      <div class="bar-left" id="bar_topleft">
        <form class="button" method="post" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="edit" /><input type="hidden" name="rev" value="" /><input type="hidden" name="id" value="discussion:nullability" /><input type="submit" value="Show pagesource" class="button" title="ALT+V" accesskey="v" /></form>        <form class="button" method="get" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="revisions" /><input type="hidden" name="id" value="discussion:nullability" /><input type="submit" value="Old revisions" class="button" title="ALT+O" accesskey="o" /></form>      </div>
  
      <div class="bar-right" id="bar_topright">
        <form class="button" method="get" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="recent" /><input type="hidden" name="id" value="" /><input type="submit" value="Recent changes" class="button" title="ALT+R" accesskey="r" /></form>        <form action="doku.php%3Fid=.html" accept-charset="utf-8" class="search" name="search" onsubmit="return svchk()"><input type="hidden" name="do" value="search" /><input type="text" id="qsearch_in" accesskey="f" name="id" class="edit" onkeyup="ajax_qsearch.call('qsearch_in','qsearch_out')" /><input type="submit" value="Search" class="button" /><div id="qsearch_out" class="ajax_qsearch" onclick="this.style.display='none'"></div></form>&nbsp;
      </div>
    </div>

        <div class="breadcrumbs">
      Trace: <span class="bcsep">&raquo;</span> <a href="doku.php%3Fid=discussion:iterators_and_generators.html" onclick="return svchk()" onkeypress="return svchk()" class="breadcrumbs" title="discussion:iterators_and_generators">iterators_and_generators</a> <span class="bcsep">&raquo;</span> <a href="doku.php%3Fid=discussion:local_packages.html" onclick="return svchk()" onkeypress="return svchk()" class="breadcrumbs" title="discussion:local_packages">local_packages</a> <span class="bcsep">&raquo;</span> <a href="doku.php%3Fid=discussion:meta_objects.html" onclick="return svchk()" onkeypress="return svchk()" class="breadcrumbs" title="discussion:meta_objects">meta_objects</a> <span class="bcsep">&raquo;</span> <a href="doku.php%3Fid=discussion:name_objects.html" onclick="return svchk()" onkeypress="return svchk()" class="breadcrumbs" title="discussion:name_objects">name_objects</a> <span class="bcsep">&raquo;</span> <span class="curid"><a href="doku.php%3Fid=discussion:nullability.html" onclick="return svchk()" onkeypress="return svchk()" class="breadcrumbs" title="discussion:nullability">nullability</a></span>          </div>
    
  </div>
  
  
  <div class="page">
    <!-- wikipage start -->
    <div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#dave_s_proposal" class="toc">Dave's proposal</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#notation" class="toc">Notation</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#defaults" class="toc">Defaults</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#non-_nullability_type_constructors" class="toc">(Non-)Nullability type constructors</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#redundant_annotations" class="toc">Redundant annotations</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#subtyping" class="toc">Subtyping</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#initial_values" class="toc">Initial values</a></span><ul class="toc">
<li class="clear"><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#initial_values_for_nullable_types" class="toc">Initial values for nullable types</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#initial_values_for_special_non-nullable_types" class="toc">Initial values for special non-nullable types</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#initial_values_for_other_non-nullable_types" class="toc">Initial values for other non-nullable types</a></span></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#counter-proposal_on_initial_values" class="toc">Counter-proposal on initial values</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#providing_default_values" class="toc">Providing default values</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#a_new_proposal_for_non-nullable_fields" class="toc">A new proposal for non-nullable fields</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#desiderata" class="toc">Desiderata</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#example" class="toc">Example</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#proposal" class="toc">Proposal</a></span><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#scope_of_field_initializers" class="toc">Scope of field initializers</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#order_of_initialization" class="toc">Order of initialization</a></span></li>
</ul>
</li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#alternatives" class="toc">Alternatives</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#some_minor_objections" class="toc">Some minor objections</a></span><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#syntactic_matters" class="toc">Syntactic matters</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#super_can_be_called_anywhere_in_the_constructur" class="toc">Super can be called anywhere in the constructur</a></span></li>
</ul>
</li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:nullability.html#a_note_on_the_nullability_snowball_effect" class="toc">A note on the nullability snowball effect</a></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<p>
This is the discussion page for <a href="doku.php%3Fid=proposals:nullability.html" class="wikilink1" title="proposals:nullability" onclick="return svchk()" onkeypress="return svchk()">nullability</a>.
</p>

<a name="dave_s_proposal"></a><h1>Dave's proposal</h1>
<div class="level1">

</div>

<a name="notation"></a><h2>Notation</h2>
<div class="level2">

<p>
 All (pre-defined) types are written capitalized, including: 
</p>
<ul>
<li class="level1"><div class="li"> <code>Object</code></div>
</li>
<li class="level1"><div class="li"> <code>String</code></div>
</li>
<li class="level1"><div class="li"> <code>Number</code></div>
</li>
<li class="level1"><div class="li"> <code>Int</code></div>
</li>
<li class="level1"><div class="li"> <code>Double</code></div>
</li>
<li class="level1"><div class="li"> <code>Boolean</code></div>
</li>
</ul>

<p>
 <strong>Justification:</strong> lowercase type names introduce confusing associations with the panoply of meanings for them in various other languages. This way there&rsquo;s no potential misconception that they might act like unboxed values as in ES3 or Java.
</p>

</div>

<a name="defaults"></a><h2>Defaults</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> almost all types are nullable by default</div>
</li>
<li class="level1"><div class="li"> the following types are not nullable by default:</div>
<ul>
<li class="level2"><div class="li"> <code>Number</code> and all subclasses, including user-defined subclasses if the <code>Number</code> classes are non-<code>final</code></div>
</li>
<li class="level2"><div class="li"> <code>Boolean</code></div>
</li>
</ul>
</li>
</ul>

<p>
 <strong>Justification:</strong> 
</p>
<ul>
<li class="level1"><div class="li"> choosing nullability as the default</div>
<ul>
<li class="level2"><div class="li"> I&rsquo;m not terribly happy about this</div>
</li>
<li class="level2"><div class="li"> but it seems to be &ldquo;the way of the world&rdquo;</div>
</li>
<li class="level2"><div class="li"> it might be too draconian for this community if types were non-nullable by default?</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> almost completely consistent</div>
<ul>
<li class="level2"><div class="li"> except for numbers and booleans, everything is nullable</div>
</li>
<li class="level2"><div class="li"> this means there are very few special cases to remember</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> numbers and booleans are non-nullable</div>
<ul>
<li class="level2"><div class="li"> AS users expect this</div>
</li>
<li class="level2"><div class="li"> long tradition going back to C et al</div>
</li>
<li class="level2"><div class="li"> down-sides, though:</div>
<ul>
<li class="level3"><div class="li"> it&rsquo;s an exception to the rule</div>
</li>
<li class="level3"><div class="li"> it might lead people to think these are somehow &ldquo;not normal objects&rdquo;</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> might be able to mitigate the effects of this confusion by making these classes immutable</div>
<ul>
<li class="level3"><div class="li"> can&rsquo;t tell the difference between &ldquo;value&rdquo; and &ldquo;reference&rdquo; types if they&rsquo;re immutable</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr noshade="noshade" size="1" />

<p>
TG1 members agreed over several generations, including our current group late last year, to make the Edition 3 &ldquo;primitive types&rdquo; be <code>Object</code> subtypes whose instances are immutable.  So we are mitigating for sure!
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/02/28 23:18</em>
</p>

</div>

<a name="non-_nullability_type_constructors"></a><h2>(Non-)Nullability type constructors</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> to express a non-nullable type, write <code>T!</code></div>
</li>
<li class="level1"><div class="li"> to express a nullable type, write <code>T?</code></div>
</li>
</ul>
<hr noshade="noshade" size="1" />

<p>
Alternative syntax proposal to avoid ambiguity with the <code>?:</code> operator: 
</p>
<ul>
<li class="level1"><div class="li"> to express a non-nullable type, write <code>T!</code> (same as above)</div>
</li>
<li class="level1"><div class="li"> to express a nullable type, write <code>?T</code></div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/03/16 16:49</em>
</p>

</div>

<a name="redundant_annotations"></a><h2>Redundant annotations</h2>
<div class="level2">

<p>
 We allow redundant annotations such as <code>Number!</code> or <code>String?</code>.
</p>

<p>
<strong>Justification:</strong> 
</p>
<ul>
<li class="level1"><div class="li"> hey, option types are useful</div>
</li>
<li class="level1"><div class="li"> next step up&ndash;<code>enum</code> or <code>switch class</code>&ndash;is syntactically much heavier</div>
</li>
<li class="level1"><div class="li"> introduces redundancies such as <code>Number!</code> and <code>String?</code> but hey, it&rsquo;s good documentation</div>
</li>
</ul>

</div>

<a name="subtyping"></a><h2>Subtyping</h2>
<div class="level2">

<p>
 I will probably get this wrong given that a) it&rsquo;s 11:30 and b) I always get this wrong anyway. That&rsquo;s what soundness proofs are for. :) 
</p>
<ul>
<li class="level1"><div class="li"> <code>T! &lt;: ?T</code></div>
</li>
<li class="level1"><div class="li"> <code>(?T &rarr; U!) &lt;: (T! &rarr; ?U)</code></div>
</li>
</ul>

<p>
 For example:
</p>
<pre class="code javascript"><span class="kw2">class</span> C <span class="br0">&#123;</span>
    <span class="kw2">function</span> foo<span class="br0">&#40;</span>x : Thing!<span class="br0">&#41;</span> : Widget <span class="br0">&#123;</span>
        ...
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw2">class</span> D <span class="kw2">extends</span> C <span class="br0">&#123;</span>
    <span class="kw2">function</span> foo<span class="br0">&#40;</span>x : Thing<span class="br0">&#41;</span> : Widget! <span class="br0">&#123;</span>
        ...
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre><hr noshade="noshade" size="1" />

<p>
Your sub type relations agree with Cardelli et al. I made a small fix to your parameter declarations. You still appear to have remnants of C syntax in your universal grammar :) Don&rsquo;t worry though, it won&rsquo;t take long before the transformation is complete!
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/03/01 12:54</em>
</p>

<p>
When I was playing around with the type system I observed that it made more sense (to my non-type-theoretic self) to model nullability as sum types rather than as subtypes.  That is, the type !Object is some primitive type #OBJECT, whereas Object? is the type (sum #NULL #OBJECT).
</p>

<p>
See my notes in <a href="doku.php%3Fid=clarification:type_system.html" class="wikilink1" title="clarification:type_system" onclick="return svchk()" onkeypress="return svchk()">type system</a>.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/04/07 05:24</em>
</p>

</div>

<a name="initial_values"></a><h2>Initial values</h2>
<div class="level2">

<p>
 In ES3, uninitialized variables are originally bound to the <code>undefined</code> value. This doesn&rsquo;t fit with the type system, since the <code>void</code> type is the only type that contains the <code>undefined</code> value.
</p>

</div>

<a name="initial_values_for_nullable_types"></a><h4>Initial values for nullable types</h4>
<div class="level4">

<p>
 Variables and fields with nullable types have the initial value <code>null</code>.
</p>

</div>

<a name="initial_values_for_special_non-nullable_types"></a><h4>Initial values for special non-nullable types</h4>
<div class="level4">

<p>
 Non-nullable types do not include either of the values <code>null</code> or <code>undefined</code>, so variables and fields with non-nullable types must behave appropriately before being explicitly initialized.
</p>

<p>
Local variables and object properties with certain built-in types, when non-nullable, are given default values. The following table lists those types and their default values: 
</p>
<table class="inline">
	<tr>
		<th class="leftalign">Built-in type   </th><th>Default value </th>
	</tr>
	<tr>
		<td class="leftalign"><code>Boolean</code>    </td><td class="leftalign"><code>false</code>    </td>
	</tr>
	<tr>
		<td class="leftalign"><code>Number</code>     </td><td class="leftalign"><code>0</code>        </td>
	</tr>
	<tr>
		<td class="leftalign"> ...            </td><td class="leftalign"> ???          </td>
	</tr>
</table>
<br />

</div>

<a name="initial_values_for_other_non-nullable_types"></a><h4>Initial values for other non-nullable types</h4>
<div class="level4">

<p>
 Local variables and object properties with other non-nullable types do not have pre-defined values before being explicitly initialized. An exception of type ??? is thrown if a program attempts to read from an uninitialized object property of such a type.
</p>

<p>
<strong>Note:</strong> we could enforce that local variable declarations must have explicit initializers, but the initializers for <code>var</code> declarations may still refer to the variables before they are assigned to, and hoisting means that such variables may also be referred to before their initializer. 
</p>
<hr noshade="noshade" size="1" />

<p>
 We might make a new <code>UninitializedError</code> subtype of <code>Error</code>, but we could do worse than just throw a <code>TypeError</code> instance if a program attempts to read from an uninitialized slot of non-nullable type.  Or we might want to promote the notion of <code>static default value</code> for all classes, so that users could count on non-nullable subtypes of those classes working.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/04/21 13:43</em>
</p>

</div>

<a name="counter-proposal_on_initial_values"></a><h2>Counter-proposal on initial values</h2>
<div class="level2">

<p>
 The problem with the above proposal is that it requires <em>all</em> references to non-nullable fields to include a dynamic check to see that the field has been initialized, which is an expensive price to pay. This happens because method calls may always be kicked off due to implicit <code>super</code> calls, and these methods may be dynamically overridden:
</p>
<pre class="code javascript"><span class="kw2">class</span> A <span class="br0">&#123;</span>
    <span class="kw2">function</span> A<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> m<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#125;</span>
    <span class="kw2">function</span> m<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw2">class</span> B <span class="kw2">extends</span> A <span class="br0">&#123;</span>
    <span class="co1">// looks safe, right?</span>
    <span class="kw2">var</span> x : Object!;
    <span class="kw2">function</span> B<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">this</span>.<span class="me1">x</span> = <span class="nu0">10</span>
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw2">class</span> C <span class="kw2">extends</span> B <span class="br0">&#123;</span>
    <span class="kw2">function</span> m<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="co1">// ouch! called before x is initialized!</span>
        <span class="kw3">print</span><span class="br0">&#40;</span><span class="kw1">this</span>.<span class="me1">x</span><span class="br0">&#41;</span>
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
An alternative is to restrict constructors not to be able to call member methods of the object, nor to pass <code>this</code> as a parameter to any <code>static</code> methods or functions. There are a few more subtle restrictions as well, such as disallowing <code>eval</code>.
</p>

<p>
What about aliasing <code>this</code>? E.g.: 
</p>
<pre class="code javascript"><span class="kw2">function</span> C<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> x = <span class="kw1">this</span>
    <span class="kw1">this</span>.<span class="me1">foo</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span>
<span class="br0">&#125;</span></pre>
<p>
 Do we need to restrict <code>this</code> only to being on the LHS of assignments for property intialization?)
</p>

<p>
This way, no code is ever able to refer to <code>this</code> except for the constructor body itself, and definite assignment analysis is simple. Now the compiler can easily reject any code that may accesses uninitialized properties.
</p>

</div>

<a name="providing_default_values"></a><h2>Providing default values</h2>
<div class="level2">

<p>
 Non-nullable types are pretty strange.
</p>

<p>
I think it&rsquo;s a bit of a cop-out to introduce non-nullable types as a guarantee against null-pointer errors, and then re-introduce crypto-null-pointer errors in the form of <code>UninitializedError</code>, especially given that these can occur anywhere in the entire program if unrestricted calls are allowed.  I think something like Dave&rsquo;s counterproposal needs to be adopted.
</p>

<p>
Thus, if a class contains non-nullable fields then many additional constraints apply.  
</p>

<p>
Those constraints will become painful for some applications.  We may be able to ease their pain by providing a reasonable &ldquo;static default&rdquo; mechanism that can be invoked explicitly.  For example, consider a class C: 
</p>
<pre class="code">  class C {
      var x : OtherClass!;
  }</pre>

<p>
 We want to enable <code>C</code> to provide and use a reasonable default value for <code>x</code>.
</p>

<p>
It is almost certainly the case that <code>OtherClass</code> should <em>not</em> be directly involved in providing that default.  If it were, then there would be a global default value for fields of type <code>OtherClass</code>.  This sounds dangerous: if anyone anywhere modifies that value, then other users of the same value will be surprised.
</p>

<p>
Thus <code>C</code>, or the application of which <code>C</code> is a part, should provide the value itself.
</p>

<p>
Here is something that works but is a little clumsy:
</p>
<pre class="code javascript">    <span class="kw2">const</span> default_otherClass : OtherClass! = <span class="kw2">new</span> OtherClass<span class="br0">&#40;</span>...<span class="br0">&#41;</span>;
&nbsp;
    <span class="kw2">class</span> C <span class="br0">&#123;</span>
        <span class="kw2">var</span> x : OtherClass! = default_otherClass;
    <span class="br0">&#125;</span></pre>
<p>
The default can be local to a scope:
</p>
<pre class="code javascript">    <span class="kw2">class</span> C <span class="br0">&#123;</span>
        <span class="kw2">private</span> static <span class="kw2">const</span> default_otherClass : OtherClass! = <span class="kw2">new</span> OtherClass<span class="br0">&#40;</span>...<span class="br0">&#41;</span>;
&nbsp;
        <span class="kw2">var</span> x : OtherClass! = default_otherClass;
    <span class="br0">&#125;</span></pre>
<p>
This is statically safe, and unproblematic: we can allow constructor calls from the static initializer, with some provision about the call not referencing variables not yet initialized.
</p>

<p>
This extends easily to use by locals defined in functions and methods, so that non-nullable locals can use this initial value.
</p>

<p>
One can argue that it may not be possible to call a constructor in <code>OtherClass</code> that early, because it&rsquo;s not set up for that.  I can&rsquo;t do anything about that.
</p>

<p>
I can however try to make it more convenient to use this mechanism when it <em>is</em> possible to create a default value.
</p>

<p>
<strong>Proposal sketch</strong>:  The model is this:
</p>
<pre class="code javascript">    <span class="kw2">class</span> C <span class="br0">&#123;</span>
        <span class="kw2">private</span> static <span class="kw2">const</span> <span class="kw2">default</span> : OtherClass = <span class="kw2">new</span> OtherClass<span class="br0">&#40;</span>...<span class="br0">&#41;</span>;
&nbsp;
        <span class="kw2">var</span> x : OtherClass!;
        <span class="kw2">function</span> f<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
            <span class="kw2">var</span> y : OtherClass!;
        <span class="br0">&#125;</span>
    <span class="br0">&#125;</span></pre>
<p>
Here <code>x</code> and <code>y</code> both get the default value for <code>OtherClass</code> from their class.  (No reason this has to be for non-nullable types only, but I think it&rsquo;s cleaner that way.  Maybe.)
</p>

<p>
<strong>Generalized proposal sketch</strong>:
</p>

<p>
The following phrase: 
</p>
<pre class="code"> const default : OtherClass! = new OtherClass(...)</pre>

<p>
 defines a default value for non-nullable slots of type OtherClass in program, package, class, and function top-level scope.  (In block scope you <em>must</em> use <code>let const</code>.)  The default object is constructed on entry to the block, before any local variables are bound (including function parameters) and independent of any other bindings in the block.  Bindings in the surrounding block are visible.  In classes it may be <code>static</code>.  Only constructor calls are allowed.  The constructor call may not pass <code>this</code> or <code>super</code> if the context of the call is a constructor function.
</p>

<p>
Whenever a variable of type <code>OtherClass!</code> is defined, the default value for the type that is in scope is used.  If there is no such value, then draconian restrictions apply to initialization order etc; to be specified.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/04/26 08:28</em>
</p>

</div>

<a name="a_new_proposal_for_non-nullable_fields"></a><h2>A new proposal for non-nullable fields</h2>
<div class="level2">

<p>
 Here&rsquo;s a new proposal for object initialization, requiring only a small change to the semantics of object initialization, but which provides a sound type system that admits non-nullable fields. It requires a small change to the semantics of field initializers, but otherwise addresses all the desiderata.
</p>

</div>

<a name="desiderata"></a><h3>Desiderata</h3>
<div class="level3">

<p>
 We <strong>want</strong> the ability to: 
</p>
<ul>
<li class="level1"><div class="li"> declare non-nullable fields</div>
</li>
<li class="level1"><div class="li"> access non-nullable fields without any additional runtime check</div>
</li>
<li class="level1"><div class="li"> use <code>this</code> in an unrestricted fashion within constructor bodies</div>
<ul>
<li class="level2"><div class="li"> call methods and access fields</div>
</li>
<li class="level2"><div class="li"> use important initialization patterns like <pre class="code javascript">observer.<span class="me1">register</span><span class="br0">&#40;</span><span class="kw1">this</span><span class="br0">&#41;</span></pre></div>
</li>
</ul>
</li>
</ul>

<p>
 We <strong>don&rsquo;t want</strong> to: 
</p>
<ul>
<li class="level1"><div class="li"> access uninitialized, non-nullable fields (ever, ideally)</div>
</li>
<li class="level1"><div class="li"> get runtime <code>UninitializedError</code>s (which are indeed somewhat of a <code>NullPointerException</code> in disguise)</div>
</li>
<li class="level1"><div class="li"> require complicated static analyses to prevent such errors</div>
</li>
<li class="level1"><div class="li"> require complicated static analyses to optimize away such runtime checks</div>
</li>
</ul>

</div>

<a name="example"></a><h3>Example</h3>
<div class="level3">

<p>
 As an example, consider the following class:
</p>
<pre class="code javascript"><span class="kw2">class</span> Foo <span class="kw2">extends</span> Bar <span class="br0">&#123;</span>
    <span class="kw2">var</span> thing : Widget! = x;
    <span class="kw2">function</span> Foo<span class="br0">&#40;</span>x : Widget!, y : String<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw2">super</span><span class="br0">&#40;</span>y<span class="br0">&#41;</span>;
        observer.<span class="me1">register</span><span class="br0">&#40;</span><span class="kw1">this</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
Note that the constructor has access to <code>this</code>, which it uses to register the object with some external observer.
</p>

<p>
Note that the field initializer for <code>thing</code> accesses the constructor argument <code>x</code>. If this seems too weird, imagine that the syntax might alternatively be something more like: 
</p>
<pre class="code javascript"><span class="kw2">class</span> Foo<span class="br0">&#40;</span>x : Widget!, y : String<span class="br0">&#41;</span> <span class="kw2">extends</span> Bar <span class="br0">&#123;</span>
    <span class="kw2">var</span> thing : Widget! = x;
    <span class="kw2">function</span> Foo <span class="br0">&#123;</span>
        <span class="kw2">super</span><span class="br0">&#40;</span>y<span class="br0">&#41;</span>;
        observer.<span class="me1">register</span><span class="br0">&#40;</span><span class="kw1">this</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
 (This alternative syntax might look more familiar to those who&rsquo;ve used <a href="http://caml.inria.fr/pub/docs/manual-ocaml/manual005.html" class="urlextern" target="_blank" title="http://caml.inria.fr/pub/docs/manual-ocaml/manual005.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">O'Caml's object system</a>.) The field initializer, by contrast, does <em>not</em> have access to <code>this</code>.
</p>

<p>
The correctness of these examples relies on the precise order of object initialization.
</p>

</div>

<a name="proposal"></a><h3>Proposal</h3>
<div class="level3">

<p>
 The change to the semantics involves the scope of field initializers and the order of initialization.
</p>

</div>

<a name="scope_of_field_initializers"></a><h4>Scope of field initializers</h4>
<div class="level4">
<ul>
<li class="level1"><div class="li"> The arguments to the constructor function are <em>in scope in field initializer expressions</em></div>
</li>
<li class="level1"><div class="li"> The keyword <code>this</code> is <em>not in scope in field initializer expressions</em></div>
<ul>
<li class="level2"><div class="li"> member fields are inaccessible to field initializers</div>
</li>
<li class="level2"><div class="li"> member methods are inaccessible to field initializers</div>
</li>
</ul>
</li>
</ul>

</div>

<a name="order_of_initialization"></a><h4>Order of initialization</h4>
<div class="level4">

<p>
 Object construction can be thought of as a tree traversal, where for any class, the &ldquo;left node&rdquo; is the object fields, the parent is the parent class&rsquo;s construction (i.e., <code>super</code>), and the &ldquo;right node&rdquo; is the constructor function body. Object construction proceeds as an in-order traversal of this conceptual tree:
</p>

<p>
To invoke the construction for the <code>Foo</code> class:
</p>
<ol>
<li class="level1"><div class="li"> initialize all fields declared in <code>Foo</code></div>
</li>
<li class="level1"><div class="li"> recursively invoke the construction of its superclass (i.e., call <code>super</code>, implicitly or explicitly)</div>
</li>
<li class="level1"><div class="li"> execute the <code>Foo</code> constructor body</div>
</li>
</ol>

<p>
 Note that because of the recursion, all fields all the way up the inheritance chain will be initialized before any constructor bodies are executed, but none of those field initializations have access to <code>this</code>, so no code is able to access fields before they are initialized. Then all superclasses&rsquo; constructor bodies are invoked before subclasses, just like normal.
</p>

</div>

<a name="alternatives"></a><h3>Alternatives</h3>
<div class="level3">

<p>
 We could enforce the <code>this</code> restriction only on non-nullable fields, but then those field initializers would have to be executed conceptually as part of the constructor body, i.e., after the non-nullable fields had all been initialized. This would make both the scope and the order of evaluation inconsistent between different fields, which might be confusing. But it&rsquo;s also less restrictive.
</p>

<p>
We also should decide on the scope of <code>let</code> at class top level.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x64%3B%26%23x68%3B%26%23x65%3B%26%23x72%3B%26%23x6d%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x63%3B%26%23x63%3B%26%23x73%3B%26%23x2e%3B%26%23x6e%3B%26%23x65%3B%26%23x75%3B%26%23x2e%3B%26%23x65%3B%26%23x64%3B%26%23x75%3B" class="mail" title="&#x64;&#x68;&#x65;&#x72;&#x6d;&#x61;&#x6e;&#x40;&#x63;&#x63;&#x73;&#x2e;&#x6e;&#x65;&#x75;&#x2e;&#x65;&#x64;&#x75;">Dave Herman</a> 2006/04/27 10:12</em>
</p>

<p>
Latest thinking from <a href="doku.php%3Fid=discussion:block_expressions.html" class="wikilink1" title="discussion:block_expressions" onclick="return svchk()" onkeypress="return svchk()">block expressions</a> under <strong>Notes</strong> is that <code>let</code> in a class body binds a lexically scoped variable in an implicit block, so you can write class initialization code without having to write an explicit block.  This implicit block and <code>var</code> vs. <code>let</code> distinction parallels what we require for global program code (for <code>eval</code>), and in our latest thinking also for function body code (for symmetry and more important, to avoid aliasing via <code>arguments</code>).
</p>

<p>
I like this proposal.  Restricting non-nullable and nullable alike seems best to me.  Nice work, Dave!
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/04/27 12:00</em>
</p>

</div>

<a name="some_minor_objections"></a><h3>Some minor objections</h3>
<div class="level3">

<p>
 It&rsquo;s clearly better than what I suggested.  I have a couple of fairly minor objections:
</p>
<ul>
<li class="level1"><div class="li"> it is pretty bizarre for the formals of the constructor to be available in a lexically disjoint area, and this has negative consequences</div>
</li>
<li class="level1"><div class="li"> the spec allows the super() statement to be anywhere in the constructor, not just in the first position</div>
</li>
</ul>

</div>

<a name="syntactic_matters"></a><h4>Syntactic matters</h4>
<div class="level4">

<p>
 Since the constructor defines names that are referenced outside the constructor, yet we are in a dynamic-language setting, apparently local changes in the constructor has non-local effects:
</p>
<ul>
<li class="level1"><div class="li"> an initialization that previously referenced a constructor argument now references something in an outer scope</div>
</li>
<li class="level1"><div class="li"> an initialization that previously referenced a global, say, now references a constructor argument because of the name clash.</div>
</li>
</ul>

<p>
 I think this needs to be fixed.   Recall what C++ does here:
</p>
<pre class="code c++">    class C <span class="br0">&#123;</span>
      C<span class="br0">&#40;</span> <span class="kw4">int</span> x, Object o <span class="br0">&#41;</span>
        : mx<span class="br0">&#40;</span>x<span class="br0">&#41;</span>
        , mo<span class="br0">&#40;</span>o<span class="br0">&#41;</span>
      <span class="br0">&#123;</span>
        <span class="co1">// constructor body</span>
      <span class="br0">&#125;</span>
      <span class="kw4">int</span> mx;
      Object mo;
    <span class="br0">&#125;</span></pre>
<p>
We should <acronym title="In my opinion">IMO</acronym> do something similar, probably using identical syntax:
</p>
<pre class="code javascript">    <span class="kw2">class</span> C <span class="br0">&#123;</span>
        <span class="kw2">function</span> C<span class="br0">&#40;</span> x : int, o : Object! <span class="br0">&#41;</span> 
          : mx<span class="br0">&#40;</span>x<span class="br0">&#41;</span>
          , mo<span class="br0">&#40;</span>o<span class="br0">&#41;</span>
        <span class="br0">&#123;</span>
        <span class="br0">&#125;</span>
        <span class="kw2">var</span> mo : Object!;
        <span class="kw2">var</span> mx : int;
    <span class="br0">&#125;</span></pre>
<p>
(which happens not to be very ambiguous syntactically because constructors always return void, but I would be happy to find a keyword or other punctuation here to avoid confusion, eg <code>initialize</code> to replace <code>:</code>).  Anyway the rule would be that all non-nullable fields in this instance must be initialized at the time the initializer block completes (ie before any constructor is called).  Everything would otherwise be as Dave proposes.
</p>

<p>
This restricts the initializers somewhat, since there is no possibility to use <code>let</code> for local variables to share among initializer expressions.  I doubt this will be a hardship.
</p>

</div>

<a name="super_can_be_called_anywhere_in_the_constructur"></a><h4>Super can be called anywhere in the constructur</h4>
<div class="level4">

<p>
 At the March meeting we talked about restricting <code>super</code> to the first statement in the constructor, which would solve this problem.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/05/02 00:46</em>
</p>

</div>

<a name="a_note_on_the_nullability_snowball_effect"></a><h3>A note on the nullability snowball effect</h3>
<div class="level3">

<p>
 A friend pointed out to me today that non-nullable types could have the same &ldquo;<a href="http://www.parashift.com/c++-faq-lite/const-correctness.html#faq-18.3" class="urlextern" target="_blank" title="http://www.parashift.com/c++-faq-lite/const-correctness.html#faq-18.3" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">snowball effect</a>&rdquo; as C++ <code>const</code> annotations: changing a nullable annotation to a non-nullable one will likely require changing subsequent type annotations, and so on and so on, making it hard to refactor nullable types into non-nullable types except early on in the development process.
</p>

<p>
The &ldquo;true&rdquo; solution (though an unacceptable one for ES) would be to make types non-nullable by default and require them to be annotated as nullable.
</p>

<p>
The workaround is probably just a dynamic cast:
</p>
<pre class="code javascript"><span class="kw2">function</span> foo<span class="br0">&#40;</span><span class="br0">&#41;</span> : Widget <span class="br0">&#123;</span> ... <span class="br0">&#125;</span>
<span class="kw2">function</span> bar<span class="br0">&#40;</span>str : !Widget<span class="br0">&#41;</span> : Blah <span class="br0">&#123;</span> ... <span class="br0">&#125;</span>
&nbsp;
bar<span class="br0">&#40;</span>foo<span class="br0">&#40;</span><span class="br0">&#41;</span> to !Widget<span class="br0">&#41;</span></pre>
<p>
 If the call to <code>foo</code> returns <code>null</code>, then the conversion results in a runtime error (<code>NPE</code>, alas). It&rsquo;s not ideal, but at least it&rsquo;s localized to exactly the point where you tried to use it in a non-nullable context and caught immediately. This is still better than what would happen without non-nullable types, leaking the <code>null</code> further down the program, possibly not to surface until some completely unrelated point.
</p>

<p>
This is probably a reasonable compromise: you can incrementally refactor a nullable type annotation into a non-nullable one by putting casts around other expressions that suddenly don&rsquo;t type-check, and you can choose whether to refactor those other expressions later.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x64%3B%26%23x68%3B%26%23x65%3B%26%23x72%3B%26%23x6d%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x63%3B%26%23x63%3B%26%23x73%3B%26%23x2e%3B%26%23x6e%3B%26%23x65%3B%26%23x75%3B%26%23x2e%3B%26%23x65%3B%26%23x64%3B%26%23x75%3B" class="mail" title="&#x64;&#x68;&#x65;&#x72;&#x6d;&#x61;&#x6e;&#x40;&#x63;&#x63;&#x73;&#x2e;&#x6e;&#x65;&#x75;&#x2e;&#x65;&#x64;&#x75;">Dave Herman</a> 2006/04/29 13:21</em>
</p>

<p>
I agree that &ldquo;const&rdquo; is a royal pain in the neck, it is a wart on both C and C++ as far as I&rsquo;m concerned.  (And then to work around the problems with &ldquo;const&rdquo; you get things like &ldquo;mutable&rdquo;.)  We should worry about that trap.
</p>

<p>
Dave, wouldn&rsquo;t that cast be inserted automatically even in the strict language?
</p>

<p>
(Anyhow the type is written <code>Widget!</code> (but <code>?Widget</code>), obviously this is going to trip people up.  Perhaps it&rsquo;s time, now that we&rsquo;ve tried to factor type expression syntax from normal expression syntax, to clean that up.)
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/05/01 23:59</em>
</p>

<p>
In the strict mode assignments from T to T! should get an implicit down cast. This diminishes the strength of the static type checker but clearly makes programming easier and probably safer in many cases because programmers will feel free to say what they mean with regard to nullability without having to cast until it compiles.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/05/02 08:18</em>
</p>

<p>
Assignment from <code>?T</code> to <code>T!</code> may want an implicit cast, but what about argument passing?  I wouldn&rsquo;t want that.
</p>

<p>
Const-ipation was a hardship, but how bad is it now that standard libraries have been migrated?  It seems worthwhile to me. No comment on <code>mutable</code> and C++.
</p>

<p>
In any case, non-nullability is not const-ipation <img src="lib/images/smileys/icon_wink.gif" align="middle" alt=";-)" />  My <code>Complex</code> class should not take null operands for its static operators, and I ought to be able to say so with type annotations.  The <code>new</code> operator cannot return <code>null</code>, so users who construct <code>Complex</code> instances can&rsquo;t inadvertently pass <code>null</code>.  If some other object keeps an optional instance on hand using <code>maybeComplex : ?Complex</code>, uses of this slot that flow into <code>Complex!</code>-annotated arguments will have be <code>null</code>-checked &ndash; and such conditioning should eliminate any unwanted static type error for such data flow.
</p>

<p>
We might want to allow <code>class C! { ... }</code> to declare <code>C</code> non-nullable by default: you would need to write <code>?C</code> to type a nullable reference to <code>C</code>.  (I still like the <code>?</code> prefix vs. the <code>!</code> postfix unary type operators, but I may be just strange that way. <img src="lib/images/smileys/icon_razz.gif" align="middle" alt=":-P" />)
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/05/02 22:49</em>
</p>

<p>
On the subject of &ldquo;Complex&rdquo; as an example:
</p>

<p>
You can&rsquo;t have <code>Number &lt;: Complex</code> because <code>Number</code> is pre-defined and <code>Complex</code> is something you put together.
</p>

<p>
You can&rsquo;t have <code>Complex &lt;: Number</code> because an automatic up-cast from <code>Complex</code> to <code>Number</code> causes information to be lost and anyway this is not a natural view (<code>Number</code> in ECMAScript being an alias for &ldquo;inexact rational&rdquo;, in Scheme lingo &ndash; ie a limited-precision real number, not a general &ldquo;number&rdquo; type).
</p>

<p>
However, given a value <code>c</code> that&rsquo;s an instance of <code>Complex</code>, you want to be able to say <code>c * 37</code>.  So what should the signature of the <code>*</code> operator on <code>Complex</code> be?  Certainly the arguments can&rsquo;t be of type <code>Complex!</code> or <code>?Complex</code>, because the type checks will fail unless both arguments are complexes.
</p>

<p>
I suspect the best you can hope for is 
</p>
<pre class="code">  static public function +(x: Object!, y: Object!) : Object!;</pre>

<p>
 which isn&rsquo;t very good.
</p>

<p>
On the subject of <code>class C!</code>: 
</p>

<p>
One definitely wants to be able to introduce names in the type environment that denote non-nullable types by default.  The way one would do that in the system as it stands is by saying
</p>
<pre class="code">
    class C { ... }
    type T = C!;
</pre>

<p>
and then use T everywhere except in <code>new</code> expressions; this is clumsy and error-prone.  I like your suggestion, I think, and it fits in neatly with the notion of Number and Boolean being non-nullable while removing the &ldquo;magic&rdquo; of how that&rsquo;s done.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/05/02 23:57</em>
</p>

<p>
I was supposing that <code>function to Complex(a:Object!)</code> in <code>class Complex! {...}</code> would do the <code>Number</code> &rArr; <code>Complex</code> conversion.  Conversions are independent of the subtype relation.  They need to be defined carefully, but if you close your eyes and make a wish, does this hold up as a sketch for how a non-nullable complex number type that allows operators to mix numbers and complex instances might work?
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/05/05 18:46</em>
</p>

<p>
I keep forgetting the conversions.  So, a full example might be more like this:
</p>
<pre class="code javascript"><span class="kw2">class</span> Complex! 
<span class="br0">&#123;</span>
    <span class="co1">// Non-nullable class types must have default values</span>
    <span class="kw2">public</span> static <span class="kw2">const</span> <span class="kw2">default</span> : Complex = <span class="kw2">new</span> Complex<span class="br0">&#40;</span><span class="nu0">0</span>,<span class="nu0">0</span><span class="br0">&#41;</span>;
&nbsp;
    <span class="kw2">public</span> <span class="kw2">function</span> Complex<span class="br0">&#40;</span>real : Number, imag : Number<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">this</span>.<span class="me1">real</span> = real;
        <span class="kw1">this</span>.<span class="me1">imag</span> = imag;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw2">public</span> <span class="kw2">function</span> to Complex<span class="br0">&#40;</span>a : Object!<span class="br0">&#41;</span> : Complex <span class="br0">&#123;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>a <span class="kw1">is</span> Complex<span class="br0">&#41;</span>
           <span class="kw1">return</span> a;
        <span class="kw1">if</span> <span class="br0">&#40;</span>a <span class="kw1">is</span> Number || a <span class="kw1">is</span> int || a <span class="kw1">is</span> uint || a <span class="kw1">is</span> Decimal<span class="br0">&#41;</span> <span class="co1">// subtype relationship??</span>
           <span class="kw1">return</span> <span class="kw2">new</span> Complex<span class="br0">&#40;</span>a,<span class="nu0">0</span><span class="br0">&#41;</span>;
        <span class="kw1">return</span> <span class="kw2">new</span> Complex<span class="br0">&#40;</span>Number<span class="br0">&#40;</span>a<span class="br0">&#41;</span>, <span class="nu0">0</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw2">public</span> static <span class="kw2">function</span> +<span class="br0">&#40;</span>a : Complex, b : ?Complex<span class="br0">&#41;</span> : Complex <span class="br0">&#123;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>b == <span class="kw2">null</span><span class="br0">&#41;</span> <span class="co1">// unary +</span>
            <span class="kw1">return</span> a;
        <span class="kw1">return</span> <span class="kw2">new</span> Complex<span class="br0">&#40;</span>a.<span class="me1">real</span> + b.<span class="me1">real</span>, a.<span class="me1">imag</span> + b.<span class="me1">imag</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw2">private</span> <span class="kw2">var</span> real : Number;
    <span class="kw2">private</span> <span class="kw2">var</span> imag : Number;
<span class="br0">&#125;</span></pre>
<p>
(Note comments on default values for value types and some iffyness related to testing whether something is a &ldquo;number&rdquo;.  We probably need to fix the type hierarchy for number s.t. there is a &ldquo;Number&rdquo; class with subtypes &ldquo;float&rdquo;, &ldquo;int&rdquo;, &ldquo;uint&rdquo;, and &ldquo;decimal&rdquo;.  Though there may be other ways of doing it, in particular, &ldquo;int&rdquo; and &ldquo;uint&rdquo; are subsets of the &ldquo;float&rdquo;, which in turn is a subset of the &ldquo;decimal&rdquo; set, if Graydon&rsquo;s spec is agreed to.  The conditional in the code above does not seem ideal in any case.)
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/05/05 20:28</em>
</p>

<p>
Just <code>a is Number</code> should suffice for all but <code>Decimal</code>, since 32-bit <code>int</code> and <code>uint</code> are subtypes of IEEE double.  <code>Decimal</code> doesn&rsquo;t fit, but then decimal real and imaginary parts have to be converted with loss of precision and rounding errors anyway.
</p>

<p>
If we need an explicit name for IEEE double, it must be <code>double</code> not <code>float</code>, given the heavy hand of C, Java, etc.
</p>

<p>
Don&rsquo;t forget to handle the unary <code>+</code> case!  Oops, the <a href="doku.php%3Fid=discussion:operators.html" class="wikilink1" title="discussion:operators" onclick="return svchk()" onkeypress="return svchk()">operators</a> spec says that <code>null</code> is passed as the second actual parameter to indicate application of the unary operator, which requires <code>b : ?Complex</code> to avoid a type error &ndash; as you noted over there for the class <code>C</code> example with <code>?Number</code>.  [<em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/05/06 01:54</em> &mdash; Fixed now.]
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/05/05 23:49</em>
</p>

<p>
I know we brought this up at a phone meeting, and I&rsquo;m not sure what the conclusion was.  Neither <code>int</code> nor <code>uint</code> is a subtype of <code>Number</code> in the draft spec; instead these types are all interconvertible.  I would be surprised if the existence of a conversion operator carries over to <code>is</code>; I doubt that&rsquo;s what you meant to imply.  
</p>

<p>
It is possible that <code>int</code> and <code>uint</code> can&rsquo;t really be subtypes of <code>Number</code> since the purpose of the narrower types is to be able to represent and manipulate them efficiently.  A subtype relationship may be problematic for parameterized classes and if Number is a dynamic class.  I&rsquo;m not completely sure it&rsquo;s a problem yet, and I can&rsquo;t construct an example right now, but I&rsquo;m a little worried.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/05/06 01:54</em>
</p>

<p>
Certainly <code>is</code> should be <code>&lt;:</code> and have nothing to do with conversions.
</p>

<p>
My premise, or vague hope at any rate, was that <code>int &lt;: Number</code> and <code>uint &lt;: Number</code> (where <code>Number </code> is <code>double</code> by default).  If an implementation optimizes the representation of <code>int</code> and <code>uint</code> to use untagged 32-bit words, then upcasting will require some magic.
</p>

<p>
One way out: the magic is that the same representation can be treated as an <code>int</code> or a <code>Number</code> instance.  The implementation would need a few bits somewhere to tag dynamic type.  Every expression that evaluates to type <code>Number</code> would have to cope.
</p>

<p>
The integral evaluation cases could be faster, but arithmetic evaluation uses <code>Number</code>, so one can&rsquo;t optimize all operators to integer-domain instructions naively.  The integral types thus become more valuable for storage minimization and common native representation goals.
</p>

<p>
Another implementation strategy would use the same wider representation (IEEE double) for all of these types, and just enforce constraints on the integral types.  Given arithmetic evaluation&rsquo;s use of <code>Number</code>, this isn&rsquo;t necessarily that bad.
</p>

<p>
If neither of these approaches is workable, then we should harden the current spec language about <code>int</code> and <code>uint</code> being unrelated types to <code>Number</code>.  In this event, you are right that numeric type testing is too verbose and unsightly.  We would want a <code>numberp</code>.
</p>

<p>
/be
</p>

<p>
I have argued (weakly) in <a href="doku.php%3Fid=clarification:type_hierarchy_for_numbers.html" class="wikilink1" title="clarification:type_hierarchy_for_numbers" onclick="return svchk()" onkeypress="return svchk()">type hierarchy for numbers</a> that it is probably the right thing for the type hierarchy to be flat, as in the draft spec.  You can however do things like this to make life less painful:
</p>
<pre class="code">
    type C = (int, uint, Number, Decimal, Complex)

    if (n is C) { ... } // &quot;is&quot; should say yes if its argument is one of the members of a union

    function f(x : C) { ... }  // constraint on x
</pre>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/05/23 05:58</em>
</p>

</div>

<!-- no cachefile used, but created -->
    <!-- wikipage stop -->
  </div>

  <div class="clearer">&nbsp;</div>

  
  <div class="stylefoot">

    <div class="meta">
      <div class="user">
              </div>
      <div class="doc">
        discussion/nullability.txt &middot; Last modified: 2006/06/02 05:52 by graydon      </div>
    </div>

   
    <div class="bar" id="bar_bottom">
      <div class="bar-left" id="bar_bottomleft">
        <form class="button" method="post" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="edit" /><input type="hidden" name="rev" value="" /><input type="hidden" name="id" value="discussion:nullability" /><input type="submit" value="Show pagesource" class="button" title="ALT+V" accesskey="v" /></form>        <form class="button" method="get" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="revisions" /><input type="hidden" name="id" value="discussion:nullability" /><input type="submit" value="Old revisions" class="button" title="ALT+O" accesskey="o" /></form>      </div>
      <div class="bar-right" id="bar_bottomright">
                        <form class="button" method="get" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="login" /><input type="hidden" name="id" value="discussion:nullability" /><input type="submit" value="Login" class="button" /></form>        <form class="button" method="get" action="index.html" onsubmit="return svchk()"><input type="hidden" name="do" value="index" /><input type="hidden" name="id" value="discussion:nullability" /><input type="submit" value="Index" class="button" title="ALT+X" accesskey="x" /></form>        <a href="doku.php%3Fid=discussion:nullability.html#top"><input type="button" class="button" value="Back to top" onclick="window.scrollTo(0, 0)" /></a>&nbsp;
      </div>
    </div>

  </div>

</div>

<div align="center" class="footerinc">
  <a target="_blank" href="feed.php" title="Recent changes RSS feed"><img src="lib/tpl/default/images/button-rss.png" width="80" height="15" alt="Recent changes RSS feed" border="0" /></a>

  <a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/2.0/" rel="license" title="Creative Commons License"><img src="lib/tpl/default/images/button-cc.gif" width="80" height="15" alt="Creative Commons License" border="0" /></a>

  <a target="_blank" href="https://www.paypal.com/xclick/business=andi%40splitbrain.org&amp;item_name=DokuWiki+Donation&amp;no_shipping=1&amp;no_note=1&amp;tax=0&amp;currency_code=EUR&amp;lc=US" title="Donate"><img src="lib/tpl/default/images/button-donate.gif" alt="Donate" border="0" /></a>

  <a target="_blank" href="http://www.php.net" title="Powered by PHP"><img src="lib/tpl/default/images/button-php.gif" width="80" height="15" alt="Powered by PHP" border="0" /></a>

  <a target="_blank" href="http://validator.w3.org/check/referer" title="Valid XHTML 1.0"><img src="lib/tpl/default/images/button-xhtml.png" width="80" height="15" alt="Valid XHTML 1.0" border="0" /></a>

  <a target="_blank" href="http://jigsaw.w3.org/css-validator/check/referer" title="Valid CSS"><img src="lib/tpl/default/images/button-css.png" width="80" height="15" alt="Valid CSS" border="0" /></a>

  <a target="_blank" href="http://wiki.splitbrain.org/wiki:dokuwiki" title="Driven by DokuWiki"><img src="lib/tpl/default/images/button-dw.png" width="80" height="15" alt="Driven by DokuWiki" border="0" /></a>



<!--

<rdf:RDF xmlns="http://web.resource.org/cc/"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<Work rdf:about="">
   <dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
   <license rdf:resource="http://creativecommons.org/licenses/by-nc-sa/2.0/" />
</Work>

<License rdf:about="http://creativecommons.org/licenses/by-nc-sa/2.0/">
   <permits rdf:resource="http://web.resource.org/cc/Reproduction" />
   <permits rdf:resource="http://web.resource.org/cc/Distribution" />
   <requires rdf:resource="http://web.resource.org/cc/Notice" />
   <requires rdf:resource="http://web.resource.org/cc/Attribution" />
   <prohibits rdf:resource="http://web.resource.org/cc/CommercialUse" />
   <permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" />
   <requires rdf:resource="http://web.resource.org/cc/ShareAlike" />
</License>

</rdf:RDF>

-->
</div>

<img src="lib/exe/indexer.php%3Fid=discussion%253Anullability&amp;1454275585" width="1" height="1" alt=""  /></body>
</html>
