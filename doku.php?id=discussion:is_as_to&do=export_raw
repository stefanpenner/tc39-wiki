This is the discussion page for [[proposals:is_as_to]].


====== Concerns about this proposal ======

I am a little uncertain on whether this proposal is "ready".

  * Some of the issues addressed tie in with the [[clarification:type system]], [[proposals:strict and standard modes]], and strict-vs-standard, but the type system is not well defined yet, the static-vs-dynamic proposal has no meat on the bones, and the draft spec is incomplete on strict-vs-dynamic (I think our discussions have progressed beyond what is written up)
  * I find it disconcerting that annotations are simply dropped in the standard language, ie, the implication is that there is no typechecking in the standard language and that ''var x : T = y'' is not the same as ''var x : T; x = y''.  This is in apparent conflict with section 3.5.2 of the January 26 draft.

I suspect this proposal should be put on hold until there is more good information available on the distinction between the strict and standard languages.

----

What did you mean by "''var x : T = y'' is not the same as ''var x : T; x = y''"? My understanding is that they are the same.

Also, if this proposal defines the meaning of the ''is'', ''as'', ''to'', and ''cast'' operators, then it has done its job. We can leave the definition of '':'' to [[clarification::type system]].

 --- //[[jodyer@adobe.com|Jeff Dyer]] 2006/05/19 09:07//

I am quoting the proposal: "Annotation var v : T = x which means var v = x to T.".  Note how the annotation on v is lost, thus implying in effect "var v : * = x to T".  At least that's how I read it.

 --- //[[lth@opera.com|Lars T Hansen]] 2006/05/19 10:31//


====== Syntax discussion ======

[//[[lth@opera.com|Lars T Hansen]] 2006/05/20 07:00//  --- Moved from the proposal page because it is really a discussion and because I generally agree with Jeff's point; the current proposal stands.]

  * syntax proposal 1: ''cast.<T>(x)'' is unambiguous, mirrors the type parameterization syntax, and mirrors C++
      * the idea with ''cast T(x)'' is that it reforms ''T(x)'', the E3 poor man's cast/conversion. I still like ''cast T(x)'' better because it has two (maybe three) fewer characters and doesn't look like a parameterised type, which it isn't.
  * syntax proposal 2: ''x as T'' is even better, IMO
      * this has two problems: it means something different in AS3; and it doesn't allow ''T'' to be a full //TypeExpression// because of syntactic ambiguity with other kinds of expressions that might occur there.
        * AS3 issue noted.  But the syntactic ambiguity does not exist with the [[proposals:syntax for type expressions]] clarification, does it?  What is the nature of the ambiguity?
           * the rhs of ''as'' is an expression that can be a //PrimaryExpression// which can be a //ParenExpression//, //ObjectLiteral//, etc. I suppose we should fix that so that the rhs of ''as'', ''to'' and ''is'' must be a //TypeExpression//. That certainly makes more sense that what is currently allowed.


----
I have a personal preference for ''cast.<T>(x)'', which is simply that ''as'' is a less-common word in the literature and history. The word ''cast'' has a longer and more widely-known history in programming languages. New users are less likely to wonder what it means.  

--- //[[graydon@mozilla.com|graydon]] 2006/05/20 23:35//

====== Existing situation ======

At the Jan 19 meeting there was some consensus that the proposed spec contains too many type annotations and too many type operators. Currently the spec contains:

  * operator ''to'' which calls a user-provided conversion operator (or one of several builtins).  
  * operator ''as'' which downcasts or returns null if the downcast fails
  * operator ''is'' which is a boolean predicate
  * annotation ''var v to T = x'' which means ''var v = x to T''
  * annotation ''var v as T = x'' which means ''var v = x as T''
  * annotation ''var v is T = x'' which means ''var v; if( x is T ) v = x; else throw new TypeError''
  * annotation ''var v : T'' which means ''var v to T''



====== Older discussion ======

===== Interaction with Null type and unsafe downcasts =====

Some users might wish to "look inside" unsafe downcasts to ensure that they are being safe: checking for ''null'' before casting to non-''null'', or in general checking that a value ''v'' of type ''T'' is also of a subtype ''U'' before casting to ''U''.

One possible technique follows:

  * Make the type-cast exception statically checked (like a checked exception in java) in strict mode.
  * For any casts ''cast T(x:U)'' where ''U <: T'' (a widening cast), eliminate the possibility of an exception being thrown.

Under this technique, only those casts guaranteed to succeed would pass the typechecker unadorned. Those cases guaranteed to fail would be hard errors, and those of unknown success (downcasts) would require that they be enclosed in an exception-catching block which handled the case of a failed downcast.

===== A more popular proposal =====

... has been moved to [[switch class]].

===== Notation for type nullability =====

... has been moved to [[nullability]].

====== Casts ======

Are both ''cast'' and ''to'' necessary?

The ''is'' operator essentially gives us the ability to check the type of a value (using the subtyping algorithm) -- and this is important. The other operation we need is casting. The ''to'' method gives programmers the ability to write their own custom casts (similarly to C++ cast overloading), which is a nice feature. But for actually performing casts, is there any need to have these two separate operators, ''cast'' and ''to''? Why not combine these to one operator? If there's an ambiguity, let the custom ''to'' method win.

 --- //[[dherman@ccs.neu.edu|Dave Herman]] 2006/08/11 17:25//


====== Proposed amendments (retired from main page 2007/03/13) ======



===== Function coercion =====

At the May f2f Cormac noted that there is a generalized "function coercion" idea lurking here.  Here is a proposal that attempts to capture that.

Consider a function f taking a function parameter fp:

    function f( fp: function ( int ) : int ) { ... }

Calling this with a function that matches the signature is straightforward:

    f( function ( x : int ) : int { return x+37; } )

Now the situation is that there are conversions from double to int and int to double, yet the following is not allowed:

    f( function ( x : double ) : double { return x+37.0; } )

We can introduce a notion of function coercion with the following rules.  Suppose a function argument //fp// to a function //f// takes arguments of types //fp_a_1//, ..., //fp_a_n// and returns a type //fp_r//.  We wish to call //f// with an actual argument //g// with argument types //g_a_1//, ..., //g_a_n//.  If the type of //g// is a subtype of //fp// we're done.  Otherwise, if there exists a one-step conversion (maybe the identity conversion) from //fp_a_i// to //g_a_i// and a one-step conversion from //g_r// to //fp_r//, then //f// can be called with //g// wrapped in a function that converts arguments and return values, that is:

<code>
    function g ( x : double ) : double { return x+37.0; };

    f( function ( x : int ) : int { return g(x); } )
</code>

I propose that such wrapping should happen automatically.

This would be expressed as part of the semantics of ''to'', where a function value f can be conversed to a function type T if the above rules hold: ''g to (function (int) : int)''.

It would not be hard to provide for this.  It might benefit scripting-type applications in the presence of strongly typed library code.  The alternatives are:
  * use 'Object' or '*' types;
  * push a union type into the function being passed, but even that does not generalize, because unions are not extensible: an existing library does not allow its interface types to be extended; or
  * use parameterized functions.  (In the above case, //f// would be parameterized on its argument and return type(s).  This does not feel entirely natural; it requires the library writer to anticipate uses, rather than leaving that to the library user.)

 --- //[[lth@opera.com|Lars T Hansen]] 2006/05/29 19:31//

===== More retired proposal text =====


====== Primary 'to' ======

As with ''cast'' it would be useful to be able to use a ''to'' operation as the base of a reference as in,

<code>
to T(x).foo()
</code>

Therefore we propose to add a primary (cast-like) ''to'' operator that takes a //TypeExpression// as the first operand and a //ParenListExpression// whose value is to be converted as the second operand.

====== Binary 'cast' ======

As with the binary ''to'' operator it would be useful to be able to use a ''cast'' operation when the destination type is not known at compile time as in,

<code>
x cast foo()
</code>

Therefore we propose to add a binary ''cast'' operator that takes a //RelationalExpression// representing the value to be checked as the left operand and a //ShiftExpression// representing the destination type as the right operand.

 --- //[[jodyer@adobe.com|Jeff Dyer]] 2007/03/13 14:01//
