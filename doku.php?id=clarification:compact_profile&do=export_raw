====== Motivation ======

A compact profile is motivated by the need to run ECMAScript programs on very small machines, with these constraining factors:

  * memory: maybe a few hundreds of kilobytes of RAM available to the scripting engine
  * footprint: there is constrained space for the code of the engine (including built-in libraries)
  * performance: these are devices in the range of 100MHz-400MHz with small caches and slow memories

A compact profile only makes sense if it is **useful**: It must support enough of the language to meet the needs of the programmers.  This is difficult, because programmers tend not to read specs, nor to allow themselves to be constrained by needs they have not seen or customers they have not met.  They will tend to use all facilities available.

====== Prior work ======

===== ECMAScript 3rd Edition Compact Profile =====

Edition 3 defined a compact profile (ECMA-327) that addressed these concerns by defining a subset language that left out the ''eval'' operator and the ''Function'' constructor (thus obviating the need for compiling ECMAScript code on the device itself, thereby saving memory for the compilation, footprint for the compiler, and the time to compile the code) and defined system objects as read-only (thus allowing them to be shared between different document contexts).  In addition the ''with'' statement did not have to supported, and along with the absence of ''eval'' this would allow scope chains to be represented more efficiently.

===== Open Mobile Alliance "ECMAScript Mobile Profile" =====

This is ECMAScript Compact Profile with the addition of versioning properties on some objects, among other things: in other words, an extended subset of ECMAScript 3rd edition.

===== How useful is 3rd Edition Compact Profile? =====

It's not useful in practice on the public web.  Opera has been looking at the demographics in the scripts on the web.  With the caveat that I don't know entirely how representative the following numbers are, I note that of a population of scripts from 420000 web pages:
  * 21% use ''eval''
  * 18% use ''with''
  * 22% use ''arguments''
  * 11% use exception handling
A reasonable conclusion would be that a large fraction of the web would not work in a browser supporting only Compact Profile.

We've instead chosen to implement the full language, and optimize the implementation heavily.  This is costly but it works in practice, in 3rd Edition.

====== Compact Profile for 4th Edition ======

Leaving aside for the moment whether we should have a compact profile, here are some initial thoughts about what we could/should do for 4th edition.

From the programmer's point of view, language or library subsetting is a poor choice, and he will submit to using a subset only if he knows his target platform.  Most authors for the web cannot be expected to follow this discipline.

From the implementor's point of view the following aspects of language and library are no good because they make the implementation complex or reduce the number of choices:

  * Supporting multiple incompatible language dialects and libraries
  * Large standard libraries
  * A rich, non-orthogonal language
  * Language features requiring run-time interpretation
  * Language features requiring full ASTs to be built (3rd edition plus E4X can be compiled building trees for only the expressions)
  * Language features requiring the use of expensive implementation techniques (unbounded lookahead, multi-pass compilation, real-time garbage collection, ...)

Apart from avoiding the above issues, here are some techniques that can be applied to 4th edition:

  * The proposed dynamic/static split is a promising idea (see [[proposals:strict and standard modes]]).
  * Optional / add-on libraries clearly marked as such and set apart in an appendix may work better than library subsets.  We've discussed this in the context of introspection facilities.
  * We could consider a standard representation for compiled programs, so that on-line compilation becomes less necessary.
  * We should avoid implementation artifacts in the language.
  * We might consider allowing for a Unicode subset if this allows Unicode support in the implementation (chiefly tables?) to be significantly smaller.

Some things we could do but which I think are probably non-starters:

  * We could work to remove dynamic scoping (see the [[lexical scope]] and [[proposals:with-bound variables]] proposals)
