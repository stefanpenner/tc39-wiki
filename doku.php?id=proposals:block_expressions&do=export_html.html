<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=proposals:block_expressions&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=proposals" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=proposals:block_expressions&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=proposals:block_expressions&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=proposals:block_expressions&amp;do=export_html.html#let_bindings" class="toc">''Let'' bindings</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=proposals:block_expressions&amp;do=export_html.html#let_statement" class="toc">Let statement</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=proposals:block_expressions&amp;do=export_html.html#let_expression" class="toc">Let expression</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=proposals:block_expressions&amp;do=export_html.html#comments" class="toc">Comments</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=proposals:block_expressions&amp;do=export_html.html#let_definitions" class="toc">Let definitions</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=proposals:block_expressions&amp;do=export_html.html#let-scoped_variables_in_for_loops" class="toc">Let-scoped variables in ''for'' loops</a></span></li>
</ul>
</li>
</ul>
</div>
</div>

<a name="let_bindings"></a><h1>''Let'' bindings</h1>
<div class="level1">

<p>
<strong>Tickets</strong>: <a href="http://bugs.ecmascript.org/ticket/240" class="urlextern" target="_blank" title="http://bugs.ecmascript.org/ticket/240" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">#240</a>, <a href="http://bugs.ecmascript.org/ticket/243" class="urlextern" target="_blank" title="http://bugs.ecmascript.org/ticket/243" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">#243</a>, <a href="http://bugs.ecmascript.org/ticket/253" class="urlextern" target="_blank" title="http://bugs.ecmascript.org/ticket/253" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">#253</a>.
</p>

<p>
(Also see the <a href="doku.php%3Fid=discussion:block_expressions.html" class="wikilink1" title="discussion:block_expressions" onclick="return svchk()" onkeypress="return svchk()">discussion page</a> for this proposal)
</p>

<p>
This proposal introduces a keyword <code>let</code> that provides local scoping constructs for variables, constants, and functions.
</p>

<p>
The rationale for the proposal is that tighter scope discipline for all variables is Good.
</p>

</div>
<!-- SECTION [1-489] -->
<a name="let_statement"></a><h2>Let statement</h2>
<div class="level2">

<p>
 Syntax:
</p>
<pre class="code">
   LetStatement ::= &quot;let&quot; &quot;(&quot; (VarInit (&quot;,&quot; VarInit)*)? &quot;)&quot; Block
   VarInit ::= ID (&quot;:&quot; Type)? (&quot;=&quot; Expression)?
             | Pattern (&quot;:&quot; Type)? &quot;=&quot; Expression
</pre>

<p>
The <code>let</code> statement binds zero or more variables whose scopes are the following Block (but not the binding clause), and then evaluates Block.  The completion value of the statement is the completion value of the Block.
</p>

<p>
There is nothing magic about the Block.  <code>var</code> statements inside the Block are hoisted as they are normally.  Function declarations are not allowed here (just as they are not normally allowed inside Blocks).
</p>

<p>
Observe that the parens following <code>let</code> are required, they could be optional but for symmetry with Let expressions (where they are not optional) they are made mandatory.
</p>

<p>
Example:
</p>
<pre class="code">
   let (x=x+10, y=12) {
     print(x+y);
   }
</pre>

<p>
The use of a destructuring <code>Pattern</code> in the binding is explored more fully in the proposal for <a href="doku.php%3Fid=proposals:destructuring_assignment.html" class="wikilink1" title="proposals:destructuring_assignment" onclick="return svchk()" onkeypress="return svchk()">destructuring assignment</a>.
</p>

</div>
<!-- SECTION [490-1511] -->
<a name="let_expression"></a><h2>Let expression</h2>
<div class="level2">

<p>
 Syntax:
</p>
<pre class="code">
    LetExpression ::= let &quot;(&quot; (VarInit (&quot;,&quot; VarInit)*)? &quot;)&quot; ListExpression
</pre>

<p>
The variables bound by the <code>let</code> expression have as their scope the ListExpression (but not the binding clause).  The expression evaluates the initializers in order and then evaluates ListExpression, whose value is the result of the entire expression.
</p>

<p>
LetExpressions are PrimaryExpressions in the sense of section 14.2 of the draft spec.
</p>

<p>
Example:
</p>
<pre class="code">
   print( let (x=x+10, y=12) x+y )
</pre>

<p>
<strong>Restriction:</strong> If the LetExpression is in the statement position then the ListExpression cannot be an object literal, as that would be seen to be the start of a Block (and the statement would be taken to be a LetStatement).
</p>

</div>
<!-- SECTION [1512-2269] -->
<a name="comments"></a><h3>Comments</h3>
<div class="level3">

<p>
 The expression at the tail of a let expression should be an AssignmentExpression to avoid conflicts when embedded in other lists. For example,
</p>
<pre class="code">
   print( let (x=x+10, y=12) x+y, &quot;hello, world!&quot; )
</pre>

<p>
If the user wants the second expression to be a part of the let, they can use parens to say so.
</p>
<pre class="code">
   print( let (x=x+10, y=12) (x+y, &quot;hello, world!&quot;) )
</pre>

<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/05/21 09:38</em>
</p>

</div>
<!-- SECTION [2270-2727] -->
<a name="let_definitions"></a><h2>Let definitions</h2>
<div class="level2">

<p>
 The <code>let</code> keyword can be used to introduce definitions of variables, constants, and functions into a block.  For example,
</p>
<pre class="code javascript">   <span class="kw1">if</span> <span class="br0">&#40;</span>x &gt; y<span class="br0">&#41;</span>
   <span class="br0">&#123;</span>
      let <span class="kw2">const</span> k = <span class="nu0">37</span>;
      let gamma : int = <span class="nu0">12</span>.<span class="nu0">7</span> + k;
      let i = <span class="nu0">10</span>;
      let <span class="kw2">function</span> f<span class="br0">&#40;</span>n<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="br0">&#40;</span>n/<span class="nu0">3</span><span class="br0">&#41;</span>+k; <span class="br0">&#125;</span>
      <span class="kw1">return</span> f<span class="br0">&#40;</span>gamma<span class="br0">&#41;</span> + f<span class="br0">&#40;</span>i<span class="br0">&#41;</span>;
   <span class="br0">&#125;</span></pre>
<p>
Variables, functions, and constants declared by <code>let</code>, <code>let function</code>, and <code>let const</code> respectively have as their scope the entire Block in which they are defined and any inner Blocks in which they are not redefined.
</p>

<p>
In programs and classes <code>let</code> does not create properties on the global and class objects like <code>var</code> does; instead, it creates properties in an implicit block created for the evaluation of statements in those contexts.
</p>

<p>
In functions, <code>let</code> executed by <code>eval</code> does not create properties on the variable object (activation object or innermost binding rib) like <code>var</code> does; instead, it creates properties in an implicit block created for the evaluation of statements in the program.  (This is just a consequence of <code>eval</code> operating on programs coupled with the preceding rule.) 
</p>
<hr noshade="noshade" size="1" />

<p>
This may seem like a &ldquo;dumb question&rdquo;, but it&rsquo;s really a dumb bug in our prototype: Does the mandatory braced body of <code>switch</code> count as a block?
</p>
<pre class="code javascript"><span class="kw2">function</span> g<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="co1">// are y and z visible here?  (I hope not.)</span>
    <span class="kw1">switch</span> <span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">case</span> <span class="nu0">1</span>:
        <span class="co1">// In any case, y and z should be bound here...</span>
        let y;
      <span class="kw1">case</span> <span class="nu0">2</span>:
        <span class="co1">// and here...</span>
        let z;
    <span class="br0">&#125;</span>
    <span class="co1">// but probably not here.</span>
<span class="br0">&#125;</span></pre>
<p>
With <code>try</code>, <code>catch</code>, and <code>finally</code> which have mandatory blocks, there&rsquo;s no confusion.  But <code>switch</code> bodies are not blocks, grammatically.  They look like blocks, however, and I think they should scope <code>let</code> as other blocks do.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/09/07 16:27</em>
</p>

<p>
Agreed. The brace after <code>switch</code> should begin a block scope.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/09/11 12:10</em> 
</p>
<hr noshade="noshade" size="1" />

<p>
OK, for another &ldquo;dumb question&rdquo; that I don&rsquo;t see explicitly addressed (but is used by way of example in the previous question)... is it legal to leave the initializer off of a let-declared variable, as with a var-declared variable? e.g.,
</p>
<pre class="code javascript">   let foo;
   let i:int;
   trace<span class="br0">&#40;</span>i<span class="br0">&#41;</span>;  <span class="co1">// outputs &quot;undefined&quot;, I presume</span></pre>
<p>
 &mdash; <em><a href="mailto:%26%23x73%3B%26%23x74%3B%26%23x65%3B%26%23x6a%3B%26%23x6f%3B%26%23x68%3B%26%23x6e%3B%26%23x73%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x73;&#x74;&#x65;&#x6a;&#x6f;&#x68;&#x6e;&#x73;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Steven Johnson</a> 2006/10/05 17:22</em>
</p>

<p>
I think this should be fine.  <code>let</code> is just a better <code>var</code> in that it provides control over the scope; in all other respects they should be the same (reduces cognitive load).
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/10/11 05:52</em>
</p>

<p>
But the default value for an <code>int</code>-annotated variable (declared by any means) is <code>0</code>, not <code>undefined</code> &ndash; right?  <code>undefined</code> is not in the value set for <code>int</code>.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/10/11 10:11</em>
</p>

</div>
<!-- SECTION [2728-5637] -->
<a name="let-scoped_variables_in_for_loops"></a><h2>Let-scoped variables in ''for'' loops</h2>
<div class="level2">

<p>
 <code>let</code> can be used to bind variables locally in the scope of <code>for</code> loops in the same way that <code>var</code> can.  For example,
</p>
<pre class="code">
   var i=0;
   for ( let i=i ; i &lt; 10 ; i++ )
     print(i);

   for ( let &amp;[name,value] in obj )
     print(&quot;Name: &quot; + name + &quot;, Value: &quot; + value);
</pre>

<p>
In loops of the form <code>for (let E1 ; E2 ; E3) S</code> the scope of variables bound in E1 excludes E1.  The first example illustrates this case, where a locally bound <code>i</code> takes the value of the outer <code>i</code> as its initial value.
</p>

<p>
In loops of the form <code>for (let E1 in E2) S</code> and <code>for each (let E1 in E2)</code> the scope of variables bound in E1 excludes both E1 and E2.
</p>

<p>
In order to allow a natural update style for loop variables, the variables are bound once before the first iteration and reused in subsequent iterations.  Thus the result of the following program is <code>5</code>, not <code>0</code>:
</p>
<pre class="code">
    var x = null;
    for ( let i=0 ; i &lt; 5 ; i++ )
        if (!x)
            x = function () { return i; }
    x();
</pre>

<p>
For <code>for-in</code> and <code>for-each</code> loops it seems viable to rebind the variables for each iteration, but it is probably unnecessarily confusing to have different rules for different loop types. 
</p>
<hr noshade="noshade" size="1" />

<p>
 This question came up just recently based on our implementation: is <code>for (let (x = y.z) side_effects(x*x); E2; E3);</code> legal?  Should it be?
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/09/01 23:01</em>
</p>

<p>
As an instance of <code>for (E1; E2; E3);</code>, you mean? I don&rsquo;t see why not. Are you suggesting adding restrictions to the grammar to prevent certain instances? Even if you don&rsquo;t have macros in the language, grammar restrictions are a pain for any tools that generate code.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x64%3B%26%23x68%3B%26%23x65%3B%26%23x72%3B%26%23x6d%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x63%3B%26%23x63%3B%26%23x73%3B%26%23x2e%3B%26%23x6e%3B%26%23x65%3B%26%23x75%3B%26%23x2e%3B%26%23x65%3B%26%23x64%3B%26%23x75%3B" class="mail" title="&#x64;&#x68;&#x65;&#x72;&#x6d;&#x61;&#x6e;&#x40;&#x63;&#x63;&#x73;&#x2e;&#x6e;&#x65;&#x75;&#x2e;&#x65;&#x64;&#x75;">Dave Herman</a> 2006/09/02 06:34</em>
</p>

<p>
Yes, this is about the C-style for loop.  We support <code>var</code> or <code>let</code> declarations, but code re-use in our parser led to exclusion of the <code>let</code> expression form, because <code>var (...</code> has never been legal.  And yes, I agree we should not have any such restriction in the ES4 grammar, so this is our bug.  This proposal was not complete in specifying that an E1 that is a <code>let</code> expression must be legal, though.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/09/02 17:44</em> 
</p>

</div>
<!-- SECTION [5638-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/d/da9d83d47cdabd518ea29fb7fcc7f387.xhtml used -->
</body>
</html>
