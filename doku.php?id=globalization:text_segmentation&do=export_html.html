<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=globalization:text_segmentation&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=globalization" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=globalization:text_segmentation&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=globalization:text_segmentation&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>

<a name="text_segmentation"></a><h1>Text Segmentation</h1>
<div class="level1">

<p>
 This is a very rough proposal for adding a text-segmentation capability to the next edition of the ECMAScript internationalization standard.
</p>

</div>
<!-- SECTION [1-175] -->
<a name="use_cases"></a><h2>Use cases</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> Splitting a single string into its constituent [grapheme clusters, words, sentences, paragraphs].</div>
</li>
<li class="level1"><div class="li"> Counting the number of [grapheme clusters, words, sentences, paragraphs] in a string.</div>
</li>
<li class="level1"><div class="li"> Locating the starting and ending boundaries of the [grapheme cluster, word, sentence, paragraph] containing a particular character offset in a document.  (e.g., for double-click handling in a text editing application).</div>
</li>
<li class="level1"><div class="li"> Supporting breaking a document into lines for rendering by locating the last legal line-break position before a given position in the string.</div>
</li>
<li class="level1"><div class="li"> Offline indexing of documents.</div>
</li>
</ul>

</div>
<!-- SECTION [176-800] -->
<a name="proposed_api"></a><h2>Proposed API</h2>
<div class="level2">

<p>
 Introduce an <code>Intl.TextSegmenter</code> object.  Constructor takes the same <code>locale</code> and <code>options</code> parameters as the other <code>Intl</code> objects, plus a <code>String</code> parameter referring to the string to be segmented*.  For now, one property in the options object is significant: <code>segmentType</code>.  This can have five values: <code>&ldquo;grapheme&rdquo;</code>, <code>&ldquo;word&rdquo;</code>, <code>&ldquo;lineBreak</code>&ldquo;, <code>&ldquo;sentence&rdquo;</code>, and <code>&ldquo;paragraph&rdquo;</code>, which are strings.  (Anything else defaults to <code>&ldquo;word&rdquo;</code>.)
</p>

<p>
<code>String.prototype.split()</code> can now take a <code>TextSegmenter</code> as well as a <code>RegEx</code>.  When used with a <code>TextSegmenter</code>, <code>split()</code> breaks the string into the units the <code>TextSegmenter</code> detects.
</p>

<p>
<code>TextSegmenter.prototype</code> would have the following functions as properties:
</p>
<ul>
<li class="level1"><div class="li"> <code>numSegments()</code>: Returns the number of segments in the string.</div>
</li>
<li class="level1"><div class="li"> <code>segmentContaining(pos)</code>: Returns an <code>Object</code> with two properties: <code>start</code> and <code>end</code>, representing the starting and ending positions in the string of the segment containing the specified position.  (Out-of-range values would return <code>undefined</code>.)</div>
</li>
<li class="level1"><div class="li"> <code>segmentType(segment)</code>: Returns some sort of value indicating the &ldquo;type&rdquo; of the specified segment.  This is really only useful for word breaking, where the text between two word boundaries might be a delimiter (whitespace or punctuation) rather than a word.  The input value is intended to be the result of a <code>segmentContaining()</code> callâ€”an <code>Object</code> whose <code>start</code> and <code>end</code> properties are valid boundary positions in the string.  If it&rsquo;s anything else, we use <code>segmentContaining()</code> to get a valid &ldquo;segment&rdquo; object.</div>
</li>
<li class="level1"><div class="li"> We could also provide <code>firstSegment()</code>, <code>lastSegment()</code>, <code>nextSegment()</code>, and <code>previousSegment()</code> convenience functions, although all of these operations can also be done with <code>segmentContaining()</code>.</div>
</li>
</ul>

<p>
 It might be nice to also modify <code>String.prototype.substring()</code> to allow the caller to pass in a &ldquo;segment&rdquo; object.
</p>

<p>
 &mdash; <em>Rich Gillam 2012/12/19</em>
</p>

<p>
 &mdash; <em>Nebojsa Ciric 2012/12/21</em>
</p>

<p>
 * Intl.TextSegmenter(locales, options, text) - so it would be 1 segmenter object per string? Isn&rsquo;t that expensive? Why not assign text to the object after construction?
</p>

<p>
 &mdash; <em>Rich Gillam 2013/1/2</em>
</p>

<p>
 * Yes.  I expected this to be controversial, and I&rsquo;m not married to it.  My thinking was that it simplifies the usage model&ndash; instead of creating a segmenter and then assigning a string to it, you do both in one step.  This doesn&rsquo;t match the implementation in ICU, of course, but I was thinking that the glue layer might be able to cache and reuse ICU BreakIterators so as to support the simpler usage model.  In the same way, I was trying for an <acronym title="Application Programming Interface">API</acronym> design that was stateless, on the theory that it better supported the use cases I knew about.  Again, the glue layer could maintain state when necessary to optimize performance.  I don&rsquo;t know&ndash; maybe it&rsquo;d make more sense to stick with a thin wrapper around ICU&rsquo;s <acronym title="Application Programming Interface">API</acronym>, but I wanted to &ldquo;think outside the box&rdquo; a little bit.
</p>

<p>
 &mdash; <em>Jungshik Shin 2013/04/09</em>  * What about &lsquo;line&rsquo; (breaking opportunities)? Line breaking is mentioned as an example, but &lsquo;line&rsquo; type is not included. I also wonder how well &lsquo;paragraph&rsquo; breaks are defined.  
</p>

</div>
<!-- SECTION [801-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/d/d98324a606fc733cbd0739df64d4ed4d.xhtml used -->
</body>
</html>
