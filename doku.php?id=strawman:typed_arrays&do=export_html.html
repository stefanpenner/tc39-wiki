<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=strawman:typed_arrays&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=strawman" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#typed_arrays" class="toc">Typed Arrays</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#typed_array_compatible_object_apis_in_ecma-262_style" class="toc">Typed Array compatible object APIs in ECMA-262 style</a></span><ul class="toc">
<li class="clear"><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#1_arraybuffer_objects" class="toc">1	 ArrayBuffer Objects</a></span><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#1.1_the_arraybuffer_constructor_called_as_a_function" class="toc">1.1	The ArrayBuffer Constructor Called as a Function</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#1.2_the_arraybuffer_constructor" class="toc">1.2	The ArrayBuffer Constructor</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#1.3_properties_of_the_arraybuffer_constructor" class="toc">1.3	Properties of the ArrayBuffer Constructor</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#1.4_properties_of_the_arraybuffer_prototype_object" class="toc">1.4	Properties of the ArrayBuffer Prototype Object</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#1.5_properties_of_the_arraybuffer_instances" class="toc">1.5	Properties of the ArrayBuffer Instances</a></span></li>
</ul>
</li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#2_typearray_objects" class="toc">2	TypeArray Objects</a></span><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#2.1_the_typearray_constructor_called_as_a_function" class="toc">2.1	The TypeArray Constructor Called as a Function</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#2.2_the_typearray_constructor" class="toc">2.2	The TypeArray Constructor</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#2.3_properties_of_the_typearray_constructor" class="toc">2.3	Properties of the TypeArray Constructor</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#2.4_properties_of_the_typearray_prototype_object" class="toc">2.4	Properties of the TypeArray Prototype Object</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#2.5_properties_of_typearray_instances" class="toc">2.5	Properties of TypeArray instances</a></span></li>
</ul>
</li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#3_dataview_objects" class="toc">3	DataView Objects</a></span><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#3.1_the_dataview_constructor_called_as_a_function" class="toc">3.1	The DataView Constructor Called as a Function</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#3.2_the_dataview_constructor" class="toc">3.2	The DataView Constructor</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#3.3_proeprties_of_the_dataview_constructor" class="toc">3.3	Proeprties of the DataView Constructor</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#3.4_properties_of_the_dataview_prototype_object" class="toc">3.4	Properties of the DataView Prototype Object</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=strawman:typed_arrays&amp;do=export_html.html#3.5_propeties_of_dataview_instances" class="toc">3.5	Propeties of DataView Instances</a></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<a name="typed_arrays"></a><h1>Typed Arrays</h1>
<div class="level1">

<p>
 The <a href="http://www.webgl.org" class="urlextern" target="_blank" title="http://www.webgl.org" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">WebGL</a> spec needs a method for high-performance access to native-typed data.  That group invented its own set of objects for this, but it has now been adopted in <a href="http://dev.w3.org/2006/webapi/FileAPI/#readAsArrayBuffer" class="urlextern" target="_blank" title="http://dev.w3.org/2006/webapi/FileAPI/#readAsArrayBuffer" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">FileAPI</a>, <a href="http://www.w3.org/TR/file-writer-api/#dfn-arraybuffer" class="urlextern" target="_blank" title="http://www.w3.org/TR/file-writer-api/#dfn-arraybuffer" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">FileWriter</a>, <a href="http://dev.w3.org/2006/webapi/XMLHttpRequest-2/#the-response-attribute" class="urlextern" target="_blank" title="http://dev.w3.org/2006/webapi/XMLHttpRequest-2/#the-response-attribute" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">XHR2</a>, and is being considered for <a href="http://lists.w3.org/Archives/Public/public-webapps/2011JanMar/0131.html" class="urlextern" target="_blank" title="http://lists.w3.org/Archives/Public/public-webapps/2011JanMar/0131.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Web Sockets</a>.  Other groups like CommonJS have also been <a href="http://wiki.commonjs.org/wiki/Binary" class="urlextern" target="_blank" title="http://wiki.commonjs.org/wiki/Binary" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">working on something similar</a>.
</p>

<p>
The core of the proposal is found here <a href="https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/TypedArray-spec.html" class="urlextern" target="_blank" title="https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/TypedArray-spec.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">https://cvs.khronos.org/svn/repos/registry/trunk/public/webgl/doc/spec/TypedArray-spec.html</a> and is descibed in ECMA-262 style <a href="doku.php%3Fid=strawman:typed_array.html#typed_array_compatible_object_apis_in_ecma-262_style" class="wikilink2" title="strawman:typed_array" onclick="return svchk()" onkeypress="return svchk()">below</a>. Here&rsquo;s an overview: 
</p>
<ul>
<li class="level1"><div class="li"> An ArrayBuffer type is introduced, which is an opaque buffer.  It is created with an explicit length, and is fixed length during its lifetime.  ArrayBuffer contents cannot be accessed directly.</div>
</li>
<li class="level1"><div class="li"> A number of types are introduced that describe how to interpret the bytes in an ArrayBuffer.  For example, an Int32Array views the bytes in an ArrayBuffer (or a subregion of an ArrayBuffer) as 32-bit signed integers.</div>
</li>
<li class="level1"><div class="li"> Multiple views can exist for the same ArrayBuffer, allowing for complex data structures to be built up, albeit with some difficulty.  </div>
</li>
<li class="level1"><div class="li"> A DataView type is introduced which allows arbitrary indexed reads and writes of basic types from the bytes in the underlying ArrayBuffer.</div>
</li>
<li class="level1"><div class="li"> The goal is to allow as close to the native byte access as possible with very few performance penalties, while still retaining safety.</div>
</li>
</ul>

<p>
 Example code:
</p>
<pre class="code javascript">  <span class="kw2">var</span> buf = <span class="kw2">new</span> ArrayBuffer<span class="br0">&#40;</span><span class="nu0">100</span><span class="br0">&#41;</span>;  <span class="co1">// create 100-byte ArrayBuffer</span>
&nbsp;
  <span class="kw2">var</span> ints = <span class="kw2">new</span> Int32Array<span class="br0">&#40;</span>buf<span class="br0">&#41;</span>;  <span class="co1">// view that buffer as 32-bit integers</span>
  <span class="kw3">print</span><span class="br0">&#40;</span>ints.<span class="me1">length</span> == <span class="nu0">25</span><span class="br0">&#41;</span>;        <span class="co1">// true -- 4 bytes for each element </span>
  <span class="kw3">print</span><span class="br0">&#40;</span>ints.<span class="me1">byteLength</span> == <span class="nu0">100</span><span class="br0">&#41;</span>;   <span class="co1">// true -- the length of ints is 100 bytes</span>
&nbsp;
  <span class="kw2">var</span> fourShorts = <span class="kw2">new</span> Int16Array<span class="br0">&#40;</span>buf, <span class="nu0">20</span>, <span class="nu0">4</span><span class="br0">&#41;</span>;  <span class="co1">// 4 16-bit integers  starting at byte 20 in the buffer</span>
  <span class="kw3">print</span><span class="br0">&#40;</span>fourShorts.<span class="me1">length</span> == <span class="nu0">4</span><span class="br0">&#41;</span>;         <span class="co1">// true -- 4 elements, as specified</span>
  <span class="kw3">print</span><span class="br0">&#40;</span>fourShorts.<span class="me1">byteLength</span> == <span class="nu0">8</span><span class="br0">&#41;</span>;     <span class="co1">// true -- 4 elements, 2 bytes each</span>
  <span class="kw3">print</span><span class="br0">&#40;</span>fourShorts.<span class="me1">byteOffset</span> == <span class="nu0">20</span><span class="br0">&#41;</span>;    <span class="co1">// true -- the offset into the ArrayBuffer is 20, as specified</span>
&nbsp;
  ints<span class="br0">&#91;</span><span class="nu0">5</span><span class="br0">&#93;</span> = 0x11223344;
  <span class="kw3">print</span><span class="br0">&#40;</span>fourShorts<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> == 0x3344<span class="br0">&#41;</span>;        <span class="co1">// true -- same bytes were modified</span>
  <span class="kw3">print</span><span class="br0">&#40;</span>fourShorts<span class="br0">&#91;</span><span class="nu0">1</span><span class="br0">&#93;</span> == 0x1122<span class="br0">&#41;</span>;        <span class="co1">// true -- platform endianness for arrays created by JS, </span></pre>
<p>
 <strong>Comments</strong>
</p>

<p>
Looks mostly good, although I&rsquo;m a little concerned that exposing native endian-ness might introduce incompatibilities.  &mdash; <em><a href="mailto:%26%23x63%3B%26%23x6f%3B%26%23x72%3B%26%23x6d%3B%26%23x61%3B%26%23x63%3B%26%23x40%3B%26%23x73%3B%26%23x6f%3B%26%23x65%3B%26%23x2e%3B%26%23x75%3B%26%23x63%3B%26%23x73%3B%26%23x63%3B%26%23x2e%3B%26%23x65%3B%26%23x64%3B%26%23x75%3B" class="mail" title="&#x63;&#x6f;&#x72;&#x6d;&#x61;&#x63;&#x40;&#x73;&#x6f;&#x65;&#x2e;&#x75;&#x63;&#x73;&#x63;&#x2e;&#x65;&#x64;&#x75;">Cormac Flanagan</a> 2010/01/27 00:14</em>
</p>

<p>
Would typed arrays be extended to any value type, so it can be a buffer of &ldquo;structs&rdquo;?  &mdash; <em><a href="mailto:%26%23x69%3B%26%23x68%3B%26%23x61%3B%26%23x62%3B%26%23x2e%3B%26%23x61%3B%26%23x77%3B%26%23x61%3B%26%23x64%3B%26%23x40%3B%26%23x67%3B%26%23x6d%3B%26%23x61%3B%26%23x69%3B%26%23x6c%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x69;&#x68;&#x61;&#x62;&#x2e;&#x61;&#x77;&#x61;&#x64;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">Ihab Awad</a> 2010/05/24 23:25</em>
</p>

<p>
@cormac: For scenarios like file reading and network protocol binary parsing, it is important to be able to observe and control endianness explicitly.  The DataView object provides this capability directly. @ihab: If the Binary Data proposal adopts the ArrrayBufferView interface for it&rsquo;s ArrayTypes, it can be used to provide compatible arrays of struct types.    &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x75%3B%26%23x6b%3B%26%23x65%3B%26%23x68%3B%26%23x40%3B%26%23x6d%3B%26%23x69%3B%26%23x63%3B%26%23x72%3B%26%23x6f%3B%26%23x73%3B%26%23x6f%3B%26%23x66%3B%26%23x74%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x75;&#x6b;&#x65;&#x68;&#x40;&#x6d;&#x69;&#x63;&#x72;&#x6f;&#x73;&#x6f;&#x66;&#x74;&#x2e;&#x63;&#x6f;&#x6d;">Luke Hoban</a> 2011/05/17 22:56</em>
</p>

</div>
<!-- SECTION [1-3451] -->
<a name="typed_array_compatible_object_apis_in_ecma-262_style"></a><h1>Typed Array compatible object APIs in ECMA-262 style</h1>
<div class="level1">

</div>
<!-- SECTION [3452-3518] -->
<a name="1_arraybuffer_objects"></a><h3>1	 ArrayBuffer Objects</h3>
<div class="level3">

</div>
<!-- SECTION [3519-3551] -->
<a name="1.1_the_arraybuffer_constructor_called_as_a_function"></a><h4>1.1	The ArrayBuffer Constructor Called as a Function</h4>
<div class="level4">

<p>
When ArrayBuffer is called as a function rather than as a constructor, it creates and initialises a new ArrayBuffer object.  Thus the function call ArrayBuffer(…) is equivalent to the object creation expression new ArrayBuffer (…) with the same arguments. 
</p>

</div>
<!-- SECTION [3552-3872] -->
<a name="1.2_the_arraybuffer_constructor"></a><h4>1.2	The ArrayBuffer Constructor</h4>
<div class="level4">

<p>
When ArrayBuffer is called as part of a new expression, it is a constructor: it initialises the newly created object. <br/>
 <br/>
 <strong> 1.2.1	new ArrayBuffer(len) </strong> <br/>
 
</p>

<p>
The [[Prototype]] internal property of the newly constructed object is set to the original ArrayBuffer prototype object, the one that is the initial value of ArrayBuffer.prototype (16.1.3.1). The [[Class]] internal property of the newly constructed object is set to &ldquo;ArrayBuffer&rdquo;. The [[Extensible]] internal property of the newly constructed object is set to true.
</p>

<p>
The length property of the newly constructed object is set to ToUInt32(len). 
</p>

<p>
A fresh native buffer nativeBuffer of length bytes is allocated.  The contents of this native buffer are zero initialized.  If the requested number of bytes could not be allocated, a RangeError is raised.  The [[NativeBuffer]] internal property of the newly constructed object is set to nativeBuffer. 
</p>

</div>
<!-- SECTION [3873-4837] -->
<a name="1.3_properties_of_the_arraybuffer_constructor"></a><h4>1.3	Properties of the ArrayBuffer Constructor</h4>
<div class="level4">

<p>
The value of the [[Prototype]] internal property of the ArrayBuffer constructor is the Function prototype object (15.3.4).
</p>

<p>
Besides the internal properties and the length property (whose value is 1), the ArrayBuffer constructor has the following properties: <br/>
 <br/>
 <strong> 1.3.1	ArrayBufer.prototype </strong> <br/>
  The initial value of ArrayBuffer.prototype is the ArrayBuffer prototype object (16.1.4).
</p>

<p>
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 
</p>

</div>
<!-- SECTION [4838-5404] -->
<a name="1.4_properties_of_the_arraybuffer_prototype_object"></a><h4>1.4	Properties of the ArrayBuffer Prototype Object</h4>
<div class="level4">

<p>
The value of the [[Prototype]] internal property of the Array prototype object is the standard built-in Object prototype object (15.2.4). The [[Class]] internal property of the newly constructed object is set to &ldquo;Object&rdquo;. The [[Extensible]] internal property of the newly constructed object is set to true. <br/>
 <br/>
 <strong> 1.4.1	ArrayBuffer.prototype.constructor </strong> <br/>
  The initial value of ArrayBuffer.prototype.constructor is the standard built-in ArrayBuffer constructor. 
</p>

</div>
<!-- SECTION [5405-5944] -->
<a name="1.5_properties_of_the_arraybuffer_instances"></a><h4>1.5	Properties of the ArrayBuffer Instances</h4>
<div class="level4">

<p>
ArrayBuffer instances inherit properties from the ArrayBuffer prototype object and their [[Class]] internal property value is &ldquo;ArrayBuffer&rdquo;. ArrayBuffer instances also have the following properties. <br/>
 <br/>
 <strong> 1.5.1	byteLength </strong> <br/>
  The byteLength property of this ArrayBuffer object is a data property whose value is the length of the ArrayBuffer in bytes, as fixed at construction time.
</p>

<p>
The length property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 
</p>

</div>
<!-- SECTION [5945-6513] -->
<a name="2_typearray_objects"></a><h3>2	TypeArray Objects</h3>
<div class="level3">

<p>
For each Type in the following table, a separate TypeArray constructor object, with corresponding prototype and instances as described below is available.
</p>
<table class="inline">
	<tr>
		<th> Type	</th><th> Array Name	</th><th> Size	</th><th> Description	</th><th> Equivalent C Type </th>
	</tr>
	<tr>
		<td> Int8	</td><td> Int8Array	</td><td> 1	</td><td> 8-bit 2&rsquo;s complement signed integer	</td><td> signed char </td>
	</tr>
	<tr>
		<td> Uint8	</td><td> Uint8Array	</td><td> 1	</td><td> 8-bit unsigned integer	</td><td> unsigned char </td>
	</tr>
	<tr>
		<td> Int16	</td><td> Int16Array	</td><td> 2	</td><td> 16-bit 2&rsquo;s complement signed integer	</td><td> Short </td>
	</tr>
	<tr>
		<td> Uint16	</td><td> Uint16Array	</td><td> 2	</td><td> 16-bit unsigned integer	</td><td> unsigned short </td>
	</tr>
	<tr>
		<td> Int32	</td><td> Int32Array	</td><td> 4	</td><td> 32-bit 2&rsquo;s complement signed integer	</td><td> Int </td>
	</tr>
	<tr>
		<td> Uint32	</td><td> Uint32Array	</td><td> 4	</td><td> 32-bit unsigned integer	</td><td> unsigned int </td>
	</tr>
	<tr>
		<td> Float32	</td><td> Float32Array	</td><td> 4	</td><td> 32-bit IEEE floating point	</td><td> Float </td>
	</tr>
	<tr>
		<td> Float64	</td><td> Float64Array	</td><td> 8	</td><td> 64-bit IEEE floating point	</td><td> Double </td>
	</tr>
</table>
<br />

<p>
In the descriptions below, the phrase “the size in bytes of Type” refers to the value in the Size column of the above table in the row corresponding to Type.  
</p>

</div>
<!-- SECTION [6514-7500] -->
<a name="2.1_the_typearray_constructor_called_as_a_function"></a><h4>2.1	The TypeArray Constructor Called as a Function</h4>
<div class="level4">

<p>
When TypeArray is called as a function rather than as a constructor, it creates and initialises a new TypeArray object.  Thus the function call TypeArray(…) is equivalent to the object creation expression new TypeArray (…) with the same arguments. 
</p>

</div>
<!-- SECTION [7501-7811] -->
<a name="2.2_the_typearray_constructor"></a><h4>2.2	The TypeArray Constructor</h4>
<div class="level4">

<p>
When TypeArray is called as part of a new expression, it is a constructor: it initialises the newly created object. <br/>
 <br/>
 <strong> 2.2.1	new TypeArray(arg0 [, arg1, [, arg2 ] ) </strong> <br/>
  The [[Prototype]] internal property of the newly constructed object is set to the original TypeArray prototype object, the one that is the initial value of TypeArray.prototype (16.2.3.1). The [[Class]] internal property of the newly constructed object is set to &ldquo;TypeArray&rdquo;. The [[Extensible]] internal property of the newly constructed object is set to true.
</p>

<p>
The remaining properties of the newly constructed object are set as follows:
</p>
<ol>
<li class="level1"><div class="li">	If the argument arg0 is a Number:</div>
<ol>
<li class="level2"><div class="li">	The length property of the newly constructed object is set to ToUInt32(arg0)</div>
</li>
<li class="level2"><div class="li">	The byteLength property of the newly constructed object is set to length multiplied by the size in bytes of Type.</div>
</li>
<li class="level2"><div class="li">	Let arrayBuffer be an object constructed as if by a call to the built-in ArrayBuffer constructor, as “new ArrayBuffer(byteLength)”.</div>
</li>
<li class="level2"><div class="li">	The buffer property of the newly constructed object is set to arrayBuffer.</div>
</li>
<li class="level2"><div class="li">	The byteOffset property of the newly constructed object is set to 0.</div>
</li>
</ol>
</li>
<li class="level1"><div class="li">	Otherwise:</div>
<ol>
<li class="level2"><div class="li">	Let O be the result of calling ToObject(arg0).</div>
</li>
<li class="level2"><div class="li">	Let class be the value of the [[Class]] internal property of O. </div>
</li>
<li class="level2"><div class="li">	If class is “ArrayBuffer”:</div>
<ol>
<li class="level3"><div class="li">	Let byteOffset be the result of calling ToUInt32 on arg1, if provided, or else 0.</div>
</li>
<li class="level3"><div class="li">	If byteOffset is not an integer multiple of the size in byte of Type, raise a RangeError exception.</div>
</li>
<li class="level3"><div class="li">	Let bufferLength be the result of calling [[Get]] on O with property name “byteLength”.</div>
</li>
<li class="level3"><div class="li">	Let byteLength be the result of calling ToUInt32 on arg2, if provided, or else bufferLength – byteOffset.</div>
</li>
<li class="level3"><div class="li">	If byteOffset + byteLength is greater than bufferLength, raise a RangeError exception.</div>
</li>
<li class="level3"><div class="li">	Let length be the result of dividing byteLength by the size in bytes of Type.</div>
</li>
<li class="level3"><div class="li">	If ToUInt32(length) !== length, raise a RangeError exception.</div>
</li>
<li class="level3"><div class="li">	The length property of the newly constructed object is set to length.  </div>
</li>
<li class="level3"><div class="li">	The byteLength property of the newly constructed object is set to byteLength.</div>
</li>
<li class="level3"><div class="li">	The buffer property of the newly constructed object is set to O.</div>
</li>
<li class="level3"><div class="li">	The byteOffset property of the newly constructed object is set to byteOffset.</div>
</li>
</ol>
</li>
<li class="level2"><div class="li">	Else:</div>
<ol>
<li class="level3"><div class="li">	Let n to be the result of calling [[Get]] on V with property name &ldquo;length&rdquo;.</div>
</li>
<li class="level3"><div class="li">	Let length be the result of calling ToUInt32(n).</div>
</li>
<li class="level3"><div class="li">	The length property of the newly constructed object is set to length.</div>
</li>
<li class="level3"><div class="li">	The byteLength property of the newly constructed object is set to length multiplied by the size in bytes of Type.</div>
</li>
<li class="level3"><div class="li">	Let arrayBuffer be an object constructed as if by a call to the built-in ArrayBuffer constructor, as “new ArrayBuffer(byteLength)”.</div>
</li>
<li class="level3"><div class="li">	Initialize i to be 0.</div>
</li>
<li class="level3"><div class="li">	While i &lt; length: </div>
<ol>
<li class="level4"><div class="li">	Let x be the result of calling [[Get]] on arrayBuffer with property name ToString(i).</div>
</li>
<li class="level4"><div class="li">	Let indexDesc be a property descriptor.</div>
</li>
<li class="level4"><div class="li">	Set indexDesc.Writable to true.</div>
</li>
<li class="level4"><div class="li">	Set indexDesc.Enumerable to true.</div>
</li>
<li class="level4"><div class="li">	Set indexDesc.Configurable to false.</div>
</li>
<li class="level4"><div class="li">	Set indexDesc.Value to x.</div>
</li>
<li class="level4"><div class="li">	Call [[DefineOwnProperty]] on the newly constructed object with arguments ToString(i), indexDesc, and false.  </div>
</li>
<li class="level4"><div class="li">	Set i to i + 1.</div>
</li>
</ol>
</li>
<li class="level3"><div class="li">	The buffer property of the newly constructed object is set to arrayBuffer.</div>
</li>
<li class="level3"><div class="li">	The byteOffset property of the newly constructed object is set to 0.</div>
</li>
</ol>
</li>
</ol>
</li>
</ol>

</div>
<!-- SECTION [7812-11378] -->
<a name="2.3_properties_of_the_typearray_constructor"></a><h4>2.3	Properties of the TypeArray Constructor</h4>
<div class="level4">

<p>
The value of the [[Prototype]] internal property of the TypeArray constructor is the Function prototype object (15.3.4).
</p>

<p>
Besides the internal properties and the length property (whose value is 3), the TypeArray constructor has the following properties: <br/>
 <br/>
 <strong> 2.3.1	TypeArray.prototype </strong> <br/>
  The initial value of TypeArray.prototype is the TypeArray prototype object (16.2.4).
</p>

<p>
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. <br/>
 <br/>
 <strong> 2.3.2	TypeArray.BYTES_PER_ELEMENT </strong> <br/>
  The initial value of TypeArray.BYTES_PER_ELEMENT is the size in bytes of Type.
</p>

<p>
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 
</p>

</div>
<!-- SECTION [11379-12182] -->
<a name="2.4_properties_of_the_typearray_prototype_object"></a><h4>2.4	Properties of the TypeArray Prototype Object</h4>
<div class="level4">

<p>
The value of the [[Prototype]] internal property of the TypeArray prototype object is the standard built-in Object prototype object (15.2.4). It’s [[Class]] is &ldquo;TypeArray&rdquo;.  <br/>
 <br/>
 <strong> 2.4.1	TypeArray.prototype.constructor </strong> <br/>
  The initial value of TypeArray.prototype.constructor is the standard built-in TypeArray constructor. <br/>
 <br/>
 <strong> 2.4.2	TypeArray.prototype.set(array [, offset] ) </strong> <br/>
  Set multiple values in the TypedArray, reading from the array input., reading input values from the array. The optional offset value indicates the index in the current array where values are written. If omitted, it is assumed to be 0. 
</p>
<ol>
<li class="level1"><div class="li">	If this does not have class “TypeArray”, throw a TypeError.</div>
</li>
<li class="level1"><div class="li">	Let offsetIndex be ToUInt32(offset)</div>
</li>
<li class="level1"><div class="li">	Let O be the result of calling ToObject(array).</div>
</li>
<li class="level1"><div class="li">	Let srcLength be the result of calling [[Get]] on O with property name “length”.</div>
</li>
<li class="level1"><div class="li">	Let targetLength be the result of calling [[Get]] on this with property name “length”</div>
</li>
<li class="level1"><div class="li">	If srcLength + offset &gt; targetLength, throw a RangeError.</div>
</li>
<li class="level1"><div class="li">	Let temp be a new TypeArray created as if by a call to “new TypeArray(srcLength)”</div>
</li>
<li class="level1"><div class="li">	Let k be 0</div>
</li>
<li class="level1"><div class="li">	While k &lt; srcLength</div>
<ol>
<li class="level2"><div class="li">	Let v be the result of calling [[Get]] on src with property name toString(k)</div>
</li>
<li class="level2"><div class="li">	Call [[Put]] on temp with arguments  ToString(k), v, and false</div>
</li>
</ol>
</li>
<li class="level1"><div class="li">	Let k be offset</div>
</li>
<li class="level1"><div class="li">	While k &lt; targetLength</div>
<ol>
<li class="level2"><div class="li">	Let v be the result of calling [[Get]] on temp with property name ToString(k-offset)</div>
</li>
<li class="level2"><div class="li">	Call [[Put]] on temp with arguments  ToString(k), v, and false</div>
</li>
</ol>
</li>
</ol>

<p>
<br/>
 <br/>
 <strong> 2.4.3	TypeArray.prototype.subarray(begin [, end] ) </strong> <br/>
  Returns a new TypedArray view of the ArrayBuffer store for this TypedArray, referencing the elements at begin, inclusive, up to end, exclusive. If either begin or end is negative, it refers to an index from the end of the array, as opposed to from the beginning.
</p>
<ol>
<li class="level1"><div class="li">	If this does not have class “TypeArray”, throw a TypeError.</div>
</li>
<li class="level1"><div class="li">	Let srcLength be the result of calling [[Get]] on this with property name “length”</div>
</li>
<li class="level1"><div class="li">	Let beginInt be ToInt32(begin)</div>
</li>
<li class="level1"><div class="li">	If beginInt &lt; 0, let beginInt be srcLength + beginInt</div>
</li>
<li class="level1"><div class="li">	Let beginIndex be min(srcLength, max(0, beginInt))</div>
</li>
<li class="level1"><div class="li">	Let endInt be ToInt32(end) if end was provided, else srcLength.</div>
</li>
<li class="level1"><div class="li">	If endInt &lt;0,let endInt be srcLength + endInt</div>
</li>
<li class="level1"><div class="li">	Let endIndex be max(0,min(srcLength, endInt))</div>
</li>
<li class="level1"><div class="li">	If endIndex &lt; beginIndex, let endIndex be beginIndex</div>
</li>
<li class="level1"><div class="li">	Return a new TypeArray with the following values for it’s proeprties:</div>
<ol>
<li class="level2"><div class="li">	The length property of the newly constructed object is set to endIndex - beginIndex</div>
</li>
<li class="level2"><div class="li">	The byteLength property of the newly constructed object is set to length multiplied by the size in bytes of Type.</div>
</li>
<li class="level2"><div class="li">	The buffer property of the newly constructed object is set to this.buffer.</div>
</li>
<li class="level2"><div class="li">	The byteOffset property of the newly constructed object is set to this.offset + beginIndex.</div>
</li>
</ol>
</li>
</ol>

</div>
<!-- SECTION [12183-15127] -->
<a name="2.5_properties_of_typearray_instances"></a><h4>2.5	Properties of TypeArray instances</h4>
<div class="level4">

<p>
TypeArray instances inherit properties from the TypeArray prototype object and their [[Class]] internal property value is &ldquo;TypeArray&rdquo;. TypeArray instances also have the following properties. <br/>
 <br/>
 <strong> 2.5.1	 [[DefineOwnProperty]] ( p, desc, throw ) </strong> <br/>
  TypeArray objects use a variation of the [[DefineOwnProperty]] internal method used for other native ECMAScript objects (8.12.9).
</p>

<p>
When the [[DefineOwnProperty]] internal method of A is called with property P, Property Descriptor Desc and Boolean flag Throw, the following steps are taken:
</p>
<ol>
<li class="level1"><div class="li">	Let succeeded be the result of calling the default [[DefineOwnProperty]] internal method (8.12.9) on A passing P, Desc, and Throw as arguments.</div>
</li>
<li class="level1"><div class="li">	If succeeded is false, return false.</div>
</li>
<li class="level1"><div class="li">	If Desc contains a Value field, let newValue be Desc.Value</div>
</li>
<li class="level1"><div class="li">	Let convertedValue to ToType(newValue)</div>
</li>
<li class="level1"><div class="li">	Let index be ToUInt32(P)</div>
</li>
<li class="level1"><div class="li">	Call the SetValueInBuffer internal operation with arguments A.buffer.[[NativeBuffer]], A.byteOffset, index, convertedValue, and Type.</div>
</li>
<li class="level1"><div class="li">	Return true.</div>
</li>
</ol>

<p>
The internal operation SetValueInBuffer takes five parameters, a native buffer nativeBuffer, an integer byteOffset, an integer index, a value of type Type newValue, and a Type valueType.  It operates as follows:
</p>
<ol>
<li class="level1"><div class="li">	Let size be the size in bytes of the type valueType.</div>
</li>
<li class="level1"><div class="li">	Let bytes be the array of bytes from nativeBuffer between offset byteOffset+(index*size) and offset byteOffset+( (index+1)*size)-1 inclusive.</div>
</li>
<li class="level1"><div class="li">	Let newValueBytes be the result of converting newValue to an array of bytes, using the platform endianness.  </div>
</li>
<li class="level1"><div class="li">	Set each byte of bytes from the corresponding byte of newValueBytes.</div>
</li>
</ol>

<p>
<br/>
 <strong> 2.5.2	[[GetOwnProperty]] ( P) </strong> <br/>
  TypeArray objects use a variation of the [[GetOwnProperty]] internal method used for other native ECMAScript objects (8.12.1). This special internal method provides access to named properties corresponding to the individual index values of the TypeArray objects.
</p>

<p>
When the [[GetOwnProperty]] internal method of A is called with property name P, the following steps are taken:
</p>
<ol>
<li class="level1"><div class="li">	Let desc be the result of calling the default [[GetOwnProperty]] internal method (8.12.1) on A with argument P.</div>
</li>
<li class="level1"><div class="li">	If desc is not undefined return desc.</div>
</li>
<li class="level1"><div class="li">	If ToString(abs(ToInteger(P) ) ) is not the same value as P, return undefined.</div>
</li>
<li class="level1"><div class="li">	Let length be the result of a calling [[Get]] on A with parameter “length”</div>
</li>
<li class="level1"><div class="li">	Let index be ToInteger(P).</div>
</li>
<li class="level1"><div class="li">	If length ≤ index, return undefined.</div>
</li>
<li class="level1"><div class="li">	Let isLittleEndian be true if the platform endianness is little endian, else false.</div>
</li>
<li class="level1"><div class="li">	Let value be the result of calling the GetValueFromBuffer internal operation with arguments A.buffer.[[NativeBuffer]], A.byteOffset, index, Type, and littleEndian.</div>
</li>
<li class="level1"><div class="li">	Return a Property Descriptor { [[Value]]: value, [[Enumerable]]: true, [[Writable]]: true, [[Configurable]]: false }</div>
</li>
</ol>

<p>
The internal operation GetValueFromBuffer takes three parameters, a native buffer nativeBuffer, an integer byteOffset, an integer index, a Type valueType, and a boolean isLittleEndian.  It operates as follows:
</p>
<ol>
<li class="level1"><div class="li">	Let size be the size in bytes of the type valueType.</div>
</li>
<li class="level1"><div class="li">	Let bytes be the array of bytes from nativeBuffer between offset byteOffset+(index*size) and offset byteOffset+( (index+1)*size)-1 inclusive.</div>
</li>
<li class="level1"><div class="li">	Let rawValue be the result of convert the array bytes to a value of type valueType, using little endian if isLittleEndian is true, otherwise big endian. </div>
</li>
<li class="level1"><div class="li">	If valueType is Float32 and rawValue is a Float32 representation of IEEE754 NaN, return the NaN Number value.</div>
</li>
<li class="level1"><div class="li">	Else, if valueType is Float64 and rawValue is a Float64 representation of IEEE754 NaN, return the NaN Number value.</div>
</li>
<li class="level1"><div class="li">	Else, return the Number value that that represents the same numeric value as rawValue</div>
</li>
</ol>

<p>
<br/>
 <strong> 2.5.3	length </strong> <br/>
  The value of the length property is the length of the TypeArray object, which was fixed at creation.  This property has attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]:false }. <br/>
 <br/>
 <strong> 2.5.4	byteLength  </strong> <br/>
  The value of the byteLength property is the length of the TypeArray object, which was fixed at creation.  This property has attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]:false }. <br/>
 <br/>
 <strong> 2.5.5	buffer </strong> <br/>
  The value of the buffer property is the length of the TypeArray object, which was fixed at creation.  This property has attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]:false }. <br/>
 <br/>
 <strong> 2.5.6	byteOffset </strong> <br/>
  The value of the byteOffset property is the length of the TypeArray object, which was fixed at creation.  This property has attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]:false }. 
</p>

</div>
<!-- SECTION [15128-19942] -->
<a name="3_dataview_objects"></a><h3>3	DataView Objects</h3>
<div class="level3">

</div>
<!-- SECTION [19943-19971] -->
<a name="3.1_the_dataview_constructor_called_as_a_function"></a><h4>3.1	The DataView Constructor Called as a Function</h4>
<div class="level4">

<p>
When DataView is called as a function rather than as a constructor, it creates and initialises a new DataView object.  Thus the function call DataView(…) is equivalent to the object creation expression new DataView(…) with the same arguments. 
</p>

</div>
<!-- SECTION [19972-20276] -->
<a name="3.2_the_dataview_constructor"></a><h4>3.2	The DataView Constructor</h4>
<div class="level4">

<p>
When DataView is called as part of a new expression, it is a constructor: it initialises the newly created object. <br/>
 <br/>
 <strong> 3.2.1	new DataView(buffer [, byteOffset [, byteLength]]) </strong> <br/>
  The [[Prototype]] internal property of the newly constructed object is set to the original DataView prototype object, the one that is the initial value of DataView.prototype (16.1.3.1). The [[Class]] internal property of the newly constructed object is set to &ldquo;DataView&rdquo;. The [[Extensible]] internal property of the newly constructed object is set to true.
</p>

<p>
The remaining proeprties are set as follows:
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(buffer)</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “ArrayBuffer”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Let byteOffset be the result of calling ToUInt32 on byteOffset, if provided, or else 0.</div>
</li>
<li class="level1"><div class="li">	Let bufferLength be the result of calling [[Get]] on O with property name “byteLength”.</div>
</li>
<li class="level1"><div class="li">	Let byteLength be the result of calling ToUInt32 on byteLength, if provided, or else bufferLength – byteOffset.</div>
</li>
<li class="level1"><div class="li">	If byteOffset + byteLength is greater than bufferLength, raise a RangeError exception.</div>
</li>
<li class="level1"><div class="li">	The byteLength property of the newly constructed object is set to byteLength.</div>
</li>
<li class="level1"><div class="li">	The buffer property of the newly constructed object is set to O.</div>
</li>
<li class="level1"><div class="li">	The byteOffset property of the newly constructed object is set to byteOffset.</div>
</li>
</ol>

</div>
<!-- SECTION [20277-21673] -->
<a name="3.3_proeprties_of_the_dataview_constructor"></a><h4>3.3	Proeprties of the DataView Constructor</h4>
<div class="level4">

<p>
The value of the [[Prototype]] internal property of the DataView constructor is the Function prototype object (15.3.4).
</p>

<p>
Besides the internal properties and the length property (whose value is 3), the DataView constructor has the following properties: <br/>
 <br/>
 <strong> 3.3.1	DataView.prototype </strong> <br/>
  The initial value of DataView.prototype is the DataView prototype object (16.1.4).
</p>

<p>
This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }. 
</p>

</div>
<!-- SECTION [21674-22223] -->
<a name="3.4_properties_of_the_dataview_prototype_object"></a><h4>3.4	Properties of the DataView Prototype Object</h4>
<div class="level4">

<p>
The value of the [[Prototype]] internal property of the DataView prototype object is the standard built-in Object prototype object (15.2.4). The [[Class]] internal property of the newly constructed object is set to &ldquo;Object&rdquo;. The [[Extensible]] internal property of the newly constructed object is set to true.
</p>

<p>
The internal operation GetValue(byteOffset, isLittleEndian, type) used by functions on DataView instances is defined as follows:
</p>
<ol>
<li class="level1"><div class="li">	Let byteOffsetInt be ToUInt32(byteOffset)</div>
</li>
<li class="level1"><div class="li">	Let totalOffset be byteOffsetInt plus the result of calling [[Get]] on this with parameter “byteOffset”</div>
</li>
<li class="level1"><div class="li">	Let byteLength be the result of calling [[Get]] on this with parameter “byteLength”</div>
</li>
<li class="level1"><div class="li">	If totalOffset &gt;= byteLength, raise a RangeError</div>
</li>
<li class="level1"><div class="li">	Let value be the result of calling the GetValueFromBuffer internal operation (2.5.2) with arguments this.buffer.[[NativeBuffer]], totalOffset, 0 and type.</div>
</li>
<li class="level1"><div class="li">	Return value</div>
</li>
</ol>

<p>
 The internal operation SetValue(byteOffset, isLittleEndian, type, value) used by functions on DataView instances  is defined as follows:
</p>
<ol>
<li class="level1"><div class="li">	Let byteOffsetInt be ToUInt32(byteOffset)</div>
</li>
<li class="level1"><div class="li">	Let totalOffset be byteOffsetInt plus the result of calling [[Get]] on this with parameter “byteOffset”</div>
</li>
<li class="level1"><div class="li">	Let byteLength be the result of calling [[Get]] on this with parameter “byteLength”</div>
</li>
<li class="level1"><div class="li">	If totalOffset &gt;= byteLength, raise a RangeError</div>
</li>
<li class="level1"><div class="li">	Let value be the result of calling the SetValueInBuffer internal operation (2.5.2) with arguments this.buffer.[[NativeBuffer]], totalOffset, 0, value and type.</div>
</li>
<li class="level1"><div class="li">	Return value</div>
</li>
</ol>

<p>
<br/>
 <strong> 3.4.1	DataView.prototype.constructor </strong> <br/>
  The initial value of DataView.prototype.constructor is the standard built-in DataView constructor. <br/>
 <br/>
 <strong> 3.4.2	DataView.prototype.getInt8(byteOffset) </strong> <br/>
  Gets the Int8 value at offset byteOffset in the DataView.
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(this)</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “DataView”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Return GetValue(byteOffset, true, Int8)</div>
</li>
</ol>

<p>
<br/>
 <strong> 3.4.3	DataView.prototype.getUint8(byteOffset) </strong> <br/>
  Gets the UInt8 value at offset byteOffset in the DataView.
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(this)</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “DataView”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Return GetValue(byteOffset, true, UInt8)</div>
</li>
</ol>

<p>
<br/>
 <strong> 3.4.4	DataView.prototype.getInt16(byteOffset, littleEndian) </strong> <br/>
  Gets the Int16 value at offset byteOffset in the DataView, using the provided endianness.
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(this)</div>
</li>
<li class="level1"><div class="li">	Let isLittleEndian be ToBoolean(littleEndian) if provided, else false</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “DataView”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Return GetValue(byteOffset, isLittleEndian, Int16)</div>
</li>
</ol>

<p>
<br/>
 <strong> 3.4.5	DataView.prototype.getUint16(byteOffset, littleEndian) </strong> <br/>
  Gets the Uint16 value at offset byteOffset in the DataView, using the provided endianness.
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(this)</div>
</li>
<li class="level1"><div class="li">	Let isLittleEndian be ToBoolean(littleEndian) if provided, else false</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “DataView”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Return GetValue(byteOffset, isLittleEndian, Uint16)</div>
</li>
</ol>

<p>
<br/>
 <strong> 3.4.6	DataView.prototype.getInt32(byteOffset, littleEndian) </strong> <br/>
  Gets the Int32 value at offset byteOffset in the DataView, using the provided endianness.
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(this)</div>
</li>
<li class="level1"><div class="li">	Let isLittleEndian be ToBoolean(littleEndian) if provided, else false</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “DataView”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Return GetValue(byteOffset, isLittleEndian, Int32)</div>
</li>
</ol>

<p>
<br/>
 <strong> 3.4.7	DataView.prototype.getUint32(byteOffset, littleEndian) </strong> <br/>
  Gets the Uint32 value at offset byteOffset in the DataView, using the provided endianness.
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(this)</div>
</li>
<li class="level1"><div class="li">	Let isLittleEndian be ToBoolean(littleEndian) if provided, else false</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “DataView”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Return GetValue(byteOffset, isLittleEndian, Uint32)</div>
</li>
</ol>

<p>
<br/>
 <strong> 3.4.8	DataView.prototype.getFloat32(byteOffset, littleEndian) </strong> <br/>
  Gets the Float32 value at offset byteOffset in the DataView, using the provided endianness.
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(this)</div>
</li>
<li class="level1"><div class="li">	Let isLittleEndian be ToBoolean(littleEndian) if provided, else false</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “DataView”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Return GetValue(byteOffset, isLittleEndian, Float32)</div>
</li>
</ol>

<p>
<br/>
 <strong> 3.4.9	DataView.prototype.getFloat64(byteOffset, littleEndian) </strong> <br/>
  Gets the Float64 value at offset byteOffset in the DataView, using the provided endianness.
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(this)</div>
</li>
<li class="level1"><div class="li">	Let isLittleEndian be ToBoolean(littleEndian) if provided, else false</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “DataView”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Return GetValue(byteOffset, isLittleEndian, Float64)</div>
</li>
</ol>

<p>
<br/>
 <strong> 3.4.10	DataView.prototype.setInt8(byteOffset, value) </strong> <br/>
  Sets the Int8 value at offset byteOffset in the DataView.
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(this)</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “DataView”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Return GetValue(byteOffset, true, Int8, ToInt8(value) )</div>
</li>
</ol>

<p>
<br/>
 <strong> 3.4.11	DataView.prototype.setUint8(byteOffset, value) </strong> <br/>
  Sets the Uint8 value at offset byteOffset in the DataView.
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(this)</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “DataView”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Return GetValue(byteOffset, true, Uint8, ToUint8(value) )</div>
</li>
</ol>

<p>
<br/>
 <strong> 3.4.12	DataView.prototype.setInt16(byteOffset, value, littleEndian) </strong> <br/>
  Sets the Int16 value at offset byteOffset in the DataView.
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(this)</div>
</li>
<li class="level1"><div class="li">	Let isLittleEndian be ToBoolean(littleEndian) if provided, else false</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “DataView”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Return GetValue(byteOffset, isLittleEndian, Int16, ToInt16(value))</div>
</li>
</ol>

<p>
<br/>
 <strong> 3.4.13	DataView.prototype.setUint16(byteOffset, value, littleEndian) </strong> <br/>
  Sets the Uint16 value at offset byteOffset in the DataView.
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(this)</div>
</li>
<li class="level1"><div class="li">	Let isLittleEndian be ToBoolean(littleEndian) if provided, else false</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “DataView”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Return GetValue(byteOffset, isLittleEndian, Uint16, ToUint16(value))</div>
</li>
</ol>

<p>
<br/>
 <strong> 3.4.14	DataView.prototype.setInt32(byteOffset, value, littleEndian) </strong> <br/>
  Sets the Int32 value at offset byteOffset in the DataView.
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(this)</div>
</li>
<li class="level1"><div class="li">	Let isLittleEndian be ToBoolean(littleEndian) if provided, else false</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “DataView”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Return GetValue(byteOffset, isLittleEndian, Int32, ToInt32(value))</div>
</li>
</ol>

<p>
<br/>
 <strong> 3.4.15	DataView.prototype.setUint32(byteOffset, value, littleEndian) </strong> <br/>
  Sets the Uint32 value at offset byteOffset in the DataView.
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(this)</div>
</li>
<li class="level1"><div class="li">	Let isLittleEndian be ToBoolean(littleEndian) if provided, else false</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “DataView”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Return GetValue(byteOffset, isLittleEndian, Uint32, ToUint32(value))</div>
</li>
</ol>

<p>
<br/>
 <strong> 3.4.16	DataView.prototype.setFloat32(byteOffset, value, littleEndian) </strong> <br/>
  Sets the Float32 value at offset byteOffset in the DataView.
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(this)</div>
</li>
<li class="level1"><div class="li">	Let isLittleEndian be ToBoolean(littleEndian) if provided, else false</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “DataView”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Return GetValue(byteOffset, isLittleEndian, Float32, ToFloat32(value))</div>
</li>
</ol>

<p>
<br/>
 <strong> 3.4.17	DataView.prototype.setUint16(byteOffset, value, littleEndian) </strong> <br/>
  Sets the Float64 value at offset byteOffset in the DataView.
</p>
<ol>
<li class="level1"><div class="li">	Let O be ToObject(this)</div>
</li>
<li class="level1"><div class="li">	Let isLittleEndian be ToBoolean(littleEndian) if provided, else false</div>
</li>
<li class="level1"><div class="li">	If the [[Class]] internal property of O is not “DataView”, raise a TypeError.</div>
</li>
<li class="level1"><div class="li">	Return GetValue(byteOffset, isLittleEndian, Float64, ToFloat64(value))</div>
</li>
</ol>

</div>
<!-- SECTION [22224-30094] -->
<a name="3.5_propeties_of_dataview_instances"></a><h4>3.5	Propeties of DataView Instances</h4>
<div class="level4">

<p>
DataView instances inherit properties from the DataView prototype object and their [[Class]] internal property value is &ldquo;DataView&rdquo;. DataView instances also have the following properties. <br/>
 <br/>
 <strong> 3.5.1	byteLength </strong> <br/>
  The value of the byteLength property is the length of the DataView object, which was fixed at creation.  This property has attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]:false }. <br/>
 <br/>
 <strong> 3.5.2	buffer </strong> <br/>
  The value of the buffer property is the length of the DataView object, which was fixed at creation.  This property has attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]:false }. <br/>
 <br/>
 <strong> 3.5.3	byteOffset </strong> <br/>
  The value of the byteOffset property is the length of the DataView object, which was fixed at creation.  This property has attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]:false }.
</p>

</div>
<!-- SECTION [30095-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/5/558967ea88c5e0a411540725b8e3e57d.xhtml used -->
</body>
</html>
