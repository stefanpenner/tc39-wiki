<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=es3.1:json_support&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=es3.1" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=es3.1:json_support&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=es3.1:json_support&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>

<p>
<a href="http://www.json.org" class="urlextern" target="_blank" title="http://www.json.org" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">JSON</a> is a simple lightweight serialization format that is much used by Frameworks. <a href="http://www.ajax.asp.net/Default.aspx" class="urlextern" target="_blank" title="http://www.ajax.asp.net/Default.aspx" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Atlas</a>, Live, <a href="http://www.developer.yahoo.com/yui" class="urlextern" target="_blank" title="http://www.developer.yahoo.com/yui" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">YUI</a> are heavy users.
</p>

<p>
A <code>JSON</code> global object is added. It provides <code>parse</code> and <code>stringify</code> methods.
</p>

<p>
<code>JSON.parse(</code><em>source</em><code>,</code> <em>reviver</em><code>)</code>
</p>

<p>
This method parses a JSON text to produce an object or array. It can throw a SyntaxError exception.
</p>

<p>
The optional <em>reviver</em> parameter is a function that can filter and transform the results. It receives each of the keys and values, and its return value is used instead of the original value. If it returns what it received, then the structure is not modified. If it returns undefined then the member is deleted.
</p>

<p>
Example:
</p>

<p>
<em> Parse the text. Values that look like <acronym title="International Organization for Standardization">ISO</acronym> date strings will
</em> be converted to Date objects. 
</p>
<pre class="code">  myData = JSON.parse(text, function (key, value) {
      var a;
      if (typeof value === 'string') {
          a =
  /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
          if (a) {
              return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                  +a[5], +a[6]));
          }
      }
      return value;
  });
  </pre>

<p>
<em> Parse the text. String values that look like &ldquo;Date(&mdash;date&mdash;)&rdquo; are
</em> turned into Date objects.    
</p>
<pre class="code">  
  myData = JSON.parse('[&quot;Date(09/09/2001)&quot;]', function (key, value) {
      var d;
      if (typeof value === 'string' &amp;&amp;
              value.slice(0, 5) === 'Date(' &amp;&amp;
              value.slice(-1) === ')') {
          d = new Date(value.slice(5, -1));
          if (d) {
              return d;
          }
      }
      return value;
  });</pre>

<p>
 This implementation is informative:
</p>
<pre class="code">  JSON.parse = function () {</pre>

<p>
 This is a function that can parse a JSON text, producing a JavaScript data structure. It is a simple, recursive descent parser.
</p>

<p>
We are defining the function inside of another function to avoid creating global variables. 
</p>
<pre class="code">      var at,     // The index of the current character
          ch,     // The current character
          escapee = {
              '&quot;':  '&quot;',
              '\\': '\\',
              '/':  '/',
              b:    '\b',
              f:    '\f',
              n:    '\n',
              r:    '\r',
              t:    '\t'
          },
          text,
  
          error = function (m) {</pre>

<p>
 Call error when something is wrong. 
</p>
<pre class="code">              throw {
                  name:    'SyntaxError',
                  message: m,
                  at:      at,
                  text:    text
              };
          },
  
          next = function (c) {</pre>

<p>
 If a c parameter is provided, verify that it matches the current character. 
</p>
<pre class="code">              if (c &amp;&amp; c !== ch) {
                  error(&quot;Expected '&quot; + c + &quot;' instead of '&quot; + ch + &quot;'&quot;);
              }</pre>

<p>
 Get the next character. When there are no more characters, return the empty string. 
</p>
<pre class="code">              ch = text.charAt(at);
              at += 1;
              return ch;
          },
  
          number = function () {
  </pre>

<p>
Parse a number value. 
</p>
<pre class="code">              var number,
                  string = &quot;&quot;;
  
              if (ch === '-') {
                  string = '-';
                  next('-');
              }
              while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {
                  string += ch;
                  next();
              }
              if (ch === '.') {
                  string += '.';
                  while (next() &amp;&amp; ch &gt;= '0' &amp;&amp; ch &lt;= '9') {
                      string += ch;
                  }
              }
              if (ch === 'e' || ch === 'E') {
                  string += ch;
                  next();
                  if (ch === '-' || ch === '+') {
                      string += ch;
                      next();
                  }
                  while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {
                      string += ch;
                      next();
                  }
              }
              number = +string;
              if (isNaN(number)) {
                  error(&quot;Bad number&quot;);
              } else {
                  return number;
              }
          },
  
          string = function () {</pre>

<p>
 Parse a string value. 
</p>
<pre class="code">              var hex,
                  i,
                  string = &quot;&quot;,
                  uffff;</pre>

<p>
 When parsing for string values, we must look for &quot; and \ characters. 
</p>
<pre class="code">              if (ch === '&quot;') {
                  while (next()) {
                      if (ch === '&quot;') {
                          next();
                          return string;
                      } else if (ch === '\\') {
                          next();
                          if (ch === 'u') {
                              uffff = 0;
                              for (i = 0; i &lt; 4; i += 1) {
                                  hex = parseInt(next(), 16);
                                  if (!isFinite(hex)) {
                                      break;
                                  }
                                  uffff = uffff * 16 + hex;
                              }
                              string += String.fromCharCode(uffff);
                          } else if (typeof escapee[ch] === 'string') {
                              string += escapee[ch];
                          } else {
                              break;
                          }
                      } else {
                          string += ch;
                      }
                  }
              }
              error(&quot;Bad string&quot;);
          },
  
          white = function () {</pre>

<p>
 Skip whitespace. 
</p>
<pre class="code">              while (ch &amp;&amp; ch &lt;= ' ') {
                  next();
              }
          },
  
          word = function () {</pre>

<p>
 true, false, or null. 
</p>
<pre class="code">              switch (ch) {
              case 't':
                  next('t');
                  next('r');
                  next('u');
                  next('e');
                  return true;
              case 'f':
                  next('f');
                  next('a');
                  next('l');
                  next('s');
                  next('e');
                  return false;
              case 'n':
                  next('n');
                  next('u');
                  next('l');
                  next('l');
                  return null;
              }
              error(&quot;Unexpected '&quot; + ch + &quot;'&quot;);
          },
  
          value,  // Place holder for the value function.
  
          array = function () {</pre>

<p>
 Parse an array value. 
</p>
<pre class="code">              var array = [];
  
              if (ch === '[') {
                  next('[');
                  white();
                  if (ch === ']') {
                      next(']');
                      return array;   // empty array
                  }
                  while (ch) {
                      array.push(value());
                      white();
                      if (ch === ']') {
                          next(']');
                          return array;
                      }
                      next(',');
                      white();
                  }
              }
              error(&quot;Bad array&quot;);
          },
  
          object = function () {</pre>

<p>
 Parse an object value. 
</p>
<pre class="code">              var key,
                  object = {};
  
              if (ch === '{') {
                  next('{');
                  white();
                  if (ch === '}') {
                      next('}');
                      return object;   // empty object
                  }
                  while (ch) {
                      key = string();
                      white();
                      next(':');
                      object[key] = value();
                      white();
                      if (ch === '}') {
                          next('}');
                          return object;
                      }
                      next(',');
                      white();
                  }
              }
              error(&quot;Bad object&quot;);
          };
  
      value = function () {</pre>

<p>
 Parse a JSON value. It could be an object, an array, a string, a number, or a word. 
</p>
<pre class="code">          white();
          switch (ch) {
          case '{':
              return object();
          case '[':
              return array();
          case '&quot;':
              return string();
          case '-':
              return number();
          default:
              return ch &gt;= '0' &amp;&amp; ch &lt;= '9' ? number() : word();
          }
      };</pre>

<p>
 Return the JSON.parse function. It will have access to all of the above functions and variables. 
</p>
<pre class="code">      return function parse(source, reviver) {
          var result;
  
          text = source;
          at = 0;
          ch = ' ';
          result = value();
          white();
          if (ch) {
              error(&quot;Syntax error&quot;);
          }</pre>

<p>
 If there is a reviver function, we recursively walk the new structure, passing each name/value pair to the reviver function for possible transformation, starting with a temporary boot object that holds the result in an empty key. If there is not a reviver function, we simply return the result. 
</p>
<pre class="code">          return typeof reviver === 'function' ? function walk(holder, key) {
              var k, v, value = holder[key];
              if (value &amp;&amp; typeof value === 'object') {
                  for (k in value) {
                      if (Object.hasOwnProperty.call(value, k)) {
                          v = walk(value, k);
                          if (v !== undefined) {
                              value[k] = v;
                          } else {
                              delete value[k];
                          }
                      }
                  }
              }
              return reviver.call(holder, key, value);
          }({&quot;&quot;: result}, &quot;&quot;) : result;
      };
  }();</pre>

<p>
 <code>JSON.stringify(</code><em>value</em><code>,</code> <em>replacer</em><code>,</code> <em>space</em><code>)</code> 
</p>
<pre class="code">  value       any JavaScript value, usually an object or array.</pre>
<pre class="code">  replacer    an optional parameter that determines how object
              values are stringified for objects without a toJSON
              method. It can be a function or an array.</pre>
<pre class="code">  space       an optional parameter that specifies the indentation
              of nested structures. If it is omitted, the text will
              be packed without extra whitespace. If it is a number,
              it will specify the number of spaces to indent at each
              level. If it is a string (such as '\t' or '&amp;nbsp;'),
              it contains the characters used to indent at each level.</pre>

<p>
 The <code>stringify</code> method produces a JSON text from a JavaScript <em>value</em>.  If <em>value</em> is an object or array, the structure will be visited recursively to determine the serialization of each membr or element. The structure must not be cyclical.
</p>

<p>
When an object value is found, if the object contains a <code>toJSON</code> method, its <code>toJSON</code> method will be called and the result will be stringified. A <code>toJSON</code> method does not serialize: it returns the value represented by the name/value pair that should be serialized, or undefined if nothing should be serialized. The <code>toJSON</code> method will be passed the key associated with the value, and this will be bound to the object holding the key.
</p>

<p>
For example, this would serialize Dates as <acronym title="International Organization for Standardization">ISO</acronym> strings. 
</p>
<pre class="code">      Date.prototype.toJSON = function (key) {
          return this.toISOString();
      };</pre>

<p>
 You can provide an optional <em>replacer</em> method. It will be passed the key and value of each member, with <code>this</code> bound to the containing object. The value that is returned from your method will be serialized. If your method returns <code>undefined</code>, then the member will be excluded from the serialization.
</p>

<p>
If the <em>replacer</em> parameter is an array, then it will be used to select the members to be serialized. It filters the results such that only members with keys listed in the <em>replacer</em> array are stringified.
</p>

<p>
Values that do not have JSON representations, such as <code>undefined</code> or functions, will not be serialized. Such values in objects will be dropped; in arrays they will be replaced with <code>null</code>. You can use a <em>replacer</em> function to replace those with JSON values. <code>JSON.stringify(undefined)</code> returns <code>undefined</code>.
</p>

<p>
The optional <em>space</em> parameter produces a stringification of the value that is filled with line breaks and indentation to make it easier to read.
</p>

<p>
If the <em>space</em> parameter is a non-empty string, then that string will be used for indentation. If the space parameter is a number, then the indentation will be that many spaces.
</p>

<p>
Example: 
</p>
<pre class="code">  text = JSON.stringify(['e', {pluribus: 'unum'}]);
  // text is '[&quot;e&quot;,{&quot;pluribus&quot;:&quot;unum&quot;}]'</pre>
<pre class="code">  text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
  // text is '[\n\t&quot;e&quot;,\n\t{\n\t\t&quot;pluribus&quot;: &quot;unum&quot;\n\t}\n]'</pre>
<pre class="code">  text = JSON.stringify([new Date()], function (key, value) {
      return this[key] instanceof Date ?
          'Date(' + this[key] + ')' : value;
  });
  // text is '[&quot;Date(---current time---)&quot;]'</pre>

<p>
 This implementation is informative:
</p>

<p>
JSON.stringify = function () { 
</p>
<pre class="code">  var gap,
      indent,
      rep;</pre>
<pre class="code">  function str(key, holder) {</pre>

<p>
 Produce a string from holder[key]. 
</p>
<pre class="code">      var i,          // The loop counter.
          k,          // The member key.
          v,          // The member value.
          length,
          mind = gap,
          partial,
          value = holder[key];</pre>

<p>
 If the value has a toJSON method, call it to obtain a replacement value. 
</p>
<pre class="code">      if (value &amp;&amp; typeof value === 'object' &amp;&amp;
              typeof value.toJSON === 'function') {
          value = value.toJSON(key);
      }</pre>

<p>
 If we were called with a replacer function, then call the replacer to obtain a replacement value. 
</p>
<pre class="code">      if (typeof rep === 'function') {
          value = rep.call(holder, key, value);
      }</pre>

<p>
 What happens next depends on the value&rsquo;s type. 
</p>
<pre class="code">      switch (typeof value) {
      case 'string':
          return value.quote();</pre>
<pre class="code">      case 'number':</pre>

<p>
 JSON numbers must be finite. Encode non-finite numbers as null. 
</p>
<pre class="code">          return isFinite(value) ? String(value) : 'null';</pre>
<pre class="code">      case 'boolean':
      case 'null':</pre>

<p>
 If the value is a boolean or null, convert it to a string. Note: typeof null does not produce &lsquo;null&rsquo;. The case is included here in the remote chance that this gets fixed someday. 
</p>
<pre class="code">          return String(value);</pre>

<p>
 If the type is &lsquo;object&rsquo;, we might be dealing with an object or an array or null. 
</p>
<pre class="code">      case 'object':</pre>

<p>
 typeof null is &lsquo;object&rsquo;, so watch out for that case. 
</p>
<pre class="code">          if (!value) {
              return 'null';
          }</pre>

<p>
 Make an array to hold the partial results of stringifying this object value. 
</p>
<pre class="code">          gap += indent;
          partial = [];</pre>
<pre class="code">          if (Array.isArray(value)) {</pre>

<p>
 The object is an array. Stringify every element. Use null as a placeholder for non-JSON values. 
</p>
<pre class="code">              length = value.length;
              for (i = 0; i &lt; length; i += 1) {
                  partial[i] = str(i, value) || 'null';
              }</pre>

<p>
 Join all of the elements together, separated with commas, and wrap them in brackets. 
</p>
<pre class="code">              v = partial.length === 0 ? '[]' :
                  gap ? '[\n' + gap +
                          partial.join(',\n' + gap) + '\n' +
                              mind + ']' :
                        '[' + partial.join(',') + ']';
              gap = mind;
              return v;
          }</pre>

<p>
 If the replacer is an array, use it to select the members to be stringified. 
</p>
<pre class="code">          if (rep &amp;&amp; typeof rep === 'object') {
              length = rep.length;
              for (i = 0; i &lt; length; i += 1) {
                  k = rep[i];
                  if (typeof k === 'string') {
                      v = str(k, value, rep);
                      if (v) {
                          partial.push(k.quote() + (gap ? ': ' : ':') + v);
                      }
                  }
              }
          } else {</pre>

<p>
 Otherwise, iterate through all of the keys in the object. 
</p>
<pre class="code">              for (k in value) {
                  if (Object.hasOwnProperty.call(value, k)) {
                      v = str(k, value, rep);
                      if (v) {
                          partial.push(k.quote() + (gap ? ': ' : ':') + v);
                      }
                  }
              }
          }</pre>

<p>
 Join all of the member texts together, separated with commas, and wrap them in braces. 
</p>
<pre class="code">          v = partial.length === 0 ? '{}' :
              gap ? '{\n' + gap +
                      partial.join(',\n' + gap) + '\n' +
                      mind + '}' :
                    '{' + partial.join(',') + '}';
          gap = mind;
          return v;
      }
  }</pre>

<p>
Return the JSON.stringify method. 
</p>
<pre class="code">  return function stringify(value, replacer, space) {</pre>

<p>
 The stringify method takes a value and an optional replacer, and an optional space parameter, and returns a JSON text. The replacer can be a function that can replace values, or an array of strings that will select the keys. A default replacer method can be provided. Use of the space parameter can produce text that is more easily readable. 
</p>
<pre class="code">      var i;
      gap = '';
      indent = '';
      if (space) {</pre>

<p>
 If the space parameter is a number, make an indent string containing that many spaces. 
</p>
<pre class="code">          switch (typeof space) {
          case 'number':
              for (i = 0; i &lt; space; i += 1) {
                  indent += ' ';
              }
              break;</pre>

<p>
 If the space parameter is a string, it will be used as the indent string. 
</p>
<pre class="code">          case 'string':
              indent = space;
          }
      }</pre>

<p>
 If there is a replacer, it must be a function or an array. Otherwise, throw an error. 
</p>
<pre class="code">      rep = replacer;
      if (replacer &amp;&amp; typeof replacer !== 'function' &amp;&amp;
              !Array.isArray(replacer)) {
          throw new Error('JSON.stringify');
      }</pre>

<p>
 Make a fake root object containing our value under the key of empty string. Return the result of stringifying the value. 
</p>
<pre class="code">      return str(&quot;&quot;, {&quot;&quot;: value});
  };</pre>

<p>
}();
</p>

<p>
Relevant Goal: <a href="doku.php%3Fid=es3.1:es3.1_goals.html" class="wikilink1" title="es3.1:es3.1_goals" onclick="return svchk()" onkeypress="return svchk()">2</a><br/>
 Relevant Design Principle: <a href="doku.php%3Fid=es3.1:design_principles.html" class="wikilink1" title="es3.1:design_principles" onclick="return svchk()" onkeypress="return svchk()">2a, 2b, 3</a><br/>
 Relevant ES4 proposal: <a href="doku.php%3Fid=proposals:json_encoding_and_decoding.html" class="wikilink1" title="proposals:json_encoding_and_decoding" onclick="return svchk()" onkeypress="return svchk()">JSON encoding and decoding.</a><br/>

</p>

<p>
 &mdash; <em><a href="mailto:%26%23x70%3B%26%23x72%3B%26%23x61%3B%26%23x74%3B%26%23x61%3B%26%23x70%3B%26%23x6c%3B%26%23x40%3B%26%23x6d%3B%26%23x69%3B%26%23x63%3B%26%23x72%3B%26%23x6f%3B%26%23x73%3B%26%23x6f%3B%26%23x66%3B%26%23x74%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x70;&#x72;&#x61;&#x74;&#x61;&#x70;&#x6c;&#x40;&#x6d;&#x69;&#x63;&#x72;&#x6f;&#x73;&#x6f;&#x66;&#x74;&#x2e;&#x63;&#x6f;&#x6d;">Pratap Lakshman</a> 2007/04/15 02:23</em> 
</p>

<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/9/9d835e6488751d00b7b6d2fb6441d6aa.xhtml used -->
</body>
</html>
