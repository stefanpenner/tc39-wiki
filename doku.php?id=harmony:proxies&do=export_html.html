<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=harmony:proxies&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="http://wiki.ecmascript.org/feed.php?mode=list&amp;ns=harmony" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=harmony:proxies&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#the_content_on_this_page_is_obsolete" class="toc">The content on this page is OBSOLETE</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#catch-all_proxies" class="toc">Catch-all Proxies</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#goals" class="toc">Goals</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#use_cases" class="toc">Use cases</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#terminology" class="toc">Terminology</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#api" class="toc">API</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#examplea_no-op_forwarding_proxy" class="toc">Example: a no-op forwarding proxy</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#the_type_of_a_proxy" class="toc">The type of a Proxy</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#proposal_details_rationale" class="toc">Proposal Details / Rationale</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#equality" class="toc">Equality</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#fixing" class="toc">Fixing</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#detecting_proxy_objects" class="toc">Detecting proxy objects</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#interaction_with_object._introspective_api" class="toc">Interaction with Object.* introspective API</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#accessing_handler_from_proxy" class="toc">Accessing handler from proxy</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#simulating_nosuchmethod_doesnotunderstand" class="toc">Simulating __noSuchMethod__ / doesNotUnderstand:</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#function_proxies" class="toc">Function Proxies</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#stratification" class="toc">Stratification</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#interaction_with_instanceof" class="toc">Interaction with ''instanceof''</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#trap_defaults" class="toc">Trap Defaults</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#semantics" class="toc">Semantics</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#interaction_of_external_methods_and_proxies" class="toc">Interaction of external methods and proxies</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#more_examples" class="toc">More Examples</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#transparent_chains_of_no-op_proxies" class="toc">Transparent chains of no-op proxies</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#a_simple_membrane" class="toc">A Simple Membrane</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#an_identity-preserving_membrane" class="toc">An identity-preserving membrane</a></span><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#garbage_collection_behavior" class="toc">Garbage Collection Behavior</a></span></li>
</ul>
</li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#an_eventual_reference_proxy" class="toc">An eventual reference proxy</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#higher-order_messages" class="toc">Higher-order Messages</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#climbing_the_meta_ladder" class="toc">Climbing the meta ladder</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#background_prior_work" class="toc">Background / Prior Work</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#in_this_wiki" class="toc">In this wiki</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#systems_that_enable_intercession_of_all_or_most_meta-level_operations" class="toc">Systems that enable intercession of all or most meta-level operations</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#systems_that_enable_intercession_of_method_invocations" class="toc">Systems that enable intercession of method invocations</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#systems_that_enable_intercession_of_missing_method_invocations_only" class="toc">Systems that enable intercession of missing method invocations only</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#open_issues" class="toc">Open issues</a></span><ul class="toc">
<li class="clear"><ul class="toc">
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#property_descriptor_normalization" class="toc">Property descriptor normalization</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#non-configurable_properties" class="toc">Non-configurable properties</a></span></li>
<li class="level4"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#validation_of_trap_results" class="toc">Validation of trap results</a></span></li>
</ul>
</li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#feedback" class="toc">Feedback</a></span></li>
</ul>
</li>
</ul>
</div>
</div>

<a name="the_content_on_this_page_is_obsolete"></a><h1>The content on this page is OBSOLETE</h1>
<div class="level1">

</div>
<!-- SECTION [1-52] -->
<a name="catch-all_proxies"></a><h2>Catch-all Proxies</h2>
<div class="level2">
<table class="inline">
	<tr>
		<td><strong>This <acronym title="Application Programming Interface">API</acronym> is superseded by the newer <a href="doku.php%3Fid=harmony:direct_proxies.html" class="wikilink1" title="harmony:direct_proxies" onclick="return svchk()" onkeypress="return svchk()">direct proxies</a> <acronym title="Application Programming Interface">API</acronym>.</strong></td>
	</tr>
</table>
<br />

<p>
See also: the <a href="https://mail.mozilla.org/pipermail/es-discuss/2009-December/010250.html" class="urlextern" target="_blank" title="https://mail.mozilla.org/pipermail/es-discuss/2009-December/010250.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">discussion thread</a> on the <code>es-discuss</code> mailing list.
</p>

<p>
A tech talk on harmony proxies is available <a href="http://code.google.com/p/es-lab/wiki/Talks#Changes_to_ECMAScript,_Part_2:_Harmony_Highlights_-_proxies_and" class="urlextern" target="_blank" title="http://code.google.com/p/es-lab/wiki/Talks#Changes_to_ECMAScript,_Part_2:_Harmony_Highlights_-_proxies_and" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">here</a>.
</p>

</div>
<!-- SECTION [53-473] -->
<a name="goals"></a><h2>Goals</h2>
<div class="level2">

<p>
 To enable ES programmers to represent virtualized objects (proxies). In particular, to enable writing generic abstractions that can intercept property access on ES objects.
</p>

<p>
Driving forces:
</p>
<ul>
<li class="level1"><div class="li"> simplicity: straightforward <acronym title="Application Programming Interface">API</acronym></div>
</li>
<li class="level1"><div class="li"> consistency: following ES5 conventions, avoiding caveats and exceptions</div>
</li>
<li class="level1"><div class="li"> efficiency: objects whose properties are not intercepted should not be affected by the interception mechanism</div>
</li>
<li class="level1"><div class="li"> security: avoid enabling arbitrary ES objects to be able to intercept the properties of another object</div>
</li>
<li class="level1"><div class="li"> stratification: separate &lsquo;meta-level behavior&rsquo; from regular, &lsquo;base-level&rsquo; objects</div>
</li>
</ul>

<p>
 Stratification avoids confusion between base and meta-level methods. Consider Spidermonkey&rsquo;s &ldquo;__noSuchMethod__&rdquo; trap, or Smalltalk&rsquo;s &ldquo;doesNotUnderstand:&rdquo; trap: what if an application (accidentally) redefines this method for application-specific purposes and application code performs explicit &ldquo;object.doesNotUnderstand(...)&rdquo; requests? This issue is aggravated when additional traps are introduced to not only trap missing methods, but essentially all &ldquo;meta-level&rdquo; operations (&rsquo;get&rsquo;, &lsquo;set&rsquo;, &lsquo;has&rsquo;, etc.). It becomes unrealistic to have all these names be &lsquo;reserved&rsquo; names with &lsquo;special&rsquo; meaning to the interpreter.
</p>

<p>
The proxy design makes it impossible to intercept the methods of regular, existing objects. Instead, only the methods of special &lsquo;proxy&rsquo; objects can be trapped. This avoids questions like:
</p>
<ol>
<li class="level1"><div class="li"> can property trapping be dynamically enabled/disabled for an object?</div>
</li>
<li class="level1"><div class="li"> can it be enabled/disabled by external objects or only by the trapped object itself?</div>
</li>
<li class="level1"><div class="li"> should the trap only trigger on access of missing properties or on existing properties as well?</div>
</li>
<li class="level1"><div class="li"> should the trap trigger on access of own or inherited properties?</div>
</li>
<li class="level1"><div class="li"> can property trapping be defined on host objects? (Mike Samuel)</div>
</li>
</ol>

</div>
<!-- SECTION [474-2311] -->
<a name="use_cases"></a><h2>Use cases</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> generic interposing abstractions to enforce access control</div>
</li>
<li class="level1"><div class="li"> creating virtualized objects: persistent objects, remote objects, lazy creation of objects</div>
</li>
<li class="level1"><div class="li"> transparent logging, tracing, profiling</div>
</li>
<li class="level1"><div class="li"> embedded domain-specific languages</div>
</li>
<li class="level1"><div class="li"> dynamic interception of missing methods calls / generation of missing methods (aka. <code>doesNotUnderstand:</code>)</div>
</li>
<li class="level1"><div class="li"> a possible basis for custom <a href="doku.php%3Fid=strawman:iterators.html" class="wikilink1" title="strawman:iterators" onclick="return svchk()" onkeypress="return svchk()">iterators</a>.</div>
</li>
</ul>

</div>
<!-- SECTION [2312-2754] -->
<a name="terminology"></a><h2>Terminology</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> The language feature: <strong>catch-all mechanism</strong> (name used for this feature by the ES4 community)</div>
</li>
<li class="level1"><div class="li"> Alternatively (the preferred term when discussing this mechanism within the broader programming language community): <strong>intercession <acronym title="Application Programming Interface">API</acronym></strong></div>
</li>
<li class="level1"><div class="li"> The object that intercepts properties: <strong>handler</strong></div>
</li>
<li class="level1"><div class="li"> The object whose properties are being intercepted: <strong>proxy</strong></div>
</li>
<li class="level1"><div class="li"> The object/method that creates intercessive proxies: <strong>proxy factory</strong> (Mirror terminology)</div>
</li>
<li class="level1"><div class="li"> The methods that reify property access: <strong>traps</strong> (analogy with operating systems)</div>
</li>
<li class="level1"><div class="li"> A proxy can either be <strong>trapping</strong> or be <strong>fixed</strong> (see later)</div>
</li>
</ul>

</div>
<!-- SECTION [2755-3392] -->
<a name="api"></a><h2>API</h2>
<div class="level2">

<p>
 Catch-alls can be defined <em>only</em> on <em>distinct</em> proxy objects, controlled by a handler object. In keeping with the current distinction in the spec between objects and functions, we found that the cleanest approach to catch-alls was to introduce two kinds of proxies: object proxies and function proxies.
</p>

<p>
Constructing an object proxy: 
</p>
<pre class="code javascript"><span class="kw2">var</span> proxy = Proxy.<span class="me1">create</span><span class="br0">&#40;</span>handler, proto<span class="br0">&#41;</span>;</pre>
<p>
Constructing a function proxy: 
</p>
<pre class="code javascript"><span class="kw2">var</span> proxy = Proxy.<span class="me1">createFunction</span><span class="br0">&#40;</span>handler, callTrap, constructTrap<span class="br0">&#41;</span>;</pre>
<p>
where:
</p>
<ul>
<li class="level1"><div class="li"> <code>proto</code> is an optional object representing the proxy&rsquo;s prototype.</div>
</li>
<li class="level1"><div class="li"> <code>callTrap</code> is a <code>function(...args) { return any; }</code> that reifies &ldquo;proxy(...args)&rdquo;. Note: The <code>this</code>-binding of the <code>callTrap</code> function is the <code>this</code>-binding of the call-site.</div>
</li>
<li class="level1"><div class="li"> <code>constructTrap</code> is an optional <code>function(...args) { return any-object; }</code> that reifies &ldquo;new proxy(...args)&rdquo;. The <code>this</code>-binding of the <code>constructTrap</code> is <code>undefined</code>. If no <code>constructTrap</code> is provided, <code>new proxy(...args)</code> is reified as calling the proxy&rsquo;s <code>callTrap</code> with <code>this</code> bound to a new object delegating to <code>proxy.prototype</code> (as per the [[Construct]] algorithm of ES5 Section 13.2.2).</div>
</li>
<li class="level1"><div class="li"> <code>handler</code> is an object that at minimum implements the following <acronym title="Application Programming Interface">API</acronym> (name denotes a property name, &rarr; is followed by return type, [t] means array-of-t, etc.):</div>
</li>
</ul>
<pre class="code javascript"><span class="br0">&#123;</span>
  getOwnPropertyDescriptor: <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> -&gt; PropertyDescriptor | undefined <span class="co1">// Object.getOwnPropertyDescriptor(proxy, name)</span>
  getPropertyDescriptor:    <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> -&gt; PropertyDescriptor | undefined <span class="co1">// Object.getPropertyDescriptor(proxy, name)   (not in ES5)</span>
  getOwnPropertyNames:      <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> -&gt; <span class="br0">&#91;</span> string <span class="br0">&#93;</span>                         <span class="co1">// Object.getOwnPropertyNames(proxy) </span>
  getPropertyNames:         <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> -&gt; <span class="br0">&#91;</span> string <span class="br0">&#93;</span>                         <span class="co1">// Object.getPropertyNames(proxy)              (not in ES5)</span>
  defineProperty:           <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span>, propertyDescriptor<span class="br0">&#41;</span> -&gt; any        <span class="co1">// Object.defineProperty(proxy,name,pd)</span>
  <span class="kw1">delete</span>:                   <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> -&gt; boolean                        <span class="co1">// delete proxy.name</span>
  fix:                      <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> -&gt; <span class="br0">&#123;</span> string: PropertyDescriptor <span class="br0">&#125;</span>     <span class="co1">// Object.{freeze|seal|preventExtensions}(proxy)</span>
                                          | undefined
<span class="br0">&#125;</span></pre>
<p>
The above methods are the handler&rsquo;s <strong>fundamental</strong> traps. Additionally, the <acronym title="Application Programming Interface">API</acronym> defines a set of optional, <strong>derived</strong> traps:
</p>
<pre class="code javascript"><span class="br0">&#123;</span>
  has:       <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> -&gt; boolean                  <span class="co1">// name in proxy</span>
  hasOwn:    <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> -&gt; boolean                  <span class="co1">// ({}).hasOwnProperty.call(proxy, name)</span>
  get:       <span class="kw2">function</span><span class="br0">&#40;</span>receiver, <span class="kw3">name</span><span class="br0">&#41;</span> -&gt; any            <span class="co1">// receiver.name</span>
  set:       <span class="kw2">function</span><span class="br0">&#40;</span>receiver, <span class="kw3">name</span>, val<span class="br0">&#41;</span> -&gt; boolean   <span class="co1">// receiver.name = val</span>
  enumerate: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> -&gt; <span class="br0">&#91;</span>string<span class="br0">&#93;</span>                     <span class="co1">// for (name in proxy) (return array of enumerable own and inherited properties)</span>
  keys:      <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> -&gt; <span class="br0">&#91;</span>string<span class="br0">&#93;</span>                     <span class="co1">// Object.keys(proxy)  (return array of enumerable own properties only)</span>
<span class="br0">&#125;</span></pre>
<p>
These traps are named &ldquo;derived&rdquo; because they are defined in terms of the fundamental traps. For example, the <code>has</code> trap can be defined by invoking the <code>getPropertyDescriptor</code> trap and testing whether or not it returns <code>undefined</code>. The fundamental traps are required, the derived traps are optional. If a derived trap is missing, the proxy performs its <a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#trap_defaults" title="harmony:proxies &crarr;" class="wikilink1">default behavior</a>. The rationale for providing optional derived traps for particular operations is that the derived trap may be able to emulate the operation with less allocations. See the &ldquo;no-op&rdquo; handler in the following section for a concrete example.
</p>

<p>
The <code>fix</code> trap is introduced to enable a proxy to interact with <code>Object.preventExtensions</code>, <code>Object.seal</code> and <code>Object.freeze</code>. A non-extensible, sealed or frozen object should somehow restrict the handler&rsquo;s freedom in terms of what it can return from subsequent calls to &lsquo;set&rsquo;, &lsquo;get&rsquo; etc. For example, if previous invocations of handler.get(p, &ldquo;foo&rdquo;) returned a non-undefined value (for some &lsquo;handler&rsquo; of a proxy p), then future invocations of handler.get(p, &ldquo;foo&rdquo;) should return the same value when p is frozen.
</p>

<p>
This proposal enforces these restrictions as follows: every time an external object tries to freeze, seal or make a proxy non-extensible, the &ldquo;fix&rdquo; trap is invoked on the proxy&rsquo;s handler. At that point, the handler has two options:
</p>
<ol>
<li class="level1"><div class="li"> either to refuse the request (by making its &lsquo;fix&rsquo; trap return &ldquo;undefined&rdquo;). The corresponding call to Object.{freeze|seal|preventExtensions} will throw a TypeError.</div>
</li>
<li class="level1"><div class="li"> or to honor the request, and committing to it by <strong>generating a description</strong> of an object. The catch-all implementation then generates a fresh object based on this description, and from that point on the proxy effectively becomes that object and the handler is bypassed entirely. Any reference to the handler by the implementation is at that point released, making it available for GC. The proxy is now said to be &lsquo;fixed&rsquo;.</div>
</li>
</ol>

</div>
<!-- SECTION [3393-8468] -->
<a name="examplea_no-op_forwarding_proxy"></a><h3>Example: a no-op forwarding proxy</h3>
<div class="level3">

<p>
 This example shows how to implement a proxy that forwards all operations applied to it to an existing object. Many use cases for proxies will probably start from this general pattern, which is why the functionality provided in the below example code is also proposed for standardization as a <a href="doku.php%3Fid=harmony:proxy_defaulthandler.html" class="wikilink1" title="harmony:proxy_defaulthandler" onclick="return svchk()" onkeypress="return svchk()">default forwarding handler</a>.
</p>
<pre class="code javascript"><span class="kw2">function</span> handlerMaker<span class="br0">&#40;</span>obj<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw1">return</span> <span class="br0">&#123;</span>
   getOwnPropertyDescriptor: <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
     <span class="kw2">var</span> desc = Object.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>obj, <span class="kw3">name</span><span class="br0">&#41;</span>;
     <span class="co1">// a trapping proxy's properties must always be configurable</span>
     <span class="kw1">if</span> <span class="br0">&#40;</span>desc !== undefined<span class="br0">&#41;</span> <span class="br0">&#123;</span> desc.<span class="me1">configurable</span> = <span class="kw2">true</span>; <span class="br0">&#125;</span>
     <span class="kw1">return</span> desc;
   <span class="br0">&#125;</span>,
   getPropertyDescriptor:  <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
     <span class="kw2">var</span> desc = Object.<span class="me1">getPropertyDescriptor</span><span class="br0">&#40;</span>obj, <span class="kw3">name</span><span class="br0">&#41;</span>; <span class="co1">// not in ES5</span>
     <span class="co1">// a trapping proxy's properties must always be configurable</span>
     <span class="kw1">if</span> <span class="br0">&#40;</span>desc !== undefined<span class="br0">&#41;</span> <span class="br0">&#123;</span> desc.<span class="me1">configurable</span> = <span class="kw2">true</span>; <span class="br0">&#125;</span>
     <span class="kw1">return</span> desc;
   <span class="br0">&#125;</span>,
   getOwnPropertyNames: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
     <span class="kw1">return</span> Object.<span class="me1">getOwnPropertyNames</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span>;
   <span class="br0">&#125;</span>,
   getPropertyNames: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
     <span class="kw1">return</span> Object.<span class="me1">getPropertyNames</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span>;                <span class="co1">// not in ES5</span>
   <span class="br0">&#125;</span>,
   defineProperty: <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span>, desc<span class="br0">&#41;</span> <span class="br0">&#123;</span>
     Object.<span class="me1">defineProperty</span><span class="br0">&#40;</span>obj, <span class="kw3">name</span>, desc<span class="br0">&#41;</span>;
   <span class="br0">&#125;</span>,
   <span class="kw1">delete</span>:       <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="kw1">delete</span> obj<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span>; <span class="br0">&#125;</span>,   
   fix:          <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
     <span class="kw1">if</span> <span class="br0">&#40;</span>Object.<span class="me1">isFrozen</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
       <span class="kw2">var</span> result = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
       Object.<span class="me1">getOwnPropertyNames</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span>.<span class="me1">forEach</span><span class="br0">&#40;</span><span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
         result<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span> = Object.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>obj, <span class="kw3">name</span><span class="br0">&#41;</span>;
       <span class="br0">&#125;</span><span class="br0">&#41;</span>;
       <span class="kw1">return</span> result;
     <span class="br0">&#125;</span>
     <span class="co1">// As long as obj is not frozen, the proxy won't allow itself to be fixed</span>
     <span class="kw1">return</span> undefined; <span class="co1">// will cause a TypeError to be thrown</span>
   <span class="br0">&#125;</span>,
&nbsp;
   has:          <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="kw3">name</span> <span class="kw1">in</span> obj; <span class="br0">&#125;</span>,
   hasOwn:       <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="br0">&#40;</span><span class="br0">&#123;</span><span class="br0">&#125;</span><span class="br0">&#41;</span>.<span class="me1">hasOwnProperty</span>.<span class="me1">call</span><span class="br0">&#40;</span>obj, <span class="kw3">name</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span>,
   get:          <span class="kw2">function</span><span class="br0">&#40;</span>receiver, <span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> obj<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span>; <span class="br0">&#125;</span>,
   set:          <span class="kw2">function</span><span class="br0">&#40;</span>receiver, <span class="kw3">name</span>, val<span class="br0">&#41;</span> <span class="br0">&#123;</span> obj<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span> = val; <span class="kw1">return</span> <span class="kw2">true</span>; <span class="br0">&#125;</span>, <span class="co1">// bad behavior when set fails in non-strict mode</span>
   enumerate:    <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
     <span class="kw2">var</span> result = <span class="br0">&#91;</span><span class="br0">&#93;</span>;
     <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> <span class="kw3">name</span> <span class="kw1">in</span> obj<span class="br0">&#41;</span> <span class="br0">&#123;</span> result.<span class="me1">push</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span>;
     <span class="kw1">return</span> result;
   <span class="br0">&#125;</span>,
   keys: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> Object.<span class="me1">keys</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span>; <span class="br0">&#125;</span>
&nbsp;
  <span class="br0">&#125;</span>;
<span class="br0">&#125;</span>
<span class="kw2">var</span> proxy = Proxy.<span class="me1">create</span><span class="br0">&#40;</span>handlerMaker<span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="br0">&#41;</span>;</pre>
<p>
Notes: It&rsquo;s OK to call handlerMaker on a proxy itself: 
</p>
<pre class="code javascript">Proxy.<span class="me1">create</span><span class="br0">&#40;</span>handlerMaker<span class="br0">&#40;</span>aProxy<span class="br0">&#41;</span><span class="br0">&#41;</span>;</pre>
<p>
The <code>get</code> access is forwarded (not delegated), but if <code>obj[p]</code> is a method, its this-binding will be set to the current receiver (= delegation!) Alternatively, both property access and method invocation can be forwarded (instead of delegated) by defining <code>get</code> as follows: 
</p>
<pre class="code javascript">get: <span class="kw2">function</span><span class="br0">&#40;</span>receiver, <span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw2">var</span> prop = obj<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span>;
  <span class="kw1">return</span> <span class="br0">&#40;</span><span class="kw1">typeof</span> prop<span class="br0">&#41;</span> === <span class="st0">"function"</span> ? prop.<span class="me1">bind</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span> : prop;
<span class="br0">&#125;</span></pre>
<p>
* independent from catch-alls, there is no reliable way in <acronym title="JavaScript">JS</acronym> to determine whether a &lsquo;set&rsquo; of the form &lsquo;obj[name] = val&rsquo; succeeded. If an exception is thrown, that exception could either have been thrown because of a failed set, or it could have been thrown by the set accessor of p. If the caller is non-strict, in order to emulate a failed &lsquo;set&rsquo;, the &lsquo;set&rsquo; trap should return false rather than throw an exception. So &lsquo;set&rsquo; cannot reliably be emulated for non-strict callers. Regarding the transparent emulation of strict-only code, this is not an issue because all callers will be strict and will expect failed &lsquo;set&rsquo;s to always throw an exception.
</p>

<p>
The proxy handler explicitly sets the <code>configurable</code> attribute of any property descriptor it returns from <code>get{Own}Property</code> to <code>true</code>. If a proxy handler would return a property descriptor whose <code>configurable</code> attribute is <code>false</code>, the proxy implementation throws an exception. The rationale is that the implementation cannot verify that the property is indeed non-configurable: a proxy could deceive a program by returning a non-configurable property descriptor but nothing would constrain it to still configure the property afterward. Hence, proxies must always reveal their properties as being configurable. Instead of having the proxy implementation throw an exception when it sees a non-configurable property descriptor, it could also silently modify the descriptor to be configurable before returning it, but that would be likely to mask errors.
</p>

</div>
<!-- SECTION [8469-12843] -->
<a name="the_type_of_a_proxy"></a><h3>The type of a Proxy</h3>
<div class="level3">

<p>
 For spec purposes:
</p>
<ul>
<li class="level1"><div class="li"> Type(anObjectProxy) === Object</div>
</li>
<li class="level1"><div class="li"> Type(aFunctionproxy) === Object</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> anObjectProxy.[[Class]] === &ldquo;Object&rdquo;</div>
</li>
<li class="level1"><div class="li"> aFunctionProxy.[[Class]] === &ldquo;Function&rdquo;</div>
</li>
</ul>

<p>
 For ES code:
</p>
<ul>
<li class="level1"><div class="li"> <code>typeof anObjectProxy === &ldquo;object&rdquo;</code></div>
</li>
<li class="level1"><div class="li"> <code>typeof aFunctionProxy === &ldquo;function&rdquo;</code></div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> <code>anObjectProxy instanceof C</code> iff <code>anObjectProxy.</code>[[Prototype]] equals or inherits from <code>C.prototype</code></div>
</li>
<li class="level1"><div class="li"> <code>aFunctionProxy instanceof Function</code></div>
</li>
</ul>

</div>
<!-- SECTION [12844-13320] -->
<a name="proposal_details_rationale"></a><h2>Proposal Details / Rationale</h2>
<div class="level2">

</div>
<!-- SECTION [13321-13362] -->
<a name="equality"></a><h3>Equality</h3>
<div class="level3">

<p>
 The <code>===</code> operator is not trapped (for security reasons: <code>a === b</code> should not trigger arbitrary code) Instead: proxies have object identity, so <code>p1 === p2</code> iff <code>p1</code> and <code>p2</code> refer to the same proxy. Fixing a proxy does not alter its object identity (the object &ldquo;generated&rdquo; by the handler during fixing does not have its own object identity, it retains the object identity of the proxy, upholding the illusion that the proxy &ldquo;becomes&rdquo; the object).
</p>

</div>
<!-- SECTION [13363-13841] -->
<a name="fixing"></a><h3>Fixing</h3>
<div class="level3">

<p>
 Upon fixing an object proxy, the prototype of the generated object is the <code>proto</code> object passed during proxy construction or <code>null</code> if none was provided. The prototype of a function proxy is always Function.prototype, and this remains the case when fixing the function proxy.
</p>

<p>
Rationale for making <code>fix</code> return an object description, rather than a live object: if the proxy can &ldquo;become&rdquo; an existing object, it is not clear whether the proxy should delegate to the existing object or become a &ldquo;snapshot&rdquo; of the object. Also, the live object already has a prototype, creating confusion as to which object should become the prototype of the proxy (its <code>proto</code> or the live object&rsquo;s prototype). If the proxy&rsquo;s prototype changes, it could confuse programs by respond differently to &ldquo;typeof&rdquo; and &ldquo;instanceof&rdquo; tests. Having the proxy become a fresh object generated from an object description avoids these issues.
</p>

<p>
<code>Object.isExtensible(proxy)</code> : if proxy is trapping, return true, otherwise (if fixed) return false
</p>

<p>
When <code>handler.fix()</code> returns <code>undefined</code>, the corresponding call to <code>Object.freeze</code>, <code>Object.seal</code>, or <code>Object.preventExtensions</code> will throw a <code>TypeError</code> (Based on the following recommendation from the sepc, section 8.6.2: &ldquo;When an algorithm uses an internal property of an object and the object does not implement the indicated internal property, a <code>TypeError</code> exception is thrown.&rdquo;)
</p>

</div>
<!-- SECTION [13842-15278] -->
<a name="detecting_proxy_objects"></a><h3>Detecting proxy objects</h3>
<div class="level3">

<p>
 In an earlier version of the proposal, a method was defined on <code>Proxy</code> to distinguish trapping proxies from regular objects or fixed proxies:
</p>

<p>
<code>Proxy.isTrapping(anObject)</code> &rarr; returns true if and only if <code>anObject</code> is a proxy and is in trapping mode.
</p>

<p>
A proxy cannot influence the outcome of this method. Once a proxy is fixed, it is in all ways simply a normal object, with no built-in way to detect that it had ever been a trapping proxy.
</p>

<p>
The current consensus is not to provide this method as it directly breaks &ldquo;transparent&rdquo; virtualization of objects (i.e. it makes it easy to write brittle code that might break when substituting some objects with proxies or vice versa). Note that, with the help of the implementor of a certain type of proxies, one could easily build <code>Proxy.isTrapping</code> on top of <a href="doku.php%3Fid=harmony:weak_maps.html" class="wikilink1" title="harmony:weak_maps" onclick="return svchk()" onkeypress="return svchk()">Weak Maps</a>: <code>Proxy.create</code> could insert new trapping proxies in a weak map. If these proxies remove themselves on <code>fix()</code>, then <code>Proxy.isTrapping</code> is equivalent to testing whether the proxy is present in the weak map.
</p>

<p>
Note: a better name for <code>Proxy.isTrapping</code> would be <code>Proxy.isProxy</code>. Once a proxy is no longer trapping, it&rsquo;s no longer a proxy altogether. Also, <code>Proxy.isTrapping(obj)</code> returning <code>false</code> could signify either that <code>obj</code> never was a proxy, or that it&rsquo;s now a fixed proxy. Since the difference no longer matters, <code>Proxy.isProxy</code> more accurately reflects the outcome of the operation.
</p>

</div>
<!-- SECTION [15279-16765] -->
<a name="interaction_with_object._introspective_api"></a><h3>Interaction with Object.* introspective API</h3>
<div class="level3">

<p>
 The Proxy functions <code>create</code> and <code>createFunction</code> act as the equivalent of a &ldquo;mirror factory&rdquo; in a Mirror <acronym title="Application Programming Interface">API</acronym>. By replacing Proxy with another object that conforms to its <acronym title="Application Programming Interface">API</acronym> (by implementing <code>create</code>, <code>createFunction</code> and <code>isTrapping</code> methods), one could create different kinds of proxies using the same <acronym title="Application Programming Interface">API</acronym>.
</p>

<p>
This proposal assumes ES-harmony&rsquo;s default &ldquo;introspection&rdquo; <acronym title="Application Programming Interface">API</acronym> (i.e. the <code>Object.*</code> methods) does not reveal proxies. That is: even methods such as <code>Object.defineProperty</code> and <code>Object.getPropertyDescriptor</code> are trapped by the proxy&rsquo;s handler (see <span class="curid"><a href="doku.php%3Fid=harmony:proxies.html#interaction_of_external_methods_and_proxies" class="wikilink1" title="harmony:proxies" onclick="return svchk()" onkeypress="return svchk()">below</a></span> for a complete list).
</p>

<p>
The <code>Proxy.isTrapping</code> method allows programmers to implement their own introspection APIs that potentially reveal proxies. For example, one could define an object that is substitutable for the primordial <code>Object</code>, redefining all introspective methods such as <code>Object.getOwnPropertyDescriptor</code>, <code>Object.getPrototypeOf</code>, etc. For example, proxies could be revealed at the &ldquo;meta-level&rdquo; as empty objects rather than invoking their traps:
</p>
<pre class="code javascript"><span class="kw2">var</span> MyObject = <span class="br0">&#123;</span>
  getOwnPropertyDescriptor: <span class="kw2">function</span><span class="br0">&#40;</span>obj, <span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> Object.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>
      Proxy.<span class="me1">isTrapping</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span> ? <span class="br0">&#123;</span><span class="br0">&#125;</span> : obj, <span class="kw3">name</span><span class="br0">&#41;</span>;
  <span class="br0">&#125;</span>
  ...
<span class="br0">&#125;</span></pre>
</div>
<!-- SECTION [16766-18132] -->
<a name="accessing_handler_from_proxy"></a><h3>Accessing handler from proxy</h3>
<div class="level3">

<p>
 By default, this proposal provides no means for code with a reference to a proxy to get a reference to that proxy&rsquo;s handler. This safeguards the integrity of the proxy and its handler, and enforces stratification. For certain types of proxies, it may occur that certain meta-level programs sometimes do require access to a proxy&rsquo;s handler (e.g. because the handler contains meta-data about the proxy that should remain invisible to base-level code). In such cases, the meta-level program can use <a href="doku.php%3Fid=harmony:weak_maps.html" class="wikilink1" title="harmony:weak_maps" onclick="return svchk()" onkeypress="return svchk()">weak maps</a> in the following pattern:
</p>
<pre class="code javascript"><span class="kw2">function</span> makeCustomProxyFactory<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw2">var</span> customProxies = WeakMap<span class="br0">&#40;</span><span class="br0">&#41;</span>;
  <span class="kw1">return</span> <span class="br0">&#123;</span>
    create: <span class="kw2">function</span><span class="br0">&#40;</span>handler, proto<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">var</span> proxy = Proxy.<span class="me1">create</span><span class="br0">&#40;</span>handler, proto<span class="br0">&#41;</span>;
      customProxies.<span class="me1">put</span><span class="br0">&#40;</span>proxy, handler<span class="br0">&#41;</span>;
      <span class="kw1">return</span> proxy;
    <span class="br0">&#125;</span>,
    handlerOf: <span class="kw2">function</span><span class="br0">&#40;</span>proxy<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> customProxies.<span class="me1">get</span><span class="br0">&#40;</span>proxy<span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>;
<span class="br0">&#125;</span></pre>
<p>
For a custom proxy <code>p</code>, it now becomes possible to reference its handler by invoking <code>factory.handlerOf(p)</code>, given that one has a reference to the custom proxy factory <code>factory</code>. Note that even using this pattern, stratification is upheld: the handler of <code>p</code> is retrieved without having to &ldquo;ask&rdquo; <code>p</code> itself.
</p>

</div>
<!-- SECTION [18133-19385] -->
<a name="simulating_nosuchmethod_doesnotunderstand"></a><h3>Simulating __noSuchMethod__ / doesNotUnderstand:</h3>
<div class="level3">

<p>
 - The <code>get</code> trap takes as an argument the receiver of the property access. When the access was performed directly on the proxy, the receiver refers to the proxy and is generally not very interesting (a proxy in this context is useful only as an identity). However, the access may have happened through delegation via the prototype chain, in which case it may be useful for the handler to be able to refer to the original receiver of the property access. Note that the proxy mechanism makes it easy to emulate delegation rather than forwarding of messages, by passing this original receiver argument as the first (<em>thisArg</em>) argument to subsequent <code>apply</code> invocations.
</p>

<p>
- The <code>get</code> trap differs from the more traditional <code>__noSuchMethod__</code>/<code>doesNotUnderstand:</code> traps in that it traps all property accesses, not just missing property accesses, since proxies are always empty. The <code>doesNotUnderstand:</code> behavior can, however, be emulated by means of a simple pattern: introduce a child object that delegates to a proxy. Client objects may then find existing properties in the child object, all non-existent properties in the child will be trapped by the proxy parent.
</p>

<p>
- Dynamic generation of methods (as used in various ORM tools like Ruby&rsquo;s ActiveRecord and Groovy&rsquo;s GORM) can be emulated using a similar pattern: introduce a child object that delegates to a proxy, and make sure the proxy&rsquo;s handler can reference this child object. Now, property accesses trapped by the handler indicate methods not understood by the child object. The handler can simply decide to add a new property to the child, such that subsequent invocations will find the generated child property, rather than triggering the handler again.
</p>

<p>
 A simple noSuchMethod-like <acronym title="Application Programming Interface">API</acronym> can be built on top of this proposal, in a library, without losing the benefits of stratification. One possibility is to define a method named &ldquo;Object.createHandled&rdquo;, similar to ES5&rsquo;s &ldquo;Object.create&rdquo; method, but which allows an additional noSuchMethod trap to be specified:
</p>
<pre class="code javascript">Object.<span class="me1">createHandled</span> = <span class="kw2">function</span><span class="br0">&#40;</span>proto, objDesc, noSuchMethod<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw2">var</span> handler = <span class="br0">&#123;</span>
    get: <span class="kw2">function</span><span class="br0">&#40;</span>rcvr, p<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw2">var</span> args = <span class="br0">&#91;</span><span class="br0">&#93;</span>.<span class="me1">slice</span>.<span class="me1">call</span><span class="br0">&#40;</span>arguments, <span class="nu0">0</span><span class="br0">&#41;</span>;
        <span class="kw1">return</span> noSuchMethod.<span class="me1">call</span><span class="br0">&#40;</span><span class="kw1">this</span>, p, args<span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>;
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>;
  <span class="kw2">var</span> p = Proxy.<span class="me1">create</span><span class="br0">&#40;</span>handler, proto<span class="br0">&#41;</span>;
  <span class="kw1">return</span> Object.<span class="me1">create</span><span class="br0">&#40;</span>p, objDesc<span class="br0">&#41;</span>;
<span class="br0">&#125;</span>;</pre>
<p>
Given a convenience function <code>Object.getOwnProperties(obj)</code>, one could write:
</p>
<pre class="code javascript">Object.<span class="me1">createHandled</span><span class="br0">&#40;</span>Parent,
  Object.<span class="me1">getOwnProperties</span><span class="br0">&#40;</span><span class="br0">&#123;</span> ... <span class="br0">&#125;</span><span class="br0">&#41;</span>,
  <span class="kw2">function</span> <span class="br0">&#40;</span>id, args<span class="br0">&#41;</span> <span class="br0">&#123;</span> ... <span class="br0">&#125;</span><span class="br0">&#41;</span>;</pre>
<p>
This comes close to the <code><u>noSuchMethod</u></code>-style of trapping missing methods, without giving up on stratification (the <code>noSuchMethod</code> trap itself is still clearly separated from the object itself). The fact that an object literal is passed as an argument to <code>Object.getOwnProperties</code> is part of the idiom. It ensures that the rest of the application only refers to the &lsquo;trapped&rsquo; object, and there is no need for the programmer to explicitly distinguish the &lsquo;trapped&rsquo; object from the &lsquo;non-trapped&rsquo; object.
</p>

<p>
The differences between <code><u>noSuchMethod</u></code>-style trapping of missing methods and using the <code>get</code> trap of proxies are discussed at length in this <a href="https://mail.mozilla.org/pipermail/es-discuss/2010-October/011912.html" class="urlextern" target="_blank" title="https://mail.mozilla.org/pipermail/es-discuss/2010-October/011912.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">e-mail thread</a>.
</p>

</div>
<!-- SECTION [19386-22799] -->
<a name="function_proxies"></a><h3>Function Proxies</h3>
<div class="level3">

<p>
 - the value of <code>this</code> in the body of the <code>callTrap</code> is significant when a function proxy is being used to emulate a method of another object. For instance: 
</p>
<pre class="code javascript"><span class="kw2">var</span> fp = Proxy.<span class="me1">createFunction</span><span class="br0">&#40;</span><span class="br0">&#123;</span><span class="br0">&#125;</span>, callTrap<span class="br0">&#41;</span>;
<span class="kw2">var</span> o = <span class="br0">&#123;</span> <span class="kw3">name</span>: fp <span class="br0">&#125;</span>;
o.<span class="kw3">name</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span>; <span class="co1">// reified as callTrap.apply(o,[x])</span></pre>
</div>
<!-- SECTION [22800-23128] -->
<a name="stratification"></a><h3>Stratification</h3>
<div class="level3">

<p>
 - The handler is a regular object. It may delegate to other objects and its delegation chain is completely independent from that of the proxy it handles. A single handler may handle multiple proxies. The handler can be a proxy itself.
</p>

<p>
- Calling <code>aProxy.get(...)</code> , <code>aProxy.fix(...)</code> explicitly on a proxy will not trigger the proxy&rsquo;s corresponding traps. Instead, the call will be reified like any other, e.g. <code>aProxy.fix()</code> invokes the handler&rsquo;s <code>get(aProxy,&rsquo;fix&rsquo;)()</code> trap. Traps can only be invoked explicitly on a proxy&rsquo;s handler, not on the proxy itself. This enforces stratification (the meta-level traps should not interfere with base-level method names). Thus, proxies continue to work correctly if an application (by accident or by design) uses the names <code>get</code>, <code>set</code>, <code>has</code>, etc.
</p>

</div>
<!-- SECTION [23129-23961] -->
<a name="interaction_with_instanceof"></a><h3>Interaction with ''instanceof''</h3>
<div class="level3">

<p>
 Interaction between proxies and the <code>instanceof</code> operator. In ES, the prototype chain is used for both inheritance and &ldquo;typing&rdquo;. Two cases to consider:
</p>
<ul>
<li class="level1"><div class="li"> case 1: <code>obj instanceof aFunctionProxy</code></div>
</li>
</ul>

<p>
aFunctionProxy can influence the result of this operator if its handler&rsquo;s <code>get</code> trap returns a meaningful value for the <code>prototype</code> property. Internally, the <code>instanceof</code> operator invokes the built-in method [[HasInstance]] on the function, which queries the function&rsquo;s <code>prototype</code> property.
</p>

<p>
Note: a function proxy may break the invariant that regular <acronym title="JavaScript">JS</acronym> objects cannot change their type (the call to <code>get</code> may return different values for &lsquo;prototype&rsquo; over time), but this is already the case for regular functions anyway. 
</p>
<ul>
<li class="level1"><div class="li"> case 2: <code>anObjectProxy instanceof aConstructorFunction</code></div>
</li>
</ul>

<p>
The <code>proto</code> object passed to the <code>Proxy.create</code> method is used to determine the <code>prototype</code> of the proxy. Hence: 
</p>
<pre class="code javascript"><span class="kw2">var</span> proxy = Proxy.<span class="me1">create</span><span class="br0">&#40;</span>handler, String.<span class="me1">prototype</span><span class="br0">&#41;</span>;
proxy <span class="kw1">instanceof</span> String <span class="co1">// true</span></pre>
<p>
 This is similar to how <code>java.lang.reflect.Proxy</code> interacts with Java&rsquo;s <code>instanceof</code> operator: upon proxy construction, a list of interface types is given such that the proxy will be an <code>instanceof</code> those interface types.
</p>

<p>
Rationale for not trapping access to a proxy&rsquo;s prototype:
</p>

<p>
We could have also reified the [[Prototype]] property on objects as a &lsquo;prototype&rsquo; trap. The downside is that <code>aProxy instanceof ConstructorFunction</code> can then potentially execute arbitrary code, and that reifying the prototype property for the purposes of <code>instanceof</code>, but not for the purposes of inheritance could be very confusing for the implementor of the handler.
</p>

<p>
Rationale for not trapping <code>instanceof</code> test as an explicit <code>isInstanceOf(function)</code> trap on the proxy handler:
</p>

<p>
Security issue: the handler is given a reference to the <code>function</code> object (the right-hand side of the <code>instanceof</code> operator). This gives the handler the ability to generate new instances of that function.
</p>

<p>
Note: allowing proxies to &ldquo;impersonate&rdquo; members of existing &ldquo;types&rdquo; should not introduce any additional security issues, as the classification mechanism for ES is already unsafe (existing objects can already &ldquo;impersonate&rdquo; membership of a &ldquo;type&rdquo; (constructor function) by virtue of simply delegating to the function&rsquo;s prototype object).
</p>

</div>
<!-- SECTION [23962-26368] -->
<a name="trap_defaults"></a><h3>Trap Defaults</h3>
<div class="level3">

<p>
 When a proxy implementation queries a handler for the name of a trap, and the result of the lookup is <code>undefined</code>:
</p>
<ul>
<li class="level1"><div class="li"> If the trap is a fundamental trap, throw a <code>TypeError</code></div>
</li>
<li class="level1"><div class="li"> If the trap is a derived trap, the proxy implementation falls back on the &ldquo;default implementation&rdquo; of the derived trap in terms of the mandatory, fundamental traps.</div>
</li>
</ul>

<p>
 The default implementation of the derived traps can be implemented in Javascript itself. This is shown below for expository purposes, but is not a normative part of the Proxy specification (in the following code, <code>this</code> refers to the handler object, and any references to methods defined on <code>Object</code>, <code>Function.prototype</code> or <code>Array.prototype</code> are assumed to refer to the built-in implementations). The function <code>normalizeAndCompletePropertyDescriptor</code> is defined <a href="doku.php%3Fid=harmony:proxies_semantics.html#utilities" class="wikilink1" title="harmony:proxies_semantics" onclick="return svchk()" onkeypress="return svchk()">here</a>.
</p>
<pre class="code javascript">  has: <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> !!<span class="kw1">this</span>.<span class="me1">getPropertyDescriptor</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span>,
  hasOwn: <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> !!<span class="kw1">this</span>.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span>,
  get: <span class="kw2">function</span><span class="br0">&#40;</span>receiver, <span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> desc = <span class="kw1">this</span>.<span class="me1">getPropertyDescriptor</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span>;
    desc = normalizeAndCompletePropertyDescriptor<span class="br0">&#40;</span>desc<span class="br0">&#41;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>desc === undefined<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> undefined; <span class="br0">&#125;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="st0">'value'</span> <span class="kw1">in</span> desc<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> desc.<span class="me1">value</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span> <span class="co1">// accessor</span>
      <span class="kw2">var</span> getter = desc.<span class="me1">get</span>;
      <span class="kw1">if</span> <span class="br0">&#40;</span>getter === undefined<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> undefined; <span class="br0">&#125;</span>
      <span class="kw1">return</span> getter.<span class="me1">call</span><span class="br0">&#40;</span>receiver<span class="br0">&#41;</span>; <span class="co1">// assumes Function.prototype.call</span>
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>,
  set: <span class="kw2">function</span><span class="br0">&#40;</span>receiver, <span class="kw3">name</span>, val<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> desc = <span class="kw1">this</span>.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span>;
    desc = normalizeAndCompletePropertyDescriptor<span class="br0">&#40;</span>desc<span class="br0">&#41;</span>;
    <span class="kw2">var</span> setter;
    <span class="kw1">if</span> <span class="br0">&#40;</span>desc<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span><span class="st0">'writable'</span> <span class="kw1">in</span> desc<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>desc.<span class="me1">writable</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
          <span class="kw1">this</span>.<span class="me1">defineProperty</span><span class="br0">&#40;</span><span class="kw3">name</span>, <span class="br0">&#123;</span>value: val<span class="br0">&#125;</span><span class="br0">&#41;</span>;
          <span class="kw1">return</span> <span class="kw2">true</span>;
        <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
          <span class="kw1">return</span> <span class="kw2">false</span>;
        <span class="br0">&#125;</span>
      <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span> <span class="co1">// accessor</span>
        setter = desc.<span class="me1">set</span>;
        <span class="kw1">if</span> <span class="br0">&#40;</span>setter<span class="br0">&#41;</span> <span class="br0">&#123;</span>
          setter.<span class="me1">call</span><span class="br0">&#40;</span>receiver, val<span class="br0">&#41;</span>; <span class="co1">// assumes Function.prototype.call</span>
          <span class="kw1">return</span> <span class="kw2">true</span>;
        <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
          <span class="kw1">return</span> <span class="kw2">false</span>;
        <span class="br0">&#125;</span>
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
    desc = <span class="kw1">this</span>.<span class="me1">getPropertyDescriptor</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span>;
    desc = normalizeAndCompletePropertyDescriptor<span class="br0">&#40;</span>desc<span class="br0">&#41;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>desc<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span><span class="st0">'writable'</span> <span class="kw1">in</span> desc<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>desc.<span class="me1">writable</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
          <span class="co1">// fall through</span>
        <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
          <span class="kw1">return</span> <span class="kw2">false</span>;
        <span class="br0">&#125;</span>
      <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span> <span class="co1">// accessor</span>
        <span class="kw2">var</span> setter = desc.<span class="me1">set</span>;
        <span class="kw1">if</span> <span class="br0">&#40;</span>setter<span class="br0">&#41;</span> <span class="br0">&#123;</span>
          setter.<span class="me1">call</span><span class="br0">&#40;</span>receiver, val<span class="br0">&#41;</span>; <span class="co1">// assumes Function.prototype.call</span>
          <span class="kw1">return</span> <span class="kw2">true</span>;
        <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
          <span class="kw1">return</span> <span class="kw2">false</span>;
        <span class="br0">&#125;</span>
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>!Object.<span class="me1">isExtensible</span><span class="br0">&#40;</span>receiver<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="kw1">return</span> <span class="kw2">false</span>;
    <span class="kw1">this</span>.<span class="me1">defineProperty</span><span class="br0">&#40;</span><span class="kw3">name</span>, <span class="br0">&#123;</span>
      value: val, 
      writable: <span class="kw2">true</span>, 
      enumerable: <span class="kw2">true</span>, 
      configurable: <span class="kw2">true</span><span class="br0">&#125;</span><span class="br0">&#41;</span>;
    <span class="kw1">return</span> <span class="kw2">true</span>;
  <span class="br0">&#125;</span>,
  enumerate: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> trapResult = <span class="kw1">this</span>.<span class="me1">getPropertyNames</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
    <span class="kw2">var</span> l = +trapResult.<span class="me1">length</span>;
    <span class="kw2">var</span> result = <span class="br0">&#91;</span><span class="br0">&#93;</span>;
    <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> i = <span class="nu0">0</span>; i &lt; l; i++<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">var</span> <span class="kw3">name</span> = String<span class="br0">&#40;</span>trapResult<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span>;
      <span class="kw2">var</span> desc = <span class="kw1">this</span>.<span class="me1">getPropertyDescriptor</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span>;
      desc = normalizeAndCompletePropertyDescriptor<span class="br0">&#40;</span>desc<span class="br0">&#41;</span>;
      <span class="kw1">if</span> <span class="br0">&#40;</span>desc !== undefined &amp;&amp; desc.<span class="me1">enumerable</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        result.<span class="me1">push</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> result;
  <span class="br0">&#125;</span>,
  keys: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">var</span> trapResult = <span class="kw1">this</span>.<span class="me1">getOwnPropertyNames</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
    <span class="kw2">var</span> l = +trapResult.<span class="me1">length</span>;
    <span class="kw2">var</span> result = <span class="br0">&#91;</span><span class="br0">&#93;</span>;
    <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> i = <span class="nu0">0</span>; i &lt; l; i++<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">var</span> <span class="kw3">name</span> = String<span class="br0">&#40;</span>trapResult<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span>;
      <span class="kw2">var</span> desc = <span class="kw1">this</span>.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span>;
      desc = normalizeAndCompletePropertyDescriptor<span class="br0">&#40;</span>desc<span class="br0">&#41;</span>;
      <span class="kw1">if</span> <span class="br0">&#40;</span>desc !== undefined &amp;&amp; desc.<span class="me1">enumerable</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        result.<span class="me1">push</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> result;
  <span class="br0">&#125;</span></pre>
<p>
Note how in all cases, the derived traps cause allocations that can be avoided by having the handler directly implement these traps, rather than to inherit these default implementations.
</p>

<p>
The advantages of having the proxy implementation provide these defaults is that:
</p>
<ul>
<li class="level1"><div class="li"> it reduces the burden on proxy implementors, who have to implement less traps.</div>
</li>
<li class="level1"><div class="li"> a built-in implementation of the above defaults is likely to be faster than using the above actual Javascript code.</div>
</li>
<li class="level1"><div class="li"> it allows us to easily add new derived traps in later versions. Proxy handlers for earlier versions will most likely not define the new trap, and will fall back on the default behavior rather than crash.</div>
</li>
</ul>

<p>
 If <a href="doku.php%3Fid=strawman:handler_access_to_proxy.html" class="wikilink1" title="strawman:handler_access_to_proxy" onclick="return svchk()" onkeypress="return svchk()">handler_access_to_proxy</a> is accepted, the above code should be adjusted to trigger the fundamental traps via the proxy, rather than by performing a direct self-send on the handler (e.g. call <code>Object.getPropertyDescriptor(proxy, name)</code> rather than <code>this.getPropertyDescriptor(name)</code>). Triggering the fundamental traps through the proxy more accurately reflects the specification.
</p>

</div>
<!-- SECTION [26369-31100] -->
<a name="semantics"></a><h2>Semantics</h2>
<div class="level2">

<p>
 See the <a href="doku.php%3Fid=harmony:proxies_semantics.html" class="wikilink1" title="harmony:proxies_semantics" onclick="return svchk()" onkeypress="return svchk()">semantics page</a>
</p>

</div>
<!-- SECTION [31101-31177] -->
<a name="interaction_of_external_methods_and_proxies"></a><h3>Interaction of external methods and proxies</h3>
<div class="level3">

<p>
 In the methods below, we assume <code>aProxy</code> to be a trapping function or object proxy.
</p>

<p>
For each of the following methods, proxies can appear to be regular objects. 
</p>
<ul>
<li class="level1"><div class="li"> <code>Object.getOwnPropertyDescriptor(aProxy, name)</code> &rarr; trap on aProxy&rsquo;s handler</div>
</li>
<li class="level1"><div class="li"> <code>Object.getOwnPropertyNames(aProxy)</code> &rarr; trap on aProxy&rsquo;s handler</div>
</li>
<li class="level1"><div class="li"> <code>Object.defineProperty(aProxy, name, attrs)</code> &rarr; trap on aProxy&rsquo;s handler</div>
</li>
<li class="level1"><div class="li"> <code>Object.defineProperties(aProxy, properties)</code> &rarr; trap on aProxy&rsquo;s handler</div>
</li>
<li class="level1"><div class="li"> <code>Object.prototype.toString.call(aProxy)</code> &rarr; returns &ldquo;Object&rdquo; or &ldquo;Function&rdquo;</div>
<ul>
<li class="level2"><div class="li"> Note that <code>aProxy.toString()</code> is base-level and will be trapped by the <code>get</code> trap</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <code>Object.getPrototypeOf(aProxy)</code> &rarr; returns <code>proto</code>, <code>null</code> or <code>Function.prototype</code></div>
</li>
<li class="level1"><div class="li"> <code>Object.create(aProxy, properties)</code> &rarr; makes a new object that inherits from aProxy</div>
</li>
<li class="level1"><div class="li"> <code>Object.seal(aProxy)</code> &rarr; calls <code>fix</code> on aProxy&rsquo;s handler</div>
</li>
<li class="level1"><div class="li"> <code>Object.freeze(aProxy)</code> &rarr; calls <code>fix</code> on aProxy&rsquo;s handler</div>
</li>
<li class="level1"><div class="li"> <code>Object.preventExtensions(aProxy)</code> &rarr; invokes <code>fix</code> trap on aProxy&rsquo;s handler</div>
</li>
<li class="level1"><div class="li"> <code>Object.isSealed(aProxy)</code> &rarr; returns false</div>
</li>
<li class="level1"><div class="li"> <code>Object.isFrozen(aProxy)</code> &rarr; returns false</div>
</li>
<li class="level1"><div class="li"> <code>Object.isExtensible(aProxy)</code> &rarr; returns true</div>
</li>
<li class="level1"><div class="li"> <code>Object.keys(aProxy)</code> &rarr; invokes <code>keys</code> trap on aProxy&rsquo;s handler</div>
</li>
<li class="level1"><div class="li"> <code>Object.prototype.toLocaleString.call(aProxy)</code> &rarr; invokes <code>aProxy.toString()</code> which traps</div>
</li>
<li class="level1"><div class="li"> <code>Object.prototype.valueOf.call(aProxy)</code> &rarr; returns <code>aProxy</code></div>
</li>
<li class="level1"><div class="li"> <code>Object.prototype.isPrototypeOf.call(aProxy, aChild)</code> &rarr; returns whether <code>aChild</code> inherits from <code>aProxy</code></div>
</li>
<li class="level1"><div class="li"> <code>Object.prototype.isPrototypeOf.call(aParent, aProxy)</code> &rarr; returns whether <code>aProxy</code> inherits from <code>aParent</code></div>
</li>
<li class="level1"><div class="li"> <code>Object.prototype.hasOwnProperty.call(aProxy, name)</code> &rarr; invokes <code>hasOwn</code> trap on aProxy&rsquo;s handler</div>
</li>
<li class="level1"><div class="li"> <code>Function.prototype.apply.call(aFunctionProxy, thisValue, args)</code> &rarr; calls <code>aFunctionProxy</code>&lsquo;s apply trap with arguments <code>thisValue</code> and <code>args</code></div>
</li>
<li class="level1"><div class="li"> <code>Function.prototype.call.call(aFunctionProxy, thisValue, ...args)</code> &rarr; calls <code>aFunctionProxy</code>&lsquo;s apply trap with arguments <code>thisValue</code> and <code>args</code></div>
</li>
<li class="level1"><div class="li"> <code>Function.prototype.bind.call(aFunctionProxy, thisValue, ...args)</code> &rarr; returns a currying of <code>aFunctionProxy</code></div>
</li>
<li class="level1"><div class="li"> <code>Function.prototype.toString.call(aFunctionProxy)</code> &rarr; returns the result of <code>Function.prototype.toString.call(callTrap)</code> where <code>callTrap</code> is the function proxy&rsquo;s callTrap.</div>
</li>
</ul>

</div>
<!-- SECTION [31178-33621] -->
<a name="more_examples"></a><h2>More Examples</h2>
<div class="level2">

</div>
<!-- SECTION [33622-33648] -->
<a name="transparent_chains_of_no-op_proxies"></a><h3>Transparent chains of no-op proxies</h3>
<div class="level3">

<p>
 It is safe to create proxies whose handlers are themselves proxies. The following example illustrates that no-op proxies, created using the <code>handlerMaker</code> function defined above, compose cleanly.
</p>
<pre class="code javascript"><span class="kw2">var</span> p2 = Proxy.<span class="me1">create</span><span class="br0">&#40;</span>Proxy.<span class="me1">create</span><span class="br0">&#40;</span>handlerMaker<span class="br0">&#40;</span>handlerMaker<span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
<span class="co1">// Or, giving each subexpression a name:</span>
<span class="kw2">var</span> h1 = handlerMaker<span class="br0">&#40;</span>obj<span class="br0">&#41;</span>;
<span class="kw2">var</span> h2 = handlerMaker<span class="br0">&#40;</span>h1<span class="br0">&#41;</span>;
<span class="kw2">var</span> p1 = Proxy.<span class="me1">create</span><span class="br0">&#40;</span>h2<span class="br0">&#41;</span>;
<span class="kw2">var</span> p2 = Proxy.<span class="me1">create</span><span class="br0">&#40;</span>p1<span class="br0">&#41;</span>;</pre>
<p>
Here is how <code>p2.name</code> is translated into <code>obj.name</code>:
</p>
<ul>
<li class="level1"><div class="li"> p2.name &rarr;</div>
</li>
<li class="level1"><div class="li"> p1.get(p2, &lsquo;name&rsquo;) &rarr;</div>
</li>
<li class="level1"><div class="li"> h2.get(p1, &lsquo;get&rsquo;)(p2, &lsquo;name&rsquo;) &rarr;</div>
</li>
<li class="level1"><div class="li"> h1[&rsquo;get&rsquo;](p2, &lsquo;name&rsquo;) &rarr;</div>
</li>
<li class="level1"><div class="li"> obj[&rsquo;name&rsquo;]</div>
</li>
</ul>

<p>
 We use such double-proxying to simplify our membrane implementations below.
</p>

</div>
<!-- SECTION [33649-34400] -->
<a name="a_simple_membrane"></a><h3>A Simple Membrane</h3>
<div class="level3">

<p>
 As with the simple membrane of figure 9.3, p 71 of <a href="http://erights.org/talks/thesis/markm-thesis.pdf" class="urlextern" target="_blank" title="http://erights.org/talks/thesis/markm-thesis.pdf" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Robust Composition</a>, the following is the simplest expository membrane that satisfies the formal property of unavoidable transitive interposition, but is not yet practical. The next example below repairs its flaws.
</p>
<pre class="code javascript"><span class="kw2">const</span> makeSimpleMembrane<span class="br0">&#40;</span>target<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  let enabled = <span class="kw2">true</span>;
  
  <span class="kw2">const</span> wrap<span class="br0">&#40;</span>wrapped<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>Object.<span class="me1">isPrimitive</span><span class="br0">&#40;</span>wrapped<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="co1">// assumed built-in</span>
      <span class="co1">// primitives provide only irrevocable knowledge, so don't</span>
      <span class="co1">// bother wrapping it.</span>
      <span class="kw1">return</span> wrapped;
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw2">const</span> wrapCall<span class="br0">&#40;</span>fun, that, args<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw1">if</span> <span class="br0">&#40;</span>!enabled<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">throw</span> <span class="kw2">new</span> Error<span class="br0">&#40;</span><span class="st0">"disabled"</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span>
      <span class="kw1">try</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> wrap<span class="br0">&#40;</span>fun.<span class="me1">apply</span><span class="br0">&#40;</span>that, args.<span class="me1">map</span><span class="br0">&#40;</span>wrap<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
      <span class="br0">&#125;</span> <span class="kw1">catch</span> <span class="br0">&#40;</span>e<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">throw</span> wrap<span class="br0">&#40;</span>e<span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw2">const</span> baseHandler = handlerMaker<span class="br0">&#40;</span>wrapped<span class="br0">&#41;</span>;
    <span class="kw2">const</span> revokeHandler = Proxy.<span class="me1">create</span><span class="br0">&#40;</span>Object.<span class="me1">freeze</span><span class="br0">&#40;</span><span class="br0">&#123;</span>
      get: <span class="kw2">const</span><span class="br0">&#40;</span>rcvr, <span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> <span class="kw2">function</span><span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
          <span class="kw1">return</span> wrapCall<span class="br0">&#40;</span>baseHandler<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span>, baseHandler, args<span class="br0">&#41;</span>;
        <span class="br0">&#125;</span>
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
          
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">typeof</span> wrapped === <span class="st0">"function"</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">const</span> callTrap<span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> wrapCall<span class="br0">&#40;</span>wrapped, wrap<span class="br0">&#40;</span><span class="kw1">this</span><span class="br0">&#41;</span>, args<span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>
      <span class="kw2">const</span> cTrap<span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>!enabled<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">throw</span> <span class="kw2">new</span> Error<span class="br0">&#40;</span><span class="st0">"disabled"</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span>
        <span class="kw1">try</span> <span class="br0">&#123;</span>
          <span class="kw1">return</span> wrap<span class="br0">&#40;</span><span class="kw2">new</span> wrapped<span class="br0">&#40;</span>...<span class="me1">args</span>.<span class="me1">map</span><span class="br0">&#40;</span>wrap<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
        <span class="br0">&#125;</span> <span class="kw1">catch</span> <span class="br0">&#40;</span>e<span class="br0">&#41;</span> <span class="br0">&#123;</span>
          <span class="kw1">throw</span> wrap<span class="br0">&#40;</span>e<span class="br0">&#41;</span>;
        <span class="br0">&#125;</span>
      <span class="br0">&#125;</span>
      <span class="kw1">return</span> Proxy.<span class="me1">createFunction</span><span class="br0">&#40;</span>revokeHandler, callTrap, cTrap<span class="br0">&#41;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
      <span class="kw1">return</span> Proxy.<span class="me1">create</span><span class="br0">&#40;</span>revokeHandler, 
                          wrap<span class="br0">&#40;</span>Object.<span class="me1">getPrototypeOf</span><span class="br0">&#40;</span>wrapped<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
  
  <span class="kw2">const</span> gate = Object.<span class="me1">freeze</span><span class="br0">&#40;</span><span class="br0">&#123;</span>
    enable:  <span class="kw2">const</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> enabled = <span class="kw2">true</span>; <span class="br0">&#125;</span>,
    disable: <span class="kw2">const</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> enabled = <span class="kw2">false</span>; <span class="br0">&#125;</span>
  <span class="br0">&#125;</span><span class="br0">&#41;</span>;
  
  <span class="kw1">return</span> Object.<span class="me1">freeze</span><span class="br0">&#40;</span><span class="br0">&#123;</span> wrapper: wrap<span class="br0">&#40;</span>target<span class="br0">&#41;</span>, gate: gate <span class="br0">&#125;</span><span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre>
<p>
The <code>...</code> depends on the proposal for <a href="doku.php%3Fid=harmony:spread.html" class="wikilink1" title="harmony:spread" onclick="return svchk()" onkeypress="return svchk()">spread arguments</a>.
</p>

<p>
The <code>handlerMaker</code> function is defined above and defines the handler for a no-op forwarding proxy.
</p>

<p>
For now, the assumed built-in <code>Object.isPrimitive</code> could be implemented as: 
</p>
<pre class="code javascript">Object.<span class="me1">isPrimitive</span> = <span class="kw2">function</span> <span class="br0">&#40;</span>obj<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> obj !== Object<span class="br0">&#40;</span>obj<span class="br0">&#41;</span> <span class="br0">&#125;</span></pre>
</div>
<!-- SECTION [34401-36617] -->
<a name="an_identity-preserving_membrane"></a><h3>An identity-preserving membrane</h3>
<div class="level3">

<p>
 The following elaboration of the above example preserves the boundary between two sides we name &ldquo;wet&rdquo; and &ldquo;dry&rdquo;. When a wet object travels towards the dry side, the membrane stretches to wrap it, keeping it wet (exposing it only to other wet objects), while exposing a mostly transpa
</p>

<p>
rent but dry wrapper around it to the dry side. When the same wet object is moves towards the dry side again, the same dry wrapper is produced, preserving corresponding object identity on each side of the membrane. 
</p>

<p>
When this dry wrapper travels back towards the wet side, the original wrapped wet object appears rather than a double wrapping, so calling a dry wrapping of a wet function with a dry wrapping of a wet argument will cause the wet unwrapped function to be called with the wet unwrapped argument. Neither side sees its own objects unnecessarily wrapped.
</p>

<p>
And vice versa of course. This is much like the covariance/contravariance logic of <a href="http://www.cs.brown.edu/~arjun/public/poly-contracts.pdf" class="urlextern" target="_blank" title="http://www.cs.brown.edu/~arjun/public/poly-contracts.pdf" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">higher order contracts</a> and the left/right relationships in <a href="http://scg.unibe.ch/archive/papers/Gybe06aSymbioticReflectionESUGJournal.pdf" class="urlextern" target="_blank" title="http://scg.unibe.ch/archive/papers/Gybe06aSymbioticReflectionESUGJournal.pdf" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">linguistic symbiosis / inter-language reflection</a>. Although the logic of asDry and asWet below are exact mirror images, we duplicate the code rather than making it yet more abstract and hard to follow.
</p>
<pre class="code javascript"><span class="kw2">const</span> makeMembrane<span class="br0">&#40;</span>wetTarget<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  let wet2dry = WeakMap<span class="br0">&#40;</span><span class="br0">&#41;</span>;
  let dry2wet = WeakMap<span class="br0">&#40;</span><span class="br0">&#41;</span>;
  
  <span class="kw2">const</span> asDry<span class="br0">&#40;</span>wet<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>Object.<span class="me1">isPrimitive</span><span class="br0">&#40;</span>wet<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="co1">// primitives provide only irrevocable knowledge, so don't</span>
      <span class="co1">// bother wrapping it.</span>
      <span class="kw1">return</span> wet;
    <span class="br0">&#125;</span>
    <span class="kw2">const</span> dryResult = wet2dry.<span class="me1">get</span><span class="br0">&#40;</span>wet<span class="br0">&#41;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>dryResult<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> dryResult; <span class="br0">&#125;</span>
    
    <span class="kw2">const</span> wetHandler = handlerMaker<span class="br0">&#40;</span>wet<span class="br0">&#41;</span>;
    <span class="kw2">const</span> dryRevokeHandler = Proxy.<span class="me1">create</span><span class="br0">&#40;</span>Object.<span class="me1">freeze</span><span class="br0">&#40;</span><span class="br0">&#123;</span>
      get: <span class="kw2">const</span><span class="br0">&#40;</span>rcvr, <span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> <span class="kw2">function</span><span class="br0">&#40;</span>...<span class="me1">dryArgs</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
          <span class="kw2">const</span> optWetHandler = dry2wet.<span class="me1">get</span><span class="br0">&#40;</span>dryRevokeHandler<span class="br0">&#41;</span>;
          <span class="kw1">try</span> <span class="br0">&#123;</span>
            <span class="kw1">return</span> asDry<span class="br0">&#40;</span>optWetHandler<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span><span class="br0">&#40;</span>...<span class="me1">dryArgs</span>.<span class="me1">map</span><span class="br0">&#40;</span>asWet<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
          <span class="br0">&#125;</span> <span class="kw1">catch</span> <span class="br0">&#40;</span>eWet<span class="br0">&#41;</span> <span class="br0">&#123;</span>
            <span class="kw1">throw</span> asDry<span class="br0">&#40;</span>eWet<span class="br0">&#41;</span>;
          <span class="br0">&#125;</span>
        <span class="br0">&#125;</span>;
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    dry2wet.<span class="me1">set</span><span class="br0">&#40;</span>dryRevokeHandler, wetHandler<span class="br0">&#41;</span>;
          
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">typeof</span> wet === <span class="st0">"function"</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">const</span> callTrap<span class="br0">&#40;</span>...<span class="me1">dryArgs</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> asDry<span class="br0">&#40;</span>wet.<span class="me1">apply</span><span class="br0">&#40;</span>asWet<span class="br0">&#40;</span><span class="kw1">this</span><span class="br0">&#41;</span>, dryArgs.<span class="me1">map</span><span class="br0">&#40;</span>asWet<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>
      <span class="kw2">const</span> cTrap<span class="br0">&#40;</span>...<span class="me1">dryArgs</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> asDry<span class="br0">&#40;</span><span class="kw2">new</span> wet<span class="br0">&#40;</span>...<span class="me1">dryArgs</span>.<span class="me1">map</span><span class="br0">&#40;</span>asWet<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>
      dryResult = Proxy.<span class="me1">createFunction</span><span class="br0">&#40;</span>dryRevokeHandler, callTrap, cTrap<span class="br0">&#41;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
      dryResult = Proxy.<span class="me1">create</span><span class="br0">&#40;</span>dryRevokeHandler, 
                               asDry<span class="br0">&#40;</span>Object.<span class="me1">getPrototypeOf</span><span class="br0">&#40;</span>wet<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
    wet2dry.<span class="me1">set</span><span class="br0">&#40;</span>wet, dryResult<span class="br0">&#41;</span>;
    dry2wet.<span class="me1">set</span><span class="br0">&#40;</span>dryResult, wet<span class="br0">&#41;</span>;
    <span class="kw1">return</span> dryResult;
  <span class="br0">&#125;</span>
  
  <span class="kw2">const</span> asWet<span class="br0">&#40;</span>dry<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>Object.<span class="me1">isPrimitive</span><span class="br0">&#40;</span>dry<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="co1">// primitives provide only irrevocable knowledge, so don't</span>
      <span class="co1">// bother wrapping it.</span>
      <span class="kw1">return</span> dry;
    <span class="br0">&#125;</span>
    <span class="kw2">const</span> wetResult = dry2wet.<span class="me1">get</span><span class="br0">&#40;</span>dry<span class="br0">&#41;</span>;
    <span class="kw1">if</span> <span class="br0">&#40;</span>wetResult<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> wetResult; <span class="br0">&#125;</span>
    
    <span class="kw2">const</span> dryHandler = handlerMaker<span class="br0">&#40;</span>dry<span class="br0">&#41;</span>;
    <span class="kw2">const</span> wetRevokeHandler = Proxy.<span class="me1">create</span><span class="br0">&#40;</span>Object.<span class="me1">freeze</span><span class="br0">&#40;</span><span class="br0">&#123;</span>
      get: <span class="kw2">const</span><span class="br0">&#40;</span>rcvr, <span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> <span class="kw2">function</span><span class="br0">&#40;</span>...<span class="me1">wetArgs</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
          <span class="kw2">const</span> optDryHandler = wet2dry.<span class="me1">get</span><span class="br0">&#40;</span>wetRevokeHandler<span class="br0">&#41;</span>;
          <span class="kw1">try</span> <span class="br0">&#123;</span>
            <span class="kw1">return</span> asWet<span class="br0">&#40;</span>optDryHandler<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span><span class="br0">&#40;</span>...<span class="me1">wetArgs</span>.<span class="me1">map</span><span class="br0">&#40;</span>asDry<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
          <span class="br0">&#125;</span> <span class="kw1">catch</span><span class="br0">&#40;</span>eDry<span class="br0">&#41;</span> <span class="br0">&#123;</span>
            <span class="kw1">throw</span> asWet<span class="br0">&#40;</span>eDry<span class="br0">&#41;</span>;
          <span class="br0">&#125;</span>
        <span class="br0">&#125;</span>;
      <span class="br0">&#125;</span>
    <span class="br0">&#125;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    wet2dry.<span class="me1">set</span><span class="br0">&#40;</span>wetRevokeHandler, dryHandler<span class="br0">&#41;</span>;
          
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="kw1">typeof</span> dry === <span class="st0">"function"</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">const</span> callTrap<span class="br0">&#40;</span>wetArgs<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> asWet<span class="br0">&#40;</span>dry.<span class="me1">apply</span><span class="br0">&#40;</span>asDry<span class="br0">&#40;</span><span class="kw1">this</span><span class="br0">&#41;</span>, wetArgs.<span class="me1">map</span><span class="br0">&#40;</span>asDry<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>
      <span class="kw2">const</span> cTrap<span class="br0">&#40;</span>...<span class="me1">wetArgs</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> asWet<span class="br0">&#40;</span><span class="kw2">new</span> dry<span class="br0">&#40;</span>...<span class="me1">wetArgs</span>.<span class="me1">map</span><span class="br0">&#40;</span>asDry<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>
      wetResult = Proxy.<span class="me1">createFunction</span><span class="br0">&#40;</span>wetRevokeHandler, callTrap, cTrap<span class="br0">&#41;</span>;
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
      wetResult = Proxy.<span class="me1">create</span><span class="br0">&#40;</span>wetRevokeHandler, 
                               asWet<span class="br0">&#40;</span>Object.<span class="me1">getPrototypeOf</span><span class="br0">&#40;</span>dry<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
    dry2wet.<span class="me1">set</span><span class="br0">&#40;</span>dry, wetResult<span class="br0">&#41;</span>;
    wet2dry.<span class="me1">set</span><span class="br0">&#40;</span>wetResult, dry<span class="br0">&#41;</span>;
    <span class="kw1">return</span> wetResult;
  <span class="br0">&#125;</span>
  
  <span class="kw2">const</span> gate = Object.<span class="me1">freeze</span><span class="br0">&#40;</span><span class="br0">&#123;</span>
    revoke: <span class="kw2">const</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      dry2wet = wet2dry = Object.<span class="me1">freeze</span><span class="br0">&#40;</span><span class="br0">&#123;</span>
        get: <span class="kw2">const</span><span class="br0">&#40;</span>key<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">throw</span> <span class="kw2">new</span> Error<span class="br0">&#40;</span><span class="st0">"revoked"</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span>,
        set: <span class="kw2">const</span><span class="br0">&#40;</span>key, val<span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="br0">&#125;</span>
      <span class="br0">&#125;</span>;
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span><span class="br0">&#41;</span>;
  
  <span class="kw1">return</span> Object.<span class="me1">freeze</span><span class="br0">&#40;</span><span class="br0">&#123;</span> wrapper: asDry<span class="br0">&#40;</span>wetTarget<span class="br0">&#41;</span>, gate: gate <span class="br0">&#125;</span><span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre>
</div>
<!-- SECTION [36618-40951] -->
<a name="garbage_collection_behavior"></a><h4>Garbage Collection Behavior</h4>
<div class="level4">

<p>
 The <code>WeakMap</code> refers to the <a href="doku.php%3Fid=harmony:weak_maps.html" class="wikilink1" title="harmony:weak_maps" onclick="return svchk()" onkeypress="return svchk()">weak maps</a> proposal. By using weak maps, graph structures that cross the membrane remain as collectable as they would be if the membrane were not there. An unreferenced cycle of wet and dry object and their wrappers is still not strongly referenced, even if the membrane is strongly referenced, and so may be collected.
</p>

<p>
To illustrate another point, an additional change is that, rather than enabling and disabling with the gate, this gate does a single one-way revoke, permanently disabling the membrane. A revoked membrane drops its weak maps, so that the non-collectability of an object on one side of the membrane no longer prevents collection of its twin on the other side. If a subgraph is fully surrounded by a membrane, then once that membrane is revoked, that subgraph is necessarily collectible. Not only is all its connectivity revoked, its ability to continue to occupy memory is revoked as well.
</p>

</div>
<!-- SECTION [40952-41939] -->
<a name="an_eventual_reference_proxy"></a><h3>An eventual reference proxy</h3>
<div class="level3">

<p>
 This example shows how to implement a proxy that represents an eventual reference, enforcing asynchronous property access on an object.
</p>
<pre class="code javascript"><span class="kw2">function</span> localFarReferenceMaker<span class="br0">&#40;</span>obj<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw2">var</span> pds = Object.<span class="me1">getPropertyDescriptors</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span>;
  <span class="kw2">var</span> nonConfigurableProperties = 
      Object.<span class="me1">freeze</span><span class="br0">&#40;</span>         Object.<span class="me1">keys</span><span class="br0">&#40;</span>pds<span class="br0">&#41;</span>.<span class="me1">filter</span><span class="br0">&#40;</span><span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> !pds<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span>.<span class="me1">configurable</span>; <span class="br0">&#125;</span><span class="br0">&#41;</span>;
  <span class="kw2">var</span> frozenProperties = 
      Object.<span class="me1">freeze</span><span class="br0">&#40;</span>nonConfigurableProperties.<span class="me1">filter</span><span class="br0">&#40;</span><span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> !pds<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span>.<span class="me1">writable</span>; <span class="br0">&#125;</span><span class="br0">&#41;</span>;
  <span class="kw2">var</span> nonSettableProperties = 
      Object.<span class="me1">freeze</span><span class="br0">&#40;</span>         frozenProperties.<span class="me1">filter</span><span class="br0">&#40;</span><span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> !pds<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span>.<span class="me1">set</span>; <span class="br0">&#125;</span><span class="br0">&#41;</span>;
  <span class="kw2">var</span> nonConfigurableOwnProperties = 
      Object.<span class="me1">freeze</span><span class="br0">&#40;</span>nonConfigurableProperties.<span class="me1">filter</span><span class="br0">&#40;</span><span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="br0">&#40;</span><span class="br0">&#123;</span><span class="br0">&#125;</span><span class="br0">&#41;</span>.<span class="me1">hasOwnProperty</span>.<span class="me1">call</span><span class="br0">&#40;</span>obj, <span class="kw3">name</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span><span class="br0">&#41;</span>;
&nbsp;
  <span class="kw2">var</span> handler = <span class="br0">&#123;</span>
   defineProperty: <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span>, desc<span class="br0">&#41;</span> <span class="br0">&#123;</span>
     setTimeout<span class="br0">&#40;</span><span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#123;</span> Object.<span class="me1">defineProperty</span><span class="br0">&#40;</span>obj, <span class="kw3">name</span>, desc<span class="br0">&#41;</span>; <span class="br0">&#125;</span>, <span class="nu0">0</span><span class="br0">&#41;</span>;
   <span class="br0">&#125;</span>,
   getOwnPropertyDescriptor: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
     <span class="kw1">if</span> <span class="br0">&#40;</span>nonConfigurableOwnProperties.<span class="me1">indexOf</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> &gt;= <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
       <span class="kw1">return</span> pds<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span>;
     <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
       <span class="kw1">return</span> undefined;
     <span class="br0">&#125;</span>
   <span class="br0">&#125;</span>,
   getOwnPropertyNames: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> nonConfigurableOwnProperties; <span class="br0">&#125;</span>,
   has:          <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> nonConfigurableProperties.<span class="me1">indexOf</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> &gt;= <span class="nu0">0</span>; <span class="br0">&#125;</span>,
   hasOwn:       <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> nonConfigurableOwnProperties.<span class="me1">indexOf</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> &gt;= <span class="nu0">0</span>; <span class="br0">&#125;</span>,
   get: <span class="kw2">function</span><span class="br0">&#40;</span>receiver, <span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
     <span class="kw1">return</span> promiseFor<span class="br0">&#40;</span><span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#123;</span><span class="kw1">return</span> obj<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span>;<span class="br0">&#125;</span><span class="br0">&#41;</span>; 
   <span class="br0">&#125;</span>,
   set: <span class="kw2">function</span><span class="br0">&#40;</span>receiver, <span class="kw3">name</span>, val<span class="br0">&#41;</span> <span class="br0">&#123;</span>
     <span class="kw1">if</span> <span class="br0">&#40;</span>nonSettableProperties.<span class="me1">indexOf</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> &gt;= <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="kw2">false</span>; <span class="br0">&#125;</span>;
     setTimeout<span class="br0">&#40;</span><span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#123;</span>obj<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span> = val;<span class="br0">&#125;</span>, <span class="nu0">0</span><span class="br0">&#41;</span>;
     <span class="kw1">return</span> <span class="kw2">true</span>;
   <span class="br0">&#125;</span>,
   <span class="kw1">delete</span>: <span class="kw2">function</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
     <span class="kw1">if</span> <span class="br0">&#40;</span>nonConfigurableProperties.<span class="me1">indexOf</span><span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> &gt;= <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="kw2">false</span>; <span class="br0">&#125;</span>;
     setTimeout<span class="br0">&#40;</span><span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#123;</span><span class="kw1">delete</span> obj<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span>;<span class="br0">&#125;</span>, <span class="nu0">0</span><span class="br0">&#41;</span>;
     <span class="kw1">return</span> <span class="kw2">true</span>;
   <span class="br0">&#125;</span>,
   enumerate: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
     <span class="kw1">return</span> nonConfigurableProperties.<span class="me1">filter</span><span class="br0">&#40;</span>
       <span class="kw2">function</span> <span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> pds<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span>.<span class="me1">enumerable</span> <span class="br0">&#125;</span><span class="br0">&#41;</span>;
   <span class="br0">&#125;</span>,
   keys: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
     <span class="kw1">return</span> nonConfigurableOwnProperties.<span class="me1">filter</span><span class="br0">&#40;</span>
       <span class="kw2">function</span> <span class="br0">&#40;</span><span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> pds<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span>.<span class="me1">enumerable</span> <span class="br0">&#125;</span><span class="br0">&#41;</span>;
   <span class="br0">&#125;</span>,
   fix: <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> undefined; <span class="br0">&#125;</span>,
  <span class="br0">&#125;</span>;
  <span class="kw1">return</span> Proxy.<span class="me1">create</span><span class="br0">&#40;</span>handler, Object.<span class="me1">getPrototypeOf</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="br0">&#41;</span>;
<span class="br0">&#125;</span></pre>
<p>
Note: <code>localFarReferenceMaker</code> should work even if <code>obj</code> is a host object.
</p>

</div>
<!-- SECTION [41940-44280] -->
<a name="higher-order_messages"></a><h3>Higher-order Messages</h3>
<div class="level3">

<p>
 A higher-order message is a message that takes another message as its argument, as explained in <a href="http://www.metaobject.com/papers/Higher_Order_Messaging_OOPSLA_2005.pdf" class="urlextern" target="_blank" title="http://www.metaobject.com/papers/Higher_Order_Messaging_OOPSLA_2005.pdf" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">this paper</a>.
</p>

<p>
Higher-order messaging builds upon catch-alls to reify the message as an object. We reify the message as a function of its receiver, by sending the message to a special catch-all named <code>_</code>:
</p>
<pre class="code javascript"><span class="kw2">var</span> msg = _.<span class="me1">foo</span><span class="br0">&#40;</span><span class="nu0">1</span>,<span class="nu0">2</span><span class="br0">&#41;</span>
msg.<span class="me1">selector</span>; <span class="co1">// &quot;foo&quot;</span>
msg.<span class="me1">args</span>; <span class="co1">// [1,2]</span>
msg<span class="br0">&#40;</span>x<span class="br0">&#41;</span>; <span class="co1">// x.foo(1,2)</span></pre>
<p>
The following example is based on the higher-order messaging paper, section 2.2:
</p>
<pre class="code javascript"><span class="kw2">var</span> salaried = employees.<span class="me1">filter</span><span class="br0">&#40;</span>_.<span class="me1">hasSalary</span><span class="br0">&#40;</span><span class="nu0">1000</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
<span class="co1">// equivalent to:</span>
<span class="kw2">var</span> salaried = employees.<span class="me1">filter</span><span class="br0">&#40;</span><span class="kw2">function</span><span class="br0">&#40;</span>e<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> e.<span class="me1">hasSalary</span><span class="br0">&#40;</span><span class="nu0">1000</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span><span class="br0">&#41;</span>;</pre>
<p>
Here is the code for the <code>_</code> object:
</p>
<pre class="code javascript"><span class="co1">// turns messages into functions</span>
<span class="kw2">var</span> _ = Proxy.<span class="me1">create</span><span class="br0">&#40;</span><span class="br0">&#123;</span>
  get: <span class="kw2">function</span><span class="br0">&#40;</span>_, <span class="kw3">name</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="kw2">function</span><span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">var</span> f = <span class="kw2">function</span><span class="br0">&#40;</span>rcvr<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> rcvr<span class="br0">&#91;</span><span class="kw3">name</span><span class="br0">&#93;</span><span class="br0">&#40;</span>...<span class="me1">args</span><span class="br0">&#41;</span>;
      <span class="br0">&#125;</span>;
      f.<span class="me1">selector</span> = <span class="kw3">name</span>;
      f.<span class="me1">args</span> = args;
      Object.<span class="me1">freeze</span><span class="br0">&#40;</span>f.<span class="me1">args</span><span class="br0">&#41;</span>;
      Object.<span class="me1">freeze</span><span class="br0">&#40;</span>f.<span class="me1">prototype</span><span class="br0">&#41;</span>;
      <span class="kw1">return</span> Object.<span class="me1">freeze</span><span class="br0">&#40;</span>f<span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
  <span class="br0">&#125;</span>
<span class="br0">&#125;</span><span class="br0">&#41;</span>;</pre>
</div>
<!-- SECTION [44281-45470] -->
<a name="climbing_the_meta_ladder"></a><h2>Climbing the meta ladder</h2>
<div class="level2">

<p>
 Catch-alls climb the meta ladder: a handler&rsquo;s traps potentially enable arbitrary code to be executed in places where the spec does not currently expect this. The intent of this section is to document and collect all places where arbitrary code can now be executed in the spec due to catch-alls. 
</p>
<ul>
<li class="level1"><div class="li"> the &lsquo;get&rsquo; and &lsquo;set&rsquo; traps do not introduce new cases, since these traps already exist in the form of accessor properties.</div>
</li>
<li class="level1"><div class="li"> the expression &ldquo;name in proxy&rdquo; evaluates to &ldquo;proxy.[[HasProperty]](name)&rdquo;. Can execute arbitrary code via the proxy&rsquo;s &ldquo;has&rdquo; trap.</div>
</li>
<li class="level1"><div class="li"> the expression &ldquo;delete proxy.name&rdquo; can execute arbitrary code via the proxy&rsquo;s &ldquo;delete&rdquo; trap.</div>
</li>
<li class="level1"><div class="li"> the expression &ldquo;for name in proxy&rdquo; can execute arbitrary code via the proxy&rsquo;s &ldquo;enumerate&rdquo; trap.</div>
</li>
<li class="level1"><div class="li"> the method &ldquo;Object.keys(proxy)&rdquo; can execute arbitrary code via the proxy&rsquo;s &ldquo;keys&rdquo; trap.</div>
</li>
<li class="level1"><div class="li"> the expression &ldquo;with (proxy) { x }&rdquo; can execute arbitrary code: the proxy becomes the &lsquo;binding object&rsquo; of an Object Environment Record (section 10.2.1.2), so identifier lookup and assignment are translated into invoking [[HasProperty]], [[Get]] and [[Put]] on the binding object. In the current spec, this statement could already execute arbitrary code if <code>x</code> is an accessor property (in which case [[Get]] and [[Put]] could execute arbitrary code). With catch-alls, this statement could execute arbitrary code without &lsquo;x&rsquo; having to be an accessor property, as simply checking the existence of <code>x</code> in <code>proxy</code> triggers the proxy&rsquo;s <code>has</code> trap.</div>
</li>
<li class="level1"><div class="li"> Proxies interact with many of the static methods defined on <code>Object</code>. However, calls to these static methods could already execute arbitrary user code if these methods were previously &ldquo;monkey-patched&rdquo;.</div>
</li>
</ul>

</div>
<!-- SECTION [45471-47241] -->
<a name="background_prior_work"></a><h2>Background / Prior Work</h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> In general: meta-objects &amp; reflection literature (especially &lsquo;intercession&rsquo;)</div>
</li>
<li class="level1"><div class="li"> Ungar &amp; Bracha&rsquo;s <a href="http://bracha.org/mirrors.pdf" class="urlextern" target="_blank" title="http://bracha.org/mirrors.pdf" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Mirrors</a> (mirrors do not enable intercession, only introspection/invocation)</div>
</li>
</ul>

</div>
<!-- SECTION [47242-47491] -->
<a name="in_this_wiki"></a><h3>In this wiki</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> The <a href="doku.php%3Fid=strawman:catchalls.html" class="wikilink1" title="strawman:catchalls" onclick="return svchk()" onkeypress="return svchk()">catchalls</a> Harmony-era strawman, withdrawn in favor of this proposal</div>
</li>
<li class="level1"><div class="li"> ES4&rsquo;s <a href="doku.php%3Fid=proposals:catchalls.html" class="wikilink1" title="proposals:catchalls" onclick="return svchk()" onkeypress="return svchk()">catchalls</a> proposal</div>
</li>
</ul>

</div>
<!-- SECTION [47492-47650] -->
<a name="systems_that_enable_intercession_of_all_or_most_meta-level_operations"></a><h3>Systems that enable intercession of all or most meta-level operations</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> <a href="http://soft.vub.ac.be/Publications/2007/vub-prog-tr-07-16.pdf" class="urlextern" target="_blank" title="http://soft.vub.ac.be/Publications/2007/vub-prog-tr-07-16.pdf" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Mirages in AmbientTalk</a>: adds intercession to a Mirror <acronym title="Application Programming Interface">API</acronym></div>
</li>
<li class="level1"><div class="li"> CLOS&rsquo;s <a href="http://www.lisp.org/mop" class="urlextern" target="_blank" title="http://www.lisp.org/mop" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">metaobject protocol</a> / metaclasses, in particular:</div>
<ul>
<li class="level2"><div class="li"> the instance structure protocol (intercept slot accesses, i.e. &ldquo;property access&rdquo;)</div>
</li>
<li class="level2"><div class="li"> the generic function invocation protocol (intercept generic function invocation, i.e. &ldquo;method calls&rdquo;)</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> <a href="http://docs.python.org/reference/datamodel.html#object.__getattribute__" class="urlextern" target="_blank" title="http://docs.python.org/reference/datamodel.html#object.__getattribute__" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">In Python</a>, <code>x.y</code> expands to <code>type(x).__getattribute__(x, &quot;y&quot;)</code>. Getting the <code>__getattribute__</code> property of <code>type(x)</code> expands similarly; this eventually bottoms out in a built-in type. The same mechanism is used for operator overloading. The main difference from the present proposal is that in Python, the <code>__getattribute__</code> hook is on <code>type(x)</code> and not a separate handler object; i.e. the Python equivalents of &ldquo;prototype&rdquo; and &ldquo;handler&rdquo; are not separable.</div>
</li>
<li class="level1"><div class="li"> The existing ES-Harmony <a href="doku.php%3Fid=strawman:catchalls.html" class="wikilink1" title="strawman:catchalls" onclick="return svchk()" onkeypress="return svchk()">catch-all strawman proposal</a></div>
</li>
</ul>

</div>
<!-- SECTION [47651-48785] -->
<a name="systems_that_enable_intercession_of_method_invocations"></a><h3>Systems that enable intercession of method invocations</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Java&rsquo;s invocation handlers: can generate a <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/reflect/Proxy.html" class="urlextern" target="_blank" title="http://java.sun.com/j2se/1.4.2/docs/api/java/lang/reflect/Proxy.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">java.lang.reflect.Proxy</a> given an InvocationHandler and one or more interface types. The proxy is typed as the given interfaces. All method invocations on the proxy are &lsquo;reified&rsquo; as calls on the InvocationHandler&rsquo;s &ldquo;invoke&rdquo; method. It is impossible to generate proxies for class types (only interface types), which sidesteps the issue of reifying property access (interfaces have no instance variables).</div>
</li>
<li class="level1"><div class="li"> Groovy&rsquo;s <a href="http://groovy.codehaus.org/Using+invokeMethod+and+getProperty" class="urlextern" target="_blank" title="http://groovy.codehaus.org/Using+invokeMethod+and+getProperty" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">invokeMethod and getProperty</a> (require a class to implement the &lsquo;GroovyInterceptable&rsquo; interface)</div>
</li>
<li class="level1"><div class="li"> E&rsquo;s <a href="http://wiki.erights.org/wiki/Proxy" class="urlextern" target="_blank" title="http://wiki.erights.org/wiki/Proxy" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">proxies for eventual references</a></div>
</li>
</ul>

</div>
<!-- SECTION [48786-49631] -->
<a name="systems_that_enable_intercession_of_missing_method_invocations_only"></a><h3>Systems that enable intercession of missing method invocations only</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Smalltalk&rsquo;s <a href="http://en.wikipedia.org/wiki/Smalltalk#Reflection" class="urlextern" target="_blank" title="http://en.wikipedia.org/wiki/Smalltalk#Reflection" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">doesNotUnderstand:</a> is probably one of the more well-known traps out there</div>
</li>
<li class="level1"><div class="li"> E&rsquo;s <a href="http://wiki.erights.org/wiki/Walnut/Ordinary_Programming/Objects_and_Functions#General_method_name_matching_and_E.call.28.29" class="urlextern" target="_blank" title="http://wiki.erights.org/wiki/Walnut/Ordinary_Programming/Objects_and_Functions#General_method_name_matching_and_E.call.28.29" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">match clause</a></div>
</li>
<li class="level1"><div class="li"> <a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/noSuchMethod" class="urlextern" target="_blank" title="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Object/noSuchMethod" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">__noSuchMethod__</a> in SpiderMonkey</div>
</li>
<li class="level1"><div class="li"> Ruby&rsquo;s <a href="http://ruby-doc.org/core/classes/Kernel.html#M005925" class="urlextern" target="_blank" title="http://ruby-doc.org/core/classes/Kernel.html#M005925" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">method_missing</a> (used extensively in ActiveRecord ORM for generating &lsquo;dynamic finders&rsquo;). Because object attributes are always accessed via accessor methods, method_missing also traps property access</div>
</li>
<li class="level1"><div class="li"> Groovy&rsquo;s <a href="http://groovy.codehaus.org/Using+methodMissing+and+propertyMissing" class="urlextern" target="_blank" title="http://groovy.codehaus.org/Using+methodMissing+and+propertyMissing" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">methodMissing and propertyMissing</a> (use case in GORM: methods that trigger methodMissing can be installed in a metaclass such that on subsequent invocations they will be found by regular   dispatch logic, no longer triggering methodMissing)</div>
</li>
</ul>

</div>
<!-- SECTION [49632-50734] -->
<a name="open_issues"></a><h2>Open issues</h2>
<div class="level2">

</div>
<!-- SECTION [50735-50759] -->
<a name="property_descriptor_normalization"></a><h4>Property descriptor normalization</h4>
<div class="level4">

<p>
 In ES5, <code>Object.getOwnPropertyDescriptor</code> and <code>Object.defineProperty</code> convert between objects representing property descriptors (aka &ldquo;property descriptor objects&rdquo;) and internal property descriptors. A question that arises with the introduction of Proxies is whether the <code>get{Own}PropertyDescriptor</code> and <code>defineProperty</code> traps can return, resp. receive an arbitrary property descriptor object or whether it can only return/receive a &ldquo;normalized&rdquo; version.
</p>

<p>
A &ldquo;normalized&rdquo; property descriptor object is an ECMAScript <code>Object</code> with the following constraints:
</p>
<ul>
<li class="level1"><div class="li"> all of its properties are data properties</div>
</li>
<li class="level1"><div class="li"> all of its property attributes are <code>{writable:true, configurable: true, enumerable: true}</code> (these are meta-attributes: attributes of properties representing attributes)</div>
</li>
<li class="level1"><div class="li"> Properties named <code>writable</code>, <code>enumerable</code> and <code>configurable</code> have a boolean value</div>
</li>
<li class="level1"><div class="li"> Properties named <code>get</code> and <code>set</code> refer to either <code>undefined</code> or a callable value</div>
</li>
<li class="level1"><div class="li"> The properties <code>value</code> and <code>writable</code> are mutually exclusive with the properties <code>get</code> and <code>set</code>.</div>
</li>
</ul>

<p>
 In the current <a href="doku.php%3Fid=harmony:proxies_semantics.html" class="wikilink1" title="harmony:proxies_semantics" onclick="return svchk()" onkeypress="return svchk()">proxies_semantics</a>, the return value of <code>get{Own}PropertyDescriptor</code> and the descriptor argument to <code>defineProperty</code> are replaced by a normalized property descriptor object. In the case of <code>get{Own}PropertyDescriptor</code>, the normalized descriptor is completed, in the case of <code>defineProperty</code> it is not. In both cases, any enumerable own or inherited properties on the original object are copied to the normalized property descriptor, so that non-standard attributes are not lost in the conversion process. This allows the Proxy <acronym title="Application Programming Interface">API</acronym> to be used to experiment with non-standard property attributes. When a proxy is fixed, non-standard attributes are lost.
</p>

<p>
Potential alternatives:
</p>
<ul>
<li class="level1"><div class="li"> Normalize property descriptor objects, but without copying non-standard attributes.</div>
</li>
<li class="level1"><div class="li"> Pass property descriptor objects through unmodified, but provide a built-in <code>Object.toPropertyDescriptor</code> that enables manual normalization. It would then be up to any client object to protect itself against inconsistent property descriptors returned by <code>Object.get{Own}PropertyDescriptor(val,name)</code> when <code>val</code> is a proxy.</div>
</li>
</ul>

<p>
 &mdash; <em><a href="mailto:%26%23x74%3B%26%23x6f%3B%26%23x6d%3B%26%23x76%3B%26%23x63%3B%26%23x2e%3B%26%23x62%3B%26%23x65%3B%26%23x40%3B%26%23x67%3B%26%23x6d%3B%26%23x61%3B%26%23x69%3B%26%23x6c%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x74;&#x6f;&#x6d;&#x76;&#x63;&#x2e;&#x62;&#x65;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">Tom Van Cutsem</a> 2011/07/12 12:10</em>
</p>

</div>
<!-- SECTION [50760-53079] -->
<a name="non-configurable_properties"></a><h4>Non-configurable properties</h4>
<div class="level4">

<p>
 Proxies as presented here cannot emulate non-configurable properties. If the <code>getOwnPropertyDescriptor</code> trap returns a property descriptor whose <code>configurable</code> attribute is <code>false</code>, that attribute should either be set to <code>true</code> or a <code>TypeError</code> should be raised. This is probably too restrictive: we want proxies to be able to emulate non-configurable properties, but without breaking the invariants associated with non-configurable properties (e.g. a non-writable, non-configurable property&rsquo;s value should be stable). According to MarkM, even host objects are not allowed to violate these invariants.
</p>

<p>
See the <a href="doku.php%3Fid=strawman:fixed_properties.html" class="wikilink1" title="strawman:fixed_properties" onclick="return svchk()" onkeypress="return svchk()">fixed_properties</a> strawman. &mdash; <em><a href="mailto:%26%23x74%3B%26%23x6f%3B%26%23x6d%3B%26%23x76%3B%26%23x63%3B%26%23x2e%3B%26%23x62%3B%26%23x65%3B%26%23x40%3B%26%23x67%3B%26%23x6d%3B%26%23x61%3B%26%23x69%3B%26%23x6c%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x74;&#x6f;&#x6d;&#x76;&#x63;&#x2e;&#x62;&#x65;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">Tom Van Cutsem</a> 2011/07/12 12:17</em>
</p>

</div>
<!-- SECTION [53080-53841] -->
<a name="validation_of_trap_results"></a><h4>Validation of trap results</h4>
<div class="level4">

<p>
 How to deal with inconsistent data returned by handler traps? Should a proxy implementation normalize inconsistent data, should it throw, or should it do nothing at all (allowing built-ins such as <code>Object.keys</code> to return data that a non-proxy implementation could never return)? This issue was discussed at the July TC39 meeting, but not resolved. Validating all trap results could be costly, and could be deferred to a Javascript wrapper around the built-ins. On the other hand, implementations might be able to perform the validation much faster than a Javascript wrapper, and in some cases may already need to perform such validation anyway to maintain internal consistency (this happens in particular when fundamental traps are invoked as part of the <a href="doku.php%3Fid=harmony:proxies&amp;do=export_html.html#trap_defaults" title="harmony:proxies &crarr;" class="wikilink1">default behavior</a> of a missing derived trap. In this case, the implementation may need to interact further with the return value of the trap). We probably need to look at these problems on a case-by-case basis, as it is not clear how much validation is necessary/can be afforded:
</p>
<ul>
<li class="level1"><div class="li"> In <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=580200" class="urlextern" target="_blank" title="https://bugzilla.mozilla.org/show_bug.cgi?id=580200" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">this bug</a> the issue came up on what to do if the return value of <code>getOwnPropertyNames</code> or <code>keys</code> contains duplicate property names: silently filter them out, leave them, or throw?</div>
</li>
<li class="level2"><div class="li"> Traps that return arrays of property names, such as <code>getOwnPropertyNames</code>: should all values in the returned array be coerced to <code>String</code> before being returned to the user? Should the array be copied (since a handler may still hold on to it)?</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x74%3B%26%23x6f%3B%26%23x6d%3B%26%23x76%3B%26%23x63%3B%26%23x2e%3B%26%23x62%3B%26%23x65%3B%26%23x40%3B%26%23x67%3B%26%23x6d%3B%26%23x61%3B%26%23x69%3B%26%23x6c%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x74;&#x6f;&#x6d;&#x76;&#x63;&#x2e;&#x62;&#x65;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">Tom Van Cutsem</a> 2010/08/04 06:24</em>
</p>

</div>
<!-- SECTION [53842-55499] -->
<a name="feedback"></a><h2>Feedback</h2>
<div class="level2">

<p>
 <strong>TC39 Meeting 1/28/10 (Mozilla)</strong>:
</p>
<ul>
<li class="level1"><div class="li"> It was remarked that (host) objects can be callable without being functions. The committee requested that we look into an <a href="doku.php%3Fid=strawman:uniform_proxies.html" class="wikilink1" title="strawman:uniform_proxies" onclick="return svchk()" onkeypress="return svchk()">alternative API</a> that removes the distinction between object and function proxies, instead turning the <code>callTrap</code> and <code>constructTrap</code> of function proxies into regular traps of the handler.</div>
</li>
<li class="level1"><div class="li"> There was some concern whether the performance of method calls on non-proxy objects could be affected by adding proxies to the language. This is best investigated by means of a concrete experiment, perhaps by extending an existing ECMAScript engine with support for proxies.</div>
</li>
<li class="level1"><div class="li"> The number of operators that proxies can virtualize is still open for discussion. The current proposal does not allow proxies to virtualize <code>typeof</code> and <code>[[Class]]</code>. Perhaps these could be virtualized but kept constant by passing appropriate values for <code>typeof</code> and <code>[[Class]]</code> to the <code>Proxy</code> constructor. The <a href="doku.php%3Fid=strawman:uniform_proxies.html" class="wikilink1" title="strawman:uniform_proxies" onclick="return svchk()" onkeypress="return svchk()">alternative API</a> does virtualize <code>typeof</code> in this manner.</div>
</li>
<li class="level1"><div class="li"> It remains an open issue how the Proxy <acronym title="Application Programming Interface">API</acronym> will be exposed. Should ES-harmony support modules, the <code>Proxy</code> object is likely to become available through a module.</div>
</li>
<li class="level1"><div class="li"> Should ES-harmony support a general <a href="doku.php%3Fid=strawman:generators.html" class="wikilink1" title="strawman:generators" onclick="return svchk()" onkeypress="return svchk()">iterator or generator mechanism</a>, the interface of the <code>enumerate</code> trap should be aligned with that mechanism.</div>
</li>
<li class="level1"><div class="li"> The membrane code contained a bug: thrown exceptions could cross the membrane unwrapped.</div>
</li>
<li class="level1"><div class="li"> <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=546590" class="urlextern" target="_blank" title="https://bugzilla.mozilla.org/show_bug.cgi?id=546590" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">SpiderMonkey implementation in progress</a> (nearly done &ndash; fast work by Andreas Gal!  &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2010/02/17 20:40</em>)</div>
</li>
</ul>

<p>
 <strong>Feedback based on spidermonkey prototype</strong>:
</p>
<ul>
<li class="level1"><div class="li"> Dave Herman pointed out that <code>Proxy.isTrapping</code> breaks transparent virtualization of objects. If there is no good use case for <code>Proxy.isTrapping</code>, we should remove it, enabling completely transparent object virtualization. One potential use for <code>Proxy.isTrapping</code> is that it allows alternative meta-level APIs to reflect on proxies differently (c.f. the &ldquo;Interaction with Object.* introspective <acronym title="Application Programming Interface">API</acronym>&rdquo; section above).</div>
</li>
<li class="level1"><div class="li"> Because a handler should implement the full handler <acronym title="Application Programming Interface">API</acronym>, and because this <acronym title="Application Programming Interface">API</acronym> is quite large, it was suggested that Proxies come with a small set of &ldquo;built-in&rdquo; handlers that can be extended. One generally useful handler is the forwarding handler, wrapping a target object. Another useful handler could be a &ldquo;sink&rdquo; handler that implements every trap as a no-op.</div>
</li>
<li class="level1"><div class="li"> Proxy implementations should not leak implementation details to proxy handlers, e.g. whether the implementation represents integer property names as numbers rather than strings. For example, if <code>p</code> is a proxy, <code>p[15]</code> should call the handler&rsquo;s <code>get</code> trap with the property name bound to the string <code>&ldquo;15&rdquo;</code>, not to the number <code>15</code>.</div>
</li>
<li class="level1"><div class="li"> Clarify the semantics of proxies and enumeration:</div>
<ul>
<li class="level2"><div class="li"> Proxy implementations should enumerate properties in a <code>for-in</code> loop in the order in which they appear in the array returned by the <code>enumerate</code> trap. </div>
</li>
<li class="level2"><div class="li"> The array returned by <code>enumerate</code> is a snapshot of the proxy&rsquo;s properties at the start of an enumeration. If a proxy becomes fixed while enumerating its properties, the enumeration should continue based on the original snapshot. However, properties that no longer exist in the fixed object should be skipped.</div>
</li>
<li class="level2"><div class="li"> New properties added to a proxy during an enumeration are not themselves enumerated.</div>
</li>
<li class="level2"><div class="li"> Existing properties deleted during an enumeration should no longer be enumerated.</div>
</li>
<li class="level2"><div class="li"> What is the effect of mutating the array returned by <code>enumerate()</code> on <code>for-in</code> loops in progress?</div>
</li>
</ul>
</li>
</ul>

<p>
 <strong>TC39 Meeting 3/24/10 (Apple)</strong>:
</p>
<ul>
<li class="level1"><div class="li"> Leave out the <code>invoke</code> trap.</div>
</li>
<li class="level1"><div class="li"> Leave out <code>Proxy.isTrapping</code>. It directly breaks transparent object virtualization. It&rsquo;s easier to add it later if it turns out that there is a valid use case.</div>
</li>
<li class="level1"><div class="li"> There was consensus about standardizing a default forwarding handler (for example <code>Proxy.createHandler(target)</code>, but the <acronym title="Application Programming Interface">API</acronym> is not yet settled). Rather than trying to come up with additional useful handlers, we should develop more experience in writing proxy handlers and see what abstractions emerge. Additional proxy handlers could be defined as a separate strawman.</div>
</li>
<li class="level1"><div class="li"> The <acronym title="Application Programming Interface">API</acronym> that distinguishes object proxies from function proxies turns out to be simpler than the uniform <acronym title="Application Programming Interface">API</acronym> (also at the implementation level).</div>
</li>
<li class="level1"><div class="li"> The experimental third <code>className</code> parameter to <code>Proxy.create</code> in spidermonkey should not be standardized. Objects should not be able to virtualize the <code>[[Class]]</code> built-in property. However, <code>Object.prototype.toString.call(proxy)</code> will reveal proxies if the object they are proxying has a non-<code>Object</code> or non-<code>Function</code> <code>[[Class]]</code>.</div>
</li>
<li class="level1"><div class="li"> There was consensus that the <code>constructTrap</code> argument to <code>Proxy.createFunction</code> can be optional. If absent, <code>new aFunctionProxy()</code> calls the <code>[[Construct]]</code> built-in method of the <code>callTrap</code>.</div>
</li>
<li class="level1"><div class="li"> Proxies and enumeration: we should postpone this discussion until there is agreement on the details of enumeration for regular objects, which should probably be discussed in a separate proposal.</div>
</li>
<li class="level1"><div class="li"> Waldemar raised objections against the current Proxy <acronym title="Application Programming Interface">API</acronym> to proxy objects with a large number of properties. The problematic traps are <code>fix</code> and <code>enumerate</code>. W.r.t <code>enumerate</code>, a proxy could return a proxy for an array. Additionally, <code>enumerate</code> should be modified as soon as there is a solid proposal for generators/iterators. Proxies for large objects could resist being fixed. This solution is satisfactory as long as no part of the spec depends on an object being non-extensible/sealed/frozen.</div>
</li>
</ul>

<p>
 &mdash; <em><a href="mailto:%26%23x74%3B%26%23x6f%3B%26%23x6d%3B%26%23x76%3B%26%23x63%3B%26%23x40%3B%26%23x67%3B%26%23x6f%3B%26%23x6f%3B%26%23x67%3B%26%23x6c%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x74;&#x6f;&#x6d;&#x76;&#x63;&#x40;&#x67;&#x6f;&#x6f;&#x67;&#x6c;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Tom Van Cutsem</a> 2010/03/26 15:45</em>
</p>

<p>
<strong>TC39 Meeting 5/24/10 (Google)</strong>:
</p>
<ul>
<li class="level1"><div class="li"> Proposed generalization that <code>proxy[obj]</code> would pass <code>obj</code> uncoerced to the <code>get</code> trap: this change would be inconvenient for existing implementations, who would no longer be able to eagerly coerce property names to strings. Proposal withdrawn.</div>
</li>
<li class="level1"><div class="li"> Disallowing recursive fixing: what should be the semantics of calling <code>fix()</code> on a proxy handler while the same proxy is already being fixed (an earlier call to <code>fix()</code> is already on the stack)? Proposed solution is to throw a type error when calling <code>fix()</code> recursively. No objections were raised.</div>
</li>
<li class="level1"><div class="li"> Dave Herman presented an <a href="doku.php%3Fid=strawman:iterators.html" class="wikilink1" title="strawman:iterators" onclick="return svchk()" onkeypress="return svchk()">iterator proposal</a> that replaces the <code>enumerate()</code> trap by an <code>iterate()</code> trap, allowing proxy properties to be enumerated &ldquo;on demand&rdquo;. There was agreement about the general idea, but confusion about the details of the iterator <acronym title="Application Programming Interface">API</acronym>.</div>
</li>
</ul>

<p>
&mdash; <em><a href="mailto:%26%23x74%3B%26%23x6f%3B%26%23x6d%3B%26%23x76%3B%26%23x63%3B%26%23x2e%3B%26%23x62%3B%26%23x65%3B%26%23x40%3B%26%23x67%3B%26%23x6d%3B%26%23x61%3B%26%23x69%3B%26%23x6c%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x74;&#x6f;&#x6d;&#x76;&#x63;&#x2e;&#x62;&#x65;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">Tom Van Cutsem</a> 2010/05/26 01:34</em>
</p>

<p>
<strong>TC39 Meeting 7/29/10 (Microsoft)</strong>:
</p>
<ul>
<li class="level1"><div class="li"> Renaming <code>enumerateOwn</code> trap to <code>keys</code>. No objections were raised.</div>
</li>
<li class="level1"><div class="li"> Previously, if derived traps were undefined, triggering them would raise a TypeError. A more useful semantics could be to have the runtime execute the default implementation of the missing derived trap. For example, if a proxy handler does not define <code>keys</code>, then <code>Object.keys(proxy)</code> will instead call the fundamental <code>getOwnPropertyNames</code> trap, and filter out the non-enumerable properties from the returned array. Proxy handler implementors could get the derived traps for free (and with a more efficient default implementation). Also, this semantics makes it easier for later versions of the spec. to add new derived traps: existing handlers that don&rsquo;t implement the new derived traps will not crash, but rather fall back on a reasonable default behavior. Note: this semantics doesn&rsquo;t break the &ldquo;double lifting&rdquo; technique. No objections against this alternative semantics were raised.</div>
</li>
<li class="level1"><div class="li"> Proxy.[[Construct]] reform: in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=571452" class="urlextern" target="_blank" title="https://bugzilla.mozilla.org/show_bug.cgi?id=571452" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">this bug</a>, the following issue came up: should the construct trap of function proxies always coerce its result to <code>Object</code>? In other words, is <code>typeof (new functionproxy())</code> guaranteed to be <code>&ldquo;object&rdquo;</code>? Previously, the answer was yes, but MarkM expressed some concern about primitives being implicitly wrapped, and Brendan noted it might get in the way of possibly future user-defined value types. There was consensus that Proxy.[[Construct]] should not perform a <code>ToObject</code> conversion. We <a href="doku.php%3Fid=harmony:proxies_semantics.html#detailed_semantics_of_additional_behavior_for_function_proxies" class="wikilink1" title="harmony:proxies_semantics" onclick="return svchk()" onkeypress="return svchk()">changed the semantics</a> such that <code>new functionproxy()</code> returns whatever the <code>construct</code> trap returns (primitives are not wrapped).</div>
</li>
<li class="level1"><div class="li"> Discussion about the integrity of values returned from proxy handler traps: to what extent should an implementation normalize or screen handler return values before passing them on as the return value of the built-in <code>Object.*</code> methods. Disagreement about how to deal with this. One camp, voiced mostly by MarkM, advocates &ldquo;as much validation as we can stand&rdquo;. Another camp, voiced mostly by Allen, advocates doing a minimum amount of validation, deferring more elaborate validation to a layered implementation (in Javascript itself). MarkM: not sure whether validation can be done in <acronym title="JavaScript">JS</acronym> efficiently, since it involves a.o. checking duplicate property names (for the return value of <code>enumerate</code> and <code>getOwnPropertyNames</code>). Allen: proxies should not be prohibitively expensive to use due to costly validation checks. MarkM notes that the &ldquo;more validation&rdquo; path could be an easier way forward, as it needs testing against implementation costs, which can be done. The &ldquo;less validation&rdquo; path needs testing against web compatibility with an ES5-based web, which doesn&rsquo;t exist yet.</div>
</li>
</ul>

<p>
 &mdash; <em><a href="mailto:%26%23x74%3B%26%23x6f%3B%26%23x6d%3B%26%23x76%3B%26%23x63%3B%26%23x2e%3B%26%23x62%3B%26%23x65%3B%26%23x40%3B%26%23x67%3B%26%23x6d%3B%26%23x61%3B%26%23x69%3B%26%23x6c%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x74;&#x6f;&#x6d;&#x76;&#x63;&#x2e;&#x62;&#x65;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">Tom Van Cutsem</a> 2010/08/05 01:53</em>
</p>

<p>
<strong>TC39 Meeting 9/30/10 (Mozilla)</strong>: 
</p>
<ul>
<li class="level1"><div class="li"> Calling <code>Object.defineProperty(proxy,name,pd)</code> on a trapping proxy triggers that proxy&rsquo;s <code>defineProperty(name,desc)</code> trap. What should the <code>desc</code> argument be bound to? Should it be bound to <code>pd</code> directly, or should it be bound to <code>ToPropertyDescriptor(pd)</code>? A problem with coercing using <code>ToPropertyDescriptor(pd)</code> is that this drops non-standard attributes, making these inaccessible to the proxy. Agreement to tweak the semantics of <code>Object.defineProperty</code> for proxies such that the <code>defineProperty</code> trap gets a property descriptor that was coerced using <code>ToPropertyDescriptor</code> but still has the non-standard attributes (they are copied from the argument object to the coerced property descriptor). See the updated <a href="doku.php%3Fid=harmony:proxies_semantics.html#modifications_to_other_object_built-ins" class="wikilink1" title="harmony:proxies_semantics" onclick="return svchk()" onkeypress="return svchk()">semantics of Object.defineProperty</a>.</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x74%3B%26%23x6f%3B%26%23x6d%3B%26%23x76%3B%26%23x63%3B%26%23x2e%3B%26%23x62%3B%26%23x65%3B%26%23x40%3B%26%23x67%3B%26%23x6d%3B%26%23x61%3B%26%23x69%3B%26%23x6c%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x74;&#x6f;&#x6d;&#x76;&#x63;&#x2e;&#x62;&#x65;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">Tom Van Cutsem</a> 2010/10/01 16:04</em>
</p>

<p>
<strong>TC39 Meeting 1/20/11 (Yahoo)</strong>: 
</p>
<ul>
<li class="level1"><div class="li"> Proposed a <a href="doku.php%3Fid=harmony:proxy_defaulthandler.html" class="wikilink1" title="harmony:proxy_defaulthandler" onclick="return svchk()" onkeypress="return svchk()">default forwarding handler</a> <acronym title="Application Programming Interface">API</acronym>.</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x74%3B%26%23x6f%3B%26%23x6d%3B%26%23x76%3B%26%23x63%3B%26%23x2e%3B%26%23x62%3B%26%23x65%3B%26%23x40%3B%26%23x67%3B%26%23x6d%3B%26%23x61%3B%26%23x69%3B%26%23x6c%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x74;&#x6f;&#x6d;&#x76;&#x63;&#x2e;&#x62;&#x65;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">Tom Van Cutsem</a> 2011/01/26 08:17</em>
</p>

<p>
The paper <a href="http://www.soe.ucsc.edu/research/report?ID=1595" class="urlextern" target="_blank" title="http://www.soe.ucsc.edu/research/report?ID=1595" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Virtual Values for Language Extension</a> sketches an extension of these proxies to also cover primitive values, working in a simpler language than Javascript.  &mdash; <em><a href="mailto:%26%23x63%3B%26%23x6f%3B%26%23x72%3B%26%23x6d%3B%26%23x61%3B%26%23x63%3B%26%23x40%3B%26%23x73%3B%26%23x6f%3B%26%23x65%3B%26%23x2e%3B%26%23x75%3B%26%23x63%3B%26%23x73%3B%26%23x63%3B%26%23x2e%3B%26%23x65%3B%26%23x64%3B%26%23x75%3B" class="mail" title="&#x63;&#x6f;&#x72;&#x6d;&#x61;&#x63;&#x40;&#x73;&#x6f;&#x65;&#x2e;&#x75;&#x63;&#x73;&#x63;&#x2e;&#x65;&#x64;&#x75;">Cormac Flanagan</a> 2010/07/29 21:50</em>
</p>

<p>
I wrote up a small <a href="http://soft.vub.ac.be/~tvcutsem/proxies/" class="urlextern" target="_blank" title="http://soft.vub.ac.be/~tvcutsem/proxies/" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">tutorial</a> on proxies. Still under construction, but may be helpful. &mdash; <em><a href="mailto:%26%23x74%3B%26%23x6f%3B%26%23x6d%3B%26%23x76%3B%26%23x63%3B%26%23x2e%3B%26%23x62%3B%26%23x65%3B%26%23x40%3B%26%23x67%3B%26%23x6d%3B%26%23x61%3B%26%23x69%3B%26%23x6c%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x74;&#x6f;&#x6d;&#x76;&#x63;&#x2e;&#x62;&#x65;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">Tom Van Cutsem</a> 2010/08/23 00:13</em> 
</p>

</div>
<!-- SECTION [55500-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/e/e28abd44675ba3c1d3fe0f5f5d297b7e.xhtml used -->
</body>
</html>
