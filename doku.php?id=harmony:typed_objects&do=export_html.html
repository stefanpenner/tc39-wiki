<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=harmony:typed_objects&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="http://wiki.ecmascript.org/feed.php?mode=list&amp;ns=harmony" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=harmony:typed_objects&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#typed_objects" class="toc">Typed Objects</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#goals" class="toc">Goals</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#examples" class="toc">Examples</a></span></li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#overview" class="toc">Overview</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#typed_objects" class="toc">Typed Objects</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#types" class="toc">Types</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#built-in_value_types" class="toc">Built-in Value Types</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#built-in_reference_types" class="toc">Built-in Reference Types</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#struct_types" class="toc">Struct Types</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#array_types" class="toc">Array Types</a></span></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#typesdetails" class="toc">Types: Details</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#opacity" class="toc">Opacity</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#type_equivalence" class="toc">Type Equivalence</a></span></li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#typed_objectsdetails" class="toc">Typed Objects: Details</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#exposing_storage" class="toc">Exposing Storage</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#struct_layout" class="toc">Struct Layout</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#introspection" class="toc">Introspection</a></span></li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#api" class="toc">API</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#types" class="toc">Types</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#struct_types" class="toc">Struct Types</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#array_types" class="toc">Array Types</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#typed_objects" class="toc">Typed Objects</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#structs" class="toc">Structs</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#arrays" class="toc">Arrays</a></span></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:typed_objects&amp;do=export_html.html#rationale" class="toc">Rationale</a></span></li>
</ul>
</div>
</div>

<a name="typed_objects"></a><h1>Typed Objects</h1>
<div class="level1">

<p>
 (Formerly known as <a href="doku.php%3Fid=harmony:binary_data.html" class="wikilink1" title="harmony:binary_data" onclick="return svchk()" onkeypress="return svchk()">binary data</a>)
</p>

<p>
 2014/01 TC39 presentation: <a href="https://docs.google.com/presentation/d/1HGoxjX74Q9i8I1ok-hkmxzWlM7CDQwxT0sUS5PJDxdg/edit?usp=sharing" class="urlextern" target="_blank" title="https://docs.google.com/presentation/d/1HGoxjX74Q9i8I1ok-hkmxzWlM7CDQwxT0sUS5PJDxdg/edit?usp=sharing" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">TC39 Typed Objects presentation</a>
</p>

</div>
<!-- SECTION [1-232] -->
<a name="goals"></a><h2>Goals</h2>
<div class="level2">

<p>
 Typed objects provide portable, memory-safe, efficient, and structured access to contiguously allocated data. Certain kinds of typed objects can also expose a binary representation of their backing store, making them conveniently serializable and deserializable.
</p>

<p>
Some use cases: 
</p>
<ul>
<li class="level1"><div class="li"> optimized data abstractions &ndash; these will be very easy to optimize well in JIT&rsquo;s</div>
</li>
<li class="level1"><div class="li"> binary serialization</div>
</li>
<li class="level1"><div class="li"> optimized data representations for compilers that generate JavaScript</div>
</li>
<li class="level1"><div class="li"> communicating structured data (such as arrays of records) to WebGL</div>
</li>
</ul>

</div>
<!-- SECTION [233-791] -->
<a name="examples"></a><h2>Examples</h2>
<div class="level2">
<pre class="code javascript"><span class="kw2">const</span> Point2D = <span class="kw2">new</span> StructType<span class="br0">&#40;</span><span class="br0">&#123;</span> x: uint32, y: uint32 <span class="br0">&#125;</span><span class="br0">&#41;</span>;
<span class="kw2">const</span> Color = <span class="kw2">new</span> StructType<span class="br0">&#40;</span><span class="br0">&#123;</span> r: uint8, g: uint8, b: uint8 <span class="br0">&#125;</span><span class="br0">&#41;</span>;
<span class="kw2">const</span> Pixel = <span class="kw2">new</span> StructType<span class="br0">&#40;</span><span class="br0">&#123;</span> point: Point2D, color: Color <span class="br0">&#125;</span><span class="br0">&#41;</span>;
&nbsp;
<span class="kw2">const</span> Triangle = Pixel.<span class="me1">Array</span><span class="br0">&#40;</span><span class="nu0">3</span><span class="br0">&#41;</span>;
&nbsp;
let t = Triangle<span class="br0">&#40;</span><span class="br0">&#91;</span><span class="br0">&#123;</span> point: <span class="br0">&#123;</span> x:  <span class="nu0">0</span>, y: <span class="nu0">0</span> <span class="br0">&#125;</span>, color: <span class="br0">&#123;</span> r: <span class="nu0">255</span>, g: <span class="nu0">255</span>, b: <span class="nu0">255</span> <span class="br0">&#125;</span> <span class="br0">&#125;</span>,
                  <span class="br0">&#123;</span> point: <span class="br0">&#123;</span> x:  <span class="nu0">5</span>, y: <span class="nu0">5</span> <span class="br0">&#125;</span>, color: <span class="br0">&#123;</span> r: <span class="nu0">128</span>, g: <span class="nu0">0</span>,   b: <span class="nu0">0</span>   <span class="br0">&#125;</span> <span class="br0">&#125;</span>,
                  <span class="br0">&#123;</span> point: <span class="br0">&#123;</span> x: <span class="nu0">10</span>, y: <span class="nu0">0</span> <span class="br0">&#125;</span>, color: <span class="br0">&#123;</span> r: <span class="nu0">0</span>,   g: <span class="nu0">0</span>,   b: <span class="nu0">128</span> <span class="br0">&#125;</span> <span class="br0">&#125;</span><span class="br0">&#93;</span><span class="br0">&#41;</span>;
<span class="co1">// ...</span></pre>
</div>
<!-- SECTION [792-1313] -->
<a name="overview"></a><h1>Overview</h1>
<div class="level1">

<p>
 This section provides a high-level overview of the typed objects library.
</p>

</div>
<!-- SECTION [1314-1415] -->
<a name="typed_objects"></a><h2>Typed Objects</h2>
<div class="level2">

<p>
 A <strong><em>typed object</em></strong> is an object that is permanently associated with a type (see below), which governs all of the object&rsquo;s property accesses. The type dictates the complete set of own-properties of every instance of that type. Specifically, instances are non-extensible and their instance properties are non-configurable.
</p>

<p>
Every &ldquo;slot&rdquo; in a typed object&rsquo;s storage is guarded by coercions, enforcing its corresponding slot type in the type. Accessing a slot gives a sub-object, sharing the storage with the original object. Assigning to a slot is a copy in memory.
</p>
<pre class="code javascript"><span class="kw2">const</span> S1 = <span class="kw2">new</span> StructType<span class="br0">&#40;</span><span class="br0">&#123;</span>x : float32, y : float64<span class="br0">&#125;</span><span class="br0">&#41;</span>;
<span class="kw2">const</span> S = <span class="kw2">new</span> StructType<span class="br0">&#40;</span><span class="br0">&#123;</span>a : int16, s1 : S1<span class="br0">&#125;</span><span class="br0">&#41;</span>;
&nbsp;
let s1 = S1<span class="br0">&#40;</span><span class="br0">&#123;</span> x : <span class="nu0">1</span>.<span class="nu0">5</span>, y : <span class="nu0">2</span>.<span class="nu0">3</span><span class="br0">&#125;</span><span class="br0">&#41;</span>;
let s = S<span class="br0">&#40;</span><span class="br0">&#123;</span>a : <span class="nu0">10</span>, s1 : s1<span class="br0">&#125;</span><span class="br0">&#41;</span>
&nbsp;
s1.<span class="me1">x</span> = <span class="nu0">2</span>.<span class="nu0">5</span>; <span class="co1">// s.s1.x does not change</span>
s.<span class="me1">s1</span> = s1; <span class="co1">// copy; s.s1.x is 2.5</span>
s1.<span class="me1">x</span> = <span class="nu0">3</span>.<span class="nu0">0</span>; <span class="co1">// s.s1.x does not change</span>
s11 = s.<span class="me1">s1</span>; <span class="co1">// s11 is a sub-object of s, sharing the it's storage.</span>
s11.<span class="me1">x</span> = <span class="nu0">3</span>.<span class="nu0">5</span>; <span class="co1">// s.s1.x is now 3.5</span>
&nbsp;</pre>
<p>
 Conceptually, a typed object is a &ldquo;fat pointer&rdquo; -  a pointer into a backing storage, augmented with its type and other parameters. Typed object is fully characterized by the following tuple:
</p>
<pre class="code"> (arrayBuffer, offset, type, opacity)</pre>

<p>
 Equality on typed objects is defined as equality on &ldquo;fat pointers&rdquo; - two structs are equal if the point at the same storage and have the same types.  (this is equivalent to component-wise equality on tuples representing the pointers). 
</p>

<p>
For the above example,
</p>
<pre class="code"> !(s1 === s.s1)
 s11 === s.s1</pre>

<p>
 Engines can then optimize the representation of the typed objects quite heavily, including potentially a zero-allocation implementation for local variables and parameters to functions.  
</p>

</div>
<!-- SECTION [1416-3133] -->
<a name="types"></a><h2>Types</h2>
<div class="level2">

<p>
 A <strong><em>type</em></strong> is a spec-internal construct that represents a kind of template or schematic for a class of data: how to allocate instances of that class, and what coercion to apply when updating a slot of that type.
</p>

<p>
A <strong><em>type object</em></strong> is an ECMAScript object that represents a particular type.
</p>

</div>
<!-- SECTION [3134-3451] -->
<a name="built-in_value_types"></a><h3>Built-in Value Types</h3>
<div class="level3">

<p>
 The typed objects library includes a number of <strong><em>value types</em></strong>, which represent immutable data. Type objects that represent value types can be called to perform their coercions, but they cannot be invoked with <code>new</code>.
</p>

<p>
The numeric value types are: 
</p>
<ul>
<li class="level1"><div class="li"> <code>uint8</code>, <code>uint8Clamped</code> : 8-bit unsigned integers</div>
</li>
<li class="level1"><div class="li"> <code>uint16</code> : 16-bit unsigned integers</div>
</li>
<li class="level1"><div class="li"> <code>uint32</code> : 32-bit unsigned integers</div>
</li>
<li class="level1"><div class="li"> <code>int8</code> : 8-bit signed integers</div>
</li>
<li class="level1"><div class="li"> <code>int16</code> : 16-bit signed integers</div>
</li>
<li class="level1"><div class="li"> <code>int32</code> : 32-bit signed integers</div>
</li>
<li class="level1"><div class="li"> <code>float32</code> : 32-bit IEEE754 floating-point numbers</div>
</li>
<li class="level1"><div class="li"> <code>float64</code> : 64-bit IEEE754 floating-point numbers</div>
</li>
</ul>

<p>
 Each numeric value type&rsquo;s coercion is the standard coercion, except for <code>uint8Clamped</code>, which performs a saturating coercion.
</p>

<p>
The other value types are: 
</p>
<ul>
<li class="level1"><div class="li"> <code>boolean</code> : ECMAScript primitive boolean</div>
</li>
<li class="level1"><div class="li"> <code>string</code> : ECMAScript primitive string</div>
</li>
</ul>

<p>
 The coercions associated with these types are the standard ECMAScript algorithms [[ToBoolean]] and [[ToString]], respectively.
</p>

</div>
<!-- SECTION [3452-4501] -->
<a name="built-in_reference_types"></a><h3>Built-in Reference Types</h3>
<div class="level3">

<p>
 The built-in <strong><em>reference type</em></strong> (i.e., non-value type): 
</p>
<ul>
<li class="level1"><div class="li"> <code>Object</code> : ECMAScript object reference</div>
</li>
</ul>

<p>
 can contain a reference to any ECMAScript object or <code>null</code>. The coercion associated with the <code>Object</code> type descriptor is the standard ECMAScript [[ToObject]] algorithm.
</p>

<p>
The built-in reference type: 
</p>
<ul>
<li class="level1"><div class="li"> <code>Any</code> : any ECMAScript value</div>
</li>
</ul>

<p>
 can contain a reference to any ECMAScript value. The <code>Any</code> type descriptor does not perform any coercion.
</p>

</div>
<!-- SECTION [4502-5003] -->
<a name="struct_types"></a><h3>Struct Types</h3>
<div class="level3">

<p>
 The <code>StructType</code> constructor defines new struct (i.e., record) type descriptors.
</p>
<pre class="code javascript">T = <span class="kw2">new</span> StructType<span class="br0">&#40;</span><span class="br0">&#123;</span> field1: T1, ..., fieldn: Tn <span class="br0">&#125;</span><span class="br0">&#41;</span></pre>
<p>
The <code>StructType</code> constructor takes an object that describes the struct layout. The object is enumerated for its own properties (similar to <code>Object.defineProperty</code> et al). If any of the own properties has an indexed name an exception is thrown (this avoids incompatibilities in the enumeration order between engines).
</p>

<p>
A struct type T can be used as a function to create a typed struct object:
</p>
<pre class="code javascript">x = T<span class="br0">&#40;</span><span class="br0">&#123;</span> field1: x1, ..., fieldn: xn <span class="br0">&#125;</span><span class="br0">&#41;</span>;</pre>
<p>
The initializer argument can be left out:
</p>
<pre class="code javascript">x = T<span class="br0">&#40;</span><span class="br0">&#41;</span>;</pre>
<p>
In this case the [[Initialize]] method for each field type is used to initialize the fields.
</p>

<p>
A struct type can also be used to create a typed object over an existing storage:
</p>
<pre class="code javascript">x = T<span class="br0">&#40;</span>arrayBuffer, offset<span class="br0">&#41;</span>;</pre>
<p>
Typed objects of the same type created over the same array buffer at the same offsets are identical:
</p>
<pre class="code javascript">x = T<span class="br0">&#40;</span>arrayBuffer, offset<span class="br0">&#41;</span>;
y = T<span class="br0">&#40;</span>arrayBuffer, offset<span class="br0">&#41;</span>;
x === y <span class="co1">// true</span></pre>
<p>
Prototypes of typed objects are derived from their types, i.e.: 
</p>
<pre class="code">x.__proto__ === T.prototype</pre>

</div>
<!-- SECTION [5004-6273] -->
<a name="array_types"></a><h3>Array Types</h3>
<div class="level3">

<p>
 For every type T, a type representing arrays of a fixed size of type T can be created:
</p>
<pre class="code javascript">TArray = T.<span class="me1">Array</span><span class="br0">&#40;</span>n<span class="br0">&#41;</span>;</pre>
<p>
An array type T can be instantiated to construct a typed array:
</p>
<pre class="code javascript">x = TArray<span class="br0">&#40;</span><span class="br0">&#91;</span><span class="nu0">1</span>, <span class="nu0">1</span>, <span class="nu0">3</span>, <span class="nu0">5</span>, <span class="nu0">8</span>, <span class="nu0">13</span>, <span class="nu0">21</span>, <span class="nu0">34</span><span class="br0">&#93;</span><span class="br0">&#41;</span>;</pre>
<p>
The initializer must have the length less than the length of an array. The initializer can be left out:
</p>
<pre class="code javascript">x = TArray<span class="br0">&#40;</span><span class="br0">&#41;</span>;</pre>
<p>
[[Initialize]] method for the array&rsquo;s element type is used to initialize the array elements not specified by the initializer.
</p>

<p>
Function T.array(n) is a shortcut for T.Array(n)(), so the following
</p>
<pre class="code javascript">x = T.<span class="me1">array</span><span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span></pre>
<p>
creates an array of 10 Ts. T.array is also overloaded to work from array-like initializer, so that:
</p>
<pre class="code javascript">x = Point.<span class="me1">array</span><span class="br0">&#40;</span><span class="br0">&#91;</span><span class="br0">&#123;</span>x : <span class="nu0">0</span>, y : <span class="nu0">0</span><span class="br0">&#125;</span>, <span class="br0">&#123;</span>x : <span class="nu0">1</span>, y : <span class="nu0">1</span><span class="br0">&#125;</span><span class="br0">&#93;</span><span class="br0">&#41;</span>;</pre>
<p>
creates a pair of Points (a 2-element array of Points). Its type is Point.Array(2).
</p>

<p>
All arrays of the same element type share the same prototype, accessible by T.Array.prototype.
</p>

<p>
Multidimensional arrays can be constructed by applying dim to array types:
</p>
<pre class="code javascript"><span class="kw2">const</span> TT = T.<span class="me1">Array</span><span class="br0">&#40;</span><span class="nu0">2</span><span class="br0">&#41;</span>.<span class="me1">Array</span><span class="br0">&#40;</span><span class="nu0">2</span><span class="br0">&#41;</span>;
<span class="kw2">var</span> tt = TT<span class="br0">&#40;</span><span class="br0">&#91;</span><span class="br0">&#91;</span><span class="nu0">1</span>,<span class="nu0">2</span><span class="br0">&#93;</span>,<span class="br0">&#91;</span><span class="nu0">3</span>,<span class="nu0">4</span><span class="br0">&#93;</span><span class="br0">&#93;</span><span class="br0">&#41;</span></pre>
<p>
The prototype relationship still applies, so that
</p>
<pre class="code"> tt.__proto__ === T.Array.Array.prototype</pre>

</div>
<!-- SECTION [6274-7577] -->
<a name="typesdetails"></a><h1>Types: Details</h1>
<div class="level1">

<p>
 This section describes the concepts of the types <acronym title="Application Programming Interface">API</acronym> in more detail.
</p>

</div>
<!-- SECTION [7578-7682] -->
<a name="opacity"></a><h2>Opacity</h2>
<div class="level2">

<p>
 For most typed objects, their backing storage can be accessed through the <acronym title="Application Programming Interface">API</acronym> below, e.g.:
</p>
<pre class="code javascript">let p = Point<span class="br0">&#40;</span><span class="br0">&#123;</span>x : <span class="nu0">0</span>, y : <span class="nu0">0</span><span class="br0">&#125;</span><span class="br0">&#41;</span>;
let arrayBuffer = storage<span class="br0">&#40;</span>p<span class="br0">&#41;</span>.<span class="me1">buffer</span>;</pre>
<p>
arrayBuffer gives direct access to the &ldquo;bytes&rdquo; underlying p. Occasionally this is undesired, e.g. when passing a typed object as an output argument to a function. To prevent access to underlying storage, an opaque instance of typed object can be created:
</p>
<pre class="code javascript">let p = Point<span class="br0">&#40;</span>arrayBuffer, <span class="nu0">64</span><span class="br0">&#41;</span>; <span class="co1">// p references existing array buffer</span>
let result = opaque<span class="br0">&#40;</span>p<span class="br0">&#41;</span>;
result.<span class="me1">x</span> = <span class="nu0">1</span>; <span class="co1">// modifies p.x</span>
storage<span class="br0">&#40;</span>result<span class="br0">&#41;</span>; <span class="co1">// returns null</span>
computeResult<span class="br0">&#40;</span>result<span class="br0">&#41;</span>; <span class="co1">// can modify result.x and result.y but cannot access arrayBuffer</span></pre>
<p>
There are three built-in types that are considered <strong><em>opaque</em></strong>: <code>Object</code>, <code>string</code>, and <code>Any</code>. For security, they are not allowed to expose their internal storage since they may contain pointers (see below). A struct or array type is opaque if it contains opaque fields or elements, respectively.
</p>

<p>
All typed objects of opaque types are opaque. Also, all sub-objects of opaque objects are opaque:
</p>
<pre class="code javascript"><span class="kw2">const</span> O = <span class="kw2">new</span> StructType<span class="br0">&#40;</span><span class="br0">&#123;</span> o : object, p : Point <span class="br0">&#125;</span><span class="br0">&#41;</span>;
f = <span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> console.<span class="me1">log</span><span class="br0">&#40;</span><span class="st0">"!!!"</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span>
o = O<span class="br0">&#40;</span><span class="br0">&#123;</span> o : f, p : <span class="br0">&#123;</span> x : <span class="nu0">1</span>, y : <span class="nu0">2</span> <span class="br0">&#125;</span><span class="br0">&#125;</span><span class="br0">&#41;</span>;
<span class="co1">// o is opaque</span>
opaque<span class="br0">&#40;</span>o<span class="br0">&#41;</span> === o; <span class="co1">// O.opaque is identity.</span>
<span class="co1">// Even though Point is not an opaque type, o.p is opaque.</span></pre>
<p>
For every non-opaque types, an opaque version can be obtained: 
</p>
<pre class="code javascript"><span class="kw2">const</span> OPoint = Point.<span class="me1">Opaque</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
<span class="kw2">var</span> op = OPoint<span class="br0">&#40;</span><span class="br0">&#123;</span> ... <span class="br0">&#125;</span><span class="br0">&#41;</span>;
storage<span class="br0">&#40;</span>op<span class="br0">&#41;</span> === undefined;
<span class="kw2">const</span> OO = O.<span class="me1">Opaque</span><span class="br0">&#40;</span><span class="br0">&#41;</span>; <span class="co1">// OO === O</span></pre>
</div>
<!-- SECTION [7683-9309] -->
<a name="type_equivalence"></a><h2>Type Equivalence</h2>
<div class="level2">

<p>
 Types have an inherent concept of equivalence, i.e., when two types T1 and T2 can be considered to be the same. In particular, any operation expecting a value of type T1 accepts values of type T2 and vice versa. Type equivalence comes into play in the <code>T.storage</code> and <code>Handle.move</code> methods (see below).
</p>

<p>
Types are considered equivalent if their structure is equivalent, in the following sense: 
</p>
<ul>
<li class="level1"><div class="li"> If they are structs, their field names and orders match and their field types are (inductively) equivalent.</div>
</li>
<li class="level1"><div class="li"> If they are arrays of fixed length, their length is the same and their element type is (inductively) equivalent.</div>
</li>
<li class="level1"><div class="li"> If they are built-in types, they must be the same built-in type.</div>
</li>
</ul>

<p>
 Note that this makes it possible to construct two user-defined types that have two separate type objects (which are distinguishable via <code>===</code>) but that are nevertheless equivalent. This <em>structural typing</em> allows for multiple libraries to interoperate without sharing common type definitions.
</p>

</div>
<!-- SECTION [9310-10335] -->
<a name="typed_objectsdetails"></a><h1>Typed Objects: Details</h1>
<div class="level1">

<p>
 This section describes the concepts of the typed objects <acronym title="Application Programming Interface">API</acronym> in more detail.
</p>

</div>
<!-- SECTION [10336-10452] -->
<a name="exposing_storage"></a><h2>Exposing Storage</h2>
<div class="level2">

<p>
 Instances of transparent types can expose their underlying storage as binary data. Transparent array types have the following properties: 
</p>
<ul>
<li class="level1"><div class="li"> <code>.buffer</code> : <code>ArrayBuffer</code> or <code>null</code> : the buffer containing the backing storage for the array</div>
</li>
<li class="level1"><div class="li"> <code>.byteOffset</code> : <code>integer</code> or <code>undefined</code> : the byte offset in the buffer at which the array data begins</div>
</li>
<li class="level1"><div class="li"> <code>.byteLength</code> : <code>integer</code> or <code>undefined</code> : the number of bytes of the buffer consumed by the array</div>
</li>
</ul>

<p>
 The following operations on typed objects expose storage: 
</p>
<ul>
<li class="level1"><div class="li"> <code>buffer(object)</code> : <code>ArrayBuffer</code> or <code>null</code> : the buffer containing the backing storage for the array</div>
</li>
<li class="level1"><div class="li"> <code>byteOffset(object)</code> : <code>integer</code> or <code>undefined</code> : the byte offset in the buffer at which the array data begins</div>
</li>
<li class="level1"><div class="li"> <code>byteLength(object)</code> : <code>integer</code> or <code>undefined</code> : the number of bytes of the buffer consumed by the array</div>
</li>
<li class="level1"><div class="li"> <code>storage(object)</code> : takes an instance of the struct type and produces an object containing the above three properties.</div>
</li>
</ul>

<p>
 An example of extracting the storage of a transparent struct:
</p>
<pre class="code javascript"><span class="kw2">const</span> Point = <span class="kw2">new</span> StructType<span class="br0">&#40;</span><span class="br0">&#123;</span> x: uint32, y: uint32 <span class="br0">&#125;</span><span class="br0">&#41;</span>;
let p = Point<span class="br0">&#40;</span><span class="br0">&#123;</span> x: <span class="nu0">0</span>, y: <span class="nu0">0</span> <span class="br0">&#125;</span><span class="br0">&#41;</span>;
let <span class="br0">&#123;</span> buffer, byteOffset, byteLength <span class="br0">&#125;</span> = storage<span class="br0">&#40;</span>p<span class="br0">&#41;</span>;</pre>
<p>
An example of an opaque struct type:
</p>
<pre class="code javascript">let t = Thing<span class="br0">&#40;</span><span class="br0">&#123;</span> foo: obj1, bar: obj2 <span class="br0">&#125;</span><span class="br0">&#41;</span>;
storage<span class="br0">&#40;</span>Thing<span class="br0">&#41;</span> === undefined <span class="co1">// true</span></pre>
</div>
<!-- SECTION [10453-11856] -->
<a name="struct_layout"></a><h2>Struct Layout</h2>
<div class="level2">

<p>
 The layout of transparent struct types is observable by exposing their storage. For portability, the layout is fully specified.
</p>

<p>
The layout of a struct type follows the enumeration order of the struct layout descriptor that was used to create the type.
</p>

<p>
Each field is padded to reside at a byte offset that is a multiple of the field type&rsquo;s byte alignment (specified below via the [[ByteAlignment]] internal property). The struct type&rsquo;s byte length is padded to be a multiple of the largest byte alignment of any of its fields.
</p>

</div>
<!-- SECTION [11857-12420] -->
<a name="introspection"></a><h2>Introspection</h2>
<div class="level2">

<p>
 Typed objects can be queried for their type object:
</p>
<pre class="code javascript">let p = <span class="kw2">new</span> Point<span class="br0">&#40;</span><span class="br0">&#41;</span>;
objectType<span class="br0">&#40;</span>p<span class="br0">&#41;</span> === Point <span class="co1">// true</span></pre>
<p>
Non-typed objects simply produce the type <code>Object</code>:
</p>
<pre class="code javascript">let o = <span class="br0">&#123;</span> x: <span class="nu0">0</span>, y: <span class="nu0">0</span> <span class="br0">&#125;</span>;
objectType<span class="br0">&#40;</span>o<span class="br0">&#41;</span> === Object <span class="co1">// true</span></pre>
</div>
<!-- SECTION [12421-12720] -->
<a name="api"></a><h1>API</h1>
<div class="level1">

</div>
<!-- SECTION [12721-12739] -->
<a name="types"></a><h2>Types</h2>
<div class="level2">

<p>
 Type objects are functions with the following additional properties: 
</p>
<ul>
<li class="level1"><div class="li"> <code>opaque</code> : <code>boolean</code></div>
</li>
</ul>

<p>
 Indicates whether the type is opaque. 
</p>
<ul>
<li class="level1"><div class="li"> <code>byteLength</code> : <code>integer</code> | <code>undefined</code></div>
</li>
</ul>

<p>
 Transparent, fixed-size types have a <code>byteLength</code> that indicates the <code>byteLength</code> of their instances. For opaque or variable-size types, this property is <code>undefined</code>. The <code>byteLength</code> of the built-in <code>boolean</code> type is 1. 
</p>
<ul>
<li class="level1"><div class="li"> <code>byteAlignment</code> : <code>integer</code> | <code>undefined</code></div>
</li>
</ul>

<p>
 Transparent, fixed-size types have a <code>byteAlignment</code> that reflects the [[ByteAlignment]] internal property. For opaque or variable-size types, this property is <code>undefined</code>. 
</p>
<ul>
<li class="level1"><div class="li"> <code>.storage(x)</code> : <code>{ buffer: ArrayBuffer, byteOffset: integer, byteLength: integer }</code></div>
</li>
</ul>

<p>
 Produces an object exposing the backing storage of the typed object (see above). 
</p>
<ul>
<li class="level1"><div class="li"> <code>.equivalent(T)</code> : <code>boolean</code></div>
</li>
</ul>

<p>
 Determines whether the two types are equivalent, using the algorithm described above. 
</p>
<ul>
<li class="level1"><div class="li"> [[Initialize]](obj, propName)</div>
</li>
</ul>

<p>
 This internal method is used for constructing default opaque objects. The method takes a base object and a property name and initializes that property of the base object with default values for the type. For number types these are zero values; for <code>Object</code> the zero value is <code>null</code>, for <code>Any</code> the zero value is <code>undefined</code>; for <code>boolean</code> the zero value is <code>false</code>; for <code>string</code> the zero value is <code>&ldquo;&ldquo;</code>; for structs and arrays these recursively initialize all fields or elements, respectively. 
</p>
<ul>
<li class="level1"><div class="li"> [[ByteAlignment]]</div>
</li>
</ul>

<p>
 This internal property indicates the alignment requirements for struct padding; it is only defined for transparent, fixed-size types. For number types, the value is the type&rsquo;s byte length. For <code>boolean</code>, the value is 1. For fixed-size arrays, the value is the [[ByteAlignment]] of the element type multiplied by the length. For structs, the value is the largest [[ByteAlignment]] of the fields.
</p>

</div>
<!-- SECTION [12740-14715] -->
<a name="struct_types"></a><h3>Struct Types</h3>
<div class="level3">

<p>
 In addition to the properties described above of all type objects, struct type objects have the following properties: 
</p>
<ul>
<li class="level1"><div class="li"> <code>fieldOffsets</code> : <code>{ string: integer, ... }</code></div>
</li>
</ul>

<p>
 A map indicating the byte offsets of each field in the struct type. 
</p>
<ul>
<li class="level1"><div class="li"> <code>fieldTypes</code> : <code>{ string: Type, ... }</code></div>
</li>
</ul>

<p>
 A map indicating the types of each field in the struct type.
</p>

</div>
<!-- SECTION [14716-15090] -->
<a name="array_types"></a><h3>Array Types</h3>
<div class="level3">

<p>
 In addition to the properties described above of all type objects, array type objects have the following properties: 
</p>
<ul>
<li class="level1"><div class="li"> <code>elementType</code> : Type</div>
</li>
</ul>

<p>
 The type of the array elements. 
</p>
<ul>
<li class="level1"><div class="li"> <code>length</code> : <code>integer</code> or <code>undefined</code></div>
</li>
</ul>

<p>
 Length of an array type.
</p>

</div>
<!-- SECTION [15091-15365] -->
<a name="typed_objects"></a><h2>Typed Objects</h2>
<div class="level2">

<p>
 All typed objects have an internal property: 
</p>
<ul>
<li class="level1"><div class="li"> [[Type]]</div>
</li>
</ul>

<p>
 that indicates the type of the object.
</p>

</div>
<!-- SECTION [15366-15500] -->
<a name="structs"></a><h3>Structs</h3>
<div class="level3">

<p>
 A struct object contains only the own-properties specified by the struct type. These are reflected as data properties that are non-configurable, writable, and enumerable.
</p>

</div>
<!-- SECTION [15501-15692] -->
<a name="arrays"></a><h3>Arrays</h3>
<div class="level3">

<p>
 A typed array contains only the own-properties <code>length</code> and <code>0</code> through <code>length</code> - 1. The <code>length</code> data property is non-configurable, non-writable, and enumerable. The indexed data properties are non-configurable, writable, and enumerable.
</p>

<p>
Typed arrays have the following methods: 
</p>
<ul>
<li class="level1"><div class="li"> <code>.get(index)</code></div>
</li>
<li class="level1"><div class="li"> <code>.set(index, value)</code></div>
</li>
<li class="level1"><div class="li"> <code>.set(array[, startOffset[, endOffset]])</code></div>
</li>
<li class="level1"><div class="li"> <code>.subarray(begin, end)</code></div>
</li>
</ul>

</div>
<!-- SECTION [15693-16127] -->
<a name="rationale"></a><h1>Rationale</h1>
<div class="level1">
<ul>
<li class="level1"><div class="li"> Why not address I/O use cases?</div>
</li>
</ul>

<p>
 The <code>DataView</code> abstraction (specified by Khronos, will be folded into ECMAScript) provides the low-level primitives needed for this, and user-land abstractions can be built on top. This is already being done, e.g. with libraries like <a href="https://github.com/jDataView/jDataView/" class="urlextern" target="_blank" title="https://github.com/jDataView/jDataView/" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">jDataView</a> or <a href="https://github.com/dherman/datascript.js" class="urlextern" target="_blank" title="https://github.com/dherman/datascript.js" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">datascript.js</a> (latter is a personal pet project of dherman&rsquo;s, not yet working).
</p>

<p>
In particular, binary formats often need expressive and dynamic data dependencies that are decidedly out of scope for this <acronym title="Application Programming Interface">API</acronym>, such as being able to specify an array whose length is determined by a preceding integer, or a file entry whose starting offset is determined by a preceding integer. 
</p>
<ul>
<li class="level1"><div class="li"> Why not allow endianness/layout to be customizable?</div>
</li>
</ul>

<p>
 Other than in the I/O case, endianness only matters for WebGL, and since this <acronym title="Application Programming Interface">API</acronym> compatibly extends Khronos typed arrays, the solution is the same. For layout, WebGL can use the type introspection <acronym title="Application Programming Interface">API</acronym>&lsquo;s to determine offsets. The other common need for controlling layout is for avoiding wasteful padding; this can be done by hand by reordering struct fields from largest to smallest. 
</p>
<ul>
<li class="level1"><div class="li"> Why depend on enumeration order for the struct layout descriptor?</div>
</li>
</ul>

<p>
 The <acronym title="Application Programming Interface">API</acronym> only uses named own-properties, whose enumeration order is portable across engines and being specified in ES6 for portability. The common case will be to use an object literal, whose syntax is highly readable for this <acronym title="Application Programming Interface">API</acronym>.
</p>

</div>
<!-- SECTION [16128-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/3/3b404c74accb9d6d363d5cf2eca100aa.xhtml used -->
</body>
</html>
