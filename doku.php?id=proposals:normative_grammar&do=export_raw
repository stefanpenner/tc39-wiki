


====== Normative Grammar ======

===== ES4 Grammar =====

[[http://www.ecmascript.org/es4/spec/grammar.pdf|PDF download]]
[[http://www.ecmascript.org/es4/spec/grammar.xls|XLS download]]

===== Revision History =====

[Note: production numbers in parens indicate locations relative to the previous draft]

  * **[[http://www.ecmascript.org/es4/spec/grammar.pdf|30-May-2008]]**: Make TypeParametersList left recursive (404); Change omega parameter in DoWhileSatement from abbrev to full (303); Rename AnnotatableDirective to AttributedDirective (343-361); Change parameter to Semicolon after DoWhileStatement to abbrev (256); Remove '>==' from Punctuator (lexical 3); Remove getter and setter declarations from interface definitions (359, 378-380, 385, 392) 
  * **[[http://www.ecmascript.org/es4/spec/grammar-2008-05-16.pdf|16-May-2008]]**: Fix various entries in the edition column (38, 354, 355, 363, 387, 389, 415, 420, 422, 436); Allow parameter-less constructor definitions (427-428, 429-431)
  * **[[http://www.ecmascript.org/es4/spec/grammar-2008-05-10.pdf|10-May-2008]]**: Add alpha to OptionalExpression (79-82, 83-84, 307); Replace inadvertently erased definition of LetBindingList; Replace ParenExpression with LetBindingList in ComprehensionExpression (45); Remove hack to handle >> and >>> in .< expressions (86, 87); Move lookahead restriction on __proto__ from NameExpression to ReservedIdentifier in FieldName (27, 30); Change allowColon to allowIn in TypedPattern and LikenedPattern (202-205); Add explicit syntax for native functions to FunctionDefinition (386-389, 392-395); Remove TypeParameter from GetterSignature and SetterSignature (400, 401); Change FunctionSignature to GetterSignature and SetterSignature in FunctionDefinition (388, 389, 394, 395); Insert comma in ConstructorInitialiser (433); Restrict use of 'use standard' to global code (470); Add use of EmptyStatement to Statement (255-270); Remove use of EmptyStatement from Substatement and Directive (272, 339, 344); Move unary 'type' expression to UnaryExpression and earse definition and uses of UnaryTypeExpression (104-113, 150, 155, 160); Remove tau parameter from Statement (255-270, 272, 341, 345)
  * **[[http://www.ecmascript.org/es4/spec/grammar-2008-05-05.pdf|05-May-2008]]**: Remove paren expression qualifier from PrimaryName (7); Rename NamespaceName to NamespaceExpression (6, 8, 9, 366, 370, 376, 466, 471, 474, 475); Remove Brackets (); Rename BracketsOrSlice to Brackets (); Rename PrimaryName to NameExpression (); Replace TypeName with TypeExpression in initialiser annotations (17, 35); Remove structual type annotation on array and object initialisers (18, 36); Add InitialiserAttribute to getter and setter syntax in object initialisers (24, 25); Inline ArrayElement (40, 43, 46); Replace use of NonemptyLetBindingList with VariableBindingList (72); Erase definition of NonemptyLetBindingList (73, 74); Refactor FunctionTypeSignature and FunctionSignature to allow rest after this parameter (230-233, 400-402, 411-415); Replace occurances of Block with { Directives } (292, 294, 312, 330, 331, 332, 335, 455, 460); Remove definition of Block (478); Erase errant ':' (404); Remove unused ResultTypeBoolean (434-435); Add SuperStatement and Directive for constructor contexts; Allow Pragma wherever Directive is allowed (339, 341-346); Consolidate Attribute non-terminals (347, 357, 362, 366-376)
  * **[[http://www.ecmascript.org/es4/spec/grammar-2008-04-29.pdf|29-Apr-2008]]**: Define NamespaceName; Use NamespaceName from 'use namespace', 'use default namespace', NamespaceInitialisation, qualifier expressions and Attribute (6, 359, 363, 369, 456, 462, 465, 466); Define ClassDeclaration, InterfaceDeclaration and TypeDeclaration and allow them in global code (343-349); Moved 'const', 'dynamic', 'final', 'interface', 'let', 'namespace', 'native', 'override', 'prototoype', 'static', 'use', and 'yield' from ContextuallyReservedIdentifier to ReservedIdentifier (lexical: 1, 2); Rename TypeReference to TypeName and TypeReferenceList to TypeNameList (223, 224, 445, 446); Replace all uses of TypeReference, TypeReferenceList, and PrimaryName that are type names with TypeName (16, 34, 218, 227, 228, 394, 395, 442-446, 450); Rename 'prototype' to '__proto__' in Attribute (367); Move '__proto__' from ContextuallyReservedIdentifier to ReservedIdentifier (lexical: 1, 2); Remove [look ahead...] conditions in Attribute (359, 363); Add LetBlockStatement to Statement (261-275)
  * **[[http://www.ecmascript.org/es4/spec/grammar-2008-04-26.pdf|26-Apr-2008]]**: Remove ambiguous production '. ParenExpression :: QualifiedNameIdentifer' in PropertyOperator (82); Remove stale use of PackageDefinition in AnnotatableDirective (349); Remove ParameterType without trailing '=' from OptionalParameterType (237); Refactored Parameters and ParametersType to allow a rest parameter as the only parameter (340, 407); Remove namespace and type definitions from local blocks (359, 360); Add Directive for class and interface blocks; Add DecimalLiteral to PrimaryExpression (55); Add lookahead condition to disambiguate PrimaryName from explicit identifiers in Attributes (361, 365); Replace FunctionName with Identifier in FunctionDeclaration (384); Add productions for getters and setters in FunctionDeclaration (384); Remove 'import' from ContextuallyReservedIdentifiers (2, lexical); Remove restriction disallowing 'let' in classes (374, 375); Allow ReservedIdentifiers as function identifiers (11, 384-394); Disallow 'use default namespace' in local blocks (336, 459-466); Remove the use of StringLiteral and NumberLiteral in QualifiedNameIdentifier and rename to PropertyIdentifier (5, 6); Move ! in TypeSignature from prefix to postfix position (441)
  * **[[http://www.ecmascript.org/es4/spec/grammar-2008-04-19.pdf|19-Apr-2008]]**: Remove Qualifier non-terminal (3, 4); Remove PrimaryName that begins with Qualifier (4); Remove definition of ReservedNamespace (5-8); Replace uses of NamspaceAttribute with PrimaryName (378, 382, 388, ); Remove definition of NamespaceAttribute (389-396); Add [no line break] to ReturnStatement (342); Move definition of gamma parameters to Patterns section; Add 'meta', 'reflet', 'intrinsic', 'iterator' and __proto__ to ContextuallyReservedIdentifiers (3, 4: lexical); Remove duplicate productions in RelationalExpression by adding an inline condition for beta == allowIn (150-158, 145); Allow Pragma anywhere in DirectivesPrefix (353); Remove definition of Pragmas (484, 485); Remove lingering use of ImportPragma in Pragma (487);
  * **[[http://www.ecmascript.org/es4/spec/grammar-2008-04-18.pdf|18-Apr-2008]]**: Remove TypeParameter from ConstructorSignature (452, 453); Remove Brackets in QualifiedNameIdentifier (13); Change argument to Block in BlockStatement to 'local' (304); Removed lingering uses of 'external' from NamespaceAttributes (388, 394); Remove lingering E4X punctuators </ and /> from (6, lexical); Change let and function expression forms to use CommaExpression instead of AssignmentExpression (22, 76, 423); Add productions for handling ''>>'' and ''>>>'' in TypeApplication (101); Add productions for handling :: in SliceExpression (98); Disallow 'let' in class bodies (398)
  * **17-Apr-2008**: Rename ElementComprehension to ArrayComprehension; Allow empty body of 'let' clause in ArrayComprehension; Add 'standard' as a pragma; Fix obligatory ',' bug in ArrayType; Allow only SimplePattern in RestParameter; Remove PackageDefinition; Remove ImportPragma; Remove 'external' from ReservedIdentifier and ReservedNamespace; Add 'Identifier : TypeExpression' to ParameterType; Replace TypeExpression with Identifier in RestParameterType; Removed 'meta::' productions from ObjectInitialiser; Remove ContextuallyReservedIdentifiers  'package', and 'xml'; (Re)-add ContextuallyReservedIdentifier 'standard'; Replace uses of QualifiedName with PrimaryName; Remove QualifiedName
  * **10-Apr-2008**: Removed reserved E4X syntax; Rename and update object and array initialisers to match latest proposals; Rename SplatExpression to SpreadExpression; Add signatures for getters and setters; Add void and boolean result types; Move 'internal', 'private', 'protected', 'public' from ReservedIdentifier to ContextuallyReservedIdentifier; Rename various "Literal" non-terminal to "Initialiser" with corresponding changes to their constituents; Change argument to CommaExpression in BracketOrSlice from allowColon to noColon; Allow FieldType with ': TypeExpression' elided; Remove getters and setters from local blocks; Change signature of FunctionDeclaration to FunctionSignatureType; Include nested let, if and for-in expressions in ElementComprehension; Allow 'const' attribute on parameters; Require optional parameters to follow obigatory ones; Replace SimplePattern in TypedIdentifier with Identifier; Refactor CaseElements; Add 'const' and 'var' to the lookahead set of ExpressionStatement
  * **09-Apr-2008**: Remove description of triple quoted strings; Rename LikedPattern to LikenedPattern; Allow trailing comma in RecordType and ObjectPattern; Add [no line break] to ThisExpression; Add reference to "line continuations" spec in lexical section; Limit syntax of annotations on object and array literals; Replace PrimaryName... in TypeExpression with TypeReference; Refactor class Block to only allow a static block statements; Added description of source text handling; Allow VariableDefinition in Substatement
  * **03-Apr-2008**: Remove reserved identifiers 'wrap' and 'has'; Replace use of PropertyName with PrimaryName in PropertyOperator; Remove definition of PropertyName; Remove 'enum' from ReservedIdentifiers; Move 'extends' from ReservedIdentifiers to ContextuallyReservedIdentifiers; Add FieldKind to getters and setter in LiteralField; Remove omega from VariableDefinition in AnnotatableDirective (Global...); Add Semicolon the other occurances of VariableDefinition in AnnotatableDirective; Add Semicolon to occurances of TypeDefinition and NamespaceDefinition in AnnotatableDirectives; Remove TypeDefinition from InterfaceDefinition; Fix various arguments in RelationalExpression; Fix argument in AnnotatableDirective (class); Add Semicolon to FunctionDeclaration production in AnnotatableDirective (interface); Add interface argument to NamespaceAttribute in Attribute (interface); Add NamespaceAttribute (interface); Replace 'intrinsic' with 'external' in NamespaceAttribute rules; Remove Attribute (local); Remove definition and use of OverloadedOperator; Rename InitialiserList to SettingList and Initialiser to Setting; Make TypeReferenceList left recursive; Rename PackageAttributes to PackageAttribute
  * **30-Mar-2008**: Rename ListExpression to CommaExpression; Make CommaExpression a binary expression in the AST; Change ParenExpression to ParenListExpression in SuperExpression; Rename ParenListExpression to ParenExpression; Remove Path qualified PropertyNames; Mark reserved/deferred features with 'x'; Remove 'wrap'; Remove 'like' as a type; Add 'like' as a binary type operator; Remove LetStatement; Remove UnitDefinition; Fold NullableTypeExpression into TypeExpression; Remove OverloadedOperator from QualifiedNameIdentifier; Add distinguishing syntax for tuples and array types in ArrayType; Add SplatExpression to arguments and array literals; Add RestPattern to array patterns; Add to ReservedIdentifiers 'type'; Add to ContextuallyReservedIdentifiers 'external'; Removed from ContextuallyReservedIdentifiers 'decimal', 'double', 'generic', 'int', 'Number', 'precision', 'rounding', 'standard', 'to', 'uint', 'unit'; Add LikedPattern to Parameter; Add 'like' predicate to ResultType; Remove ParameterKind and use in Parameter 
  * **20-Mar-2008**: Use noColon parameter before : in ConditionalExpression and NonAssignmentExpression; Swapped [PropertyName, QualifiedName] => [QualifiedName, PropertyName]; Removed . AttributeName from PropertyOperator; Add AttributeName to PrimaryName; Rename Brackets to BracketsOrSlice; Add Brackets, without slice; Change Brackets in PropertyOperator to BracketsOrSlice; Add TypeUnionList etc to allow for | list separators and empty unions; Move LetExpression from ConditionalExpression to PrimaryExpression; Move the UnaryTypeExpression from PostfixExpression to ConditionalExpression and NonAssignmentExpression; Replace TypedExpression with ParenListExpression; Remove TypedExpression; Remove import aliasing; Add ReservedNamespace to PrimaryExpression; Add ".*" syntax to PropertyOperator for E4X compatibility; Remove 'intrinsic' from ReservedNamesapce and ContextuallyReservedIdentifiers; Add TypeApplication syntax to BasicTypeExpression (got dropped by ealier refactoring); Refactored CaseElementsPrefix; Change PrimaryNameList to TypeReferenceList in InterfaceInheritance (typo)
  * **04-Dec-2007**: Add productions for AnnotattableDirective(class,...)
  * **31-Oct-2007**: Add 'wrap' to ReservedIdenifiers; Move 'is' and 'cast' from ContextuallyReservedIdentifiers to ReservedIdentifiers; Add version number for which each production applies
  * **23-Oct-2007**: Add 'wrap' operation to RelationalExpression; Add 'like' type expression; Rename root type expression from NullableType to TypeExpression
  * **17-Oct-2007**: Change 'this callee' to 'this function'; Remove 'callee' from ContextuallyReservedIdentifiers; Add TypeReference and TypeReferenceList; Replace use of PrimaryName and PrimaryNameList in ClassInheritance and InterfaceInheritance with TypeReference and TypeReferenceList; Remove [No newline] contraint in ReturnStatement; Add Semicolon after DoStatement; Minor reordering of productions in PrimaryExpression; Rename ObjectType to RecordType; Initial definition of mapping from concrete to abstract syntax  * **14-Oct-2007**: Remove 'type' TypeExpression from UnaryExpr; Add UnaryTypeExpression; Change uses of TypeExpression to NullableTypeExpression for symmetry with TypeDefinitions; Restore use of 'undefined' in TypeExpression (although ambiguous, provides clarity); update 'use decimal' pragma; Rename DestructuringField* to Field*Pattern and DestructuringElement* to Element*Pattern; Change "Path . Identifier" in NamespaceAttribute to PrimaryName; Remove Identifier from NamespaceAttribute
  * **04-Oct-2007**: Replace Identifier with NonAttributeQualifiedIdentifier in FieldName; Add ReservedNamespace to Qualifier; Change arguments to Pattern in Initialiser to allowIn, allowExpr; Remove Semicolon after DoStatement; Add TypeApplication to PropertyIdentifier; Remove PropertyName; Rename NonAttributeIdentifier to PropertyName; Remove default from TypeCaseElement; Remove duplicate production for XMLElementContent
  * **22-Aug-2007**: Fix several cases of missing rule arguments; Move use of Semicolon out of VariableDefinition
  * **21-Aug-2007**: Remove '*' from QualifiedNameIdentifier; Rename use of AttributeIdentifier to AttributeName in PrimaryExpression; Add SwitchTypeStatement to Statement; Replace ClassName with Identifier TypeSignature in InterfaceDefinition and FunctionDefinition; Replace ParameterisedTypeName with Identifier TypeSignature in TypeDefinition; Fix various other typos found by E. Suen
  * **20-Aug-2007**: Remove LiteralField without value; Add FieldName without pattern to DestructuringField; Move null and undefined from NullableTypeExpression to TypeExpression; Erase ToSignature; Distinguish FunctionExpressionBody from FunctionBody; Move Semicolon into specific definition rules that use them; Add UnitDefinition; Fix use unit pragma; Factor out ClassSignature from ClassName (now just Identifier); Replace use of SimpleQualifiedName with PrimaryName in NamespaceInitialiser; Rename RecordType to ObjectType; Change String to StringLiteral; Number to NumberLiteral in QualifiedNameIdentifier; Remove ambiguous ReservedNamespace in Qualifier; Remove 'undefined' from TypeExpression; Add 'callee' and 'generator' to ContextuallyReservedIdentifiers
  * **23-Jul-2007**: Require Block body in LetStatement; Fixed missed renames of *Identifier to *Name; Allow trailing common in ObjectLiteral; Make 'debugger' a reserved identifier; Add 'this callee' and 'this generator' as a primary expressions; Simplified TypedPattern; Change prefix of type application from TypeExpression to ParenListExpression; Remove 'null' and 'undefined' from TypeExpression; Require semicolon after braceless function body; Various fixes to the beta argument; Add alpha parameter to indicate contexts which allow annotations on object and array literals; Fix missed replacement of PrimaryIdentifier with PrimaryName; Add Unit pragmas; Relax rules that packages must come before any other directive (make PackageDefinition a Directive)
  * **29-May-2007**: Add types 'null' and 'undefined' to TypeExpression; Rename Identifier to Name; add non-terminal QualifiedNameIdentifier to hold various kinds of identifiers; Add TypedExpression and use in head of WithStatement and SwitchTypeStatement; Change name of get and set fields to FieldName; Eliminate distinction between NullableTypeExpression and TypeExpression; 
  * **23-May-2007**: Fix list comprehensions; Remove 'debugger' and 'include' from ContextuallyReservedIdentifier; Change body of yield, let and function expressions from ListExpression to AssignmentExpression; Remove use of the alpha parameter to distinguish allowList from noList uses of yield, let and function expressions; Add optional Qualifier to FieldName
  * **10-Apr-2007**: Fix several typos; Add to SimpleQualifiedIdentifier syntax for calling global intrinsic overloadable operator
  * **06-Apr-2007**: Replace errant reference to TypeIdentifier with PropertyIdentifier; Move from ReservedIdentifiers to ContextuallyReservedIdentifiers: cast const implements import interface internal intrinsic is let package private protected public to use; Remove ReservedIdentifier: as; Add missing allowIn argument to uses of FunctionBody; Remove lexical non-terminal PackageIdentifiers
  * **30-Mar-2007**: Replace TypeIdentifier in PrimaryExpression with PrimaryIdentifier; Inline PropertyIdentifier production; Rename TypeIdentifier to PropertyIdentifier
  * **29-Mar-2007**: Revert previous restriction that 'use default namespace' argument must be a particular reserved namespace; Add tau parameter to BlockStatement and Block to allow top-level blocks with hoisted definitions; Rename ParameterisedClassName to ParameterisedTypeName; Change Identifier in TypeDefinition to ParameterisedTypeName; Replace the lexeme PackageIdentifier with the nonterminal Path, which gets resolved to a PackageName or an object referece by the definer; Move the ListExpression form of function body into FunctionBody; Add PrimaryIdentifier production and move Path qualified references out of TypeIdentifier to PrimaryIdentifier; Change right side of PropertyOperator from QualifiedIdentifier to TypeIdentifier; Add 'has' to the ContextuallyReservedIdentifiers; Update FunctionName to include 'call' and 'has' functions; Remove 'invoke' from ContextuallyReservedIdentifiers
  * **13-Mar-2007**: Add SuperInitialiser to as optional final constituent of ConstructorInitialiser; Erase SuperStatement; Erase ''const function'' from the class context (all methods are const); Restrict use default namespace argument to public, internal and intrinsic; Remove 'in' from ContextuallyReservedIdentifiers; Define 'function to' so that no return type is allowed; Remove 'construct' from ContextuallyReservedIdentifiers; Add 'invoke' to ContextuallyReservedIdentifiers
  * **02-Mar-2007**: Erase gamma parameter from TypedPattern (always noExpr), Add syntax for array comprehension; Rename ElementList to Elements; Rename FieldList to Fields; Rename NonemptyFieldList to FieldList; Add ''const function'' definition syntax; Change PropertyIdentifier to * in function call definitions; Rename call to invoke in non-catchall definitions; Remove 'construct' function; Update PackageIdentifier; Remove '^^' and '^^=' punctuators; Fork FunctionSignatureType from FunctionSignature; Fix bug which allowed ''this : T ,'' in FunctionSignature; Make 'null' and 'undefined' NullableTypeExpressions; Add 'undefined' to ContextuallyReservedIdentifiers
  * **18-Jan-2007**: Add syntactic parameter tau to distinguish between contexts that allow / exclude certain kinds of definitions; Add syntax for constructor definitions, including ConstructorInitialiser; Add syntax to FunctionSignature to constrain type of 'this'; Dinstinguish between nullable/nonnullable and orther type expression; Allow any TypeExpression in TypedPattern
  * **06-Dec-2006**: Add BlockStatement non-terminal, minor refactoring of the Program productions; Rename PackageDefinition as Package; Change NonAttributeQualifiedIdentifier to FieldName in DestructuringField; Change SwitchTypeStatement to take a ListExpression and TypeExpression in its head rather than a binding form; Merge LogicalAssignmentOperator into CompoundAssignmentOperator; Rename Inheritance to ClassInheritance; Rename ExtendsList to InterfaceInheritance; Refactor InterfaceDefinition to have a more specific syntax;
  * **29-Nov-2006**: Update AST nodes for VariableDefinition; Update AST nodes for Pragmas; Change rhs of SimplePattern from PostfixExpression to LeftHandSideExpression; Tighten the syntax of definition attributes that are reference to namespaces; Add AST nodes for SwitchStatement and SwitchTypeStatement 
  * **21-Nov-2006**: Make the 'cast' operator a peer of the infx 'to' operator; Propagate the a parameter to FunctionExpression; Unify TypedIdentifier and TypedPattern, and lhs postfix expressions and Pattern; Remove logical xor operator; Add 'precision' to PragmaIdentifier and ContextuallyReservedIdentifier; Add AST node types for expressions; Refactor slice syntax; Remove empty bracket syntax
  * **14-Nov-2006**: Move 'yield' from Reserved to contextually reserved; Add ReservedIdentifier after '::' in ExpressionQualifiedIdentifier; Refactor RestParameter; Remove abstract function declaration from FunctionCommon; Add accessors to ObjectLiteral; Move TypedIdentifier and TypedPattern to the Expressions section; Remove FieldName : ParenExpression; Remove ExpressionClosure; Add expression closure syntax to FunctionExpression; Propogate the b parameter down to FunctionExpression; Distinguish between RecordType and ArrayType in TypedPattern; Rename noLet and allowLet to noList and allowList, respectively; Add «empty» to DestructuringFieldList; Added links to 'triple quotes' and 'extend regexp' proposals
  * **26-Sep-2006**: Add ReservedIdentifier after '::'; Parameterise productions to restrict the context where LetExpression and YieldExpression can be used; Change the body of LetExpression and YieldExpression from AssignmentExpression to ListExpression
  * **21-Sep-2006**: Rename lexical non-terminals 'String' to 'StringLiteral' and 'Number' to 'NumberLiteral'; Remove infix 'to' and 'cast' expressions; Move 'yield' to 'AssignmentExpression' (again); Replace Arguments with ParenExpression in SuperExpression
  * **15-Sep-2006**: Add rules for tagging an object or array literal with a structural type; Add “decimal”, “double”, “int”, “uint”, “Number”, “rounding”, “strict”, and “standard” to the list of ContextuallyReservedIdentifiers; Fix capitalisation of PackageIdentifier (409); Add definition of lexical Identifier; Remove redundant productions referring to ContextuallyReservedIdentifier; Add "Number" as a PragmaArgument; Refactor YieldExpression to be used by MultiplicativeExpression and use UnaryExpressi
  * **30-Aug-2006**: Remove 'native' from ReservedIdentifier; Add lexical non-terminals for missing literal forms and VirtualSemicolon; Replace productions for Identifier with one that uses lexical symbol ContextuallyReservedIdentifiers; Replace RestParameters with RestParameter (57); Replace Expression with ListExpression (94,99,101,106); Replace NonAssignmentExpression with LogicalOrExpression (219); Remove unused production for DestructuringAssignmentExpression (250); Remove Statement production for SwitchTypeStatement (291); Sort Statement productions; Remove unused productions for Substatements and SubstatementsPrefix; Replace use of VariableInitialiser with AssignmetExpression (441); Replace uses of TypeName with TypeIdentifier (462,463); Rename TypeNameList as TypeIdentifierList
  * **15-Jun-2006**: Add 'yield' expression without subexpression; Remove Semicolon after PragmaItems in UsePragma; Remove parens around PragmaArgument in PragmaItem; Change SimpleQualifiedIdentifier to SimpleTypeIdentifier in PragmaArgument; Add SimpleTypeIdentifier to NamespaceInitialisation
  * **07-Jun-2006**: Remove AttributeCombination from Attributes; Remove true and false from Attributes (they are a carryover from the NS proposal and have never been proposed here); Added comment on the creation of a lexical PackageIdentifier from a syntactic PackageName; Allow 'let' on VariableDefinition and FunctionDefinition; Merge SwitchType into SwitchStatement; Add 'call' to context keywords and syntactic identifier; Replace ListExpression in Arguments with ArgumentList; Reuse VariableBinding for LetBinding; Add ParameterAttributes to Pattern in Parameter; Add TypedParameter to RestParameter; Change Identifier to TypedIdentifier in RestParameter; Add TypedPattern to TypeCaseElement; Rename 'private' to 'internal' in PackageAttributes
  * **01-Jun-2006**: Add '!' to ClassName; Remove 'as'; Replace TypeExpression on the rhs of 'is' and 'to' with ShiftExpression; Rename AttributeQualifiedIdentifier to AttributeIdentifier; Add 'type' operator to UnaryExpression; Change yield construct from YieldStatement to YieldExpression; Add 'yield' to the list of reserved identifiers; Add TypedPattern everywhere that TypedIdentifier is used to defined a variable, except in switch-type; Define the meaning of the lexical symbol PackageIdentifier; Add //PrimaryExpression// ''to'' and //RelationalExpression// ''cast''
  * **23-May-2006**: Add 'super' to reserved words; Refactor TypeIdentifier; Use simpler E3 syntax for PostfixExpression; Rename LPattern and children to Pattern etc.; Move DestructuringAssignmentExpression out of AssignmentExpresion; Move LetExpression to AssignmentExpression; Remove attribute blocks; Remove variable initialiser with multiple attributes on the rhs; Add parens around pragma arguments; Add prama identifiers 'default namespace' and 'default package'; Add PackageAttribute to PackageDefinition; Sort rules for readability
  * **16-May-2006**: Added '.' before '<…>' in type definitions; removed ReservedNamespace from PrimaryExpression since it is already include via QualifiedIdentifier; simplified PostfixExpression; changed qualifier on ExpressionQualifiedIdentifier from ParenExpression to ParentListExpression; Refactored TypeIdentifier; replaced QualifiedIdentifier with TypeIdentifier and added AttributeQualifiedIdentifier in PrimaryExpression; made .< a token rather than two; Redefined TypeParameters to include the .< and > delimiters
  * **15-May-2006**: Moved 'PackageIdentifier . Identifier' from PrimaryExpression to QualifiedIdenfier; Added dot to left angle brace for parameterized type expressions in TypeExpression
  * **12-May-2006**: Initial draft. First attempt to capture the whole grammar of ES4. Current with the latest proposals

===== Discussion and resolved bugs =====

Currently UnaryExpression is an orphan and not referenced anywhere. Seems to have been lost from MultiplicativeExpression when it was changed to be YieldExpression.

 --- //[[mob@mbedthis.com|Michael O'Brien]] 2006/10/19 12:20//

Relative to the 30-Aug-2006 edition:
  * Should "decimal", "double", "int", "uint", "Number", "rounding", "strict", and "standard" be ContextuallyReservedIdentifier?
  * Line 409, "packageidentifier" should probably be "PackageIdentifier"
  * Line 1, terminal (boldface) "Identifier" is not defined in the section Lexical Structure
  * ContextuallyReservedIdentifier appears several places in the grammar but is redundant, because it is part of Identifier which is one of the nonterminals reached from all(?) these locations (unlike ReservedIdentifier)
  * Latest draft of Numbers proposal adds "use Number" as a pragma

 --- //[[lth@opera.com|Lars T Hansen]] 2006/09/13 09:29//

Above issues addressed in the 15 September revision

Relative to 18-Sept-2006 edition: I see we have both:
  * ''cast TypeExpression ParenListExpression'' (line 96) and
  * ''RelationalExpression cast ShiftExpression'' (line 184)
as well as
  * ''to TypeExpression ParenListExpression'' (line 97) and
  * ''RelationalExpression to ShiftExpression'' (line 183)
I didn't realize there were two version of each of these operators: the prefix version takes a static type expression and the infix version takes an ordinary expression, allowing computed types. In particular, if all you need is a cast to a static type, you can use the prefix version, but if you want to use a computed type, you can use the infix version. Is that the idea?

Thinking out loud here: as an alternative, would it be simpler to just have a reflective API for the case of computed types? Then you only need one operator which takes a TypeExpression, and the more general case would be an API such as a ''static'' method of a ''Type'' class, like:

<code javascript>
static native function cast(x:*, t:Type) : *;
</code>

You can't give it a precise result type, but we can't do that with the general cast operator anyway (unless you're giving it a static type). I think this would be a cleaner, simpler design, and would be less likely to confuse programmers (4 different cast operators, all almost the same!).

 --- //[[dherman@ccs.neu.edu|Dave Herman]] 2006/09/18 14:40//

Relative to 26-Sept-2006 edition (minor issues):

  * RegExp literals may contain unescaped slash inside charset, this changes the lexical grammar (discussed at Sept f2f)
  * Triple-quoted strings missing
  * Grammar line 223 has a superscript "a" that should probably be "\alpha"

 --- //[[lth@opera.com|Lars T Hansen]] 2006/09/27 08:38//

//MultiplicativeExpression// produces //YieldExpression// alone or on the right -- should be //UnaryExpression// throughout.

Why is //SimpleYieldExpression// split according to //allowLet//?  The presence or absence of a ''yield'' operand is not context-sensitive.

Did we want to use a LR or LL approach?  I'm thinking of //AssignmentExpression// producing either //ConditionalExpression// or something that starts with //PostfixExpression//, which isn't LL(k) for any k.

 --- //[[brendan@mozilla.org|Brendan Eich]] 2006/09/27 09:43//

Since most of us already have hand-written parsers I'm guessing we'd really like to know whether the grammar can be transformed into LL(k), at least.  My parser theory is rusty and my textbooks are not here, but ISTR that LL(k) contains LALR(k-1).  Whether true or not, I would be satisfied by a classification of the grammar according to some known class along with a theorem that states that that class is contained in LL(k) for some reasonable k.

 --- //[[lth@opera.com|Lars T Hansen]] 2006/09/27 09:55//