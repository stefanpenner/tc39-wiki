<html>
<head>
<title>ECMAScript 4th Edition -- Predefined Types and Objects </title>
<style>
/* -*- indent-tabs-mode: nil -*- */
.fixme { font-size: smaller; padding-left: 1em; color: red }
.note { font-size: smaller; padding-left: 1em }
.part { font-size: 24pt }
.grammar { font-style: italic }
.indented { padding-left: 3em }
.nonterm { padding-top: 1em }
.xref { border: thin solid red; }
.section { margin-bottom: -1em; font-family: sans-serif; font-size: smaller }
.implsection { margin-bottom: -1em; padding-bottom: 0.3em; font-family: sans-serif; font-size: smaller }
.literal { font-style: normal; font-weight: bold }
H1,H2,H3,H4,H5,H6 { font-family: sans-serif }
H1 { font-size: 14pt }
H2 { font-size: 12pt }
H3 { font-size: 11pt }
H4 { font-size: 10pt }

P code { font-size: 10pt }
code { font-style: normal; font-weight: normal }

pre { font-size: 9pt }

body { counter-reset: chapter section subsection subsubsection subsubsubsection;
       font-size: 10pt; 
       margin: 0.75in }

table { font-size: inherit;
        width: 70%;
        margin: 2em; 
        border: 1px solid lightgrey; }

th { background: lightgrey; }

td { padding: 1em; }

.pcounter:before {
    content: counter(para); 
}

.pcounter {
    position: absolute; left: 0.5in;
    counter-increment: para
}

H1:before {
    padding-right: 1em;
    content: counter(chapter) "  ";
    counter-increment: chapter }

H1 {
    counter-reset: section para;
}

H2:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "  ";
    counter-increment: section }

H2 {
    counter-reset: subsection para;
}

H3:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "." counter(subsection) "  ";
    counter-increment: subsection }

H3 {
    counter-reset: subsubsection para;
}

H4:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "." counter(subsection) "." counter(subsubsection) "  ";
    counter-increment: subsubsection }

H4 {
    counter-reset: para;
}

H5:before {
    padding-right: 1em;
    content: counter(chapter) "." counter(section) "." counter(subsection) "." counter(subsubsection) "." counter(subsubsubsection) "  ";
    counter-increment: subsubsubsection }

H5 {
    counter-reset: para;
}

</style>
</head>

<body>
<h1>Introduction</h1>



<P><span class="pcounter"></span> There are certain built-in objects available whenever an
ECMAScript program begins execution.  One, the global object, is in
the scope chain of the executing program.  Others are accessible as
initial properties of the global object.

<P><span class="pcounter"></span> ECMAScript execution environments may provide multiple global
objects, each of which may be accessible from the others.  Whether
each of these global objects has separate intial values for the
initial properties described in this section, or whether the values
are shared, is implementation-defined.

<P><span class="pcounter"></span>Many built-in objects behave like functions: they can be invoked
with arguments.  Some of them furthermore are constructors: they are
classes intended for use with the <code>new</code> operator. For each built-in
class, this specification describes the arguments required by that
class's constructor and properties of the Class object. For each
built-in class, this specification furthermore describes properties of
the prototype object of that class and properties of specific object
instances returned by a <code>new</code> expression that constucts instances of
that class.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; The 3rd Edition of this Standard did not provide classes, and
all built-in objects provided as classes in 4th Edition were
previously provided as functions.  The change from functions to
classes is observable to programs that convert the built-in class
objects to strings.

<P><span class="pcounter"></span>Built-in classes have four kinds of functions, collectively called
methods: constructors, static methods, prototype methods, and
intrinsic instance methods.  Non-class built-in objects may
additionally hold non-method functions.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; The 3rd Edition of this standard provided only
constructors and prototype methods.  The new methods are not visible
to 3rd Edition code being executed by a 4th Edition implementation.

<P><span class="pcounter"></span>Unless otherwise specified in the description of a particular
class, if a constructor, prototype method, or ordinary function described
in this section is given fewer arguments than the function is
specified to require, the function shall behave exactly as if it had
been given sufficient additional arguments, each such argument being
the <code>undefined</code> value.

<P><span class="pcounter"></span>Unless otherwise specified in the description of a particular
class, if a constructor, prototype method, or ordinary function described
in this section is given more arguments than the function is specified
to allow, the behaviour of the function is undefined. In particular,
an implementation is permitted (but not required) to throw a
<code>TypeError</code> exception in this case.

<p class="note"><b>IMPLEMENTATION NOTE</b>&nbsp;&nbsp; Implementations that add additional capabilities to the set
of built-in classes are encouraged to do so by adding new functions
and methods rather than adding new parameters to existing functions
and methods.

<P><span class="pcounter"></span>Every built-in function, and every built-in class object with
a <code>meta::invoke</code> method, has the Function prototype object, which is
the initial value of the expression <code>Function.prototype</code> (<span class="xref">Function.prototype</span>), as the value of its internal
<code>[[Prototype]]</code> property.

<P><span class="pcounter"></span>Every built-in class object that does not have a <code>meta::invoke</code> method
has the Object prototype object, which is the initial
value of the expression <code>Object.prototype</code> (<span class="xref">Object.prototype</span>),
as the value of its internal <code>[[Prototype]]</code> property.



<P><span class="pcounter"></span>Every built-in prototype object has the Object prototype object,
which is the initial value of the expression <code>Object.prototype</code>
(<span class="xref">Object.prototype</span>), as the value of its internal
<code>[[Prototype]]</code> property, except the Object prototype object itself.

<P><span class="pcounter"></span>None of the built-in functions described in this section shall
implement the internal <code>[[Construct]]</code> method unless otherwise specified
in the description of a particular function. None of the built-in
functions described in this section shall initially have a
<code>prototype</code> property unless otherwise specified in the description
of a particular function. Every built-in Function object described in
this section--whether as a constructor, an ordinary function, or a
method--has a <code>length</code> property whose value is an integer. Unless
otherwise specified, this value is equal to the largest number of
named arguments shown in the section headings for the function
description, including optional parameters.

<p class="note"><b>EXAMPLE</b>&nbsp;&nbsp;  The Function object that is the initial
value of the <code>slice</code> property of the String prototype object is
described under the section heading <code>String.prototype.slice(start,end)</code> which shows the two named arguments start and end; therefore
the value of the length property of that Function object is 2.



<P><span class="pcounter"></span>The built-in objects and functions are defined in terms of
ECMAScript packages, namespaces, classes, types, methods, properties,
and functions, with the help from a small number of implementation
hooks.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; Though the behavior and structure of built-in objects and
functions is expressed in ECMAScript terms, implementations are not
required to implement them in ECMAScript, only to preserve the
behavior as it is defined in this Standard.

<P><span class="pcounter"></span>Implementation hooks manifest themselves as functions in the
<code>magic</code> namespace, as in the definition of the intrinsic
<code>toString</code> method on <code>Object</code> objects:

<PRE>
intrinsic function toString() : string
    private::toString();
</PRE>

<P><span class="pcounter"></span>All magic function definitions are collected in section <span class="xref">library-magic</span>.

<P><span class="pcounter"></span>The definitions of the built-in objects and functions also leave
some room for the implementation to choose strategies for certain
auxiliary and primitive operations.  These variation points manifest
themselves as functions in the <code>informative</code> namespace, as in the
definition of the intrinsic global function <code>hashcode</code>:

<PRE>
intrinsic const function hashcode(o): uint {
    switch type (o) {
    &#x0085;
    case (x: String)    { return informative::stringHash(string(x)) }
    case (x: *)         { return informative::objectHash(x) }
    }
}
</PRE>

<P><span class="pcounter"></span>Informative methods and functions are defined non-operationally in
the sections that make use of them.

<P><span class="pcounter"></span>The definitions of the built-in objects and functions also make use
of internal helper functions and properties, written in ECMAScript.
These helper functions and properties are not available to user
programs and are included in this Standard for expository purposes, as
they help to define the semantics of the functions that make use of
them.  Helper functions and properties manifest themselves as
definitions in the <code>helper</code> namespace, as in the definition of the
global <code>encodeURI</code> function:

<PRE>
intrinsic const function encodeURI(uri: string): string
    <em>encode</em>(uri, <em>uriReserved</em> + <em>uriUnescaped</em> + "#")
</PRE>

<P><span class="pcounter"></span>Helper functions and properties are defined where they are first
used, but are sometimes referenced from multiple sections in this
Standard.

<P><span class="pcounter"></span>Unless noted otherwise in the description of a particular class or
function, the behavior of built-in objects is unaffected by
definitions or assignments performed by the user program.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  In effect, the <code>intrinsic</code> namespace is open for all built-in
code, and this namespace takes precedence over the <code>public</code> namespace.

<P><span class="pcounter"></span> In some cases the built-in functions construct new error objects
that are then thrown as exceptions.  For purposes of documentation an
informative string is passed to the constructors of the error objects.
These strings are never to be considered normative.


<h1>Assumptions and notational conveniences</h1>

<P><span class="pcounter"></span> (This section will be removed eventually.)

<P><span class="pcounter"></span> The following assumptions are made throughout the description of
the builtins.  I believe they are correct for the language, but they
need to be specified / cleaned up elsewhere; some of the descriptions
here need to be merged into the foregoing sections.


<h2>Classes</h2>

<P><span class="pcounter"></span> Classes are reified as singleton class objects <code>C</code> which behave
like ECMAScript objects in all respects.  We do <i>not</i> assume here
that these class objects are instances of yet other classes; they can
be assumed just to exist.  Class objects have some set of fixtures
(always including the <code>prototype</code> property) and a <code>[[Prototype]]</code>
chain, at a minimum.

<P><span class="pcounter"></span> The <code>Function</code> prototype object is on the <code>[[Prototype]]</code> chain of
every class object, whether native or user defined.  This was true for
all constuctor functions in ES3; it does not seem reasonable to be
incompatible for native objects in ES4, and it does not seem
reasonable to have a special case for native objects in ES4 (though that
would be possible).

<P><span class="pcounter"></span> <i>Consequence:</i> It will be assumed that the <code>Function</code> prototype
object is on the prototype chain of every callable class object, and this will not
be described explicitly for each object, unlike 3rd Edition.


<h2>Prototype chains</h2>

<P><span class="pcounter"></span> Every class object <code>C</code> has a constant <code>C.prototype</code> fixture
property, with fixed type <code>Object</code>.  Unless specified otherwise,
<code>C.prototype</code> references an object <code>PC</code> that appears to be an
instance of <code>C</code> except for the value of <code>PC.<code>[[Prototype]]</code></code>, which
is normally a reference to <code>B.prototype</code> where <code>B</code> is the base
class of <code>C</code>.  (Thus the prototype hierarchy mirrors the class
hierarchy, and inheritance of prototype properties mirrors the
inheritance of class properties.)

<P><span class="pcounter"></span> <i>Consequence:</i> It will be assumed that every class object has a
<code>prototype</code> property and that that property will reference the
prototype object for that class, which is always described separately.
The fact that there is a <code>prototype</code> property will not be described
explicitly for each object, unlike 3rd Edition.

<P><span class="pcounter"></span> Every <code>[[Prototype]]</code> property of an object <code>O</code> of class described
by class object <code>C</code>, unless specified otherwise, is initialized from
the value of <code>C.prototype</code>. 

<P><span class="pcounter"></span> <i>Consequence:</i> The structure of the prototype chain is elided
from the description of the native classes except where it diverges
from the standard behavior.


<h2>Constant-initialized properties</h2>

<P><span class="pcounter"></span> Several properties on both class objects and prototype objects are
initialized by references to constants, for example <code>length</code>
properties on class objects and <code>constructor</code> properties on
prototype objects.  These properties are trivially described in the
synopsis and normally do not get a separate section in the body of the
class description.

<P><span class="pcounter"></span> As far as <code>constructor</code> is concerned, it is a standard feature of
the prototype object and its initial value is always the class object,
so it does not have to be described either.  So it isn't.

<h2>Special cases</h2>

<P><span class="pcounter"></span> This is a list of all the special cases I'm aware of in the sections
following.

<UL>
  <LI> Object.prototype.<code>[[Prototype]]</code> is null
  <LI> Math.<code>[[Prototype]]</code> does not have a constructor
  <LI> Math is an instance of a class that is not constructable through the meta-objects system
  <LI> double.prototype === Number.prototype and double.<code>[[Prototype]]</code> === Number.<code>[[Prototype]]</code>
  <LI> decimal.prototype === Number.prototype and decimal.<code>[[Prototype]]</code> === Number.<code>[[Prototype]]</code>
  <LI> string.prototype === String.prototype and string.<code>[[Prototype]]</code> === String.<code>[[Prototype]]</code>
  <LI> boolean.prototype === Boolean.prototype and boolean.<code>[[Prototype]]</code> === Boolean.<code>[[Prototype]]</code>
</UL>

<h1>The Global Object</h1>



<P><span class="pcounter"></span> The global object is an instance of an implementation-dependent
class.  In particular, the name of this class and the contents of
the class's prototype object are implementation-dependent.

<P><span class="pcounter"></span> The class describing the global object does not have an accessible
constructor function; it is not possible to use the global object as a
constructor with the <code>new</code> operator.

<P><span class="pcounter"></span> The class describing the global object does not have a
<code>meta::invoke</code> method; it is not possible to call the global object
as a function.

<h2>Synopsis</h2>

<P><span class="pcounter"></span>The global object contains the following properties, functions,
types, and class definitions.

<PRE>
namespace __ES4__

__ES4__ namespace intrinsic = &#x0085;
__ES4__ namespace iterator = &#x0085;
__ES4__ namespace reflect = &#x0085;
__ES4__ namespace meta = &#x0085;

class Object &#x0085;
class Function &#x0085;
class Array &#x0085;
class String &#x0085;
class Boolean &#x0085;
class Number &#x0085;
class Date &#x0085;
class RegExp &#x0085;
class Error &#x0085;
class EvalError &#x0085;
class RangeError &#x0085;
class ReferenceError &#x0085;
class SyntaxError &#x0085;
class TypeError &#x0085;
class URIError &#x0085;

__ES4__ class string &#x0085;
__ES4__ class boolean
__ES4__ class double &#x0085;
__ES4__ class decimal &#x0085;
__ES4__ class Name &#x0085;
__ES4__ class Namespace &#x0085;
__ES4__ class Map.&#60;K,V> &#x0085;
__ES4__ class Vector.&#60;T> &#x0085;

__ES4__ type EnumerableId = &#x0085;
__ES4__ type AnyNumber = &#x0085;
__ES4__ type AnyString = &#x0085;
__ES4__ type AnyBoolean = &#x0085;
__ES4__ type Callable = &#x0085;

intrinsic const function eval(s: string) &#x0085;
intrinsic const function parseInt(s: string, r: double=0): AnyNumber &#x0085;
intrinsic const function parseFloat(s: string): AnyNumber &#x0085;
intrinsic const function isNaN(n: AnyNumber): boolean &#x0085;
intrinsic const function isFinite(n: AnyNumber): boolean &#x0085;
intrinsic const function isIntrinsic(n: AnyNumber): boolean &#x0085;
intrinsic const function isInt(n: AnyNumber): boolean &#x0085;
intrinsic const function isUint(n: AnyNumber): boolean &#x0085;
intrinsic const function toInt(n: AnyNumber): double &#x0085;
intrinsic const function toUint(n: AnyNumber): double &#x0085;
intrinsic const function decodeURI(s: string): string &#x0085;
intrinsic const function decodeURIComponent(s: string): string &#x0085;
intrinsic const function encodeURI(s: string): string &#x0085;
intrinsic const function encodeURIComponent(s: string): string &#x0085;
intrinsic const function hashcode(x): double &#x0085;

function eval(x) &#x0085;
function parseInt(s, r=undefined) &#x0085;
function parseFloat(s) &#x0085;
function isNaN(x) &#x0085;
function isFinite(x) &#x0085;
function decodeURI(x) &#x0085;
function decodeURIComponent(x) &#x0085;
function encodeURI(x) &#x0085;
function encodeURIComponent(x) &#x0085;
__ES4__ function isInt(n: AnyNumber): boolean &#x0085;
__ES4__ function isUint(n: AnyNumber): boolean &#x0085;
__ES4__ function toInt(n: AnyNumber): double &#x0085;
__ES4__ function toUint(n: AnyNumber): double &#x0085;

const NaN: double = &#x0085;
const Infinity: double = &#x0085;
const undefined: undefined = &#x0085;
const Math: helper::MathType = &#x0085;
const __ECMASCRIPT_VERSION__: double = &#x0085;
__ES4__ const global = &#x0085;
</PRE>

<h2>Namespace Properties on the Global Object</h2>

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; The namespace properties are all new in the 4th Edition of this
Standard.

<h3>__ES4__</h3>

<P><span class="pcounter"></span> The namespace <code>__ES4__</code> is used to tag all names introduced in
the global object in the 4th Edition of this Standard, except for two:
<code>__ES4__</code> and <code>__ECMASCRIPT_VERSION__</code>.

<P><span class="pcounter"></span> The namespace <code>__ES4__</code> is automatically opened by the
implementation for code that is to be treated as 4th Edition code, but
not for code that is to be treated as 3rd Edition code.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The risk of polluting the name space for 3rd Edition code with
new names is deemed too great to always open the <code>__ES4__</code> name
space.

<P><span class="pcounter"></span> The means by which an implementation determines whether to treat
code according to 3rd Edition or 4th Edition is outside the scope of
this Standard.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  This standard makes recommendations for how mime types should
be used to tag script content in a web browser.  (See <span class="xref">appendix-mime-types</span>.)

<h3>intrinsic</h3>

<P><span class="pcounter"></span> The namespace <code>intrinsic</code> is used to tag pre-defined types,
properties, and methods.  

<P><span class="pcounter"></span> The namespace <code>intrinsic</code> is reserved by the language.  Except
in the case where a method tagged <code>intrinsic</code> overrides an intrinsic
method inherited from a pre-defined class, it is an error for user
code to introduce new bindings in the <code>intrinsic</code> namespace.

<P><span class="pcounter"></span> The bindings in the <code>intrinsic</code> namespace are always constant
fixtures.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  A <i>fixture</i> is a binding that is not deletable and which
takes precedence over dynamic names during lexical name lookup.

<h3>reflect</h3>

<P><span class="pcounter"></span> The namespace <code>reflect</code> is used to tag pre-defined interfaces in
the reflection subsystem.

<P><span class="pcounter"></span> The namespace <code>reflect</code> is reserved by the language.  It is an
error for user code to introduce new bindings in the <code>reflect</code>
namespace.

<h3>meta</h3>

<P><span class="pcounter"></span> The namespace <code>meta</code> is used to tag methods that participate in
the language's protocols for invocation and property access.

<P><span class="pcounter"></span> The namespace <code>meta</code> is reserved by the language.  Except in the
case where a class definition uses it to tag (possibly static) methods
called <code>invoke</code>, <code>get</code>, <code>set</code>, <code>has</code>, or <code>delete</code>, it is an
error for user code to introduce new bindings in the <code>meta</code>
namespace.

<h3>iterator</h3>

<P><span class="pcounter"></span> The namespace <code>iterator</code> is used for the iteration protocol,
which is defined elsewhere.  (See <span class="xref">iterators</span>.)

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  Unlike the namespaces <code>__ES4__</code>, <code>intrinsic</code>, <code>reflect</code>, and
<code>meta</code>, the namespace <code>iterator</code> is not reserved by the system.


<h2>Value Properties on the Global Object</h2>

<h3>__ECMASCRIPT_VERSION__</h3>

<P><span class="pcounter"></span> The value of the constant property <code>__ECMASCRIPT_VERSION__</code> is
an integer denoting the version of this Standard to which the
implementation conforms.  For this 4th Edition of the Standard, the
value of <code>__ECMASCRIPT_VERSION__</code> is 4.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  This property is new in the 4th Edition of this Standard.  It
is one of two properties introduced in the 4th Edition of this
Standard that is not in the <code>__ES4__</code> namespace.  (The other is
<code>__ES4__</code>.)

<h3>NaN</h3>

<P><span class="pcounter"></span> The value of the constant property <code>NaN</code> is <b>NaN</b> (see <span class="xref">nan-value</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
const NaN : double = &#x0085;
</PRE>

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; <code>NaN</code> was not constant in the 3rd Edition of this Standard.

<h3>Infinity</h3>

<P><span class="pcounter"></span>The value of <code>Infinity</code> is +&#x221E; (see <span class="xref">infinity-value</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
const Infinity : double = &#x0085;
</PRE>

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; <code>Infinity</code> was not constant in the 3rd Edition of this Standard.

<h3>undefined</h3>

<P><span class="pcounter"></span>The value of <code>undefined</code> is <b>undefined</b> (see <span class="xref">undefined-value</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
const undefined : undefined = &#x0085;
</PRE>

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; <code>undefined</code> was not constant in the 3rd Edition of this Standard.

<h3>Math</h3>

<P><span class="pcounter"></span>The value of <code>Math</code> is the Math object (see <span class="xref">math-object</span>). 

<P class="implsection"><b>Implementation</b>
<PRE>
const Math : helper::MathType = &#x0085;
</PRE>

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; <code>Math</code> was not constant in the 3rd Edition of this Standard.

<P><span class="pcounter"></span> The helper type <code>MathType</code> (see <span class="xref">MathType</span>) is a
structural record type that includes a property for every intrinsic
method and public constant property defined on the Math object.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The type of <code>Math</code> impacts strict mode type checking.


<h3>global</h3>

<P><span class="pcounter"></span>The value of <code>global</code> is the global object that contains the
property <code>global</code>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  There may be multiple global objects in a program, and these
objects may share values or immutable state: for example, their
<code>isNaN</code> properties may hold the same function object.  However, each
global object has separate mutable state, and a separate value for the
intrinsic <code>global</code> property.

<P class="implsection"><b>Implementation</b>
<PRE>
const global = &#x0085;
</PRE>

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; <code>global</code> is new in the 4th Edition of this Standard.


<h2>Function Properties of the Global Object</h2>

<h3>eval</h3>

<P><span class="pcounter"></span> <i>It is likely that the description in this section needs to be
broken up and scattered over several parts of the final specification,
but for the time being it's best if everything is centralized here.
I've added more expository and background material than the spec
really ought to have; we'll clean this up by and by.   --lars</i>

<h4>Overview and background</h4>

<P><span class="pcounter"></span> The global object has properties named <code>eval</code> and
<code>intrinsic::eval</code>.  Those properties initially hold the same value,
a function, and that function -- the <code>eval</code> function -- can be
called in all the ways that any other function in the language can be
called.  There are however some run-time restrictions (described
below) on when those calls are valid.

<P><span class="pcounter"></span> In addition, there is an operator in the language that is also
known under the names <code>eval</code> and <code>intrinsic::eval</code>.  The <code>eval</code>
operator has access to the lexical environment of its context; it can
look up and introduce bindings in the environment of its context.

<P><span class="pcounter"></span> Together, the <code>eval</code> function and the <code>eval</code> operator provide
run-time evaluation functionality that (a) is compatible with the
functionality mandated for <code>eval</code> by the 3rd Edition and (b) handles
all important known uses of <code>eval</code> on the web.

<P><span class="pcounter"></span> The 3rd Edition only mandates the equivalent of the operator form
of the 4th Edition, yet it describes <code>eval</code> as a function that has
the ability to inspect and modify its caller's lexical environment.
In practice, an implementation that supports only the functionality
mandated by the 3rd Edition will not support the web well, and as a
consequence several implementations of ECMAScript in web browsers
provide <code>eval</code> as a true function that actually has the ability to
inspect and modify its caller's environment, no matter who the caller
of <code>eval</code> is and regardless of the name under which <code>eval</code> has
been called.

<P><span class="pcounter"></span> In other words, the 3rd Edition form of <code>eval</code>, implemented in
full generality, makes it generally impossible to know if any
particular scope contains a binding for any particular name, since any
function call in the scope may be a call to <code>eval</code>, which may
introduce new names in the scope.

<P><span class="pcounter"></span> As an illustration, the following program prints "20" in Mozilla 
Firefox, even though casual inspection of the program would lead one to
conclude that the <code>x</code> referenced in the body of <code>g</code> is the constant
binding in the outer scope:
<PRE>
   const x = 10;
   function g(f,s) {
       f(s);
       return x;
   }

   document.writeln(g(eval,"var x=20"));
</PRE>

<P><span class="pcounter"></span> In conclusion, the primary reason for splitting the definition of
<code>eval</code> into function and operator forms in the 4th Edition is in
order to be able to control the extent to which <code>eval</code> can introduce
new names in scopes, while at the same time remaining compatible with
existing programs.

<P><span class="pcounter"></span> The secondary reason for splitting the definition of <code>eval</code> into
function and operator forms is that the behavior illustrated above
largely precludes some standard code generation strategies.  A typical
approach in lexically scoped languages is to translate variable
references at compile time to <i>(rib,offset)</i> pairs; at run-time,
scope object number <i>rib</i> (where the innermost is number zero) is
fetched and property number <i>offset</i> is fetched out of it.  That
approach is only possible if the environment is known at compile time.
If there is a chance that <code>eval</code> can introduce new names into a
scope at run-time then lookup in that scope must always be by name;
with an operator form of <code>eval</code> it is possible to know at compile
time whether a scope may be thus affected.

<P><span class="pcounter"></span> Several other features and clarifications have been incorporated
into the 4th Edition in an attempt to constrain the effects of
<code>eval</code>.  While the splitting of <code>eval</code> into an operator form and a
function form makes it clearer when a non-global environment might
have new bindings introduced, it does not prevent such bindings from
being introduced.

<P><span class="pcounter"></span> The additional features and clarifications are:
<UL>

<LI> If the version number passed as the second argument to <code>eval</code>
     is greater than 3, then the program being evaluated is given a
     fresh variable object in which it can create bindings; as a
     consequence, no bindings can be introduced into the caller's
     environment (except by assignment to non-existent global
     variables).

<LI> <code>eval</code> is prevented from changing the DontDelete attribute on
      existing bindings when a binding form is evaluated.

<LI> The operator form of <code>eval</code> is disallowed inside classes.

<LI> The operator form of <code>eval</code> is disallowed in strict mode.
</UL> 

<h4>eval&nbsp;(program,&nbsp;version=&#x0085;)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The eval function and the eval operator (described fully below)
are invoked on a <i>program</i>, which is a value of any type, and a
<i>version</i>, which is intended to be a nonnegative integer (defaulting
to 3).

<P><span class="pcounter"></span> If the <i>program</i> is a string then it must represent valid source
code according to the nonterminal <i>Program</i> (see <span class="xref">Grammar</span>), with
the proviso that the keyword set recognized during lexical analysis is
determined by <i>version</i>, as follows.  Convert version to an integer
as with the ToInt32 operation.  If the converted value of <i>version</i>
is 3 or less then the keyword set is the set of reserved words in the
3rd Edition of this Standard (E262-3 section 7.5.2).  Otherwise, if
the converted value of <i>version</i> is <i>n</i> then the keyword set is
the set of reserved and contextually reserved words in the <i>n</i>th
Edition of this Standard.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  Program arguments to <code>eval</code> that use e.g. <code>let</code> as an
identifier will continue to work in a 4th Edition implementation
(where <code>let</code> is a keyword) as long as no <i>version</i> is passed to
<code>eval</code>, or the value of the version passed is 3 or less.

<P><span class="pcounter"></span> If the converted value of <i>version</i> is 4 or greater then the
evaluation takes place in a fresh variable object.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  In other words, <code>eval</code> will be unable to introduce bindings
in its caller's variable object if <i>version</i> is 4 or greater.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  Unlike in the 3rd Edition of this Standard, <code>eval</code> is not
allowed to change a property from being DontDelete to being deletable.
That restriction belongs in the section on adding bindings to the
variable object (10.1.3 in 3rd Ed) and is only mentioned here for the
time being.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> If the <i>program</i> is a string then the result of compiling and
evaluating <i>program</i> as a <i>Program</i> is returned.  Otherwise,
<i>program</i> is returned unchanged.

<P class="implsection"><b>Implementation</b>
<PRE>
function eval( program, version=3 ) &#x0085;
</PRE>

<h4>The <code>eval</code> operator</h4>

<P><span class="pcounter"></span> <i>There are two possible designs for the operator form.  One is
that an expression of the form <code>eval(s)</code> is </i>always<i> taken as the
operator form, regardless of the binding of <code>eval</code> in the context of
the expression; the other is that an expression of that form </i>may<i>
be the operator form, and that it is the operator form only if the
binding of <code>eval</code> is the original, global binding.  Since the former
design would be incompatible with 3rd Edition, we use the latter.</i>

<P><span class="pcounter"></span> It will always be lexically apparent when <code>eval</code> is <i>possibly</i>
being used as an operator, but in the general case it is not possible
to determine until run-time whether it is <i>actually</i> being used as
an operator.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  For the intrinsic form of the operator it is possible to
determine this at compile time, in the absence of the use of <code>with</code>
in the enclosing context.

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The operator form is <i>possibly</i> being used in an expression <i>E</i> if
<i>E</i> has the form of a <i>CallExpression</i> (including the parentheses
bracketing the arguments) and the <i>MemberExpression</i> that denotes
the function to be called has the form of the unqualified identifier
<code>eval</code> or the qualified identifier <code>intrinsic::eval</code>.  That is,
apart from any superflous parentheses, <i>E</i> has the form <i>M(P, ...)</i>.

<P><span class="pcounter"></span> If the possible use of the operator form of <code>eval</code> appears in
any context inside a class, a <b>SyntaxError</b> is thrown.

<P><span class="pcounter"></span> If the possible use of the operator form of <code>eval</code> appears in
any context inside block in which strict mode is in effect (even
inside a block that overrides strict mode by decreeing standard mode),
a <b>SyntaxError</b> is thrown.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The purpose of these restriction is partly to avoid
inconsistencies (in strict mode) and partly to signal that the use of
the <code>eval</code> operator is potentially harmful to program integrity.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  A less restrictive, but probably equally safe, alternative
would be to allow <code>eval</code> to be used inside a class provided that a
version parameter was being passed and its value was a constant known
to be 4 or greater.

<P><span class="pcounter"></span> If the <i>program</i> operand to <code>eval</code> contains definitions for
classes, interfaces, packages, namespaces, types, or units, then a
<code>SyntaxError</code> is thrown (even if the use of the <code>eval</code> operator is
at the outer program's top level where these forms would normally be
allowed).

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Should that be EvalError?

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  It seems it would not be entirely unreasonable to lift that
restriction if the <i>version</i> is greater than 3, but it's unclear as
yet what the problems might be with e.g. allowing classes to have
elaborate scope chains around them.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The eval operator returns an ECMAScript value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> In the case that a possible use of the operator form is
detected, <i>M(P, ...)</i> is evaluated as follows.

<P><span class="pcounter"></span> (The implementation of the <code>eval</code> operator is presented as
pseudo-code because it is not expressible in ECMAScript.  Eventually,
it may be presented as Standard ML code.)

<PRE>
  look up M in the environment yielding the value V
  if V is the pre-defined eval function and
     the binding object O holding V is an ES global object and
     the global object on the scope chain of V is O then
       invoke eval as follows:
         evaluate the P in order to yield argument value A
         if there are no A values, then 
           return undefined
         if the first A value is not a string, then 
           return the first A
         if there is a second A then let K=int(A), else let K=3
         evaluate the program denoted by the first A as follows:
           if K &#60;= 3
             the scope chain is the lexical chain in effect at 
                 the point of invocation of M
             the variable object is the innermost variable object in effect
                 (which is to say that it excludes binding objects 
                 introduced for "let", "catch", named function expressions, 
                 and "switch type")
           else
             the scope chain is the lexical chain in effect at the point of
                 invocation of M, extended by a new variable object W
             the variable object is W
           fi
           the value of "this" is the global object O
           the keyword set is determined by K
  else
    evaluate the P in order to yield a list of arguments A
    invoke V as a function on the arguments A
  fi
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The requirement that the global object of V be O precludes
sharing of <code>eval</code> functions among multiple global environments.  It
is possible that that requirement is not actually needed for
consistent operation.

<h4>The <code>eval</code> function</h4>

<P><span class="pcounter"></span> If the operator form is not detected syntactically then <code>eval</code>
is either being called as a function under a different name or it is
being invoked as a method on an object.  The implementation does not
need to handle this case syntactically; it is handled as a regular
function call.

<P><span class="pcounter"></span> The following description applies to both the public <code>eval</code>
function and the intrinsic <code>eval</code> function, both defined in the
global object.

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The global <code>eval</code> function evaluates its first argument as a
program in the global scope of the <code>eval</code> function.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The global <code>eval</code> function returns the value computed by
the program that is evaluated, or its first argument if the first
argument is not a string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The body of the pre-defined <code>eval</code> function <i>V</i> is
evaluated in the context of a list of argument values <i>A</i> as
follows.

<P><span class="pcounter"></span> (The implementation of the <code>eval</code> function is presented as
pseudo-code because it is not expressible in ECMAScript.  Eventually,
it may be presented as ECMAScript code with the addition of "magic"
run-time system hooks.)

<PRE>
  if the "this" object O is an ES global object and
     the global object on the scope chain of V is O then
       if there are no A values, then 
         return undefined
       if the first A value is not a string, then 
         return the first A
       if there is a second A then let K=int(A), else let K=3
       evaluate the program denoted by the first A as follows:
         if K&#60;=3 then
           the scope chain holds O only
           the variable object is O
         else
           the scope chain holds O extended by a new variable object W
           the variable object is W
         fi
         the value of "this" is O
         the keyword set is determined by K
  else
    throw EvalError
  fi
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The requirement that the global object of V be O precludes
sharing of <code>eval</code> functions among multiple global environments.  It
is possible that that requirement is not actually needed for
consistent operation.


<h4>Restrictions on the use of the <code>eval</code> property</h4>

<P><span class="pcounter"></span> If the global <code>eval</code> property is assigned to, an <code>EvalError</code>
exception may be thrown.


<h3>intrinsic::parseInt&nbsp;(s,&nbsp;r=&#x0085;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>parseInt</code> function computes an integer value
dictated by interpretation of the contents of the string argument
<i>s</i> according to the specified radix <i>r</i> (which defaults to zero).
Leading whitespace in <i>s</i> is ignored.  If <i>r</i> is zero, the radix is
assumed to be 10 except when the number begins with the character
pairs 0x or 0X, in which case a radix of 16 is assumed.  Any radix-16
number may also optionally begin with the character pairs 0x or 0X.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>parseInt</code> function returns a number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function parseInt(s: string, r: double=0): AnyNumber {
    let i;

    for ( i=0 ; i &#60; s.length && <em>isTrimmableSpace</em>(s[i]) ; i++ )
        ;
    s = s.intrinsic::substring(i);

    let sign = 1;
    if (s.length >= 1 && s[0] == '-')
        sign = -1;
    if (s.length >= 1 && (s[0] == '-' || s[0] == '+'))
        s = s.intrinsic::substring(1);

    let maybe_hexadecimal = false;
    r = intrinsic::toInt(r);
    if (r == 0) {
        r = 10;
        maybe_hexadecimal = true;
    }
    else if (r == 16)
        maybe_hexadecimal = true;
    else if (r &#60; 2 || r > 36)
        return NaN;

    if (maybe_hexadecimal &&
        s.length >= 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) {
        r = 16;
        s = s.intrinsic::substring(2);
    }

    for ( i=0 ; i &#60; s.length && <em>isDigitForRadix</em>(s[i], r) ; i++ )
        ;
    s = s.intrinsic::substring(0,i);

    if (s == "")
        return NaN;

    return sign * <em>numericValue</em>(s, r);
}
</PRE>

<P><span class="pcounter"></span> The helper function <code>isDigitForRadix(c,r)</code> computes whether
<code>c</code> is a valid digit for the radix <code>r</code>, see <span class="xref">helper:isDigitForRadix</span>.

<P><span class="pcounter"></span> The helper function <code>isTrimmableSpace(c)</code> computes whether
<code>c</code> is a space character that can be trimmed off the beginning
of the string, see <span class="xref">helper:isTrimmableSpace</span>.

<P><span class="pcounter"></span>The informative function <code>numericValue(s, r)</code> computes the
numeric value of a radix-<code>r</code> string <code>s</code>.  If <code>r</code> is 10 and <code>s</code>
contains more than 20 significant digits, every significant digit
after the 20th may be replaced by a 0 digit, at the option of the
implementation; and if <code>r</code> is not 2, 4, 8, 10, 16, or 32, then the
returned value may be an implementation-dependent approximation to the
mathematical integer value that is represented by <code>s</code> in radix-<code>r</code>
notation.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; In the 3rd Edition of this Standard, the <code>parseInt</code> function was
allowed to, though not encouraged to, interpret a string with a
leading <code>0</code> but no leading <code>0x</code> or <code>0X</code> as a base-8 number if
the radix was not supplied in the call or was supplied as zero.  This
is no longer allowed; the function must interpret such a number as a
base-10 number.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; <code>parseInt</code> may interpret only a leading portion of the string as an
integer value; it ignores any characters that cannot be interpreted as
part of the notation of an integer, and no indication is given that
any such characters were ignored.

<h4 id="helper:isDigitForRadix">isDigitForRadix </h4>

<PRE>
helper function isDigitForRadix(c, r) {
    c = c.intrinsic::toUpperCase();
    if (c >= '0' && c &#60;= '9')
        return (c.intrinsic::charCodeAt(0) - '0'.intrinsic::charCodeAt(0)) &#60; r;
    if (c >= 'A' && c &#60;= 'Z')
        return (c.intrinsic::charCodeAt(0) - 'A'.intrinsic::charCodeAt(0) + 10) &#60; r;
    return false;
}
</PRE>


<h3>parseInt&nbsp;(&nbsp;s,&nbsp;r=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>parseInt</code> function converts its first argument to
<code>string</code> and its second argument to <code>double</code>, and then calls its
intrinsic counterpart.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The <code>parseInt</code> function returns a number.

<P class="implsection"><b>Implementation</b>
<PRE>
public function parseInt(s, r=0)
    intrinsic::parseInt(string(s), double(r));
</PRE>


<h3>intrinsic::parseFloat&nbsp;(s)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The intrinsic <code>parseFloat</code> function computes a number value
dictated by interpretation of the contents of the string argument <i>s</i> as a
decimal literal.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>parseFloat</code> function returns a number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function parseFloat(s: string) {
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; <code>parseFloat</code> may interpret only a leading portion of <i>s</i> as a
number value; it ignores any characters that cannot be interpreted as
part of the notation of an decimal literal, and no indication is given
that any such characters were ignored.

<h3>parseFloat&nbsp;(s)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>parseFloat</code> function converts its argument to <code>string</code>,
then calls its intrinsic counterpart.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The <code>parseFloat</code> function returns a number.

<P class="implsection"><b>Implementation</b>
<PRE>
public function parseFloat(s)
    intrinsic::parseFloat(string(s));
</PRE>


<h3>intrinsic::isNaN&nbsp;(n)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The intrinsic <code>isNaN</code> function tests whether a numeric value <i>n</i> is an
IEEE not-a-number value.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The intrinsic <code>isNaN</code> function returns 
<b>true</b> if <i>n</i> is <b>NaN</b>, and otherwise returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function isNaN(n: AnyNumber): boolean
    (!(n === n));
</PRE>

<h3>isNaN&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>isNaN</code> function converts its argument to a number, then
calls its intrinsic counterpart.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The <code>isNaN</code> function returns <b>true</b> if <i>x</i> converted to a
number is <b>NaN</b>, and otherwise returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
public function isNaN(x)
    intrinsic::isNaN(Number(x));
</PRE>


<h3>intrinsic::isFinite&nbsp;(n)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The intrinsic <code>isFinite</code> function tests whether a numeric
value <i>n</i> is finite (neither not-a-number nor an infinity).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The intrinsic <code>isFinite</code> function returns <b>true</b> if <i>n</i> is
finite, and otherwise returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function isFinite(n: AnyNumber): boolean
    (!intrinsic::isNaN(n) && n != -Infinity && n != Infinity);
</PRE>


<h3>isFinite&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>isFinite</code> function converts its argument to a number,
then calls its intrinsic counterpart on the converted value.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The <code>isFinite</code> function returns <b>true</b> if <i>x</i> converted to
a number is finite, and otherwise returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
public function isFinite(x)
    intrinsic::isFinite(Number(x));
</PRE>


<h3>intrinsic::isIntegral&nbsp;(n)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The intrinsic <code>isIntegral</code> function tests whether a numeric
value <i>n</i> is integral (a finite integer).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The intrinsic <code>isIntegral</code> function returns <b>true</b> if <i>n</i> is
integral, and otherwise returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function isIntegral(v:AnyNumber): boolean
    intrinsic::isFinite(v) && Math.intrinsic::floor(v) == v;
</PRE>

<h3>isIntegral&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>isIntegral</code> function converts its argument <i>x</i> to a number,
then calls the intrinsic <code>isIntegral</code> function on the converted value.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The <code>isIntegral</code> function returns <b>true</b> if <i>x</i> converted
to a number is integral, and otherwise returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
__ES4__ function isIntegral(v)
    intrinsic::isIntegral(Number(v));
</PRE>

<h3>intrinsic::isInt&nbsp;(n)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The intrinsic <code>isInt</code> function tests whether a numeric value
<i>n</i> is an <code>int</code> value (a finite integer in the range
-2<SUP>31</SUP> to 2<SUP>31</SUP>-1, inclusive).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The intrinsic <code>isInt</code> function returns <b>true</b> if <i>n</i>
is an <code>int</code> value, and otherwise returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function isInt(n:AnyNumber) : boolean
    intrinsic::isIntegral(n) && n >= -0x7FFFFFFF && n &#60;= 0x7FFFFFFF;
</PRE>

<h3>isInt&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>isInt</code> function converts its argument <i>x</i> to a number,
then calls the intrinsic <code>isInt</code> function on the converted value.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The <code>isInt</code> function returns <b>true</b> if <i>x</i> converted
to a number is an <code>int</code> value, and otherwise returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
__ES4__ function isInt(x)
    intrinsic::isInt(Number(x));
</PRE>

<h3>intrinsic::isUint&nbsp;(n)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The intrinsic <code>isUint</code> function tests whether the numeric
value <i>n</i> is a <code>uint</code> value (a finite integer in the range 0 to
2<SUP>32</SUP>-1, inclusive).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The intrinsic <code>isUint</code> function returns <b>true</b> if <i>n</i>
is a <code>uint</code> value, and otherwise returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function isUint(n:AnyNumber) : boolean
    intrinsic::isIntegral(n) && n >= 0 && n &#60;= 0xFFFFFFFF;
</PRE>

<h3>isUint&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>isUint</code> function converts its argument <i>x</i> to a number,
then calls the intrinsic <code>isUint</code> function on the converted value.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The <code>isUint</code> function returns <b>true</b> if <i>x</i> converted
to a number is a <code>uint</code> value, and otherwise returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
__ES4__ function isUint(x)
    intrinsic::isUint(Number(x));
</PRE>

<h3>intrinsic::toInt&nbsp;(n)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The intrinsic <code>toInt</code> function converts its argument <i>n</i> to an <code>int</code> value
using the ToInt32 algorithm (see <span class="xref">ToInt32</span>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The intrinsic <code>toInt</code> function returns an <code>int</code> value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function toInt(n:AnyNumber) : double
    n | 0;
</PRE>

<h3>toInt&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>toInt</code> function converts its argument <i>x</i> to a number, then
calls the intrinsic <code>toInt</code> function on the converted value.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The <code>toInt</code> function returns an <code>int</code> value.

<P class="implsection"><b>Implementation</b>
<PRE>
__ES4__ function toInt(x)
    intrinsic::toInt(Number(x));
</PRE>

<h3>intrinsic::toUint&nbsp;(n)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The intrinsic <code>toUint</code> function converts its argument <i>n</i> to a <code>uint</code> value
using the ToUint32 algorithm (see <span class="xref">ToUint32</span>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The intrinsic <code>toUint</code> function returns a <code>uint</code> value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function toUint(n:AnyNumber) : double
    n >>> 0;
</PRE>

<h3>toUint&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>toUint</code> function converts its argument <i>x</i> to a number, then
calls the intrinsic <code>toUint</code> function on the converted value.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The <code>toUint</code> function returns a <code>uint</code> value.

<P class="implsection"><b>Implementation</b>
<PRE>
__ES4__ function toUint(x) : boolean
    intrinsic::toUint(Number(x));
</PRE>


<h3>URI Handling Function Properties</h3>

<P><span class="pcounter"></span>Uniform Resource Identifiers, or URIs, are strings that identify
resources (e.g. web pages or files) and transport protocols by which
to access them (e.g. HTTP or FTP) on the Internet. The ECMAScript
language itself does not provide any support for using URIs except for
functions that encode and decode URIs as described in sections <span class="xref">decodeURI</span>, <span class="xref">decodeURIComponent</span>, <span class="xref">encodeURI</span>, and <span class="xref">encodeURIComponent</span>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; Many implementations of ECMAScript provide additional
functions and methods that manipulate web pages; these functions are
beyond the scope of this standard.

<P><span class="pcounter"></span>A URI is composed of a sequence of components separated by component separators. The general form is:
<div class="indented">
<i>Scheme <code>:</code> First <code>/</code> Second <code>;</code> Third <code>?</code> Fourth</i>
</div>

<P><span class="pcounter"></span>where the italicised names represent components and the ":", "/",
";" and "?" are reserved characters used as separators.  The
<code>encodeURI</code> and <code>decodeURI</code> functions are intended to work with
complete URIs; they assume that any reserved characters in the URI are
intended to have special meaning and so are not encoded.  The
<code>encodeURIComponent</code> and <code>decodeURIComponent</code> functions are
intended to work with the individual component parts of a URI; they
assume that any reserved characters represent text and so must be
encoded so that they are not interpreted as reserved characters when
the component is part of a complete URI.  The following lexical
grammar specifies the form of encoded URIs.

<div class="grammar">
<div class="nonterm">uri :::</div>
<div class="indented">uriCharacters<sub>opt</sub></div>

<div class="nonterm">uriCharacters :::</div>
<div class="indented">uriCharacter uriCharacters<sub>opt</sub></div>

<div class="nonterm">uriCharacter :::</div>
<div class="indented">uriReserved<br>
uriUnescaped<br>
uriEscaped</div>

<div class="nonterm">uriReserved ::: <b>one of</b></div>
<div class="indented"><code>; / ? : @ & = + $ ,</code></div>

<div class="nonterm">uriUnescaped :::</div>
<div class="indented">uriAlpha<br>
DecimalDigit<br>
uriMark</div>

<div class="nonterm">uriEscaped :::</div>
<div class="indented">% HexDigit HexDigit</div>

<div class="nonterm">uriAlpha ::: <b>one of</b></div>
<div class="indented"><code>a b c d e f g h i j k l m n o p q r s t u v w x y z</code><br>
<code>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</code></div>

<div class="nonterm">uriMark ::: <b>one of</b></div>
<div class="indented"><code>- _ . ! ~ * ' ( )</code></div>
</div>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #170.)  Upgrade to Unicode 5 in the following
sections, and upgrade to handling the entire (21-bit) Unicode
character set.

<P><span class="pcounter"></span>When a character to be included in a URI is not listed above or is
not intended to have the special meaning sometimes given to the
reserved characters, that character must be encoded. The character is
first transformed into a sequence of octets using the UTF-8
transformation, with surrogate pairs first transformed from their
UCS-2 to UCS-4 encodings. (Note that for code points in the range
[0,127] this results in a single octet with the same value.)  The
resulting sequence of octets is then transformed into a string with
each octet represented by an escape sequence of the form "<code>%xx</code>".

<P><span class="pcounter"></span>The encoding and escaping process is described by the helper
function <code>encode</code> taking two string arguments <code>s</code> and
<code>unescapedSet</code>.

<PRE>
helper function encode(s: string, unescapedSet: string): string {
    let R = "";
    let k = 0;

    while (k != s.length) {
        let C = s[k];

        if (unescapedSet.intrinsic::indexOf(C) != -1) {
            R = R + C;
            k = k + 1;
            continue;
        }

        let V = C.intrinsic::charCodeAt(0);
        if (V >= 0xDC00 && V &#60;= 0xDFFF)
            throw new URIError(/* Invalid code */);
        if (V >= 0xD800 && V &#60;= 0xDBFF) {
            k = k + 1;
            if (k == s.length)
                throw new URIError(/* Truncated code */);
            let V2 = s[k].intrinsic::charCodeAt(0);
            V = (V - 0xD800) * 0x400 + (V2 - 0xDC00) + 0x10000;
        }

        let octets = <em>toUTF8</em>(V);
        for ( let j=0 ; j &#60; octets.length ; j++ )
            R = R + "%" + <em>twoHexDigits</em>(octets[j]);
        k = k + 1;
    }
    return R;
}
</PRE>
<PRE>
helper function twoHexDigits(B) {
    let s = "0123456789ABCDEF";
    return s[B >> 4] + s[B & 15];
}
</PRE>

<P><span class="pcounter"></span>The unescaping and decoding process is described by the helper
function <code>decode</code> taking two string arguments <code>s</code> and
<code>reservedSet</code>.

<PRE>
helper function decode(s: string, reservedSet: string): string {
    let R = "";
    let k = 0;
    while (k != s.length) {
        if (s[k] != "%") {
            R = R + s[k];
            k = k + 1;
            continue;
        }

        let start = k;
        let B = <em>decodeHexEscape</em>(s, k);
        k = k + 3;

        if ((B & 0x80) == 0) {
            let C = string.intrinsic::fromCharCode(B);
            if (reservedSet.intrinsic::indexOf(C) != -1)
                R = R + s.intrinsic::substring(start, k);
            else
                R = R + C;
            continue;
        }

        let n = 1;
        while (((B &#60;&#60; n) & 0x80) == 1)
            ++n;
        if (n == 1 || n > 4)
            throw new URIError(/* Invalid encoded character */);

        let octets = [B];
        for ( let j=1 ; j &#60; n ; ++j ) {
            let B = <em>decodeHexEscape</em>(s, k);
            if ((B & 0xC0) != 0x80)
                throw new URIError(/* Invalid encoded character */);
            k = k + 3;
            octets.intrinsic::push(B);
        }
        let V = <em>fromUTF8</em>(octets);
        if (V > 0x10FFFF)
            throw new URIError(/* Invalid Unicode code point */);
        if (V > 0xFFFF) {
            L = ((V - 0x10000) & 0x3FF) + 0xD800;
            H = (((V - 0x10000) >> 10) & 0x3FF) + 0xD800;
            R = R + string.intrinsic::fromCharCode(H, L);
        }
        else {
            let C = string.intrinsic::fromCharCode(V);
            if (reservedSet.intrinsic::indexOf(C))
                R = R + s.intrinsic::substring(start, k);
            else
                R = R + C;
        }
    }
    return R;
}
</PRE>
<PRE>
helper function decodeHexEscape(s, k) {
    if (k + 2 >= s.length ||
        s[k] != "%" ||
        (!<em>isDigitForRadix</em>(s[k+1], 16) &&
         !<em>isDigitForRadix</em>(s[k+1], 16)))
        throw new URIError(/* Invalid escape sequence */);
    return intrinsic::parseInt(s.intrinsic::substring(k+1, k+3), 16);
}
</PRE>

<P><span class="pcounter"></span>The helper function <code>isDigitForRadix</code> was defined in section
<span class="xref">helper:isDigitForRadix</span>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The syntax of Uniform Resource Identifiers is given in
RFC2396.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; A formal description and implementation of UTF-8 is
given in the Unicode Standard, Version 2.0, Appendix A.  In UTF-8,
characters are encoded using sequences of 1 to 6 octets. The only
octet of a "sequence" of one has the higher-order bit set to 0, the
remaining 7 bits being used to encode the character value. In a
sequence of n octets, n>1, the initial octet has the n higher-order
bits set to 1, followed by a bit set to 0. The remaining bits of that
octet contain bits from the value of the character to be encoded. The
following octets all have the higher-order bit set to 1 and the
following bit set to 0, leaving 6 bits in each to contain bits from
the character to be encoded. The possible UTF-8 encodings of
ECMAScript characters are:

<center>
<table border="1">
  <tr><th>Code Point Value</th><th>Representation</th>    <th>1st Octet</th><th>2nd Octet</th><th>3rd Octet</th><th>4th Octet</th></tr>
  <tr><td>0x0000 - 0x007F</td> <td>00000000 0zzzzzzz</td> <td>0zzzzzzz</td></tr>
  <tr><td>0x0080 - 0x07FF</td> <td>00000yyy yyzzzzzz</td> <td>110yyyyy</td> <td>10zzzzzz</td></tr>
  <tr><td>0x0800 - 0xD7FF</td> <td>xxxxyyyy yyzzzzzz</td> <td>1110xxxx</td> <td>10yyyyyy</td><td>10zzzzzz</td></tr>
  <tr><td>0xD800 - 0xDBFF<br>
          followed by<br>
          0xDC00 - 0xDFFF</td> <td>110110vv vvwwwwxx<br>
                                   followed by<br>
                                   110111yy yyzzzzzz</td> <td>11110uuu</td> <td>10uuwwww</td> <td>10xxyyyy</td> <td>10zzzzzz</td></tr>
  <tr><td>0xD800 - 0xDBFF<br>
      not followed by<br>
      0xDC00 - 0xDFFF</td>     <td>causes URIError</td></tr>
  <tr><td>0xDC00 - 0xDFFF</td> <td>causes URIError</td></tr>
  <tr><td>0xE000 - 0xFFFF</td> <td>xxxxyyyy yyzzzzzz</td> <td>1110xxxx</td> <td>10yyyyyy</td> <td>10zzzzzz</td></tr>
</table>
</center>

<P><span class="pcounter"></span>Where
<div class="indented">uuuuu = vvvv + 1</div>
<P><span class="pcounter"></span>to account for the addition of 0x10000 as in section 3.7,
Surrogates of the Unicode Standard version 2.0.

<P><span class="pcounter"></span>The range of code point values 0xD800-0xDFFF is used to encode
surrogate pairs; the above transformation combines a UCS-2 surrogate
pair into a UCS-4 representation and encodes the resulting 21-bit
value in UTF-8. Decoding reconstructs the surrogate pair.

<P><span class="pcounter"></span>The helper functions <code>encode</code> and <code>decode</code>, defined above, use
the helper functions <code>toUTF8</code> and <code>fromUTF8</code> to convert code
points to UTF-8 sequences and to convert UTF-8 sequences to code
points, respectively.

<PRE>
helper function toUTF8(v) {
    if (v &#60;= 0x7F)
        return [v];
    if (v &#60;= 0x7FF)
        return [0xC0 | ((v >> 6) & 0x3F),
                0x80 | (v & 0x3F)];
    if (v &#60;= 0xD7FF || v >= 0xE000 && v &#60;= 0xFFFF)
        return [0xE0 | ((v >> 12) & 0x0F),
                0x80 | ((v >> 6) & 0x3F),
                0x80 | (v & 0x3F)];
    if (v >= 0x10000)
        return [0xF0 | ((v >> 18) & 0x07),
                0x80 | ((v >> 12) & 0x3F),
                0x80 | ((v >> 6) & 0x3F),
                0x80 | (v & 0x3F)];
    throw URIError(/* Unconvertible code */);
}
</PRE>
<PRE>
helper function fromUTF8(octets) {
    let B = octets[0];
    let V;
    if ((B & 0x80) == 0)
        V = B;
    else if ((B & 0xE0) == 0xC0)
        V = B & 0x1F;
    else if ((B & 0xF0) == 0xE0)
        V = B & 0x0F;
    else if ((B & 0xF8) == 0xF0)
        V = B & 0x07;
    for ( let j=1 ; j &#60; octets.length ; j++ )
        V = (V &#60;&#60; 6) | (octets[j] & 0x3F);
    return V;
}
</PRE>

<P><span class="pcounter"></span>Several helper strings are defined based on the grammar shown
previously:

<PRE>
helper const uriReserved = ";/?:@&=+$,";
</PRE>
<PRE>
helper const uriAlpha = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
</PRE>
<PRE>
helper const uriDigit = "0123456789";
</PRE>
<PRE>
helper const uriMark = "-_.!~*'()";
</PRE>
<PRE>
helper const uriUnescaped = <em>uriAlpha</em> + <em>uriDigit</em> + <em>uriMark</em>;
</PRE>


<h4>intrinsic::decodeURI&nbsp;(encodedURI)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>decodeURI</code> function computes a new version of
a URI in which each escape sequence and UTF-8 encoding of the sort
that might be introduced by the <code>encodeURI</code> function is replaced
with the character that it represents.  Escape sequences that could
not have been introduced by <code>encodeURI</code> are not replaced.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>decodeURI</code> function returns a decoded string.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function decodeURI(encodedURI: string)
    <em>decode</em>(encodedURI, <em>uriReserved</em> + "#");
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The character "<code>#</code>" is not decoded from escape sequences even
though it is not a reserved URI character.

<h4>decodeURI&nbsp;(encodedURI)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>decodeURI</code> function converts its argument to <code>string</code>, then
calls its intrinsic counterpart.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>decodeURI</code> function returns a decoded string.

<P class="implsection"><b>Implementation</b>
<PRE>
public function decodeURI(encodedURI)
    intrinsic::decodeURI(string(encodedURI));
</PRE>


<h4>intrinsic::decodeURIComponent&nbsp;(encodedURIComponent)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>decodeURIComponent</code> function computes a new
version of a URI in which each escape sequence and UTF-8 encoding of
the sort that might be introduced by the <code>encodeURIComponent</code>
function is replaced with the character that it represents.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>decodeURIComponent</code> function returns a decoded string.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function decodeURIComponent(encodedURIComponent)
    <em>decode</em>(encodedURIComponent, "");
</PRE>

<h4>decodeURIComponent&nbsp;(encodedURIComponent)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>decodeURIComponent</code> function converts its argument to
<code>string</code>, then calls its intrinsic counterpart.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>decodeURIComponent</code> function returns a decoded string.

<P class="implsection"><b>Implementation</b>
<PRE>
public function decodeURIComponent(encodedURIComponent)
    intrinsic::decodeURIComponent(string(encodedURIComponent));
</PRE>


<h4>intrinsic::encodeURI&nbsp;(uri)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>encodeURI</code> function computes a new version of
a URI in which each instance of certain characters is replaced by one,
two, three, or four escape sequences representing the UTF-8 encoding of the
character.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>encodeURI</code> function returns a encoded string.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function encodeURI(uri: string): string
    <em>encode</em>(uri, <em>uriReserved</em> + <em>uriUnescaped</em> + "#")
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The character "<code>#</code>" is not encoded to an escape sequence
even though it is not a reserved or unescaped URI character.

<h4>encodeURI&nbsp;(uri)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>encodeURI</code> function converts its argument to string, then
calls its intrinsic counterpart.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>encodeURI</code> function returns a encoded string.

<P class="implsection"><b>Implementation</b>
<PRE>
public function encodeURI(uri)
    intrinsic::encodeURI(string(uri));
</PRE>


<h4>intrinsic::encodeURIComponent&nbsp;(uriComponent)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>encodeURIComponent</code> function computes a new
version of a URI in which each instance of certain characters is
replaced by one, two, three, or four escape sequences representing the
UTF-8 encoding of the character.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>encodeURIComponent</code> function returns a encoded string.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function encodeURIComponent(uriComponent: string): string
    <em>encode</em>(uri, <em>uriReserved</em>);
</PRE>

<h4>encodeURIComponent&nbsp;(uriComponent)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>encodeURIComponent</code> function converts its
argument to string, then calls its intrinsic counterpart.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>encodeURIComponent</code> function returns a encoded string.

<P class="implsection"><b>Implementation</b>
<PRE>
public function encodeURIComponent(uriComponent)
    intrinsic::encodeURIComponent(string(uriComponent));
</PRE>


<h3>intrinsic::hashcode&nbsp;(x)</h3>



<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>hashcode</code> function computes a numeric value
for its argument such that if two values <code>v1</code> and <code>v2</code> are equal
by the operator <code>intrinsic::===</code> then <code>hashcode(v1)</code> is
numerically equal to <code>hashcode(v2)</code>.

<P><span class="pcounter"></span> The hashcode of any value for which <code>isNaN</code> returns <b>true</b> is
zero.

<P><span class="pcounter"></span> The hashcode computed for an object does not change over time.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>hashcode</code> function returns a nonnegative integer
below 2<SUP>32</SUP>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic const function hashcode(o): double {
    switch type (o) {
    case (x: null)       { return 0 }
    case (x: undefined)  { return 0 }
    case (x: AnyBoolean) { return Number(x) }
    case (x: AnyNumber)  { return intrinsic::toUint(x) }
    case (x: AnyString)  { return <em>stringHash</em>(x) }
    case (x: Namespace)  { return <em>namespaceHash</em>(x) }
    case (x: Name)       { return <em>nameHash</em>(x) }
    case (x: *)          { return <em>objectHash</em>(x) }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>stringHash</code>, <code>namespaceHash</code>,
<code>nameHash</code>, and <code>objectHash</code> compute hash values for strings,
namespaces, names, and arbitrary objects, respectively.  They can take
into account their arguments' immutable structure only.

<P><span class="pcounter"></span> The implementation should strive to compute different hashcodes
for values that are not the same by <code>intrinsic::===</code>, as the utility
of this function depends on that property.  (The user program should
be able to expect that the hashcodes of objects that are not the same
are different with high probability.)

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  A typical implementation of <code>stringHash</code> will make use of the
string's character sequence and its length.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  A typical implementation of <code>objectHash</code> may make use of the
object's address in memory if the object, or it may maintain a
separate table mapping objects to hash codes.

<p class="note"><b>IMPLEMENTATION NOTE</b>&nbsp;&nbsp; The intrinsic <code>hashcode</code> function should not return
pointer values cast to integers, even in implementations that do not
use a moving garbage collector.  Exposing memory locations of objects
may make security vulnerabilities in the host environment
significantly worse.  Implementations -- in particular those which
read network input -- should return numbers unrelated to memory
addresses if possible, or at least use memory addresses subject to
some cryptographically strong one-way transformation, or sequence
numbers, cookies, or similar.


<h2>Class and Interface Properties of the Global Object</h2>

<P><span class="pcounter"></span>The class properties of the global object are defined in later sections of this Standard:
<ul>
  <li> The <code>Object</code> class is defined in section <span class="xref">class Object</span>
  <li> The <code>Function</code> class is defined in section <span class="xref">class Function</span>
  <li> The <code>Name</code> class is defined in section <span class="xref">class Name</span>
  <li> The <code>Namespace</code> class is defined in section <span class="xref">class Namespace</span>
  <li> The <code>Array</code> class is defined in section <span class="xref">class Array</span>
  <li> The <code>String</code> and <code>string</code> classes are defined in sections <span class="xref">class String</span> and <span class="xref">class string</span>, respectively.
  <li> The <code>Boolean</code> and <code>boolean</code> classes are defined in sections <span class="xref">class Boolean</span> and <span class="xref">class boolean</span>, respectively.
  <li> The <code>Number</code>, <code>double</code>, and <code>decimal</code> classes are defined in sections <span class="xref">class Number</span>, <span class="xref">class double</span>, and <span class="xref">class decimal</span>, respectively.
  <li> The <code>Date</code> class is defined in section <span class="xref">class Date</span>
  <li> The <code>RegExp</code> class is defined in section <span class="xref">class RegExp</span>
  <li> The <code>Map</code> class is defined in section <span class="xref">class Map</span>
  <li> The <code>Vector</code> class is defined in section <span class="xref">class Vector</span>
  <li> The <code>Error</code> class and its subclasses <code>EvalError</code>, <code>RangeError</code>, <code>ReferenceError</code>, <code>SyntaxError</code>, <code>TypeError</code>, and <code>URIError</code> are defined in sections <span class="xref">class Error</span>, <span class="xref">class EvalError</span>, <span class="xref">class RangeError</span>, <span class="xref">class ReferenceError</span>,  <span class="xref">class SyntaxError</span>, <span class="xref">class TypeError</span>, and <span class="xref">class URIError</span>, respectively.
</ul>


<h2>Type Properties on the Global Object</h2>

<h3>EnumerableId</h3>

<P><span class="pcounter"></span>The type <code>EnumerableId</code> is a union type of all the nominal types
that are treated as property names by the iteration protocol and the
pre-defined objects:

<PRE>
__ES4__ type EnumerableId = (int|uint|string|Name);
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Removed <code>int</code> and <code>uint</code> from this type if/when we agree that
that's the right thing.


<h3>AnyNumber</h3>

<P><span class="pcounter"></span>The type <code>AnyNumber</code> is a union type of all the nominal
types that are treated as numbers by the language:

<PRE>
__ES4__ type AnyNumber = (double|decimal|Number);
</PRE>

<h3>AnyString</h3>

<P><span class="pcounter"></span>The type <code>AnyString</code> is a union type of all the nominal
types that are treated as strings by the language:

<PRE>
__ES4__ type AnyString = (string|String);
</PRE>

<h3>AnyBoolean</h3>

<P><span class="pcounter"></span>The type <code>AnyBoolean</code> is a union type of all the nominal
types that are treated as booleans by the language:

<PRE>
__ES4__ type AnyBoolean = (boolean|Boolean);
</PRE>

<h3>Callable</h3>

<P><span class="pcounter"></span> The type <code>Callable</code> is a record type describing any object that
can be called as a function:

<PRE>
__ES4__ type Callable = { meta::invoke: * }
</PRE>



<h1 id="class Object"> The class <code>Object</code> </h1>



<P><span class="pcounter"></span> The class <code>Object</code> is a dynamic non-final class that does not
subclass any other objects: it is the root of the class hierarchy.

<P><span class="pcounter"></span> All values in ECMAScript except <b>undefined</b> and <b>null</b> are
instances of the class <code>Object</code> or one of its subclasses.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  Host objects may not be instances of <code>Object</code> or its
subclasses, but must to some extent behave as if they are (see <span class="xref">Host objects</span>).


<h2>Synopsis</h2>

<P><span class="pcounter"></span>The class <code>Object</code> provides this interface:

<PRE>
public dynamic class Object
{
    public function Object(value=undefined) &#x0085
    static meta function invoke(value=undefined) &#x0085

    static public const length = 1

    intrinsic function toString() : string &#x0085
    intrinsic function toLocaleString() : string &#x0085
    intrinsic function valueOf() : Object &#x0085
    intrinsic function hasOwnProperty(name: EnumerableId): boolean &#x0085
    intrinsic function isPrototypeOf(value): boolean &#x0085
    intrinsic function propertyIsEnumerable(name: EnumerableId): boolean &#x0085
    intrinsic function __defineProperty__(name: EnumerableId, value, enumerable:boolean=true, removable:boolean=true, writable:boolean=true): void &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>Object</code> prototype object provides these direct properties:
<PRE>
    toString:             function () &#x0085;
    toLocaleString:       function () &#x0085;
    valueOf:              function () &#x0085;
    hasOwnProperty:       function (name) &#x0085;
    isPrototypeOf:        function (value) &#x0085;
    propertyIsEnumerable: function (name) &#x0085;
    __defineProperty__:   function (name, value, enumerable=undefined, removable=undefined, writable=undefined) &#x0085;
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  It is likely that <code>__defineProperty__</code> should become a
static method on the <code>Object</code> object and that its parameters
should be passed in some other way, for example as individual
values fetched from <code>Object</code> (<code>Object.WRITABLE</code>, and so on)
or as a set of bits or'ed together from bit values fetched
from <code>Object</code>.

<P><span class="pcounter"></span> The <code>Object</code> prototype object is itself an instance of the class
<code>Object</code>, with the exception that the value of its <code>[[Prototype]]</code>
property is <b>null</b>.


<h2>Methods on the <code>Object</code> class object</h2>

<h3>new&nbsp;Object&nbsp;(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Object</code> constructor is called with an argument
<i>value</i> (defaulting to <b>undefined</b>) as part of a <code>new</code>
expression, it transforms the <i>value</i> to an object in a way that
depends on the type of <i>value</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Object</code> constructor returns an object (an instance of
<code>Object</code> or one of its subclasses, or a host object).

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The <code>Object</code> constructor is the only constructor function
defined on a class in the language whose result may be a value of a
different class than the one in which the constructor is defined.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>Object</code> constructor can't be expressed as a regular
ECMAScript constructor.  Instead it is presented below as a helper
function <code>makeObject</code> that the ECMAScript implementation will invoke
when it evaluates <code>new Object</code>.

<P><span class="pcounter"></span> The helper function <code>makeObject</code> only is invoked on native ECMAScript
values.  If <code>new Object</code> is evaluated on a host object, then actions
are taken and a result is returned in an implementation dependent
manner that may depend on the host object.

<PRE>
helper function makeObject(value=undefined) {
    switch type (value) {
    case (s: string) {
        return new String(s);
    }
    case (b: boolean) { 
        return new Boolean(b);
    }
    case (n: (int|uint|double|decimal)) { 
        return new Number(n);
    }
    case (x: (null|undefined)) { 
        return magic::createObject();
    }
    case (o: Object) {
        return o;
    }
    }
}
</PRE>


<h3>Object&nbsp;(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Object</code> class object is called as a function with zero
or one arguments it performs a type conversion.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> It returns the converted value.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(value=undefined)
    new Object(value);
</PRE>


<h2>Methods on <code>Object</code> instances</h2>

<P><span class="pcounter"></span> The intrinsic methods on <code>Object</code> instances delegate to private
methods that are also called by the prototype methods.

<h3>intrinsic::toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts the <code>this</code> object
to a string.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns the concatenation of
<code>"["</code>, <code>"object"</code>, a single space character (U+0032), the class
name of the object, and <code>"]"</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toString() : string
    private::toString();
</PRE>
<PRE>
private function toString(): string
    "[object " + <em>getClassName</em>() + "]";
</PRE>

<P><span class="pcounter"></span> The helper function <code>getClassName</code> returns the name for the
class.  This method is overridden in some of the pre-defined classes
in order to provide backward compatibility with the 3rd Edition of this
Standard: It is overridden by the class Error.

<PRE>
helper function getClassName()
    <em>getClassName</em>(this);
</PRE>

<P><span class="pcounter"></span> The function <code>helper::getClassName</code> extracts the class name
from the object.  See <span class="xref">helper:getClassName</span>.


<h3>intrinsic::toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method calls the public
<code>toString</code> method on the <code>this</code> object.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  This method is provided to give all objects a generic
<code>toLocaleString</code> interface, even though not all may use it.
Currently, <code>Array</code>, <code>Number</code>, and <code>Date</code> provide their own
locale-sensitive <code>toLocaleString</code> methods.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toLocaleString() : string
    private::toLocaleString();
</PRE>
<PRE>
private function toLocaleString()
    this.toString();
</PRE>


<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns its <code>this</code> value.

<P><span class="pcounter"></span> If the object is the result of calling the Object constructor with
a host object (see <span class="xref">Host objects</span>), it is
implementation-defined whether <code>valueOf</code> returns its <code>this</code> value
or another value such as the host object originally passed to the
constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns an object value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function valueOf() : Object
    private::valueOf();
</PRE>
<PRE>
private function valueOf(): Object
    this;
</PRE>


<h3>intrinsic::hasOwnProperty&nbsp;(&nbsp;name&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>hasOwnProperty</code> method determines whether the
<code>this</code> object contains a property with a certain <i>name</i>, without
considering the prototype chain.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; Unlike <code>[[HasProperty]]</code> (see <span class="xref">HasProperty-defn</span>), this
method does not consider objects in the prototype chain.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>hasOwnProperty</code> method returns <code>true</code> if the
object contains the property, otherwise it returns <code>false</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function hasOwnProperty(name: EnumerableId): boolean
    <em>hasOwnProperty</em>(this, name);
</PRE>
<PRE>
private function hasOwnProperty(name: EnumerableId): boolean
    <em>hasOwnProperty</em>(this, name);
</PRE>

<P><span class="pcounter"></span> The function <code>helper::hasOwnProperty</code> tests whether the object
contains the named property on its local property list (the prototype
chain is not considered).  See <span class="xref">helper:hasOwnProperty</span>.

<P><span class="pcounter"></span> The helper function <code>toEnumerableId</code> returns its argument if it
is one of the member types of <code>EnumerableId</code> (<code>int</code>, <code>uint</code>,
<code>string</code>, and <code>Name</code>) and otherwise converts the argument to
<code>string</code>.

<PRE>
helper function toEnumerableId(x) {
    switch type (x) {
    case (x: EnumerableId) { return x; }
    case (x: *)            { return string(x); }
    }
}
</PRE>


<h3>intrinsic::isPrototypeOf&nbsp;(&nbsp;value&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>isPrototypeOf</code> method determines whether its
<code>this</code> object is a prototype object of the argument <i>value</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>isPrototypeOf</code> method returns <code>true</code> if the
<code>this</code> object is on the prototype chain of <i>value</i>, otherwise it
returns <code>false</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function isPrototypeOf(value): boolean
    private::isPrototypeOf(value);
</PRE>
<PRE>
private function isPrototypeOf(value): boolean {
    if (!(value is Object))
        return false;

    let obj = value;
    while (true) {
        obj = <em>getPrototype</em>(obj);
        if (obj === null || obj === undefined)
            return false;
        if (obj === this)
            return true;
    }
}
</PRE>

<P><span class="pcounter"></span> The function <code>helper::getPrototype</code> extracts the <code>[[Prototype]]</code> property
from the object.  See <span class="xref">helper:getPrototype</span>.


<h3>intrinsic::propertyIsEnumerable&nbsp;(&nbsp;name&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>propertyIsEnumerable</code> method retrieves the
enumerability flag for a property with a certain <i>name</i> on the
<code>this</code> object, without considering the prototype chain.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>propertyIsEnumerable</code> method returns <code>false</code>
if the property does not exist on the <code>this</code> object; otherwise it
returns the value of the enumerability flag.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function propertyIsEnumerable(name: EnumerableId): boolean
    private::propertyIsEnumerable(name);
</PRE>
<PRE>
private function propertyIsEnumerable(name) {
    if (!<em>hasOwnProperty</em>(this, name))
        return false;
    return !<em>getPropertyIsEnumerable</em>(this, name);
}
</PRE>

<P><span class="pcounter"></span> The function <code>helper::hasOwnProperty</code> tests whether the object
contains the named property on its local property list.  See <span class="xref">helper:hasOwnProperty</span>.

<P><span class="pcounter"></span> The function <code>helper::getPropertyIsDontEnum</code> gets the DontEnum
flag of the property.  See <span class="xref">helper:getPropertyIsDontEnum</span>.


<h3>intrinsic::__defineProperty__&nbsp;(&nbsp;name,&nbsp;value,&nbsp;enumerable=&#x0085;,&nbsp;removable=&#x0085;,&nbsp;writable=&#x0085;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>__defineProperty__</code> method creates a new
dynamic property named <i>name</i> on this object, giving it the value
<i>value</i> and attributes determined by the parameters <i>enumerable</i>,
<i>removable</i>, and <i>writable</i>.  If the property already exists, or
if a non-writable property with the same name exists on an object in
the prototype chain of this object, then a <b>TypeError</b> exception is
thrown.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The name <code>__defineProperty__</code> (with the leading and trailing
underscores) has been chosen in order to minimize the risk of name
collisions with existing content on the web.

<p class="note"><b>IMPLEMENTATION NOTE</b>&nbsp;&nbsp;  The name <code>__defineProperty__</code> mirrors the names of the
non-standard methods <code>__defineGetter__</code> and <code>__defineSetter__</code>
that are provided by some implementations.  Those implementations may
wish to extend the non-standard methods so that they provide control
of at least enumerability and deletability in a manner compatible with
<code>__defineProperty__</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>__defineProperty__</code> method returns nothing.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function __defineProperty__(name: EnumerableId, value, enumerable:boolean=true, removable:boolean=true, writable:boolean=true): void
    private::__defineProperty__(name, value, enumerable, removable, writable);
</PRE>
<PRE>
private function __defineProperty__(name, value, enumerable, removable, writable) {
    if (<em>hasOwnProperty</em>(this, name))
        throw new TypeError(/* Property exists */);

    let obj = <em>getPrototype</em>(this);
    while (obj != null) {
        if (<em>hasOwnProperty</em>(obj, name) && !<em>getPropertyIsWritable</em>(obj, name))
            throw new TypeError(/* non-Writable property in prototype chain */);
        obj = <em>getPrototype</em>(obj);
    }

    this[name] = value;
    <em>setPropertyIsEnumerable</em>(this, name, enumerable);
    <em>setPropertyIsRemovable</em>(this, name, removable);
    <em>setPropertyIsWritable</em>(this, name, writable);
}
</PRE>

<P><span class="pcounter"></span> The function <code>helper::hasOwnProperty</code> tests whether the object
contains the named property on its local property list.  See <span class="xref">helper:hasOwnProperty</span>.

<P><span class="pcounter"></span> The function <code>helper::getPrototype</code> extracts the <code>[[Prototype]]</code> property
from the object.  See <span class="xref">helper:getPrototype</span>.

<P><span class="pcounter"></span> The functions <code>helper::getPropertyIsDontEnum</code>,
<code>helper::getPropertyIsDontDelete</code>, and <code>helper::getPropertyIsReadOnly</code>
retrieve the attribute flags of the property.  See 
<span class="xref">helper:getPropertyIsDontEnum</span>,
<span class="xref">helper:getPropertyIsDontDelete</span>, and
<span class="xref">helper:getPropertyIsReadOnly</span>.

<P><span class="pcounter"></span> The functions <code>helper::setPropertyIsDontEnum</code>,
<code>helper::setPropertyIsDontDelete</code>, and <code>helper::setPropertyIsReadOnly</code>
set the attribute flags of the property.  See 
<span class="xref">helper:setPropertyIsDontEnum</span>,
<span class="xref">helper:setPropertyIsDontDelete</span>, and
<span class="xref">helper:setPropertyIsReadOnly</span>.


<h2>Methods on the <code>Object</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods on the <code>Object</code> prototype object all perform
simple type adjustments and then perform the same actions as the
corresponding intrinsic methods.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The prototype methods return what their corresponding intrinsic
methods return.

<P class="implsection"><b>Implementation</b>
<PRE>
public prototype function toString()
    this.private::toString();
</PRE>
<PRE>
public prototype function toLocaleString()
    this.private::toLocaleString();
</PRE>
<PRE>
public prototype function valueOf()
    this.private::valueOf();
</PRE>
<PRE>
public prototype function hasOwnProperty(name)
    this.private::hasOwnProperty(<em>toEnumerableId</em>(name));
</PRE>
<PRE>
public prototype function isPrototypeOf(value)
    this.private::isPrototypeOf(value);
</PRE>
<PRE>
public prototype function propertyIsEnumerable(name)
    this.private::propertyIsEnumerable(<em>toEnumerableId</em>(name));
</PRE>
<PRE>
public prototype function __defineProperty__(name, value, enumerable=undefined, removable=undefined, writable=undefined)
    this.private::__defineProperty__(<em>toEnumerableId</em>(name),
                                     value,
                                     enumerable === undefined ? true : boolean(enumerable),
                                     removable === undefined ? true : boolean(removable),
                                     writable === undefined ? true : boolean(writable));
</PRE>




<h1 id="class Function"> The class <code>Function</code> </h1>



<P><span class="pcounter"></span> The class <code>Function</code> is a dynamic, non-final, direct subclass of
<code>Object</code> (see <span class="xref">class Object</span>).

<P><span class="pcounter"></span> All objects defined by <code>function</code> definitions or expressions in
ECMAScript are instances of the class <code>Function</code>.

<P><span class="pcounter"></span> Not all objects that can be called as functions are instances of
subclasses of the <code>Function</code> class, however.  Any object that has a
<code>meta::invoke</code> property can be called as a function.

<P><span class="pcounter"></span> The structural type <code>Callable</code> (see <span class="xref">type:Callable</span>) 
matches every object that has a <code>meta::invoke</code> property.


<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Function</code> provides the following interface:

<PRE>
dynamic class Function extends Object
{
    public function Function(...args) &#x0085
    static meta function invoke(...args) &#x0085

    static public function apply(fn: Callable, thisArg: Object=null, argArray: Object=null) &#x0085
    static public function bind(method: Callable, thisObj: Object, ...args) &#x0085
    static public function call(fn: Callable, thisObj: Object=null, ...args) &#x0085

    static public const length = 1

    meta final function invoke( &#x0085; ) &#x0085;

    override intrinsic function toString() : string &#x0085

    intrinsic function apply(thisArg: Object=null, argArray: Object=null) &#x0085
    intrinsic function bind(thisObj: Object, ...args) &#x0085
    intrinsic function call(thisObj: Object=null, ...args) &#x0085

    public const length = &#x0085;
    public var   prototype = &#x0085;
}
</PRE>

<P><span class="pcounter"></span>The <code>Function</code> prototype object provides these direct properties:

<PRE>
    meta::invoke: function () &#x0085;
    length:       0
    toString:     function () &#x0085;
    apply:        function(thisArg, argArray) &#x0085;
    bind:         function(thisArg, ...args) &#x0085;
    call:         function(thisArg, ...args) &#x0085;
</PRE>


<h2>Methods on the <code>Function</code> class object</h2>

<H3 id="Function: constructor"> new Function (p1, p2, &#x0085; , pn, body) </h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Function</code> constructor is called with some arguments
as part of a <code>new</code> expression, it creates a new <code>Function</code>
instance whose parameter list is given by the concatenation of the
<i>p<SUB>i</SUB></i> arguments separated by "," and whose executable code
is given by the <i>body</i> argument.

<P><span class="pcounter"></span> There may be no <i>p<SUB>i</SUB></i> arguments, and <i>body</i> is optional too,
defaulting to the empty string.

<P><span class="pcounter"></span> If the first character of the comma-separated concatenation of the
<i>p<SUB>i</SUB></i> is a left parenthesis then the list of parameters
must be parseable as a <i>FormalParameterList<sub>opt</sub></i> enclosed
in parentheses and optionally followed by a colon and a return type.

<P><span class="pcounter"></span> Otherwise, the list of parameters must be parsable as a
<i>FormalParameterList<sub>opt</sub></i>.

<P><span class="pcounter"></span> If the list of parameters is not parseable as outlined in the
previous two paragraphs, or if the body is not parsable as a
<i>FunctionBody</i>, then a <b>SyntaxError</b> exception is thrown (see the
grammar in section <span class="xref">ECMAScript grammar</span>).

<P><span class="pcounter"></span> Regardless of the form of the parameter list, it may include type
annotations, default parameter values, and rest arguments.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  It appears likely that the <code>Function</code> constructor needs to
accept a version parameter so that the keyword set can be controlled,
as is the case for <code>eval</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Function</code> constructor returns a new <code>Function</code> instance.

<P class="implsection"><b>Implementation</b>
<PRE>
public function Function(...args)
    <em>createFunction</em>(args);
</PRE>
<PRE>
helper function createFunction(args) {
    let parameters = "";
    let body = "";
    if (args.length > 0) {
        body = args[args.length-1];
        args.length = args.length-1;
        parameters = args.join(",");
    }
    body = string(body);
    <em>initializeFunction</em>(this, __ES4__::global, parameters, body);
}
</PRE>

<P><span class="pcounter"></span> The magic function <code>initializeFunction</code> initializes the function
object <code>this</code> from the list of parameters and the body, as specified
in section <span class="xref">translation:FunctionExpression</span>.  The global
object is passed in as the scope parameter.

<P><span class="pcounter"></span>A <code>prototype</code> object is automatically created for every function,
to provide for the possibility that the function will be used as a
constructor.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  It is permissible but not necessary to have one argument for
each formal parameter to be specified. For example, all three of the
following expressions produce the same result:

<PRE>
new Function("a", "b", "c", "return a+b+c")

new Function("a, b, c", "return a+b+c")

new Function("a,b", "c", "return a+b+c")
</PRE>


<h3 id="Function: static meta invoke">Function&nbsp;(p1,&nbsp;p2,&nbsp;&#x0085;&nbsp;,&nbsp;pn,&nbsp;body)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Function</code> class object is called as a function it
creates and initialises a new <code>Function</code> object.  Thus the function
call <code>Function(&#x0085;)</code> is equivalent to the object creation
expression <code>new Function(&#x0085;)</code> with the same arguments.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Function</code> class object called as a function returns a
new <code>Function</code> instance.

<P class="implsection"><b>Implementation</b>

<PRE>
meta static function invoke(...args)
    new Function(...args);
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Ticket #357: That particular definition makes use of the
prefix "spread" operator, which has not yet been formally accepted
into the language.

<h3>apply&nbsp;(&nbsp;fn,&nbsp;thisArg=&#x0085;,&nbsp;argArray=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>apply</code> method takes arguments <i>fn</i>,
<i>thisArg</i>, and <i>argArray</i> and invokes <i>fn</i> in the standard
manner, passing <i>thisArg</i> as the value for <code>this</code> and the members
of <i>argArray</i> as the individual argument values.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>apply</code> method returns the value returned by <i>fn</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
static public function apply(fn: Callable, thisArg: Object=null, argArray: Object=null) {
    if (argArray === null)
        argArray = [];
    return <em>apply</em>(fn, thisArg, argArray);
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The magic <code>apply</code> function performs the actual invocation (see
<span class="xref">magic::apply</span>).  This code will eventually change to
use the prefix "spread" operator.



<h3>bind&nbsp;(&nbsp;fn,&nbsp;thisArg=&#x0085;,&nbsp;...args&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>bind</code> method takes arguments <i>fn</i>, <i>thisArg</i>,
and optionally some <i>args</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>bind</code> method returns a <code>Function</code> object that accepts
some arguments <i>moreargs</i> and which calls <i>fn</i> with <i>thisArg</i> as
the <code>this</code> object and the values of <i>args</i> and <i>moreargs</i> as
actual arguments.

<P class="implsection"><b>Implementation</b>
<PRE>
static public function bind(method: Callable, thisObj: Object, ...args)
    <em>bind</em>(method, thisObj, args);
</PRE>
<PRE>
static helper function bind(method, thisObj, args) {
    return function (...moreargs)
               method.apply(thisObj, args.concat(moreargs));
}
</PRE>


<h3>call&nbsp;(&nbsp;fn,&nbsp;thisArg=&#x0085;,&nbsp;...args&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>call</code> method takes arguments <i>fn</i> and
<i>thisArg</i> and optionally some <i>args</i> and invokes <i>fn</i> in the
standard manner, passing <i>thisArg</i> as the value for <code>this</code> and the
members of <i>args</i> as the individual argument values.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>call</code> method returns the value returned by <i>fn</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
static public function call(fn: Callable, thisObj: Object=null, ...args)
    Function.apply(fn, thisObj, args);
</PRE>



<h2>Methods on Function instances</h2>

<h3>meta::invoke&nbsp;(&nbsp;&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The meta method <code>invoke</code> is specialized to the individual
<code>Function</code> object.  When called, it evaluates the executable code
for the function.

<P><span class="pcounter"></span> The meta method <code>invoke</code> is typically called by the ECMAScript
implementation as part of the function invocation and object
construction protocols.  When a function or method is invoked, the
<code>invoke</code> method of the function or method object provides the code
to run.  When a function is used to construct a new object, the
<code>invoke</code> method provides the code for the constructor function.

<P><span class="pcounter"></span> The signature of the meta method <code>invoke</code> is determined when the
<code>Function</code> instance is created, and is determined by the text that
defines the function being created.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The meta method <code>invoke</code> is <code>final</code>; therefore subclasses
can add properties and methods but can't override the function calling
behavior.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #173.)  While it is necessary that the <code>invoke</code>
method is completely magic in <code>Function</code> instances, it's not clear
that it needs to be magic for instances of subclasses of <code>Function</code>,
because these can be treated like other objects that have <code>invoke</code>
methods (and which already work just fine in the reference
implementation).  Therefore it should not be <code>final</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The meta method <code>invoke</code> returns the value produces by the
first <code>return</code> statement that is evaluated during the evaluation of
the executable code for the function represented by this <code>Function</code>
object.

<h3>intrinsic::toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts the executable code
of the function to a string representation.  This representation has
the syntax of a <i>FunctionDeclaration</i> or <i>FunctionExpression</i>.
Note in particular that the use and placement of white space, line
terminators, and semicolons within the representation string is
implementation-dependent.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; ES3 required the syntax to be that of a <i>FunctionDeclaration</i>
only, but that made it impossible to produce a string representation
for functions created from unnamed function expressions.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString() : string
    private::toString();
</PRE>

<P><span class="pcounter"></span> The private function <code>toString</code> is implementation-dependent.


<h3>intrinsic::apply&nbsp;(&nbsp;thisObj=&#x0085;,&nbsp;args=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>apply</code> method calls the static <code>apply</code> method
with the value of <code>this</code> as the first argument.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>apply</code> method returns the result of the static
<code>apply</code> method.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function apply(thisArg: Object=null, argArray: Object=null)
    Function.apply(this, thisArg, argArray);
</PRE>


<h3>intrinsic::bind&nbsp;(&nbsp;thisObj=&#x0085;,&nbsp;...args)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>bind</code> method calls the static <code>bind</code> method
with the value of <code>this</code> as the first argument.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>bind</code> method returns the result of the static
<code>bind</code> method.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function bind(thisObj: Object, ...args)
    Function.<em>bind</em>(this, thisObj, args);
</PRE>


<h3>intrinsic::call&nbsp;(&nbsp;thisObj=&#x0085;,&nbsp;...args)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The intrinsic <code>call</code> method calls the static <code>apply</code> method
with the value of <code>this</code> as the first argument.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>call</code> method returns the result of the static
<code>call</code> method.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function call(thisObj: Object=null, ...args)
    Function.apply(this, thisObj, args);
</PRE>


<h2>Value properties of <code>Function</code> instances</h2>

<h3>length</h3>

<P><span class="pcounter"></span> The value of the constant <code>length</code> property is the number of
non-rest arguments accepted by the function.

<P><span class="pcounter"></span> The value of the <code>length</code> property is an integer that indicates
the "typical" number of arguments expected by the function.  However,
the language permits the function to be invoked with some other number
of arguments.  The behaviour of a function when invoked on a number of
arguments other than the number specified by its length property
depends on the function.


<h3>prototype</h3>

<P><span class="pcounter"></span> The initial value of the <code>prototype</code> property is a fresh
<code>Object</code> instance.

<P><span class="pcounter"></span> The value of the <code>prototype</code> property is used to initialise the
internal <code>[[Prototype]]</code> property of a newly created object before the
<code>Function</code> instance is invoked as a constructor for that newly
created object.


<h2>Invoking the <code>Function</code> prototype object</h2>

<P><span class="pcounter"></span> When the <code>Function</code> prototype object is invoked it accepts any
arguments and returns <b>undefined</b>:

<PRE>
public prototype meta function invoke(...args)
    undefined;
</PRE>


<h2>Methods on the <code>Function</code> prototype object</h2>

<P><span class="pcounter"></span> The methods on the <code>Function</code> prototype object perform simple
type adjustments and then perform the same actions as their intrinsic
counterparts:

<PRE>
public prototype function toString(this: Function)
    this.private::toString();
</PRE>
<PRE>
public prototype function apply(this: Callable, thisArg=undefined, argArray=undefined)
    Function.apply(this,
                   thisArg === undefined ? null : thisArg,
                   argArray === undefined ? null : argArray);
</PRE>
<PRE>
public prototype function bind(this: Callable, thisObj, ...args)
    Function.<em>bind</em>(this, thisObj, args);
</PRE>
<PRE>
public prototype function call(this: Callable, thisObj=undefined, ...args)
    Function.apply(this,
                   thisObj === undefined ? null : thisObj,
                   args);
</PRE>


<h2>Value properties on the <code>Function</code> prototype object</h2>

<h3>length</h3> 

<P><span class="pcounter"></span> The initial value of the <code>length</code> prototype property is 0.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span>
<PRE>
public prototype var length : double = 0;
</PRE>

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The "length" property of the prototype is not obviously
required by the 3rd Edition of this Standard, but MSIE, Firefox,
Opera, and Safari all provide it.




<H1 id="class Name"> The class <code>Name</code> </H1>



<P><span class="pcounter"></span> The class <code>Name</code> is a final, nullable, non-dynamic, direct
subclass of <code>Object</code> that reflects a property name as a pair of
<code>Namespace</code> and <code>string</code> values.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The <code>Namespace</code> class is new in the 4th Edition of this Standard.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Name</code> provides the following interface:

<PRE>
__ES4__ final class Name extends Object
{
    public function Name(...args) &#x0085;
    static meta function invoke(...args): Name &#x0085;
    
    static public const length = 2

    override intrinsic function toString() : string &#x0085

    public const qualifier:  Namespace
    public const identifier: string
}
</PRE>

<P><span class="pcounter"></span> The <code>Name</code> prototype object provides the following direct properties:

<PRE>
    toString: function (this: Name) &#x0085;
</PRE>

<h2>Operators</h2>

<P><span class="pcounter"></span> Two <code>Name</code> objects are equal (by <code>==</code> and <code>===</code>) if and only
if their <code>qualifier</code> properties are equal and their <code>identifier</code>
properties are equal (by the operator used to compare the <code>Name</code>
objects).

<h2>Methods on the <code>Name</code> class object</h2>

<h3>new&nbsp;Name&nbsp;(&nbsp;x&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> When the <code>Name</code> constructor is called with one argument <i>x</i>
then <i>x</i> must be either a <code>Name</code> object, a <code>string</code>, a
<code>String</code>, or an integer in the range 0 through 2<SUP>32</SUP>-1.  If
<i>x</i> is a <code>Name</code> object then <i>x</i> is returned.  Otherwise <i>x</i> is
converted to a string and a <code>Name</code> object is returned whose
<code>qualifier</code> is the public namespace and whose <code>identifier</code> is the
converted value of <i>x</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
public function Name( id ) &#x0085;
</PRE>

<h3>new&nbsp;Name(&nbsp;x,&nbsp;y&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> When the <code>Name</code> constructor is called with two arguments
<i>x</i> and <i>y</i> it returns a <code>Name</code> object constructed from its
arguments.  The value of <i>x</i> must be a <code>Namespace</code> object.  The
value of <i>y</i> must be a <code>string</code>, a <code>String</code>, or an integer in
the range 0 through 2<SUP>32</SUP>-1.  The <code>qualifier</code> of the
returned value is <i>x</i>.  The <code>identifier</code> of the returned value is
the value of <i>y</i> converted to string.

<P class="implsection"><b>Implementation</b>
<PRE>
public function Name( ns: Namespace?, id ) &#x0085;
</PRE>

<h3>Name&nbsp;(&nbsp;...args&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>Name</code> class object called as a function creates a
<code>Name</code> object by invoking the <code>Name</code> constructor on its
argument(s).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Name</code> class object called as a function returns a
<code>Name</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke( ...args ): Name!
    new Name(...args);
</PRE>

<h2>Methods on <code>Name</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts this <code>Name</code> object
to a string.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString() : string
    private::toString();
</PRE>
<PRE>
private function toString() : string {
    if (qualifier === public)
        return identifier;
    return string(qualifier) + "::" + identifier;
}
</PRE>


<h2>Value properties of <code>Name</code> instances</h2>

<h3>qualifier</h3>

<P><span class="pcounter"></span> The <code>qualifier</code> property holds the namespace value for this
<code>Name</code> object.  If <code>qualifier</code> is null then the implied namespace
is the compatibility namespace <b>noNS</b>.

<h3>identifier</h3>

<P><span class="pcounter"></span> The <code>identifier</code> property holds the identifier value for this
<code>Name</code> object.  It is never null.


<h2>Methods on the <code>Name</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods on the <code>Name</code> prototype object perform the same
operations as their corresponding intrinsic methods perform.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The methods on the <code>Name</code> prototype object return what their
corresponding intrinsic methods return.

<P class="implsection"><b>Implementation</b>
<PRE>
public prototype function toString(this : Name)
    this.private::toString();
</PRE>


 
<H1 id="class Namespace"> The class <code>Namespace</code> </H1>



<P><span class="pcounter"></span> The class <code>Namespace</code> is a final, non-dynamic, nullable,
direct subclass of <code>Object</code>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  <code>Namespace</code> values can be created by <code>new</code> expressions in
the user program or by the evaluation of a <code>namespace</code> definition,
which creates a new namespace and a constant binding for it.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The <code>Namespace</code> class is new in the 4th Edition of this
Standard.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Namespace</code> provides the following interface:

<PRE>
__ES4__ final class Namespace extends Object
{
    public function Namespace(name=undefined) &#x0085;
    static meta function invoke(x) &#x0085;

    static public const length = 1

    override intrinsic function toString(): string &#x0085;

    const name: (string|undefined) &#x0085;
}
</PRE>

<P><span class="pcounter"></span> The <code>Namespace</code> prototype object provides the following direct
properties:

<PRE>
    toString: function () &#x0085;
</PRE>


<h2>Operators</h2>

<P><span class="pcounter"></span> The operators <code>==</code> and <code>===</code> compare forgeable <code>Namespace</code>
objects by comparing their names as obtained by the <code>name</code> accessor,
see below.  Forgeable namespaces with the same name are equal by those
operators.

<P><span class="pcounter"></span> In all other cases, <code>Namespace</code> objects are equal only to
themselves.


<h2>Methods on the <code>Namespace</code> class object</h2>

<h3>new&nbsp;Namespace(name=&#x0085;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> When the <code>Namespace</code> constructor is called with no arguments
or with the argument <b>undefined</b> it returns a new unforgeable
<code>Namespace</code> object.  The returned object is unequal to every
previously existing <code>Namespace</code> object.

<P><span class="pcounter"></span> When the <code>Namespace</code> constructor is called with an argument
<i>name</i> that is not <b>undefined</b> it converts <i>name</i> to string and
returns a new forgeable namespace whose name is the converted value.

<P class="implsection"><b>Implementation</b>
<PRE>
public function Namespace(name=undefined) &#x0085;
</PRE>

<h3>Namespace(x)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Namespace</code> class object called as a function returns a
<code>Namespace</code> object.  If <i>x</i> is a <code>Namespace</code> object then it is
returned.  Otherwise a new <code>Namespace</code> object is constructed by 
invoking the <code>Namespace</code> constructor on <i>x</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke( x ): Namespace! {
    if (x is Namespace!)
        return x;
    return new Namespace(x);
}
</PRE>

<h2>Methods on <code>Namespace</code> instances</h2>

<h3>intrinsic::toString()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts the <code>Namespace</code>
object to a string.  If the <code>Namespace</code> object is forgeable (it was
created with an explicit name) then the string returned by
<code>toString</code> contains the name as a substring.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>toString</code> method returns an implementation-defined
string.  

<P><span class="pcounter"></span> Suppose the intrinsic <code>toString</code> method is invoked on two
namespaces <i>N1</i> and <i>N2</i> yielding strings <i>T1</i> and <i>T2</i>,
respectively.  <i>T1</i> and <i>T2</i> are equal if and only if <i>N1</i> is
equal to <i>N2</i> (by <code>===</code> or <code>==</code>).

<P><span class="pcounter"></span> Suppose the intrinsic <code>toString</code> method is invoked on two
different forgeable namespaces <i>N1</i> and <i>N2</i> created from strings
<i>S1</i> and <i>S2</i>, yielding strings <i>T1</i> and <i>T2</i>, respectively.
<i>T1</i> and <i>T2</i> have the same relationship (determined by the
relational operators) as <i>S1</i> and <i>S2</i>.


<h2>Value Properties on <code>Namespace</code> instances</h2>

<h3>name</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> If this <code>Namespace</code> object is a forgeable namespace then the
value of the property <code>name</code> is the string name with which the
namespace was constructed.

<P><span class="pcounter"></span> If this <code>Namespace</code> object is an unforgeable namespace then the
value of the property <code>name</code> is <b>undefined</b>.


<h2>Methods on the <code>Namespace</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods on the <code>Namespace</code> prototype object delegate to
their corresponding intrinsic methods.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The methods on the <code>Namespace</code> prototype object return what
their corresponding intrinsic methods return.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this:Namespace)
    this.intrinsic::toString()
</PRE>
 


<H1 id="class Array"> The class <code>Array</code> </H1>



<P><span class="pcounter"></span> The class <code>Object</code> is a dynamic non-final subclass of <code>Object</code>
(see <span class="xref">class Object</span>).

<P><span class="pcounter"></span> Array objects give special treatment to a certain class of
property names.  A property name that can be interpreted as an
unsigned integer less than 2<sup>32</sup>-1 is an <i>array index</i>.

<P><span class="pcounter"></span> A property name <i>P</i> (in the form of a string value) is an array
index if and only if <i>string(uint(P))</i> is equal to <i>P</i> and
<i>uint(P)</i> is not equal to 2<sup>32</sup>-1.

<P><span class="pcounter"></span> Every <code>Array</code> object has a <code>length</code> property whose value is
always a nonnegative integer less than 2<sup>32</sup>.  The value of
the <code>length</code> property is numerically greater than the name of every
property whose name is an array index; whenever a property of an Array
object is created or changed, other properties are adjusted as
necessary to maintain this invariant.  Specifically, whenever a
property is added whose name is an array index, the <code>length</code>
property is changed, if necessary, to be one more than the numeric
value of that array index; and whenever the <code>length</code> property is
changed, every property whose name is an array index whose value is
not smaller than the new length is automatically deleted.  This
constraint applies only to properties of the Array object itself and
is unaffected by <code>length</code> or array index properties that may be
inherited from its prototype.

<P><span class="pcounter"></span> The set of <i>array elements</i> held by any object (not just
<code>Array</code> objects) are those properties of the object that are named
by array indices numerically less than the object's <code>length</code>
property.  (If the object has no <code>length</code> property then its value is
assumed to be zero, and the object has no array elements.)

<h2>Synopsis</h2>

<P><span class="pcounter"></span>The Array class provides the following interface:

<PRE>
dynamic class Array extends Object
{
    function Array(...args) &#x0085;
    static meta function invoke(...items) &#x0085

    static function concat(object/*: Object!*/, ...items): Array &#x0085
    static function every(object/*:Object!*/, checker/*:function*/, thisObj:Object=null): boolean &#x0085 
    static function filter(object/*:Object!*/, checker/*function*/, thisObj:Object=null): Array &#x0085
    static function forEach(object/*:Object!*/, eacher/*function*/, thisObj:Object=null): void &#x0085
    static function indexOf(object/*:Object!*/, value, from:AnyNumber=0): AnyNumber &#x0085
    static function join(object/*: Object!*/, separator: string=","): string &#x0085
    static function lastIndexOf(object/*:Object!*/, value, from:AnyNumber=NaN): AnyNumber &#x0085
    static function map(object/*:Object!*/, mapper/*:function*/, thisObj:Object=null): Array &#x0085
    static function pop(object/*:Object!*/) &#x0085
    static function push(object/*: Object!*/, ...args): double &#x0085
    static function reverse(object/*: Object!*/)/*: Object!*/ &#x0085
    static function shift(object/*: Object!*/) &#x0085
    static function slice(object/*: Object!*/, start: AnyNumber, end: AnyNumber, step: AnyNumber) &#x0085
    static function some(object/*:Object!*/, checker/*:function*/, thisObj:Object=null): boolean &#x0085
    static function sort(object/*: Object!*/, comparefn) &#x0085
    static function splice(object/*: Object!*/, start: AnyNumber, deleteCount: AnyNumber, ...items): Array &#x0085
    static function unshift(object/*: Object!*/, ...items) : double &#x0085

    static const length = 1

    override intrinsic function toString():string &#x0085
    override intrinsic function toLocaleString():string &#x0085
    intrinsic function concat(...items): Array &#x0085
    intrinsic function every(checker:Checker, thisObj:Object=null): boolean &#x0085
    intrinsic function filter(checker:Checker, thisObj:Object=null): Array &#x0085
    intrinsic function forEach(eacher:Eacher, thisObj:Object=null): void &#x0085
    intrinsic function indexOf(value, from:AnyNumber=0): AnyNumber &#x0085
    intrinsic function join(separator: string=","): string &#x0085
    intrinsic function lastIndexOf(value, from:AnyNumber=NaN): AnyNumber &#x0085
    intrinsic function map(mapper:Mapper, thisObj:Object=null): Array &#x0085
    intrinsic function pop() &#x0085
    intrinsic function push(...args): double &#x0085
    intrinsic function reverse()/*: Object!*/ &#x0085
    intrinsic function shift() &#x0085
    intrinsic function slice(start: AnyNumber, end: AnyNumber, step: AnyNumber): Array &#x0085
    intrinsic function some(checker:Checker, thisObj:Object=null): boolean &#x0085
    intrinsic function sort(comparefn:Comparator):Array &#x0085
    intrinsic function splice(start: AnyNumber, deleteCount: AnyNumber, ...items): Array &#x0085
    intrinsic function unshift(...items): double &#x0085

    function get length(): uint &#x0085;
    function set length(len: uint): void &#x0085;
}
</PRE>

<P><span class="pcounter"></span> The <code>Array</code> prototype object provides these direct properties:

<PRE>
   toString:       function () &#x0085; ,
   toLocaleString: function () &#x0085; ,
   concat:         function (...items) &#x0085; ,
   every:          function (checker, thisObj=null) &#x0085; ,
   filter:         function (checker, thisObj=null) &#x0085; ,
   forEach:        function (eacher, thisObj=null) &#x0085; ,
   indexOf:        function (value, from=0) &#x0085; ,
   join:           function (separator=",") &#x0085; ,
   lastIndexOf:    function (value, from=Infinity) &#x0085; ,
   map:            function (mapper, thisObj=null) &#x0085; ,
   pop:            function () &#x0085; ,
   push:           function (...items) &#x0085; ,
   reverse:        function () &#x0085; ,
   shift:          function () &#x0085; ,
   slice:          function (start=0, end=Infinity) &#x0085; ,
   some:           function (checker, thisObj=null) &#x0085; ,
   sort:           function (comparefn=undefined) &#x0085; ,
   splice:         function (start, deleteCount, ...items) &#x0085; ,
   unshift:        function (...items) &#x0085; ,
   length:         &#x0085;
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  We've since also included <code>reduce</code> and <code>reduceRight</code> as static,
intrinsic, and prototype methods.


<h2>Methods on the <code>Array</code> class object</h2>

<P><span class="pcounter"></span> The <code>Array</code> class provides a number of static methods for
manipulating array elements: <code>concat</code>, <code>every</code>, <code>filter</code>,
<code>forEach</code>, <code>indexOf</code>, <code>join</code>, <code>lastIndexOf</code>, <code>map</code>, <code>pop</code>,
<code>push</code>, <code>reverse</code>, <code>shift</code>, <code>slice</code>, <code>some</code>, <code>sort</code>,
<code>splice</code>, and <code>unshift</code>.  These static methods are intentionally
<i>generic</i>; they do not require that their <i>object</i> argument
be an <code>Array</code> object.  Therefore they can be applied to other kinds
of objects as well.  Whether the generic Array methods can be applied
successfully to a host object is implementation-dependent.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; The static generic methods on the Array class are all new in 4th
edition.


<h3>new&nbsp;Array&nbsp;(&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Array</code> constructor is called with some set of
arguments <i>items</i> as part of a <code>new&nbsp;Array</code> expression, it
initializes the <code>Array</code> object from its argument values.

<P><span class="pcounter"></span> If there is exactly one argument of any number type, then its
value is taken to be the initial value of the <code>length</code> property.
The value must be a nonnegative integer less than 2<sup>32</sup>.

<P><span class="pcounter"></span> If there are zero or more than one arguments, the arguments are
taken to be the initial values of array elements, and there will be
as many elements as there are arguments.

<P class="implsection"><b>Implementation</b>
<PRE>
function Array(...items) {
    if (items.length === 1) {
        let item = items[0];
        if (item is AnyNumber) {
            if (intrinsic::toUint(item) === item)
                this.length = intrinsic::toUint(item);
            else
                throw new RangeError("Invalid array length");
        }
        else {
            this.length = 1;
            this[0] = item;
        }
    }
    else {
        this.length = items.length;
        for ( let i=0, limit=items.length ; i &#60; limit ; i++ )
            this[i] = items[i];
    }
}
</PRE>


<h3>Array&nbsp;(&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When <code>Array</code> class is called as a function rather than as a
constructor, it creates and initialises a new <code>Array</code> object.  Thus
the function call <code>Array(&#x0085;)</code> is equivalent to the object
creation expression new <code>Array(&#x0085;)</code> with the same arguments.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Array</code> class called as function returns a new <code>Array</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(...items) {
    if (items.length == 1)
        return new Array(items[0]);
    else
        return items;
}
</PRE>


<h3>concat&nbsp;(&nbsp;object,&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>concat</code> method collects the array elements from
<i>object</i> followed by the array elements from the additional
<i>items</i>, in order, into a new Array object.  All the <i>items</i> must
be objects.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>concat</code> method returns a new <code>Array</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
static function concat(object/*: Object!*/, ...items): Array
    <em>concat</em>(object, items);
</PRE>
<PRE>
helper static function concat(object/*: Object!*/, items: Array): Array {
    let out = new Array;

    let function emit(x) {
        if (x is Array) {
            for (let i=0, limit=x.length ; i &#60; limit ; i++)
                out[out.length] = x[i];
        }
        else
            out[out.length] = x;
    }

    emit( object );
    for (let i=0, limit=items.length ; i &#60; limit ; i++)
        emit( items[i] );

    return out;
}
</PRE>

<P><span class="pcounter"></span>The helper <code>concat</code> method is also used by the intrinsic and
prototype variants of <code>concat</code>.


<h3>every&nbsp;(&nbsp;object,&nbsp;checker,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>every</code> method calls <i>checker</i> on every array
element of <i>object</i> in increasing numerical index order, stopping as
soon as any call returns <b>false</b>.

<P><span class="pcounter"></span><i>Checker</i> is called with three arguments: the property value, the
property index, and <i>object</i> itself.  The <i>thisObj</i> is used as the
<code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>every</code> method returns <b>true</b> if all the calls to
<i>checker</i> returned true values, otherwise it returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function every(object/*:Object!*/, checker/*:function*/, thisObj:Object=null): boolean {

    if (typeof checker != "function")
        throw new TypeError("Function object required to 'every'");

    for (let i=0, limit=object.length ; i &#60; limit ; i++) {
        if (i in object)
            if (!checker.call(thisObj, object[i], i, object))
                return false;
    }
    return true;
}
</PRE>


<h3>filter&nbsp;(&nbsp;object,&nbsp;checker,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>filter</code> method calls <i>checker</i> on every array element
of <i>object</i> in increasing numerical index order, collecting all the
array elements for which checker returns a true value.

<P><span class="pcounter"></span> <i>Checker</i> is called with three arguments: the property value, the
property index, and <i>object</i> itself.  The <i>thisObj</i> is used as the
<code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>filter</code> method returns a new <code>Array</code> object
containing the elements that were collected, in the order they were
collected.

<P class="implsection"><b>Implementation</b>
<PRE>
static function filter(object/*:Object!*/, checker/*function*/, thisObj:Object=null): Array {

    if (typeof checker != "function")
        throw new TypeError("Function object required to 'filter'");

    let result = [];
    for (let i = 0, limit=object.length ; i &#60; limit ; i++) {
        if (i in object) {
            let item = object[i];
            if (checker.call(thisObj, item, i, object))
                result[result.length] = item;
        }
    }
    return result;
}
</PRE>


<h3>forEach&nbsp;(&nbsp;object,&nbsp;eacher,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>forEach</code> method calls <i>eacher</i> on every array
element of <i>object</i> in increasing numerical index order, discarding
any return value of <i>eacher</i>.

<P><span class="pcounter"></span> <i>Eacher</i> is called with three arguments: the property value, the
property index, and <i>object</i> itself.  The <i>thisObj</i> is used as the
<code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>forEach</code> method does not return a value.

<P class="implsection"><b>Implementation</b>
<PRE>
static function forEach(object/*:Object!*/, eacher/*function*/, thisObj:Object=null): void {

    if (typeof eacher != "function")
        throw new TypeError("Function object required to 'forEach'");

    for (let i=0, limit = object.length ; i &#60; limit ; i++)
        if (i in object)
            eacher.call(thisObj, object[i], i, object);
}
</PRE>


<h3>indexOf&nbsp;(&nbsp;object,&nbsp;value,&nbsp;from=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>indexOf</code> method compares <i>value</i> with every
array element of <i>object</i> in increasing numerical index order,
starting at the index <i>from</i>, stopping when an array element is
equal to <i>value</i> by the <code>===</code> operator.

<P><span class="pcounter"></span> <i>From</i> is rounded toward zero before use.  If <i>from</i> is
negative, it is treated as <code><i>object</i>.length+<i>from</i></code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>indexOf</code> method returns the array index the first
time <i>value</i> is equal to an element, or -1 if no such element is
found.

<P class="implsection"><b>Implementation</b>
<PRE>
static function indexOf(object/*:Object!*/, value, from:AnyNumber=0): AnyNumber {
    let len = object.length;

    from = from &#60; 0 ? Math.ceil(from) : Math.floor(from);
    if (from &#60; 0)
        from = from + len;

    while (from &#60; len) {
        if (from in object)
            if (value === object[from])
                return from;
        from = from + 1;
    }
    return -1;
}
</PRE>


<h3>join&nbsp;(&nbsp;object,&nbsp;separator=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>join</code> method concatenates the string
representations of the array elements of <i>object</i> in increasing
numerical index order, separating the individual strings by
occurrences of <i>separator</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>join</code> method returns the complete concatenated
string.

<P class="implsection"><b>Implementation</b>
<PRE>
static function join(object/*: Object!*/, separator: string=","): string {
    let out = "";

    for (let i=0, limit=intrinsic::toUint(object.length) ; i &#60; limit ; i++) {
        if (i > 0)
            out += separator;
        let x = object[i];
        if (x !== undefined && x !== null)
            out += string(x);
    }

    return out;
}
</PRE>


<h3>lastIndexOf&nbsp;(&nbsp;object,&nbsp;value,&nbsp;from=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>lastIndexOf</code> method compares <i>value</i> with every
array element of <i>object</i> in decreasing numerical index order,
starting at the index <i>from</i>, stopping when an array element is
equal to <i>value</i> by the <code>===</code> operator.

<P><span class="pcounter"></span> <i>From</i> is rounded toward zero before use.  If <i>from</i> is
negative, it is treated as <code><i>object</i>.length+<i>from</i></code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>lastIndexOf</code> method returns the array index the
first time <i>value</i> is equal to an element, or -1 if no such element
is found.

<P class="implsection"><b>Implementation</b>
<PRE>
static function lastIndexOf(object/*:Object!*/, value, from:AnyNumber=NaN): AnyNumber {
    let len = object.length;

    if (isNaN(from))
        from = len - 1;
    else {
        from = from &#60; 0 ? Math.ceil(from) : Math.floor(from);
        if (from &#60; 0)
            from = from + len;
        else if (from >= len)
            from = len - 1;
    }

    while (from > -1) {
        if (from in object)
            if (value === object[from])
                return from;
        from = from - 1;
    }
    return -1;
}
</PRE>


<h3>map&nbsp;(&nbsp;object,&nbsp;mapper,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>map</code> method calls <i>mapper</i> on each array element of
<i>object</i> in increasing numerical index order, collecting the return values
from <i>mapper</i> in a new <code>Array</code> object.

<P><span class="pcounter"></span><i>Mapper</i> is called with three arguments: the property value, the
property index, and <i>object</i> itself.  The <i>thisObj</i> is used as the
<code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>map</code> method returns a new <code>Array</code> object where
the array element at index <i>i</i> is the value returned from the call
to <i>mapper</i> on <i>object[i]</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function map(object/*:Object!*/, mapper/*:function*/, thisObj:Object=null): Array {

    if (typeof mapper != "function")
        throw new TypeError("Function object required to 'map'");

    let result = [];
    for (let i = 0, limit = object.length; i &#60; limit ; i++)
        if (i in object)
            result[i] = mapper.call(thisObj, object[i], i, object);
    return result;
}
</PRE>


<h3>pop&nbsp;(&nbsp;object&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>pop</code> method extracts the last array element from
<i>object</i> and removes it by decreasing the value of the <code>length</code>
property of <i>object</i> by 1.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>pop</code> method returns the removed element.

<P class="implsection"><b>Implementation</b>
<PRE>
static function pop(object/*:Object!*/) {
    let len = intrinsic::toUint(object.length);

    if (len != 0) {
        len = len - 1;
        let x = object[len];
        delete object[len]
        object.length = len;
        return x;
    }
    else {
        object.length = len;
        return undefined;
    }
}
</PRE>


<h3>push&nbsp;(&nbsp;object,&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>push</code> method appends the values in <i>items</i> to
the end of the array elements of <i>object</i>, in the order in which
they appear, in the process updating the <code>length</code> property of <i>object</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>push</code> method returns the new value of the
<code>length</code> property of <i>object</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function push(object/*: Object!*/, ...args): double
    Array.<em>push</em>(object, args);
</PRE>
<PRE>
helper static function push(object/*:Object!*/, args: Array): double {
    let len = intrinsic::toUint(object.length);

    for (let i=0, limit=args.length ; i &#60; limit ; i++)
        object[len++] = args[i];

    object.length = len;
    return len;
}
</PRE>

<P><span class="pcounter"></span>The helper <code>push</code> method is also used by the intrinsic and
prototype variants of <code>push</code>.


<h3>reverse&nbsp;(&nbsp;object&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>reverse</code> method rearranges the array elements of
<i>object</i> so as to reverse their order.  The <code>length</code> property of
<i>object</i> remains unchanged.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>reverse</code> method returns <i>object</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function reverse(object/*: Object!*/)/*: Object!*/ {
    let len = intrinsic::toUint(object.length);
    let middle = Math.floor(len / 2);

    for ( let k=0 ; k &#60; middle ; ++k ) {
        let j = len - k - 1;
        if (j in object) {
            if (k in object)
                [object[k], object[j]] = [object[j], object[k]];
            else {
                object[k] = object[j];
                delete object[j];
            }
        }
        else if (k in object) {
            object[j] = object[k];
            delete object[k];
        }
        else {
            delete object[j];
            delete object[k];
        }
    }

    return object;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  Property deletion is observable to objects that implement the
<code>meta::delete</code> method, and may not be omitted from this algorithm.

<h3>shift&nbsp;(&nbsp;object&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>shift</code> method removes the element called <code>0</code> in
<i>object</i>, moves the element at index <i>i+1</i> to index <i>i</i>, and
decrements the <code>length</code> property of <i>object</i> by 1.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>shift</code> method returns the element that was removed.

<P class="implsection"><b>Implementation</b>
<PRE>
static function shift(object/*: Object!*/) {
    let len = intrinsic::toUint(object.length);
    if (len == 0) {
        object.length = 0;
        return undefined;
    }

    let x = object[0];

    for (let i = 1; i &#60; len; i++)
        object[i-1] = object[i];
    delete object[len - 1];
    object.length = len - 1;
    return x;
}
</PRE>


<h3>slice&nbsp;(&nbsp;object,&nbsp;start=&#x0085;,&nbsp;end=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>slice</code> method extracts the subrange of array
elements from <i>object</i> between <i>start</i> (inclusive) and <i>end</i>
(exclusive) into a new Array.

<P><span class="pcounter"></span> If <i>start</i> is negative, it is treated as
<code><i>object</i>.length+<i>start</i></code>.  If <i>end</i> is negative, it is
treated as <code><i>object</i>.length+<i>end</i></code>.  In either case the values
of <i>start</i> and <i>end</i> are bounded between 0 and
<code><i>object</i>.length</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>slice</code> method returns a new <code>Array</code> object
containing the extracted array elements.

<P class="implsection"><b>Implementation</b>
<PRE>
static function slice(object/*: Object!*/, start: AnyNumber, end: AnyNumber, step: AnyNumber) {
    let len = intrinsic::toUint(object.length);

    step = int(step);
    if (step == 0)
        step = 1;

    if (intrinsic::isNaN(start))
        start = step > 0 ? 0 : (len-1);
    else
        start = <em>clamp</em>(start, len);

    if (intrinsic::isNaN(end))
        end = step > 0 ? len : (-1);
    else
        end = <em>clamp</em>(end, len);

    let out = new Array;
    for (let i = start; step > 0 ? i &#60; end : i > end; i += step)
        out.push(object[i]);

    return out;
}
</PRE>
<PRE>
helper function clamp(val: AnyNumber, len: double): double {
    val = <em>toInteger</em>(val);
    if (val &#60; 0)
        val += len;
    return intrinsic::toUint( Math.min( Math.max( val, 0 ), len ) );
}
</PRE>


<h3>some&nbsp;(&nbsp;object,&nbsp;checker,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>some</code> method calls <i>checker</i> on every array element in
<i>object</i> in increasing numerical index order, stopping as soon as <i>checker</i> returns
a true value.

<P><span class="pcounter"></span><i>Checker</i> is called with three arguments: the property value, the
property index, and the object itself.  The <i>thisObj</i> is used as the
<code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>some</code> method returns <b>true</b> when <i>checker</i>
returns a true value, otherwise returns <b>false</b> if all the calls to
<i>checker</i> return false values.

<P class="implsection"><b>Implementation</b>
<PRE>
static function some(object/*:Object!*/, checker/*:function*/, thisObj:Object=null): boolean {

    if (typeof checker != "function")
        throw new TypeError("Function object required to 'some'");

    for (let i=0, limit=object.length; i &#60; limit ; i++) {
        if (i in object)
            if (checker.call(thisObj, object[i], i, object))
                return true;
    }
    return false;
}
</PRE>


<h3>sort&nbsp;(object,&nbsp;comparefn=&#x0085;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>sort</code> method sorts the array elements of
<i>object</i>, it rearranges the elements of <i>object</i> according to some
criterion.

<P><span class="pcounter"></span>The sort is not necessarily stable (that is, elements that compare
equal do not necessarily remain in their original order).  If
<i>comparefn</i> is not <b>undefined</b>, it should be a function that
accepts two arguments <i>x</i> and <i>y</i> and returns a negative value if
<i>x < y</i>, zero if <i>x = y</i>, or a positive value if <i>x > y</i>.

<P><span class="pcounter"></span>If <i>comparefn</i> is not <b>undefined</b> and is not a consistent
comparison function for the array elements of <i>object</i> (see <span class="xref">sorting-logic</span>),
the behaviour of <code>sort</code> is implementation-defined.  Let <i>len</i> be
<code>uint(object.length)</code>.  If there exist integers <i>i</i> and <i>j</i>
and an object <i>P</i> such that all of the conditions below are
satisfied then the behaviour of <code>sort</code> is implementation-defined:

<ol>
<li> <i>0 &#x2264; i < len</i>
<li> <i>0 &#x2264; j < len</i>
<li> <i>object</i> does not have a property with name <code>string(<i>i</i>)</code>
<li> <i>P</i> is obtained by following one or more <code>[[Prototype]]</code> properties starting at <code>this</code>
<li> <i>P</i> has a property with name <code>string(<i>j</i>)</code>
</ol>

<P><span class="pcounter"></span> If the behavior of <code>sort</code> is not implementation-defined then
the array is sorted as described in section <span class="xref">sorting-logic</span>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>sort</code> method returns <i>object</i>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span>
The static <code>sort</code> method calls on the generic sorting engine,
passing a function to compare elements of <i>object</i>.

<PRE>
static function sort(object/*: Object!*/, comparefn) {

    function compare(j, k) {
        if (!(j in object) && !(k in object))
            return 0;
        if (!(j in object))
            return 1;
        if (!(k in object))
            return -1;

        let x = object[j];
        let y = object[k];

        if (x === undefined && y === undefined)
            return 0;
        if (x === undefined)
            return 1;
        if (y === undefined)
            return -1;

        if (comparefn !== undefined)
            return comparefn(x, y);

        x = String(x);
        y = String(y);
        if (x &#60; y) return -1;
        if (x > y) return 1;
        return 0;
    }

    let len = intrinsic::toUint(object.length);
    <em>sortEngine</em>(object, 0, len-1, compare);
    return object;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  Because non-existent property values always compare greater
than <b>undefined</b> property values, and <b>undefined</b> always compares
greater than any other value, <b>undefined</b> property values always
sort to the end of the result, followed by non-existent property
values.

<h4 id="sorting-logic"> The sorting engine </h4>

<P><span class="pcounter"></span> The sorting engine sorts the numerically named properties of an
object between two indices <code>low</code> and <code>high</code> inclusive, using a
sort-specific function <code>sortCompare</code> to compare elements at two
indices:

<PRE>
informative function sortEngine(object, low, high, sortCompare) &#x0085;
</PRE>

<P><span class="pcounter"></span> The sorting engine perform an implementation-dependent sequence of
calls to the <code>[[Get]]</code>, <code>[[Put]]</code>, and <code>[[Delete]]</code> methods of <i>object</i>
and to <i>sortCompare</i>, where the first argument for each call to
<code>[[Get]]</code>, <code>[[Put]]</code>, or <code>[[Delete]]</code>, and both arguments to
<i>sortCompare</i>, are nonnegative integers greater than or equal to
<i>low</i> and less than or equal to <i>high</i>.

</OL>

<P><span class="pcounter"></span>Following the execution of the preceding algorithm, <i>object</i> must
have the following two properties.

<ol>
  <li> There must be some mathematical permutation &#x03C0; of the
nonnegative integers in the range <i>low</i> to <i>high</i> inclusive, such that for every nonnegative
integer <i>j</i> in that range, if property <i>old[j]</i> existed, then
<i>new[&#x03C0;(j)]</i> is exactly the same value as <i>old[j]</i>, but if
property <i>old[j]</i> did not exist, then <i>new[&#x03C0;(j)]</i> does not
exist.

  <li> Then for all nonnegative integers <i>j</i> and <i>k</i> in that
range, if <i>sortCompare(j,k) &lt; 0</i>, then <i>&#x03C0;(j) &lt; &#x03C0;(k)</i>.
</ol>

<P><span class="pcounter"></span>Here the notation <i>old[j]</i> is used to refer to the hypothetical
result of calling the <code>[[Get]]</code> method of this object with argument
<i>j</i> before this function is executed, and the notation <i>new[j]</i> to
refer to the hypothetical result of calling the <code>[[Get]]</code> method of this
object with argument <i>j</i> after this function has been executed.

<P><span class="pcounter"></span>A function <i>comparefn</i> is a consistent comparison function for a
set of values <i>S</i> if all of the requirements below are met for all
values <i>a</i>, <i>b</i>, and <i>c</i> (possibly the same value) in the set
<i>S</i>: The notation <i>a &lt;CF b</i> means <i>comparefn(a,b) < 0</i>;
<i>a =CF b</i> means <i>comparefn(a,b) = 0</i> (of either sign); and <i>a >CF b</i>
means <i>comparefn(a,b) > 0</i>.

<OL>

<LI> Calling <i>comparefn(a,b)</i> always returns the same value <i>v</i>
when given a specific pair of values <i>a</i> and <i>b</i> as its two
arguments. Furthermore, <i>v</i> has type <i>Number</i>, and <i>v</i> is not
<b>NaN</b>. Note that this implies that exactly one of <i>a &lt;CF b</i>,
<i>a =CF b</i>, and <i>a >CF b</i> will be true for a given pair of <i>a</i>
and <i>b</i>.

<LI> <i>a =CF a</i> (reflexivity)

<LI> If <i>a =CF b</i>, then <i>b =CF a</i> (symmetry)

<LI> If <i>a =CF b</i> and <i>b =CF c</i>, then <i>a =CF c</i> (transitivity of <i>=CF</i>)

<LI> If <i>a &lt;CF b</i> and <i>b &lt;CF c</i>, then <i>a &lt;CF c</i> (transitivity of <i>&lt;CF</i>)

<LI> If <i>a >CF b</i> and <i>b >CF c</i>, then <i>a >CF c</i> (transitivity of <i>>CF</i>)

</OL>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The above conditions are necessary and sufficient to ensure
that <i>comparefn</i> divides the set <i>S</i> into equivalence classes and
that these equivalence classes are totally ordered.


<h3>splice&nbsp;(&nbsp;object,&nbsp;start,&nbsp;deleteCount,&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>splice</code> method replaces the <i>deleteCount</i> array
elements of <i>object</i> starting at array index <i>start</i> with values
from the <i>items</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>splice</code> method returns a new Array object
containing the array elements that were removed from <i>objects</i>, in
order.

<P class="implsection"><b>Implementation</b>
<PRE>
static function splice(object/*: Object!*/, start: AnyNumber, deleteCount: AnyNumber, ...items): Array
    Array.<em>splice</em>(object, start, deleteCount, items);
</PRE>
<PRE>
helper static function splice(object/*: Object!*/, start: AnyNumber, deleteCount: AnyNumber, items: Array) {
    let out = new Array();
    let len = intrinsic::toUint(object.length);

    start = <em>clamp</em>( start, len );
    deleteCount = <em>clamp</em>( deleteCount, len - start );

    let end = start + deleteCount;

    for (let i = 0; i &#60; deleteCount; i++)
        out.push(object[i + start]);

    let insertCount = items.length;
    let shiftAmount = insertCount - deleteCount;

    if (shiftAmount &#60; 0) {
        shiftAmount = -shiftAmount;

        for (let i = end; i &#60; len; i++)
            object[i - shiftAmount] = object[i];

        for (let i = len - shiftAmount; i &#60; len; i++)
            delete object[i];
    }
    else {
        for (let i = len; i > end; ) {
            --i;
            object[i + shiftAmount] = object[i];
        }
    }

    for (let i = 0; i &#60; insertCount; i++)
        object[start+i] = items[i];

    object.length = len + shiftAmount;
    return out;
}
</PRE>

<P><span class="pcounter"></span>The helper <code>clamp</code> function was defined earlier (see <span class="xref">Array.slice</span>).


<h3>unshift&nbsp;(&nbsp;object,&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>unshift</code> method inserts the values in <i>items</i>
as new array elements at the start of <i>object</i>, such that their
order within the array elements of <i>object</i> is the same as the order
in which they appear in <i>items</i>.  Existing array elements in
<i>object</i> are shifted upward in the index range, and the <code>length</code>
property of <i>object</i> is updated.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>unshift</code> method returns the new value of the
<code>length</code> property of <i>object</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function unshift(object/*: Object!*/, ...items) : double
    Array.<em>unshift</em>(this, object, items);
</PRE>
<PRE>
helper static function unshift(object/*: Object!*/, items: Array) : double {
    let len = intrinsic::toUint(object.length);
    let numitems = items.length;

    for ( let k=len-1 ; k >= 0 ; --k ) {
        let d = k + numitems;
        if (k in object)
            object[d] = object[k];
        else
            delete object[d];
    }

    for (let i=0; i &#60; numitems; i++)
        object[i] = items[i];

    object.length = len+numitems;

    return len+numitems;
}
</PRE>

<h2>Method Properties of Array Instances</h2>

<h3>Intrinsic methods</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic methods on Array instances delegate to their static
counterparts.  Unlike their static and prototype counterparts, these
methods are bound to their instance and they are not generic.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic methods on Array instances return what their static
counterparts return.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString():string
    join();
</PRE>
<PRE>
override intrinsic function toLocaleString():string {
    let out = "";
    for (let i = 0, limit = this.length; i &#60; limit ; i++) {
        if (i > 0)
            out += ",";
        let x = this[i];
        if (x !== null && x !== undefined)
            out += x.toLocaleString();
    }
    return out;
}
</PRE>
<PRE>
intrinsic function concat(...items): Array
    Array.<em>concat</em>(this, items);
</PRE>
<PRE>
intrinsic function every(checker:Checker, thisObj:Object=null): boolean
    Array.every(this, checker, thisObj);
</PRE>
<PRE>
intrinsic function filter(checker:Checker, thisObj:Object=null): Array
    Array.filter(this, checker, thisObj);
</PRE>
<PRE>
intrinsic function forEach(eacher:Eacher, thisObj:Object=null): void {
    Array.forEach(this, eacher, thisObj);
}
</PRE>
<PRE>
intrinsic function indexOf(value, from:AnyNumber=0): AnyNumber
    Array.indexOf(this, value, from);
</PRE>
<PRE>
intrinsic function join(separator: string=","): string
    Array.join(this, separator);
</PRE>
<PRE>
intrinsic function lastIndexOf(value, from:AnyNumber=NaN): AnyNumber
    Array.lastIndexOf(this, value, from);
</PRE>
<PRE>
intrinsic function map(mapper:Mapper, thisObj:Object=null): Array
    Array.map(this, mapper, thisObj);
</PRE>
<PRE>
intrinsic function pop()
    Array.pop(this);
</PRE>
<PRE>
intrinsic function push(...args): double
    Array.<em>push</em>(this, args);
</PRE>
<PRE>
intrinsic function reverse()/*: Object!*/
    Array.reverse(this);
</PRE>
<PRE>
intrinsic function shift()
    Array.shift(this);
</PRE>
<PRE>
intrinsic function slice(start: AnyNumber, end: AnyNumber, step: AnyNumber): Array
    Array.slice(this, start, end, step);
</PRE>
<PRE>
intrinsic function some(checker:Checker, thisObj:Object=null): boolean
    Array.some(this, checker, thisObj);
</PRE>
<PRE>
intrinsic function sort(comparefn:Comparator):Array
    Array.sort(this, comparefn);
</PRE>
<PRE>
intrinsic function splice(start: AnyNumber, deleteCount: AnyNumber, ...items): Array
    Array.<em>splice</em>(this, start, deleteCount, items);
</PRE>
<PRE>
intrinsic function unshift(...items): double
    Array.<em>unshift</em>(this, items);
</PRE>



<h2>Value properties of Array instances</h2>

<P><span class="pcounter"></span>Array instances inherit properties from the Array prototype object
and also have the following properties.

<h3>length</h3>

<P><span class="pcounter"></span>The <code>length</code> property of this Array object is always numerically
greater than the name of every property whose name is an array index.


<h2>Method properties on the <code>Array</code> prototype object</h2>

<h3>toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The prototype <code>toString</code> method converts the array to a <code>string</code>.
It has the same effect as if the intrinsic <code>join</code> method were invoked for this
object with no argument.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The prototype <code>toString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this:Array)
    this.join();
</PRE>

<h3>toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The elements of this Array are converted to strings using their
public <code>toLocaleString</code> methods, and these strings are then concatenated,
separated by occurrences of a separator string that has been derived
in an implementation-defined locale-specific way.  The result of
calling this function is intended to be analogous to the result of
<code>toString</code>, except that the result of this function is intended to
be locale-specific.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The prototype <code>toLocaleString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toLocaleString(this:Array)
    this.toLocaleString();
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The first parameter to this method is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.


<h3>Generic methods</h3>

<P><span class="pcounter"></span>These methods delegate to their static counterparts, and like their
counterparts, they are generic: they can be transferred to other
objects for use as methods.  Whether these methods can be applied
successfully to a host object is implementation-dependent.

<PRE>
prototype function concat(...items)
    Array.<em>concat</em>(this, items);
</PRE>
<PRE>
prototype function every(checker, thisObj=null)
    Array.every(this, checker, thisObj);
</PRE>
<PRE>
prototype function filter(checker, thisObj=null)
    Array.filter(this, checker, thisObj);
</PRE>
<PRE>
prototype function forEach(eacher, thisObj=null) {
    Array.forEach(this, eacher, thisObj);
}
</PRE>
<PRE>
prototype function indexOf(value, from=0)
    Array.indexOf(this, value, Number(from));
</PRE>
<PRE>
prototype function join(separator=undefined)
    Array.join(this, separator === undefined ? "," : string(separator));
</PRE>
<PRE>
prototype function lastIndexOf(value, from=NaN)
    Array.lastIndexOf(this, value, Number(from));
</PRE>
<PRE>
prototype function map(mapper, thisObj=null)
    Array.map(this, mapper, thisObj);
</PRE>
<PRE>
prototype function pop()
    Array.pop(this);
</PRE>
<PRE>
prototype function push(...args)
    Array.<em>push</em>(this, args);
</PRE>
<PRE>
prototype function reverse()
    Array.reverse(this);
</PRE>
<PRE>
prototype function shift()
    Array.shift(this);
</PRE>
<PRE>
prototype function slice(start, end, step)
    Array.slice(this, Number(start), Number(end), Number(step))
</PRE>
<PRE>
prototype function some(checker, thisObj=null)
    Array.some(this, checker, thisObj);
</PRE>
<PRE>
prototype function sort(comparefn)
    Array.sort(this, comparefn);
</PRE>
<PRE>
prototype function splice(start, deleteCount, ...items)
    Array.<em>splice</em>(this, Number(start), Number(deleteCount), items);
</PRE>
<PRE>
prototype function unshift(...items)
    Array.<em>unshift</em>(this, items);
</PRE>

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp; In the 3rd Edition of this Standard some of the functions on the
Array prototype object had <code>length</code> properties that did not reflect
those functions' signatures.  In the 4th Edition of this Standard, all
functions on the Array prototype object have <code>length</code> properties
that follow the general rule stated in section <span class="xref">function-semantics</span>.


 
<h1>String classes</h1>



<P><span class="pcounter"></span> ECMAScript provides a primitive string representation in the class
<code>string</code>.  It is primitive in the sense that this representation is
directly operated upon by operators of the language, and in the sense
that it is a final and non-dynamic class for which ECMAScript
implementations may provide efficient representations.

<P><span class="pcounter"></span> ECMAScript also provides the class <code>String</code>, which is a dynamic
non-final class that holds <code>string</code> values.  Instances of <code>String</code>
are converted to <code>string</code> when operated upon by operators of the
language.


<h2 id="type AnyString"> The type <code>AnyString</code> </h2>

<P><span class="pcounter"></span> The type <code>AnyString</code> is a union type that contains the two
built-in string types.  By standard subtyping rules it also includes
all classes that extend <code>String</code>.

<PRE>
__ES4__ type AnyString = (string|String!);
</PRE>


<H1 id="class String"> The class <code>String</code> </h1>

<P><span class="pcounter"></span>The class <code>String</code> is a dynamic, nullable, non-final subclass of
<code>Object</code>.  It is a container for <code>string</code> values.  Instances of
<code>String</code> are converted to <code>string</code> when operated upon by the
operators of the language.

<P><span class="pcounter"></span> The class <code>String</code> can be extended and the extending classes can
provide novel representations for string values.

<h3>Synopsis</h3>

<P><span class="pcounter"></span> The class <code>String</code> provides the following interface:

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Optional arguments need to be handled better in these interfaces.

<PRE>
dynamic class String
{
    function String(value="") &#x0085
    static meta function invoke(value="") &#x0085

    static function fromCharCode(...args) &#x0085
    static function charAt(self, pos) &#x0085
    static function charCodeAt(self, pos) &#x0085
    static function concat(self, ...args) : string &#x0085
    static function indexOf(self, searchString, position): double &#x0085
    static function lastIndexOf(self, searchString, position) : double &#x0085
    static function localeCompare(self, that) : double &#x0085
    static function match(self, regexp) : Array &#x0085
    static function replace(self, searchValue, replaceValue) : string &#x0085
    static function search(self, regexp) : double &#x0085
    static function slice(self, start, end, step): string &#x0085
    static function split(self, separator, limit): Array! &#x0085
    static function substring(self, start, end): string &#x0085
    static function toLowerCase(self): string &#x0085
    static function toLocaleLowerCase(self): string &#x0085
    static function toUpperCase(self): string &#x0085
    static function toLocaleUpperCase(self): string &#x0085
    static function trim(self) : string &#x0085

    static const length: uint = 1

    override intrinsic function toString() : string &#x0085
    override intrinsic function valueOf() : string &#x0085

    intrinsic function charAt(pos: double = 0) : string &#x0085
    intrinsic function charCodeAt(pos: double = 0) : double &#x0085
    intrinsic function concat(...args) : string &#x0085
    intrinsic function indexOf(searchString: AnyString, position: double = 0.0) : double &#x0085
    intrinsic function lastIndexOf(searchString: AnyString, position: double) : double &#x0085
    intrinsic function localeCompare(that: AnyString) : double &#x0085
    intrinsic function match(regexp: RegExp!) : Array &#x0085
    intrinsic function replace(s: (RegExp!|AnyString), r: (AnyString|function(...):AnyString)) : string &#x0085
    intrinsic function search(regexp: RegExp!) : double &#x0085
    intrinsic function slice(start: AnyNumber, end: AnyNumber, step: AnyNumber): string &#x0085
    intrinsic function split(separator:(AnyString|RegExp!), limit: double = double.MAX_VALUE) : Array! &#x0085
    intrinsic function substring(start: double, end: double=Infinity) : string &#x0085
    intrinsic function toLowerCase(): string &#x0085
    intrinsic function toLocaleLowerCase(): string &#x0085
    intrinsic function toUpperCase() : string &#x0085
    intrinsic function toLocaleUpperCase() : string &#x0085
    intrinsic function trim() : string &#x0085

    function get length() : double &#x0085
    meta function get(n) &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>String</code> prototype object provides the following direct properties:

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Optional arguments need to be handled better in these interfaces.

<PRE>
    toString:          function (this:Strings) &#x0085;
    valueOf:           function (this:Strings) &#x0085;
    charAt:            function (pos) &#x0085;
    charCodeAt:        function (pos) &#x0085;
    concat:            function (...strings) &#x0085;
    indexOf:           function (searchString, pos) &#x0085;
    lastIndexOf:       function (searchString, pos) &#x0085;
    localeCompare:     function (that) &#x0085;
    match:             function (regexp) &#x0085;
    replace:           function (searchValue, replaceValue) &#x0085;
    search:            function (regexp) &#x0085;
    slice:             function (start, end) &#x0085;
    split:             function (separator, limit) &#x0085;
    substring:         function (start, end) &#x0085;
    toLowerCase:       function () &#x0085;
    toLocaleLowerCase: function () &#x0085;
    toUpperCase:       function () &#x0085;
    toLocaleUpperCase: function () &#x0085;
    trim:              function () &#x0085;
</PRE>

<P><span class="pcounter"></span> The <code>String</code> prototype object is also used as the prototype object for the
class <code>string</code>.

<h2>Methods on the <code>String</code> class object</h2>

<h3>new&nbsp;String&nbsp;(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>String</code> constructor initializes a new <code>String</code> object
by storing <i>value</i>, converted to <code>string</code>, in a private property.
<i>Value</i> defaults to the empty string.

<h3>String(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>String</code> class object called as a function converts
<i>value</i> to <code>string</code> (not to <code>String</code>).  <i>Value</i> defaults to
the empty string.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>String</code> class object called as a function returns a
<code>string</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(value="")
    string(value);
</PRE>

<h3>Methods that delegate to <code>string</code> methods</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic methods <code>charAt</code>, <code>charCodeAt</code>, <code>concat</code>,
<code>indexOf</code>, <code>lastIndexOf</code>, <code>localeCompare</code>, <code>match</code>,
<code>replace</code>, <code>search</code>, <code>slice</code>, <code>split</code>, <code>substring</code>,
<code>toLowerCase</code>, <code>toLocaleLowerCase</code>, <code>toUpperCase</code>,
<code>toLocaleUpperCase</code>, and <code>trim</code> all delegate 
to the corresponding static methods on the <code>string</code> class.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> These static methods return what their corresponding static
methods on the <code>string</code> class return.

<P class="implsection"><b>Implementation</b>
<PRE>
static function charAt(self, pos)
    string.charAt(self, pos);
</PRE>
<PRE>
static function charCodeAt(self, pos)
    string.charCodeAt(self, pos);
</PRE>
<PRE>
static function concat(self, ...args) : string
    string.<em>concat</em>(self, args);
</PRE>
<PRE>
static function indexOf(self, searchString, position): double
    string.indexOf(self, searchString, position);
</PRE>
<PRE>
static function lastIndexOf(self, searchString, position) : double
    string.lastIndexOf(self, searchString, position);
</PRE>
<PRE>
static function localeCompare(self, that) : double
    string.localeCompare(self, that);
</PRE>
<PRE>
static function match(self, regexp) : Array
    string.match(self, regexp);
</PRE>
<PRE>
static function replace(self, searchValue, replaceValue) : string
    string.replace(self, searchValue, replaceValue);
</PRE>
<PRE>
static function search(self, regexp) : double
    string.search(self, regexp);
</PRE>
<PRE>
static function slice(self, start, end, step): string
    string.slice(self, Number(start), Number(end), Number(step));
</PRE>
<PRE>
static function split(self, separator, limit): Array!
    string.split(self, separator, limit);
</PRE>
<PRE>
static function substring(self, start, end): string
    string.substring(self, start, end);
</PRE>
<PRE>
static function toLowerCase(self): string
    string.toLowerCase(self);
</PRE>
<PRE>
static function toLocaleLowerCase(self): string
    string.toLocaleLowerCase(self);
</PRE>
<PRE>
static function trim(self) : string
    string.trim(self);
</PRE>

<h2>Methods on <code>String</code> instances</h2>

<h3>toString</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns this <code>String</code>
object converted to <code>string</code>.  For the class <code>String</code> itself this
results in the extraction of the private string value held by the
<code>String</code>.  Subclasses of <code>String</code> can represent strings
differently by overriding <code>toString</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString() : string
    val;
</PRE>

<h3>valueOf</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns the result of calling
the intrinsic <code>toString</code> method.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf() : string
    val;
</PRE>

<h3>Methods that delegate to <code>string</code> methods</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic methods <code>charAt</code>, <code>charCodeAt</code>, <code>concat</code>,
<code>indexOf</code>, <code>lastIndexOf</code>, <code>localeCompare</code>, <code>match</code>,
<code>replace</code>, <code>search</code>, <code>slice</code>, <code>split</code>, <code>substring</code>,
<code>toLowerCase</code>, <code>toLocaleLowerCase</code>, <code>toUpperCase</code>,
<code>toLocaleUpperCase</code>, and <code>trim</code> all delegate 
to the corresponding static methods on the <code>string</code> class, passing
<code>this</code> as the first argument in all cases.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> These intrinsic methods return what their corresponding static
methods on the <code>string</code> class return.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function charAt(pos: double = 0) : string
    string.charAt(val, pos);
</PRE>
<PRE>
intrinsic function charCodeAt(pos: double = 0) : double
    string.charCodeAt(val, pos);
</PRE>
<PRE>
intrinsic function concat(...args) : string
    string.<em>concat</em>(val, args);
</PRE>
<PRE>
intrinsic function indexOf(searchString: AnyString, position: double = 0.0) : double
    string.indexOf(val, searchString, position);
</PRE>
<PRE>
intrinsic function lastIndexOf(searchString: AnyString, position: double) : double
    string.lastIndexOf(val, searchString, position);
</PRE>
<PRE>
intrinsic function localeCompare(that: AnyString) : double
    string.localeCompare(val, that);
</PRE>
<PRE>
intrinsic function match(regexp: RegExp!) : Array
    string.match(val, regexp);
</PRE>
<PRE>
intrinsic function replace(s: (RegExp!|AnyString), r: (AnyString|function(...):AnyString)) : string
    string.replace(val, searchValue, replaceValue);
</PRE>
<PRE>
intrinsic function search(regexp: RegExp!) : double
    string.search(val, r);
</PRE>
<PRE>
intrinsic function slice(start: AnyNumber, end: AnyNumber, step: AnyNumber): string
    string.slice(val, start, end, step);
</PRE>
<PRE>
intrinsic function split(separator:(AnyString|RegExp!), limit: double = double.MAX_VALUE) : Array!
    string.split(val, separator, limit);
</PRE>
<PRE>
intrinsic function substring(start: double, end: double=Infinity) : string
    string.substring(val, start, end);
</PRE>
<PRE>
intrinsic function toLowerCase(): string
    string.toLowerCase(val);
</PRE>
<PRE>
intrinsic function toLocaleLowerCase(): string
    string.toLocaleLowerCase(val);
</PRE>
<PRE>
intrinsic function toUpperCase() : string
    string.toUpperCase(val);
</PRE>
<PRE>
intrinsic function toLocaleUpperCase() : string
    string.toLocaleUpperCase(val);
</PRE>
<PRE>
intrinsic function trim() : string
    string.trim(string(val));
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The second parameter to the intrinsic method <code>localeCompare</code>
and the first parameter to the intrinsic methods <code>toLocaleLowerCase</code>
and <code>toLocaleUpperCase</code> are likely to be used in a future version of
this standard; it is recommended that implementations do not use these
parameter position for anything else.

<h2>Methods on the <code>String</code> prototype object</h2>

<h3>toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> Returns the result of invoking the intrinsic <code>toString</code>
method.

<P><span class="pcounter"></span> The <code>toString</code> function is not generic; it throws a
<b>TypeError</b> exception if its this value is not a <code>String</code> or
<code>string</code> object.  Therefore, it cannot be transferred to other kinds
of objects for use as a method.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this: AnyString)
    this.intrinsic::toString();
</PRE>

<h3>valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> Returns this result of invoking the intrinsic <code>valueOf</code> method.

<P><span class="pcounter"></span> The <code>valueOf</code> function is not generic; it throws a <b>TypeError</b>
exception if its this value is not a <code>String</code> or <code>string</code> object.
Therefore, it cannot be transferred to other kinds of objects for use
as a method.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function valueOf(this: AnyString)
    this.intrinsic::valueOf();
</PRE>

<h3>Methods that delegate to <code>string</code> methods</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods <code>charAt</code>, <code>charCodeAt</code>, <code>concat</code>,
<code>indexOf</code>, <code>lastIndexOf</code>, <code>localeCompare</code>, <code>match</code>,
<code>replace</code>, <code>search</code>, <code>slice</code>, <code>split</code>,
<code>substring</code>, <code>toLowerCase</code>, <code>toLocaleLowerCase</code>,
<code>toUpperCase</code>, <code>toLocaleUpperCase</code>, and <code>trim</code> on the <code>String</code>
prototype object all delegate to the
corresponding static methods on the <code>string</code> class, passing <code>this</code>
as the first argument in all cases.

<P><span class="pcounter"></span> These methods are all generic, they do not require that their
<code>this</code> object is a <code>String</code>.  Therefore, they can be transferred
to other kinds of objects for use as methods.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> These methods on the <code>String</code> prototype object all return the
values returned by their corresponding static methods on the
<code>string</code> class.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function charAt(pos)
    string.charAt(this.toString(), pos);
</PRE>
<PRE>
prototype function charCodeAt(pos)
    string.charCodeAt(this.toString(), pos);
</PRE>
<PRE>
prototype function concat(...args)
    string.<em>concat</em>(this.toString(), args);
</PRE>
<PRE>
prototype function indexOf(searchString, position)
    string.indexOf(this.toString(), searchString, position);
</PRE>
<PRE>
prototype function lastIndexOf(searchString, position)
    string.lastIndexOf(this.toString(), searchString, position);
</PRE>
<PRE>
prototype function localeCompare(that)
    string.localeCompare(this.toString(), that);
</PRE>
<PRE>
prototype function match(regexp)
    string.match(this.toString(), regexp);
</PRE>
<PRE>
prototype function replace(searchValue, replaceValue)
    string.replace(this.toString(), searchValue, replaceValue);
</PRE>
<PRE>
prototype function search(regexp)
    string.search(this.toString(), regexp);
</PRE>
<PRE>
prototype function slice(start, end, step)
    string.slice(this.toString(), Number(start), Number(end), Number(step));
</PRE>
<PRE>
prototype function split(separator, limit)
    string.split(this.toString(), separator, limit);
</PRE>
<PRE>
prototype function substring(start, end)
    string.substring(this.toString(), start, end);
</PRE>
<PRE>
prototype function toLowerCase()
    string.toLowerCase(this.toString());
</PRE>
<PRE>
prototype function toLocaleLowerCase()
    string.toLocaleLowerCase(this.toString());
</PRE>
<PRE>
prototype function trim()
    string.trim(this.toString());

</PRE>


<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The second parameter to the prototype method <code>localeCompare</code>
and the first parameter to the prototype methods <code>toLocaleLowerCase</code>
and <code>toLocaleUpperCase</code> are likely to be used in a future version of
this standard; it is recommended that implementations do not use these
parameter position for anything else.
 
<H1 id="class string"> The class <code>string</code> </h1>



<P><span class="pcounter"></span> The class <code>string</code> is a final, non-nullable, non-dynamic
subclass of Object that represents an immutable indexable sequence of
Unicode characters.  The property <code>"length"</code> holds the number of
characters in this sequence.  The property <code>"0"</code> names the first
character, the property <code>"1"</code> names the second character, and so on,
up to property <code>"length"</code>-1.  Single characters are represented as
<code>string</code> objects with length equal to one.

<P><span class="pcounter"></span> The <code>string</code> class has the same prototype object as the
<code>String</code> class; changes made to the prototype object of one class
are visible on the prototype object of the other class.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The class <code>string</code> is new in the 4th Edition of this
Standard, but <code>string</code> models the "string values" in the 3rd
Edition.


<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>string</code> provides the following interface:

<PRE>
final class string!
{
    function string(value="") &#x0085
    static meta function invoke(value="") &#x0085

    static function fromCharCode(...codes) &#x0085
    static function charAt(self, pos) : string &#x0085
    static function charCodeAt(self, pos) : double &#x0085
    static function concat(self, ...args) &#x0085
    static function indexOf(self, searchString, position) : double &#x0085
    static function lastIndexOf(self, searchString, position) : double &#x0085
    static function localeCompare(self, that) : double &#x0085
    static function match(self, regexp): Array &#x0085
    static function replace(self, s, r): string &#x0085
    static function search(self, regexp): double &#x0085
    static function slice(object, start: AnyNumber=NaN, end: AnyNumber=NaN, step: AnyNumber=1) &#x0085
    static function split(self, separator, limit) : Array! &#x0085
    static function substring(self, start, end) : string &#x0085
    static function toLowerCase(self): string &#x0085
    static function toLocaleLowerCase(self): string &#x0085
    static function toUpperCase(self): string &#x0085
    static function toLocaleUpperCase(self) &#x0085
    static function trim(s): string &#x0085

    static const length: uint = 1

    override intrinsic function toString() : string &#x0085
    override intrinsic function valueOf() : string &#x0085

    intrinsic function charAt(pos: double = 0) : string &#x0085
    intrinsic function charCodeAt(pos: double = 0) : double &#x0085
    intrinsic function concat(...args) : string &#x0085
    intrinsic function indexOf(searchString: string, position: double = 0.0) : double &#x0085
    intrinsic function lastIndexOf(searchString: string, position: double) : double &#x0085
    intrinsic function localeCompare(that : string) : double &#x0085
    intrinsic function match(regexp: RegExp) : Array &#x0085
    intrinsic function replace(searchValue: (string|RegExp!), &#x0085
    intrinsic function search(regexp: RegExp!) : double &#x0085
    intrinsic function slice(start: AnyNumber=NaN, end: AnyNumber=NaN, step: AnyNumber=1): string &#x0085
    intrinsic function split(separator:(string|RegExp!), limit: double = double.MAX_VALUE): Array! &#x0085
    intrinsic function substring(start: double, end: double=this.length) : string &#x0085
    intrinsic function toLowerCase() : string &#x0085
    intrinsic function toLocaleLowerCase() : string &#x0085
    intrinsic function toUpperCase() : string &#x0085
    intrinsic function toLocaleUpperCase() : string &#x0085
    intrinsic function trim() : string &#x0085

    function get length() : double &#x0085
    meta function get(pos) &#x0085
}
</PRE>

<h2>Static Methods on the <code>string</code> Class</h2>

<h3>new&nbsp;string&nbsp;(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>string</code> constructor initializes a new <code>string</code> object
by storing an implementation-dependent string representation of
<i>value</i> in a private property.  The default <i>value</i> is the empty
string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>string</code> constructor is implementation-dependent.

<h3>string&nbsp;(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>string</code> class object called as a function converts
<i>value</i> to <code>string</code> as by the <code>ToString</code> operator.  The default
<i>value</i> is the empty string.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>string</code> class object called as a function returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(value="")
    (value is string) ? value : new string(value);
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #176.) The use of <code>magic::newString</code> is an
optimization that confuses the spec; <code>new string(x)</code> would have been
better.

<h3>fromCharCode&nbsp;(&nbsp;...codes&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>fromCharCode</code> method creates a <code>string</code>
containing as many characters as there are elements in <i>codes</i>.
Each element of <i>codes</i> specifies the Unicode code point value of
one character of the resulting string, with the first argument
specifying the first character, and so on, from left to right.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #170.) The code below assumes a 21-bit Unicode
representation.  What happens in a system that only has 16-bit
unicode?  We'd like to be backwards compatible.  If so, the upper bits
are ignored.  This conflicts with how <code>\u{...}</code> is handled, though:
it creates two code points.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>fromCharCode</code> method returns the computed <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function fromCharCode(...codes)
    string.<em>fromCharCode</em>(codes);
</PRE>
<PRE>
helper static function fromCharCode(codes: Array): string {
    let s = "";
    for (let i=0, limit=codes.length ; i &#60; limit ; ++i)
        s += <em>fromCharCode</em>(intrinsic::toUint(codes[i] & 0x1FFFFF));
    return s;
}
</PRE>

<h3>charAt&nbsp;(self,&nbsp;pos)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>charAt</code> method converts <i>self</i> to <code>string</code> and
extracts the character at index <i>pos</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>charAt</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function charAt(self, pos) : string {
    let S    = string(self);
    let ipos = <em>toInteger</em>(pos);
    if (ipos &#60; 0 || ipos >= S.length)
        return "";
    return <em>fromCharCode</em>(<em>charCodeAt</em>(S, intrinsic::toUint(ipos)));
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #176.) The use of <code>magic::charCodeAt</code> is an optimization that
complicates the spec; <code>string.charCodeAt(x)</code> would have been better.

<h3>charCodeAt&nbsp;(self,&nbsp;pos)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>charCodeAt</code> method converts <i>self</i> to <code>string</code> and
extracts the code point value of the character at index <i>pos</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>charCodeAt</code> method returns a number.

<P class="implsection"><b>Implementation</b>
<PRE>
static function charCodeAt(self, pos) : double {
    let S = string(self);
    let ipos = <em>toInteger</em>(pos);
    if (ipos &#60; 0 || ipos >= S.length)
        return NaN;
    return <em>charCodeAt</em>(S, intrinsic::toUint(ipos));
}
</PRE>

<h3>concat&nbsp;(&nbsp;self,&nbsp;...strings&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>concat</code> method computes a <code>string</code> value
consisting of the characters of <i>self</i> (converted to <code>string</code>)
followed by the characters of each of the elements of <i>strings</i>
(where each argument is converted to <code>string</code>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>concat</code> method returns the concatenated <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function concat(self, ...args)
    string.<em>concat</em>(self, args);
</PRE>
<PRE>
helper static function concat(self, strings) : string {
    let S = string(self);
    let n = strings.length;
    for (let i=0; i &#60; n ; i++)
        S += string(strings[i]);
    return S;
}
</PRE>

<h3>indexOf&nbsp;(&nbsp;self,&nbsp;searchString,&nbsp;position)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>indexOf</code> method searches <i>self</i> (converted to
string) for occurrences of <i>searchString</i> (converted to <code>string</code>),
at positions that are greater than or equal to <i>position</i> (converted
to integer).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>indexOf</code> method returns the smallest index at
which a match was found, or -1 if there was no match.

<P class="implsection"><b>Implementation</b>
<PRE>
static function indexOf(self, searchString, position) : double {
    let S     = string(self);
    let SS    = string(searchString);
    let pos   = <em>toInteger</em>(position);
    let slen  = S.length;
    let m     = Math.min(Math.max(pos, 0), slen);
    let sslen = SS.length;
    let lim   = slen - sslen + 1;
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #176.) The use of <code>magic::charCodeAt</code> is an optimization that
complicates the spec; using <code>string.charCodeAt</code> would have been
better.

<h3>lastIndexOf&nbsp;(&nbsp;self,&nbsp;searchString,&nbsp;position)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>lastIndexOf</code> method searches <i>self</i> (converted
to string) for occurrences of <i>searchString</i> (converted to
<code>string</code>), at positions that are smaller than or equal to
<i>position</i> (converted to integer).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>lastIndexOf</code> method returns the greatest index at
which a match was found, or -1 if there was no match.

<P class="implsection"><b>Implementation</b>
<PRE>
static function indexOf(self, searchString, position) : double {
    let S     = string(self);
    let SS    = string(searchString);
    let pos   = <em>toInteger</em>(position);
    let slen  = S.length;
    let m     = Math.min(Math.max(pos, 0), slen);
    let sslen = SS.length;
    let lim   = slen - sslen + 1;
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #176.) The use of <code>magic::charCodeAt</code> is an optimization that
complicates the spec; using <code>string.charCodeAt</code> would have been
better.

<h3>localeCompare&nbsp;(self,&nbsp;other)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>localeCompare</code> method compares <i>self</i>
(converted to <code>string</code>) with <i>other</i> (converted to string) in a
locale-sensitive manner.  The two strings are compared in an
implementation-defined fashion.  The comparison is intended to order
strings in the sort order specified by the system default locale.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>localeCompare</code> method returns a number other than
<b>NaN</b> that represents the result of the comparison.  The result will
be negative, zero, or positive, depending on whether <i>self</i> comes
before <i>other</i> in the sort order, the strings are equal, or <i>self</i>
comes after <i>other</i> in the sort order, respectively.

<P><span class="pcounter"></span>The static <code>localeCompare</code> method is a consistent comparison
function (as defined in <span class="xref">sort:consistent_comparator</span>) on
the set of all strings.  Furthermore, <code>localeCompare</code> returns 0 or -0
when comparing two strings that are considered canonically equivalent
by the Unicode standard.

<P><span class="pcounter"></span>The actual return values are left implementation-defined to permit
implementers to encode additional information in the result value, but
the function is required to define a total ordering on all strings and
to return 0 when comparing two strings that are considered canonically
equivalent by the Unicode standard.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The static <code>localeCompare</code> method is implementation-defined.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  This function is intended to rely on whatever
language-sensitive comparison functionality is available to the
ECMAScript environment from the host environment, and to compare
according to the rules of the host environment's current locale. It is
strongly recommended that this function treat strings that are
canonically equivalent according to the Unicode standard as identical
(in other words, compare the strings as if they had both been
converted to Normalised Form C or D first). It is also recommended
that this function not honour Unicode compatibility equivalences or
decompositions.  If no language-sensitive comparison at all is
available from the host environment, this function may perform a
bitwise comparison.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The third parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.


<h3>match&nbsp;(self,&nbsp;regexp)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>match</code> method searches <i>self</i> (converted to
<code>string</code>) for occurrences of <i>regexp</i> (converted to <code>RegExp</code>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> If the <code>global</code> flag on <i>regexp</i> is <b>false</b>, the <code>match</code> method returns
the result obtained by invoking the intrinsic <code>exec</code> method on <i>regexp</i> with <i>self</i>
as a parameter.

<P><span class="pcounter"></span> If the <code>global</code> flag on <i>regexp</i> is <b>true</b>, the <code>match</code>
method returns an array of strings containing the substrings of
<i>self</i> that were matched by <i>regexp</i>, in order.

<P class="implsection"><b>Implementation</b>
<PRE>
static function match(self, regexp): Array {
    let S = string(self);
    let R = (regexp is RegExp) ? regexp : new RegExp(regexp);

    if (!R.global)
        return R.exec(S);

    let matches = [];

    R.lastIndex = 0;
    while (true) {
        let oldLastIndex = R.lastIndex;
        let res = R.exec(S);

        if (res === null)
            break;

        matches.push(res[0]);
        if (R.lastIndex === oldLastIndex)
            ++R.lastIndex;
    }
    if (matches.length == 0)
        return null;
    else
        return matches;
}
</PRE>

<h3>replace&nbsp;(self,&nbsp;searchValue,&nbsp;replaceValue)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>replace</code> method computes a string from <i>self</i>
(converted to <code>string</code>) by replacing substrings matching
<i>searchValue</i> (converted to <code>string</code> if not <code>RegExp</code>) by
instances of <i>replaceValue</i> (converted to <code>string</code> if not a
function).

<P><span class="pcounter"></span> If <i>replaceValue</i> is a function, then it is called once for each
matched substring on arguments providing details about the match, and
the value returned from this call is converted to <code>string</code> if
necessary and replaces the matched substring.

<P><span class="pcounter"></span> If <i>replaceValue</i> is not a function then a string to replace a
matched substring is derived from <i>replaceValue</i> by replacing
characters of <i>replaceValue</i> (converted to <code>string</code>) as specified
in the following table.  These <code>$</code> replacements are done
left-to-right, and, once such a replacement is performed, the new
replacement text is not subject to further replacements.  For example,
<code>"$1,$2".replace(/(\$(\d))/g, "$$1-$1$2")</code> returns
<code>"$1-$11,$1-$22"</code>.  A <code>$</code> in <i>replaceValue</i> that does not match
any of the forms below is left as is.

<table border=1>
<tr><th>Characters</th><th>Replacement text</th></tr>
<tr><td>$$</td>        <td>$</td></tr>
<tr><td>$&</td>        <td>The matched substring.</td></tr>
<tr><td>$`</td>        <td>The portion of <i>self</i> that precedes the matched substring.</td></tr>
<tr><td>$'</td>        <td>The portion of <i>self</i> that follows the matched substring.</td></tr>
<tr><td>$n</td>        <td>The <i>n</i>th capture, where <i>n</i> is a single digit 1-9 and <code>$n</code> is not
                           followed by a decimal digit. If <i>n&#x2264;m</i> and the <i>n</i>th capture
                           is undefined, use the empty string instead. If <i>n>m</i>,
                           the result is implementation-defined.</td></tr>
<tr><td>$nn</td>       <td>The <i>nn</i>th capture, where <i>nn</i> is a two-digit decimal number
                           01-99. If <i>nn&#x2264;m</i> and the <i>nn</i>th capture is undefined, use
                           the empty string instead. If <i>nn>m</i>, the result is implementation-defined.</td></tr>
</table>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  In the above table, <i>m</i> is the length of the search result's
capture array.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>replace</code> function returns a <code>string</code> object
that is the concatenation of the unmatched portions of <i>self</i> and
the computed replace values for the matched portions of <i>self</i>, in
order.

<P class="implsection"><b>Implementation</b>
<PRE>
static function replace(self, s, r): string {

    let function substituteFunction(start: double, end: double, m: double, cap: Array) : string {
        let A = [];
        A[0] = S.substring(start, end);
        for ( let i=0 ; i &#60; m ; i++ )
            A[i+1] = cap[i+1];
        A[m+2] = start;
        A[m+3] = S;
        return string(replaceFun.apply(null, A));
    }

    let function substituteString(start: double, end: double, m: double, cap: Array) : string {
        let s   = "";
        let i   = 0;
        let r   = /\$(?:(\$)|(\&)|(\`)|(\')|([0-9]{1,2}))/g;
        let res;

        while ((res = r.exec(replaceString)) !== null) {
            s += replaceString.substring(i, r.lastIndex - res[0].length);
            i = r.lastIndex;

            if (res[1])      s += "$";
            else if (res[2]) s += S.substring(start, end);
            else if (res[3]) s += S.substring(0, start);
            else if (res[4]) s += S.substring(end);
            else {
                let n = parseInt(res[5]);
                if (n &#60;= m && cap[n] !== undefined)
                    s += cap[n];
            }
        }
        s += replaceString.substring(i);

        return s;
    }

    let function match( regexp, i : double ) : [double, CapArray]  {
        while (i &#60;= S.length) {
            let res : MatchResult = regexp.<em>match</em>(S, i);
            if (res !== null) {
                res.captures[0] = S.substring(i,res.endIndex);
                return [i, res.captures];
            }
            ++i;
        }
        return [0, null];
    }

    let S             = string(self);
    let replaceString = (r is string) ? r cast string : null;
    let replaceFun    = (r is Function) ? r cast Function : null;

    let substitute : function (double, double, double, Array) : string =
        replaceFun !== null ? substituteFunction : substituteString;

    if (s !== null && s is RegExp) {
        let regexp = s cast RegExp;
        let m      = regexp.<em>nCapturingParens</em>;

        if (!regexp.global) {
            let [i, res] = match(regexp, 0);

            if (res === null)
                return S;

            let end = i + res[0].length;
            return S.substring(0,i) + substitute(i, end, m, res) + S.substring(end);
        }
        else {
            let newstring = "";
            let prevEnd   = 0;

            regexp.lastIndex = 0;
            while (true) {
                let oldLastIndex : double = regexp.lastIndex;
                let [i,res] = match(regexp, intrinsic::toUint(oldLastIndex));

                if (res === null)
                    break;

                newstring += S.substring(prevEnd, i);

                let end = i + res[0].length;
                regexp.lastIndex = end;
                if (regexp.lastIndex == oldLastIndex)
                    regexp.lastIndex++;
                newstring += substitute(i, end, m, res);
                prevEnd = end;
            }
            newstring += S.substring(prevEnd, S.length);

            return newstring;
        }
    }
    else {
        let searchString = string(s);
        let pos          = S.indexOf(searchString, 0);

        if (pos === -1)
            return S;

        let end = pos + searchString.length;
        return S.substring(0,pos) + substitute(pos, end, 0, []) + S.substring(end);
    }
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #177.) The code above needs to be factored into a
top-level function with the auxiliary functions following it; values
of names now free in the nested functions must be passed as
parameters.

<h3>search&nbsp;(self,&nbsp;regexp)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>search</code> method searches <i>self</i> (converted to
<code>string</code>) for the first occurrence of the search term <i>regexp</i>
(converted to <code>RegExp</code>).

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  This method ignores the <code>lastIndex</code> and global properties of
<i>regexp</i>.  The <code>lastIndex</code> property of <i>regexp</i> is left
unchanged.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>search</code> method returns a number indicating the index
at which a match was made, or -1 if there was no match.

<P class="implsection"><b>Implementation</b>
<PRE>
static function search(self, regexp): double {
    let S = string(self);
    let R = (regexp is RegExp) ? regexp : new RegExp(regexp);

    for ( let i=0, limit=S.length ; i &#60; limit ; i++ )
        if (R.<em>match</em>(S, i) !== null)
            return i;
    return -1;
}
</PRE>

<h3>slice&nbsp;(self,&nbsp;start,&nbsp;end)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>slice</code> method extracts a substring of <i>self</i>
(converted to <code>string</code>) from <i>start</i> and up to but not including
<i>end</i> (both converted to integer).  Both <i>start</i> and <i>end</i> may
be negative.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>slice</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function slice(object, start: AnyNumber=NaN, end: AnyNumber=NaN, step: AnyNumber=1) {

    let len = intrinsic::toUint(object.length);

    step = int(step);
    if (step == 0)
        step = 1;

    if (intrinsic::isNaN(start))
        start = step > 0 ? 0 : (len-1);
    else
        start = <em>clamp</em>(start, len);

    if (intrinsic::isNaN(end))
        end = step > 0 ? len : (-1);
    else
        end = <em>clamp</em>(end, len);

    let out = new string();
    for (let i = start; step > 0 ? i &#60; end : i > end; i += step)
        out += object[i];

    return out;
}
</PRE>

<h3>split&nbsp;(self,&nbsp;separator,&nbsp;limit)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>split</code> method extracts substrings from <i>self</i>
(converted to <code>string</code>), where substrings are separated by instances
of <i>separator</i> (converted to <code>string</code> if not a <code>RegExp</code>).  At
most <i>limit</i> substrings are extracted.

<P><span class="pcounter"></span> Occurrences of <i>separator</i> are not part of any substring in the result.

<P><span class="pcounter"></span>The value of <i>separator</i> may be an empty string, an empty regular
expression, or a regular expression that can match an empty string.
In this case, <i>separator</i> does not match the empty substring at the
beginning or end of the input string, nor does it match the empty
substring at the end of the previous separator match.  (For example,
if <i>separator</i> is the empty string, the string is split up into
individual characters; the length of the result array equals the
length of the string, and each substring contains one character.)  If
<i>separator</i> is a regular expression, only the first match at a given
position of the <code>this</code> string is considered, even if backtracking could
yield a non-empty-substring match at that position.  (For example,
<code>string.split("ab",/a*?/)</code> evaluates to the array <code>["a","b"]</code>,
while <code>string.split("ab",/a*/)</code> evaluates to the array
<code>["","b"]</code>.)

<P><span class="pcounter"></span> If <i>self</i> is (or converts to) the empty string, the result
depends on whether <i>separator</i> can match the empty string.  If it
can, the result contains no elements.  Otherwise, the result contains
one element, which is the empty string.

<P><span class="pcounter"></span> If <i>separator</i> is a regular expression that contains capturing
parentheses, then each time <i>separator</i> is matched the results
(including any undefined results) of the capturing parentheses are
spliced into the result. For example,
<PRE>
"A&#60;B>bold&#60;/B>and&#60;CODE>coded&#60;/CODE>".split(/&#60;(\/)?([^&#60;>]+)>/)
</PRE>
evaluates to the array
<PRE>
["A", undefined, "B", "bold", "/", "B", "and", undefined, "CODE", "coded", "/", "CODE", ""].
</PRE>

<P><span class="pcounter"></span>If <i>separator</i> is <b>undefined</b>, then the result contains just one
string, which is <i>self</i> (converted to <code>string</code>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>split</code> method returns a new <code>Array</code> object
holding the extracted substrings, in order.

<P class="implsection"><b>Implementation</b>
<PRE>
static function split(self, separator, limit) : Array! {
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #178.) The exposition leaves something to be desired.
Should split <code>splitMatch</code> out as a separate helper function, at
least.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The static <code>split</code> method ignores the value of
<i>separator</i><code>.global</code> for separators that are <code>RegExp</code> objects.

<h3>substring&nbsp;(self,&nbsp;start,&nbsp;end)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>substring</code> method extracts a substring from
<i>self</i> (converted to <code>string</code>) from <i>start</i> up to but not
including <i>end</i> (converted to number).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>substring</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function substring(self, start, end) : string {
    let S   = string(self);
    let len = S.length;

    start = <em>toInteger</em>(start);
    end = end === undefined ? len : <em>toInteger</em>(end);

    start = Math.min(Math.max(start, 0), len);
    end = Math.min(Math.max(end, 0), len);

    if (start > end)
        [start, end] = [end, start];

    let s = "";
    for ( let i=start ; i &#60; end ; i++ )
        s += S[i];

    return s;
}
</PRE>

<h3>toLowerCase&nbsp;(&nbsp;self&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>toLowerCase</code> method converts the characters of
<i>self</i> (converted to string) to lower case.  The characters are
converted one by one.  The result of each conversion is the original
character, unless that character has a Unicode lowercase equivalent,
in which case the lowercase equivalent is used instead.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The result should be derived according to the case mappings in
the Unicode character database (this explicitly includes not only the
<code>UnicodeData.txt</code> file, but also the <code>SpecialCasings.txt</code> file
that accompanies it in Unicode 2.1.8 and later).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>toLowerCase</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function toLowerCase(self): string {
    let S = string(self);
    let s = "";

    for ( let i=0, limit=S.length ; i &#60; limit ; i++ ) {
        let u = Unicode::toLowerCaseCharCode(<em>charCodeAt</em>(S,intrinsic::toUint(i)));
        if (u is double)
            s += <em>fromCharCode</em>(intrinsic::toUint(u));
        else {
            for ( let j=0 ; j &#60; u.length ; j++ )
                s += <em>fromCharCode</em>(u[j]);
        }
    }
    return s;
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #176.) The use of <code>magic::charCodeAt</code> and
<code>magic::fromCharCode</code> is a confusing optimization.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #179.) Cross reference to the Unicode library somehow,
or put the unicode stuff into the <code>helper</code> namespace.

<h3>toLocaleLowerCase&nbsp;(&nbsp;self&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>toLocaleLowerCase</code> method works exactly the same
as the static <code>toLowerCase</code> method except that it is intended to
yield the correct result for the host environment's current locale,
rather than a locale-independent result.  There will only be a
difference in the few cases (such as Turkish) where the rules for that
language conflict with the regular Unicode case mappings.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>toLocaleLowerCase</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span>
The static <code>toLocaleLowerCase</code> method is implementation-dependent.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The second parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<h3>toUpperCase&nbsp;(&nbsp;self&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>toUpperCase</code> method converts the characters of
<i>self</i> (converted to string) to upper case.  The characters are
converted one by one.  The result of each conversion is the original
character, unless that character has a Unicode uppercase equivalent,
in which case the uppercase equivalent is used instead.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The result should be derived according to the case mappings in
the Unicode character database (this explicitly includes not only the
<code>UnicodeData.txt</code> file, but also the <code>SpecialCasings.txt</code> file
that accompanies it in Unicode 2.1.8 and later).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>toUpperCase</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function toUpperCase(self): string {
    let S   = string(self);
    let s   = "";

    for ( let i=0, limit=S.length ; i &#60; limit ; i++ ) {
        let u = Unicode::toUpperCaseCharCode(<em>charCodeAt</em>(S,intrinsic::toUint(i)));
        if (u is double)
            s += <em>fromCharCode</em>(intrinsic::toUint(u));
        else {
            for ( let j=0 ; j &#60; u.length ; j++ )
                s += <em>fromCharCode</em>(u[j]);
        }
    }
    return s;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  Because both <code>toUpperCase</code> and <code>toLowerCase</code> have
context-sensitive behaviour, the functions are not symmetrical. In
other words, <code>string.toLowerCase(string.toUpperCase(s))</code> is not
necessarily equal to <code>string.toLowerCase(s)</code>.


<h3>toLocaleUpperCase&nbsp;(&nbsp;self&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>toLocaleUpperCase</code> method works exactly the same
as the static <code>toUpperCase</code> method except that it is intended to
yield the correct result for the host environment's current locale,
rather than a locale-independent result.  There will only be a
difference in the few cases (such as Turkish) where the rules for that
language conflict with the regular Unicode case mappings.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>toLocaleUpperCase</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span>
The static <code>toLocaleUpperCase</code> method is implementation-dependent.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The second parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<h3>trim&nbsp;(&nbsp;self&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>trim</code> method extracts a substring from <i>self</i>
(converted to <code>string</code>) such that the extracted string contains no
whitespace characters at either end.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>trim</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static function trim(s): string {
    s = string(s);

    let len = s.length;
    let i, j;

    for ( i=0 ; i &#60; len && Unicode::isTrimmableSpace(s.charAt(i)) ; i++ )
        ;
    for ( j=len-1 ; j >= i && Unicode::isTrimmableSpace(s.charAt(j)) ; j-- )
        ;
    return s.substring(i,j+1);
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #179.) Reference to Unicode library -- handle this somehow.

<h2>Methods on <code>string</code> instances</h2>

<h3>intrinsic::toString</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns this string value: the object itself.

<PRE>
override intrinsic function toString() : string
    this;
</PRE>

<h3>intrinsic::valueOf</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns this string value: the object itself.

<PRE>
override intrinsic function valueOf() : string
    this;
</PRE>

<h3>Methods that delegate to static methods</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic methods <code>charAt</code>, <code>charCodeAt</code>, <code>concat</code>,
<code>indexOf</code>, <code>lastIndexOf</code>, <code>localeCompare</code>, <code>match</code>,
<code>replace</code>, <code>search</code>, <code>slice</code>, <code>split</code>,
<code>substring</code>, <code>toLowerCase</code>, <code>toLocaleLowerCase</code>,
<code>toUpperCase</code>, <code>toLocaleUpperCase</code>, and <code>trim</code> all delegate to
the corresponding static methods on the <code>string</code> class.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> These intrinsic methods return what their corresponding static
methods on the <code>string</code> class return.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function charAt(pos: double = 0) : string
    string.charAt(this, pos);
</PRE>
<PRE>
intrinsic function charCodeAt(pos: double = 0) : double
    string.charCodeAt(this, pos);
</PRE>
<PRE>
intrinsic function concat(...args) : string
    string.<em>concat</em>(this, args);
</PRE>
<PRE>
intrinsic function indexOf(searchString: string, position: double = 0.0) : double
    string.indexOf(this, searchString, position);
</PRE>
<PRE>
intrinsic function lastIndexOf(searchString: string, position: double) : double
    string.lastIndexOf(this, searchString, position);
</PRE>
<PRE>
intrinsic function localeCompare(that : string) : double
    string.localeCompare(this, that);
</PRE>
<PRE>
intrinsic function match(regexp: RegExp) : Array
    string.match(this, regexp);
</PRE>
<PRE>
intrinsic function replace(searchValue: (string|RegExp!),
                           replaceValue: (string|function(...):string)) : string
    string.replace(this, searchValue, replaceValue);
</PRE>
<PRE>
intrinsic function search(regexp: RegExp!) : double
    string.search(this, regexp);
</PRE>
<PRE>
intrinsic function slice(start: AnyNumber=NaN, end: AnyNumber=NaN, step: AnyNumber=1): string
    string.slice(this, start, end, step);
</PRE>
<PRE>
intrinsic function split(separator:(string|RegExp!), limit: double = double.MAX_VALUE): Array!
    string.split(this, separator, limit)

    static function split(self, separator, limit) : Array! {
    type matcher = (string|RegExp!);

    let function splitMatch(R: matcher, S: string, q: double) : [double, [string]]? {
        switch type (R) {
            case (x: string) {
                let r = x.length;
                if (q + r &#60;= S.length && S.substring(q, q + r) === R)
                    return [q+r, []];
                else
                    return null;
            }
            case (x: RegExp!) {
                let mr: MatchResult = x.<em>match</em>(S, q);
                if (mr === null)
                    return null;
                else
                    return [mr.endIndex, mr.captures];
            }
            }
    }

    let A   = new Array;
    let lim = limit === undefined ? double.MAX_VALUE : double(limit);
    let S   = string(self);
    let s   = S.length;
    let p   = 0;
    let R;

    if (separator !== null && separator is RegExp)
        R = separator;
    else
        R = string(separator);

    if (lim === 0)
        return A;

    if (separator === undefined) {
        A[0] = S;
        return A;
    }

    if (s === 0) {
        let z = splitMatch(R, S, 0);
        if (z === null)
            A[0] = S;
        return A;
    }

    for ( let q = p ; q !== s ; ) {
        let z = splitMatch(R, S, q);
        if (z === null) {
            ++q;
            continue;
        }

        let [e,cap] = z;
        if (e === p) {
            ++q;
            continue;
        }

        A[A.length] = S.substring(p, q);
        if (A.length === lim)
            return A;

        p = e;

        for ( let i=1 ; i &#60; cap.length ; i++ ) {
            A[A.length] = cap[i];
            if (A.length === lim)
                return A;
        }

        q = p;
    }

    A[A.length] = S.substring(p, s);
    return A;
}
</PRE>
<PRE>
intrinsic function substring(start: double, end: double=this.length) : string
    string.substring(this, start, end);
</PRE>
<PRE>
intrinsic function toLowerCase() : string
    string.toLowerCase(this);
</PRE>
<PRE>
intrinsic function toLocaleLowerCase() : string
    string.toLowerCase(this);
</PRE>
<PRE>
intrinsic function toUpperCase() : string
    string.toUpperCase(this);
</PRE>
<PRE>
intrinsic function toLocaleUpperCase() : string
    string.toLocaleUpperCase(this);
</PRE>
<PRE>
intrinsic function trim() : string
    string.trim(this);
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The second parameter to the intrinsic method <code>localeCompare</code>
and the first parameter to the intrinsic methods <code>toLocaleLowerCase</code>
and <code>toLocaleUpperCase</code> are likely to be used in a future version of
this standard; it is recommended that implementations do not use these
parameter position for anything else.
 
<h1>Boolean classes</h1>



<P><span class="pcounter"></span> ECMAScript provides a primitive truth value representation in the
class <code>boolean</code>.  It is primitive in the sense that this
representation is directly operated upon by the operators of the
language, and in the sense that the class <code>boolean</code> is a final and
non-dynamic class for which ECMAScript implementations may provide
efficient representations.

<P><span class="pcounter"></span> ECMAScript also provides the class <code>Boolean</code>, which is a dynamic
non-final class that holds <code>boolean</code> values.  

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  Instances of <code>Boolean</code> are not normally converted to
<code>boolean</code> when operated upon by operators of the language.


<H2 id="type AnyBoolean"> The type <code>AnyBoolean</code> </h2>

<P><span class="pcounter"></span> The type <code>AnyBoolean</code> is a union containing all the built-in
boolean types.  By standard subtyping rules it also includes all
classes that extend <code>Boolean</code>.

<PRE>
__ES4__ type AnyBoolean = (boolean|Boolean!);
</PRE>


<H1 id="class Boolean"> The class <code>Boolean</code> </h1>

<P><span class="pcounter"></span> The class <code>Boolean</code> is a dynamic, nullable, non-final subclass
of <code>Object</code> that holds a boolean value in the form of a <code>boolean</code>
object.  Instances of <code>Boolean</code> are converted to <code>boolean</code> when
operated upon by operators of the language.

<P><span class="pcounter"></span> The class <code>Boolean</code> can be extended and the extending classes
can provide novel representations for boolean values.


<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Boolean</code> provides the following interface:

<PRE>
dynamic class Boolean
{
    function Boolean(x=false) : val = boolean(x) {} &#x0085
    static meta function invoke(x=false) : boolean &#x0085

    static const length: uint = 1

    override intrinsic function toString() : string &#x0085
    override intrinsic function valueOf() : boolean &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>Boolean</code> prototype object provides the following direct properties:

<PRE>
    toString: function (this: Booleans) &#x0085;
    valueOf:  function (this: Booleans) &#x0085;
</PRE>

<P><span class="pcounter"></span> The <code>Boolean</code> prototype object is also the prototype object of
the class <code>boolean</code>.

<h2>Methods on the <code>Boolean</code> class object</h2>

<h3>new&nbsp;Boolean&nbsp;(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>Boolean</code> constructor intializes a new <code>Boolean</code> object
by storing <i>value</i>, converted to <code>boolean</code>, in a private property.
The default <i>value</i> is <b>false</b>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>Boolean</code> constructor is implementation-defined.

<h3>Boolean(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>Boolean</code> class object called as a function converts
<i>value</i> to <code>boolean</code> (not <code>Boolean</code>).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>boolean</code> class object called as a function returns a
<code>boolean</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(x=false) : boolean
    boolean(x);
</PRE>

<h2>Methods on <code>Boolean</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts this boolean value
to a string.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString() : string
    intrinsic::valueOf().intrinsic::toString();
</PRE>

<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns this boolean value.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns a <code>boolean</code> object
(not a <code>Boolean</code> object).

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf() : boolean
    val;
</PRE>

<h2>Methods on the <code>Boolean</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods on the <code>Boolean</code> prototype object invoke their
intrinsic counterparts.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The methods on the <code>Boolean</code> prototype object return what their
intrinsic counterparts return.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this: AnyBoolean)
    this.intrinsic::toString();
</PRE>
<PRE>
prototype function valueOf(this: AnyBoolean)
    this.intrinsic::valueOf();

</PRE>


<H1 id="class boolean"> The class <code>boolean</code> </h1>

<P><span class="pcounter"></span> The class <code>boolean</code> is a non-dynamic, non-nullable, final
subclass of <code>Object</code>.  It represents a boolean value (<b>true</b> or
<b>false</b>).

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The class <code>boolean</code> is new in the 4th Edition of this
Standard, but <code>boolean</code> models the "boolean values" in the 3rd
Edition.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>boolean</code> provides the following interface:

<PRE>
final class boolean!
{
    function boolean(value=false) &#x0085
    static meta function invoke(x=false) : boolean &#x0085

    static const length: uint = 1

    override intrinsic function toString() : string &#x0085
    override intrinsic function valueOf() : boolean &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>boolean</code> prototype object is the same as the <code>Boolean</code>
prototype object (<span class="xref">Boolean.prototype</span>).


<h2>Methods on the <code>boolean</code> class object</h2>

<h3>new&nbsp;boolean&nbsp;(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>boolean</code> constructor intializes a new <code>boolean</code> object
by storing an implementation-dependent representation of the truth
value of <i>value</i>, as computed by <code>ToBoolean</code> (see <span class="xref">ToBoolean</span>), in a private
property.  The default <i>value</i> is <b>false</b>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>boolean</code> constructor is implementation-defined.

<h3>boolean(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>boolean</code> class object called as a function converts
<i>value</i> to <code>boolean</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>boolean</code> class object called as a function returns a
<code>boolean</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(x=false) : boolean
    (x is boolean) ? x : new boolean(x);
</PRE>

<h2>Methods on <code>boolean</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts this boolean value
to a string, either <code>"true"</code> or <code>"false"</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns the string.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString() : string
    this ? "true" : "false";
</PRE>

<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns a <code>boolean</code> instance:
the object on which the method was invoked.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns its <code>this</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf() : boolean
    this;
</PRE>


<h1>Number classes</h1>



<P><span class="pcounter"></span> ECMAScript provides a variety of primitive number representations.
They are primitive in the sense that these are the representations
directly operated upon by the operators of the language, and also in
the sense that they are represented by final non-dynamic classes for
which ECMAScript implementations may provide efficient
representations.

<P><span class="pcounter"></span> The class <code>double</code> represents 64-bit IEEE-format binary floating
point numbers approximately in the range -1.7976931348623157 &#x00D7;
10<SUP>308</SUP> to +1.7976931348623157 &#x00D7; 10<SUP>308</SUP>.

<P><span class="pcounter"></span> The class <code>decimal</code> represents 128-bit IEEE-format decimal
floating point numbers in the range
<NOBR>-(10<SUP>34</SUP>-1) &#x00D7; 10<SUP>6111</SUP></NOBR> to
<NOBR>(10<SUP>34</SUP>-1) &#x00D7; 10<SUP>6111</SUP></NOBR>.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The 3rd Edition of this Standard provided only one kind of
primitive number value, represented as 64-bit IEEE-format binary
floating point.

<P><span class="pcounter"></span> ECMAScript also provides the class <code>Number</code>, which is a dynamic
non-final class that represents 64-bit IEEE-format binary floating
point numbers.


<H2 id="type AnyNumber"> The type <code>AnyNumber</code> </h2>

<P><span class="pcounter"></span> The type <code>AnyNumber</code> is a union type that contains all the number
types in the language.

<PRE>
__ES4__ type AnyNumber = (double|decimal|Number!);
</PRE>


<H1 id="class Number"> The class <code>Number</code> </h1>

<P><span class="pcounter"></span> The class <code>Number</code> is a dynamic, nullable, non-final direct
subclass of <code>Object</code> that holds a <code>double</code> value.

<P><span class="pcounter"></span> All intrinsic methods of <code>Number</code> obtain the number value stored
in the object by calling the intrinsic <code>valueOf</code> method.  If the
class <code>Number</code> is extended then the extending class can override the
intrinsic <code>valueOf</code> method in order to provide new ways of
representing the number value stored in the class.

<P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method is not constrained to return a
<code>double</code> value, it can return any primitive number type.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Number</code> provides the following interface:

<PRE>
dynamic class Number
{
    function Number(value=0) &#x0085
    static meta function invoke(value=0) &#x0085
    
    static const MAX_VALUE: double = double.MAX_VALUE
    static const MIN_VALUE: double = double.MIN_VALUE
    static const NaN: double = double.NAN
    static const NEGATIVE_INFINITY: double = double.NEGATIVE_INFINITY
    static const POSITIVE_INFINITY: double = double.POSITIVE_INFINITY
    static const length: uint = 1

    override intrinsic function toString(radix = 10) : string &#x0085
    override intrinsic function toLocaleString() : string &#x0085
    override intrinsic function valueOf(): (double|decimal) &#x0085

    intrinsic function toFixed(fractionDigits=0): string &#x0085
    intrinsic function toExponential(fractionDigits=undefined) : string &#x0085
    intrinsic function toPrecision(precision=undefined) : string &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>Number</code> prototype object provides these direct properties:

<PRE>
    toString:       function (this: Numeric, radix) &#x0085;
    toLocaleString: function (this: Numeric) &#x0085;
    valueOf:        function (this: Numeric) &#x0085;
    toFixed:        function (this: Numeric, fractionDigits) &#x0085;
    toExponential:  function (this: Numeric, fractionDigits) &#x0085;
    toPrecision:    function (this: Numeric, precision) &#x0085;
</PRE>


<h2>Methods on the <code>Number</code> class object</h2>

<h3>new&nbsp;Number(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>Number</code> constructor initialises the newly created
<code>Number</code> object by storing <i>value</i> (which defaults to +0),
converted to <code>double</code>, in a private property.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  It is likely that <code>Number</code> should not be constrained to hold
<code>double</code> values, but that it should be able to hold any numeric type
and that its methods should work properly on any numeric type, in a
type-specific manner.


<h3>Number(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Number</code> class object is called as a function it
performs a type conversion: if <i>value</i> (which defaults to +0) is not
a primitive number type it is converted to <code>double</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Number</code> class object called as a function returns
<i>value</i> converted to a primitive number type.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(value=0) {
    if (value is AnyNumber)
        return value;
    return double(value);
}
</PRE>

<h2>Value properties on the <code>Number</code> class object</h2>

<h3>MAX_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MAX_VALUE</code> is the largest positive finite value
represented by the <code>double</code> class.

<h3>MIN_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MIN_VALUE</code> is the smallest positive value
represented by the <code>double</code> class.

<h3>NaN</h3>

<P><span class="pcounter"></span> The value of <code>NaN</code> is the not-a-number value represented by the
<code>double</code> class.

<h3>NEGATIVE_INFINITY</h3>

<P><span class="pcounter"></span> The value of <code>NEGATIVE_INFINITY</code> is the value -&#x221E; as
represented by a <code>double</code> object.

<h3>POSITIVE_INFINITY</h3>

<P><span class="pcounter"></span> The value of <code>POSITIVE_INFINITY</code> is the value +&#x221E; as
represented by a <code>double</code> object.


<h2>Methods on <code>Number</code> instances</h2>


<h3>intrinsic::toString&nbsp;(&nbsp;radix=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts this number value to a string representation
in a base given by <i>radix</i>.

<P><span class="pcounter"></span> If radix is the number 10 or undefined, then the result is as for the <code>ToString</code> operator.

<P><span class="pcounter"></span> If radix is an integer from 2 to 36, but not 10, the result is an implementation-dependent string

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString(radix = 10) : string
    intrinsic::valueOf().intrinsic::toString(radix);
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The intrinsic <code>toString</code> method operates by obtaining a
primitive number value, which it then converts to string by invoking
the intrinsic <code>toString</code> method on the primitive value.

<h3>intrinsic::toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method converts this number
value to a string value that represents the number value formatted
according to the conventions of the host environment's current locale.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method returns an
implementation-dependent string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method is
implementation-dependent, and it is permissible, but not encouraged,
for it to return the same thing as the intrinsic <code>toString</code> method.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.


<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns the number value
represented by this <code>Number</code> object.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns a primitive number value.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf(): (double|decimal)
    val;
</PRE>


<h3>Intrinsic methods that delegate to methods on primitive types</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toFixed</code>, <code>toExponential</code>, and
<code>toPrecision</code> methods operate by obtaining a primitive number value
from the intrinsic <code>valueOf</code> method, then invoking the appropriate
method on the primitive value.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toFixed</code>, <code>toExponential</code>, and
<code>toPrecision</code> methods return what their delegates return.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toFixed(fractionDigits=0): string
    intrinsic::valueOf().intrinsic::toFixed(fractionDigits);
</PRE>
<PRE>
intrinsic function toExponential(fractionDigits=undefined) : string
    intrinsic::valueOf().intrinsic::toExponential(fractionDigits);
</PRE>
<PRE>
intrinsic function toPrecision(precision=undefined) : string
    intrinsic::valueOf().intrinsic::toPrecision(precision);
</PRE>

<h2>Methods on the <code>Number</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods on the <code>Number</code> prototype object are constrained to
being invoked on members of the type <code>Numeric</code>.  All operate by
calling the corresponding intrinsic method on the <code>this</code> object.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The <code>Number</code> prototype object is also the prototype object
for <code>int</code>, <code>uint</code>, <code>double</code>, and <code>decimal</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The methods on the <code>Number</code> prototype object return what
their corresponding intrinsic methods return.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this: AnyNumber, radix=10)
    this.intrinsic::toString(radix);
</PRE>
<PRE>
prototype function toLocaleString(this: AnyNumber)
    this.intrinsic::toLocaleString();
</PRE>
<PRE>
prototype function valueOf(this: AnyNumber)
    this.intrinsic::valueOf();
</PRE>
<PRE>
prototype function toFixed(this:AnyNumber, fractionDigits)
    this.intrinsic::toFixed(fractionDigits);
</PRE>
<PRE>
prototype function toExponential(this: AnyNumber, fractionDigits)
    this.intrinsic::toExponential(fractionDigits);
</PRE>
<PRE>
prototype function toPrecision(this: AnyNumber, precision)
    this.intrinsic::toPrecision(precision);

</PRE>



<H1 id="class double"> The class <code>double</code> </h1>



<P><span class="pcounter"></span> The class <code>double</code> is a final, non-nullable, non-dynamic direct
subclass of <code>Object</code> that represents 64-bit ("double precision")
IEEE binary floating point number values in the range
-(1-(1/2)<SUP>53</SUP>) &#x00D7; 2<SUP>1024</SUP> to
+(1-(1/2)<SUP>53</SUP>) &#x00D7; 2<SUP>1024</SUP> inclusive
(approximately the range -1.7976931348623157 &#x00D7; 10<SUP>308</SUP>
to +1.7976931348623157 &#x00D7; 10<SUP>308</SUP>, inclusive), plus the
three special values -&#x221E;, +&#x221E;, and NaN.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The class <code>double</code> is new in the 4th Edition of this
Standard, but <code>double</code> models the "number values" in the 3rd
Edition.


<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>double</code> provides the following interface:

<PRE>
final class double!
{
    function double(value=false) &#x0085
    static meta function invoke(x=0d) &#x0085
    
    static const MAX_VALUE: double = &#x0085;
    static const MIN_VALUE: double = &#x0085;
    static const NaN: double = &#x0085;
    static const NEGATIVE_INFINITY: double = &#x0085;
    static const POSITIVE_INFINITY: double = &#x0085;
    static const E: double = &#x0085;
    static const LN10: double = &#x0085;
    static const LN2: double = &#x0085;
    static const LOG2E: double = &#x0085;
    static const LOG10E: double = &#x0085;
    static const PI: double = &#x0085;
    static const SQRT1_2: double = &#x0085;
    static const SQRT2: double = &#x0085;
    static const length: uint = 1

    override intrinsic function toString(radix = 10) : string &#x0085
    override intrinsic function toLocaleString() : string &#x0085
    override intrinsic function valueOf() : double &#x0085

    intrinsic function toFixed(fractionDigits=0) : string &#x0085
    intrinsic function toExponential(fractionDigits=undefined) : string &#x0085
    intrinsic function toPrecision(precision=undefined) : string &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>double</code> prototype object is identical to the <code>Number</code>
prototype object (<span class="xref">Number.prototype</span>).

<h2>Methods on the <code>double</code> class object</h2>

<h3>new&nbsp;double(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>double</code> constructor initialises the newly created
<code>double</code> object by storing an implementation-dependent
representation of the double-precision value of <i>value</i>, converted
to a number by the ToNumber operator, in a private property.  The
default <i>value</i> is 0.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>double</code> constructor is implementation-dependent.

<h3>double(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>double</code> class object is called as a function it
performs a type conversion: it converts <i>value</i> (which defaults
to +0) to <code>double</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>double</code> class object called as a function returns
<i>value</i> converted to <code>double</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(x=0d)
    (x is double) ? x : new double(x);
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #176.)  The optimization used here, <code>magic::newDouble</code> for <code>new
double</code>, makes the spec harder than it needs to be.

<h2>Value properties on the <code>double</code> class object</h2>

<h3>MAX_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MAX_VALUE</code> is the largest positive finite value
represented by the <code>double</code> class, type, which is
approximately 1.7976931348623157 &#x00D7; 10<SUP>308</SUP>.

<h3>MIN_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MIN_VALUE</code> is the smallest positive value
represented by the <code>double</code> class, which is approximately 5 &#x00D7;
10<SUP>-324</SUP>.

<h3>NaN</h3>

<P><span class="pcounter"></span> The value of <code>NaN</code> is the not-a-number value represented by a
<code>double</code> instance.

<h3>NEGATIVE_INFINITY</h3>

<P><span class="pcounter"></span> The value of <code>NEGATIVE_INFINITY</code> is the value -&#x221E; as
represented by a <code>double</code> instance.

<h3>POSITIVE_INFINITY</h3>

<P><span class="pcounter"></span> The value of <code>POSITIVE_INFINITY</code> is the value +&#x221E; as
represented by a <code>double</code> instance.

<h3>E</h3>

<P><span class="pcounter"></span> The value of <code>E</code> is the <code>double</code> value for <i>e</i>, the base of the
natural logarithms, which is approximately 2.7182818284590452354.

<h3>LN10</h3>

<P><span class="pcounter"></span>The value of <code>LN10</code> is the <code>double</code> value for the natural
logarithm of 10, which is approximately 2.302585092994046.

<h3>LN2</h3>

<P><span class="pcounter"></span>The value of <code>LN2</code> is the <code>double</code> value for the natural
logarithm of 2, which is approximately 0.6931471805599453.

<h3>LOG2E</h3>

<P><span class="pcounter"></span>The value of <code>LOG2E</code> is the <code>double</code> value for the base-2
logarithm of <i>e</i>, the base of the natural logarithms; this value is
approximately 1.4426950408889634.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>double.LOG2E</code> is approximately the reciprocal
of the value of <code>double.LN2</code>.

<h3>LOG10E</h3>

<P><span class="pcounter"></span>The value of <code>LOG10E</code> is the double value for the base-10
logarithm of <i>e</i>, the base of the natural logarithms; this value is
approximately 0.4342944819032518.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>double.LOG10E</code> is approximately the reciprocal
of the value of <code>double.LN10</code>.

<h3>PI</h3>

<P><span class="pcounter"></span>The value of <code>PI</code> is the <code>double</code> value for &#x03C0;, the ratio of
the circumference of a circle to its diameter, which is approximately
3.1415926535897932.

<h3>SQRT1_2</h3>

<P><span class="pcounter"></span>The value of <code>SQRT1_2</code> is the <code>double</code> value for the square
root of 1/2, which is approximately 0.7071067811865476.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>double.SQRT1_2</code> is approximately the reciprocal
of the value of <code>double.SQRT2</code>.

<h3>SQRT2</h3>

<P><span class="pcounter"></span>The value of <code>SQRT2</code> is the <code>double</code> value for the square root
of 2, which is approximately 1.4142135623730951.


<h2>Methods on <code>double</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;radix=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts this number value
to a string representation in a base given by <i>radix</i>.

<P><span class="pcounter"></span> If radix is the number 10 or undefined, then the result is as for
the <code>ToString</code> operator.

<P><span class="pcounter"></span> If radix is an integer from 2 to 36, but not 10, the result is an
implementation-dependent string

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString(radix = 10) : string {
    if (radix === 10 || radix === undefined)
        return string(this);
    if (radix is AnyNumber && radix >= 2 && radix &#60;= 36 && intrinsic::isIntegral(radix))
        return <em>toString</em>(int(radix));
    throw new TypeError("Invalid radix argument to double.toString");
}
</PRE>


<h3>intrinsic::toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method converts this number
value to a string value that represents the value of the integer
formatted according to the conventions of the host environment's
current locale.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method returns an
implementation-dependent string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method is
implementation-dependent, and it is permissible, but not encouraged,
for it to return the same thing as the intrinsic <code>toString</code> method.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns the number value
represented by this <code>double</code> object: the object itself.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns its <code>this</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf() : double
    this;
</PRE>


<h3>intrinsic::toFixed&nbsp;(&nbsp;fractionDigits=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toFixed</code> method converts the this number value
to a string in fixed-point notation with <i>fractionDigits</i> digits
after the decimal point.  If <i>fractionDigits</i> is <b>undefined</b>, 0
is assumed.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toFixed</code> method returns the fixed-point
notation string representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toFixed(fractionDigits=0) : string {
    let x = this;
    let f = <em>toInteger</em>(fractionDigits);
    if (f &#60; 0 || f > 20)
        throw new RangeError();

    if (isNaN(x))
        return "NaN";
    let s = "";
    if (x &#60; 0) {
        s = "-";
        x = -x;
    }

    if (x >= Math.pow(10,21))
        return s + string(m);

    let n = toFixedStep10(x, f);
    let m = n == 0 ? "0" : string(n);
    if (f == 0)
        return s + m;
    let k = m.length;
    if (k &#60;= f) {
        m = "00000000000000000000".substring(0,f+1-k) + m;
        k = f+1;
    }
    return s + m.substring(0,k-f) + "." + m.substring(k-f);
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #184.) Note that calling anything "step 10" no longer
makes sense.

<p class="fixme"> Note also that "step 10" is informative and needs to
be documented and implemented as such.

<P><span class="pcounter"></span> An implementation is permitted to extend the behaviour of toFixed
for values of <i>fractionDigits</i> less than 0 or greater than 20.  In
this case <code>toFixed</code> would not necessarily throw <b>RangeError</b> for
such values.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The output of <code>toFixed</code> may be more precise than <code>toString</code>
for some values because <code>toString</code> only prints enough significant
digits to distinguish the number from adjacent number values. For
example, <code>(1000000000000000128).toString()</code> returns
"1000000000000000100", while <code>(1000000000000000128).toFixed(0)</code>
returns "1000000000000000128".


<h3>intrinsic::toExponential&nbsp;(&nbsp;fractionDigits=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toExponential</code> method converts this number value
to a string in exponential notation with one digit before the
significand's decimal point and <i>fractionDigits</i> digits after the
significand's decimal point.  If <i>fractionDigits</i> is <b>undefined</b>,
include as many significand digits as necessary to uniquely specify
the number (just like in <code>ToString</code> except that in this case the
number is always output in exponential notation).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toExponential</code> method returns the exponential
notation string representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toExponential(fractionDigits=undefined) : string {
    return "**toExponential: FIXME**";
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #185.) Implement this function.

<P><span class="pcounter"></span>An implementation is permitted to extend the behaviour of
<code>toExponential</code> for values of <i>fractionDigits</i> less than 0 or
greater than 20.  In this case <code>toExponential</code> would not necessarily
throw <b>RangeError</b> for such values.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 19 be used as a guideline:

<P class="note">Let e, n, and f be integers such that <i>f &#x2265; 0</i>,
<i>10<SUP>f</SUP> &#x2264; n < 10<SUP>f+1</SUP></i>, the number value for
<i>n &#x00D7; 10<SUP>e-f</SUP></i> is <i>x</i>, and <i>f</i> is as small as
possible.  If there are multiple possibilities for <i>n</i>, choose the
value of <i>n</i> for which <i>n &#x00D7; 10<SUP>e-f</SUP></i> is closest in
value to <i>x</i>.  If there are two such possible values of <i>n</i>,
choose the one that is even.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #186.) "Step 19" is obsolete.

<h3>intrinsic::toPrecision&nbsp;(&nbsp;precision=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toPrecision</code> method converts this number value
to a string, either in exponential notation with one digit before the
significand's decimal point and <i>precision</i>-1 digits after the
significand's decimal point or in fixed notation with <i>precision</i>
significant digits.  If precision is <b>undefined</b>, call <code>ToString</code>
(<span class="xref">operator:ToString</span>) instead.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toPrecision</code> method returns the selected
string representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toPrecision(precision=undefined) : string {
    return "**toPrecision: FIXME**";
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #185.) Implement this function.

<P><span class="pcounter"></span> An implementation is permitted to extend the behaviour of
<code>toPrecision</code> for values of precision less than 1 or greater than
21.  In this case <code>toPrecision</code> would not necessarily throw
<b>RangeError</b> for such values.



<H1 id="class decimal"> The class <code>decimal</code> </h1>




<P><span class="pcounter"></span> The class <code>decimal</code> is a final, non-nullable, non-dynamic direct
subclass of <code>Object</code> that represents 128-bit IEEE decimal floating
point number values in the range 
<NOBR>-(10<SUP>34</SUP>-1) &#x00D7; 10<SUP>6111</SUP></NOBR> to
<NOBR>(10<SUP>34</SUP>-1) &#x00D7; 10<SUP>6111</SUP></NOBR> inclusive,
plus the three special values -&#x221E;, +&#x221E;, and NaN.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The class <code>decimal</code> is new in the 4th Edition of this
Standard.


<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>decimal</code> provides the following interface:

<PRE>
final class decimal!
{
    function decimal(value=false) &#x0085
    static meta function invoke(x=0m) &#x0085
    
    static const MAX_VALUE: decimal = &#x0085;
    static const MIN_VALUE: decimal = &#x0085;
    static const NaN: decimal = &#x0085;
    static const NEGATIVE_INFINITY: decimal = &#x0085;
    static const POSITIVE_INFINITY: decimal = &#x0085;
    static const E: decimal = &#x0085;
    static const LN10: decimal = &#x0085;
    static const LN2: decimal = &#x0085;
    static const LOG2E: decimal = &#x0085;
    static const LOG10E: decimal = &#x0085;
    static const PI: decimal = &#x0085;
    static const SQRT1_2: decimal = &#x0085;
    static const SQRT2: decimal = &#x0085;
    static const length: uint = 1

    override intrinsic function toString(radix = 10) : string &#x0085
    override intrinsic function toLocaleString() : string &#x0085
    override intrinsic function valueOf() : decimal &#x0085

    intrinsic function toFixed(fractionDigits=0) : string &#x0085
    intrinsic function toExponential(fractionDigits=undefined) : string &#x0085
    intrinsic function toPrecision(precision=undefined) : string &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>decimal</code> prototype object is identical to the <code>Number</code>
prototype object (<span class="xref">Number.prototype</span>).

<h2>Methods on the <code>decimal</code> class object</h2>

<h3>new&nbsp;decimal(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The <code>decimal</code> constructor initialises the newly created
<code>decimal</code> object by storing an implementation-dependent
representation of the decimal value of <i>value</i>, as converted by
<code>ToNumber</code>, in a private property.  The default <i>value</i> is +0.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span>The <code>decimal</code> constructor is implementation-dependent.

<h3>decimal(&nbsp;value=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>decimal</code> class object is called as a function it
performs a type conversion: it converts <i>value</i> (which defaults
to +0) to <code>decimal</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>decimal</code> class object called as a function returns
<i>value</i> converted to <code>decimal</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(x=0m)
    (x is decimal) ? x : new decimal(x);
</PRE>


<h2>Value properties on the <code>decimal</code> class object</h2>

<h3>MAX_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MAX_VALUE</code> is the largest positive finite value
represented by the <code>decimal</code> class, type, which is
<NOBR>(10<SUP>34</SUP>-1) &#x00D7; 10<SUP>6111</SUP></NOBR>.

<h3>MIN_VALUE</h3>

<P><span class="pcounter"></span> The value of <code>MIN_VALUE</code> is the smallest positive value
represented by the <code>decimal</code> class, which is
<NOBR>10<SUP>-6143</SUP></NOBR>.

<h3>NaN</h3>

<P><span class="pcounter"></span> The value of <code>NaN</code> is the not-a-number value represented by a
<code>decimal</code> instance.

<h3>NEGATIVE_INFINITY</h3>

<P><span class="pcounter"></span> The value of <code>NEGATIVE_INFINITY</code> is the value -&#x221E; as
represented by a <code>decimal</code> instance.

<h3>POSITIVE_INFINITY</h3>

<P><span class="pcounter"></span> The value of <code>POSITIVE_INFINITY</code> is the value +&#x221E; as
represented by a <code>decimal</code> instance.

<h3>E</h3>

<P><span class="pcounter"></span> The value of <code>E</code> is the <code>decimal</code> value for <i>e</i>, the base of the
natural logarithms, which is approximately 2.718281828459045235360287471352662.



<h3>LN10</h3>

<P><span class="pcounter"></span>The value of <code>LN10</code> is the <code>decimal</code> value for the natural
logarithm of 10, which is approximately 2.302585092994045684017991454684364.



<h3>LN2</h3>

<P><span class="pcounter"></span>The value of <code>LN2</code> is the <code>decimal</code> value for the natural
logarithm of 2, which is approximately 0.6931471805599453094172321214581766.



<h3>LOG2E</h3>

<P><span class="pcounter"></span>The value of <code>LOG2E</code> is the <code>decimal</code> value for the base-2
logarithm of <i>e</i>, the base of the natural logarithms; this value is
approximately 1.442695040888963407359924681001892.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>decimal.LOG2E</code> is approximately the reciprocal
of the value of <code>decimal.LN2</code>.



<h3>LOG10E</h3>

<P><span class="pcounter"></span>The value of <code>LOG10E</code> is the decimal value for the base-10
logarithm of <i>e</i>, the base of the natural logarithms; this value is
approximately 0.4342944819032518276511289189166051.



<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>decimal.LOG10E</code> is approximately the reciprocal
of the value of <code>decimal.LN10</code>.

<h3>PI</h3>

<P><span class="pcounter"></span>The value of <code>PI</code> is the <code>decimal</code> value for &#x03C0;, the ratio of
the circumference of a circle to its diameter, which is approximately
3.141592653589793238462643383279503.



<h3>SQRT1_2</h3>

<P><span class="pcounter"></span>The value of <code>SQRT1_2</code> is the <code>decimal</code> value for the square
root of 1/2, which is approximately 0.7071067811865475244008443621048490.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>decimal.SQRT1_2</code> is approximately the reciprocal
of the value of <code>decimal.SQRT2</code>.


     1/sqrt(2) = 0.7071067811865475244008443621048490392848359376884740365883398689953674
     as computed by math.sch -->

<h3>SQRT2</h3>

<P><span class="pcounter"></span>The value of <code>SQRT2</code> is the <code>decimal</code> value for the square root
of 2, which is approximately 1.414213562373095048801688724209698.



<h2>Methods on <code>decimal</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;radix=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts this number value
to a string representation in a base given by <i>radix</i>.

<P><span class="pcounter"></span> If radix is the number 10 or undefined, then the result is as for
the <code>ToString</code> operator.

<P><span class="pcounter"></span> If radix is an integer from 2 to 36, but not 10, the result is an
implementation-dependent string

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString(radix = 10) : string {
    if (radix === 10 || radix === undefined)
        return string(this);
    if (radix is AnyNumber && radix >= 2 && radix &#60;= 36 && intrinsic::isIntegral(radix))
        return <em>toString</em>(int(radix));
    throw new TypeError("Invalid radix argument to decimal.toString");
}
</PRE>

<h3>intrinsic::toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method converts this number
value to a string value that represents the value of the integer
formatted according to the conventions of the host environment's
current locale.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method returns an
implementation-dependent string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method is
implementation-dependent, and it is permissible, but not encouraged,
for it to return the same thing as the intrinsic <code>toString</code> method.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.


<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns the number value
represented by this <code>decimal</code> object: the object itself.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns its <code>this</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf() : decimal
    this;
</PRE>


<h3>intrinsic::toFixed&nbsp;(&nbsp;fractionDigits=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toFixed</code> method converts this number value
to a string in fixed-point notation with <i>fractionDigits</i> digits
after the decimal point.  If <i>fractionDigits</i> is <b>undefined</b>, 0
is assumed.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toFixed</code> method returns the fixed-point
notation string representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toFixed(fractionDigits=0) : string
    double(this).intrinsic::toFixed(fractionDigits);
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #188.) That implementation is bogus.

<P><span class="pcounter"></span> An implementation is permitted to extend the behaviour of toFixed
for values of <i>fractionDigits</i> less than 0 or greater than 20.  In
this case <code>toFixed</code> would not necessarily throw <b>RangeError</b> for
such values.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #188.) Greater number of fractionDigits is possible for decimal.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The output of <code>toFixed</code> may be more precise than <code>toString</code>
for some values because <code>toString</code> only prints enough significant
digits to distinguish the number from adjacent number values. For
example, <code>(1000000000000000128).toString()</code> returns
"1000000000000000100", while <code>(1000000000000000128).toFixed(0)</code>
returns "1000000000000000128".

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #188.) Better example / more precision (for decimal).

<h3>intrinsic::toExponential&nbsp;(&nbsp;fractionDigits=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toExponential</code> method converts this number value
to a string in exponential notation with one digit before the
significand's decimal point and <i>fractionDigits</i> digits after the
significand's decimal point.  If <i>fractionDigits</i> is <b>undefined</b>,
include as many significand digits as necessary to uniquely specify
the number (just like in <code>ToString</code> except that in this case the
number is always output in exponential notation).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>toExponential</code> method returns the exponential
notation string representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toExponential(fractionDigits=undefined) : string
    double(this).intrinsic::toExponential(fractionDigits);
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #188.) That implementation is bogus.

<P><span class="pcounter"></span>An implementation is permitted to extend the behaviour of
<code>toExponential</code> for values of <i>fractionDigits</i> less than 0 or
greater than 20.  In this case <code>toExponential</code> would not necessarily
throw <b>RangeError</b> for such values.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #188.) Greater number of fractionDigits is possible for decimal.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  For implementations that provide more accurate conversions than
required by the rules above, it is recommended that the following
alternative version of step 19 be used as a guideline:

<P class="note">Let e, n, and f be integers such that <i>f &#x2265; 0</i>,
<i>10<SUP>f</SUP> &#x2264; n < 10<SUP>f+1</SUP></i>, the number value for
<i>n &#x00D7; 10<SUP>e-f</SUP></i> is <i>x</i>, and <i>f</i> is as small as
possible.  If there are multiple possibilities for <i>n</i>, choose the
value of <i>n</i> for which <i>n &#x00D7; 10<SUP>e-f</SUP></i> is closest in
value to <i>x</i>.  If there are two such possible values of <i>n</i>,
choose the one that is even.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #188.) "Step 19" is obsolete.


<h3>intrinsic::toPrecision&nbsp;(&nbsp;precision=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toPrecision</code> method converts this number value
to a string, either in exponential notation with one digit before the
significand's decimal point and <i>precision</i>-1 digits after the
significand's decimal point or in fixed notation with <i>precision</i>
significant digits.  If precision is <b>undefined</b>, call <code>ToString</code>
(<span class="xref">operator:ToString</span>) instead.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toPrecision</code> method returns the selected string
representation of this number value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toPrecision(precision=undefined) : string
    double(this).intrinsic::toPrecision(precision);
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #188.) That implementation is bogus.

<P><span class="pcounter"></span> An implementation is permitted to extend the behaviour of
<code>toPrecision</code> for values of precision less than 1 or greater than
21.  In this case <code>toPrecision</code> would not necessarily throw
<b>RangeError</b> for such values.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #188.) Greater precision possible for decimal.




<H1 id="Math object"> The <code>Math</code> Object </H1>



<P><span class="pcounter"></span> The global <code>Math</code> object is a single object that has some named
properties, some of which are functions.  The <code>Math</code> object is the
only instance of an internal helper class called <code>Math</code>.

<P><span class="pcounter"></span> The <code>Math</code> object acts as a container for built-in
mathematics-related functions and constants.


<h2>Synopsis</h2>

<P><span class="pcounter"></span> For convenience of notation the definition of the Math object uses
the helper type name <code>PrimitiveNumber</code>.

<PRE>
helper type PrimitiveNumber = (double|decimal);
</PRE>

<P><span class="pcounter"></span> The intrinsic methods on the math object are restricted to
arguments of the type <code>PrimitiveNumber</code>.

<P><span class="pcounter"></span> The <code>Math</code> object provides the following interface:

<PRE>
helper dynamic final class Math extends Object
{
    intrinsic function abs(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function acos(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function atan(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function atan2(y: helper::PrimitiveNumber, x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function ceil(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function cos(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function exp(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function floor(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function log(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function max(x: helper::PrimitiveNumber, y: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function min(x: helper::PrimitiveNumber, y: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function pow(x: helper::PrimitiveNumber, y: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function random(): double &#x0085
    intrinsic function round(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function sin(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function sqrt(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085
    intrinsic function tan(x: helper::PrimitiveNumber): helper::PrimitiveNumber &#x0085

    const E: double = double.E
    const LN10: double = double.LN10
    const LN2: double = double.LN2
    const LOG2E: double = double.LOG2E
    const LOG10E: double = double.LOG10E
    const PI: double = double.PI
    const SQRT1_2: double = double.SQRT1_2
    const SQRT2: double = double.SQRT2
}
</PRE>

<P><span class="pcounter"></span> The constant values <code>E</code>, <code>LN10</code>, <code>LN2</code>, <code>LOG2E</code>,
<code>LOG10E</code>, <code>PI</code>, <code>SQRT1_2</code>, and <code>SQRT2</code> in the <code>Math</code> class
are of type <code>double</code> for compatibility with 3rd Edition.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  New code may find it more convenient to access these constant
values through the <code>double</code> or <code>decimal</code> classes, as appropriate,
to obtain values with the best precision for the particular type.

<P><span class="pcounter"></span> The <code>Math</code> object additionally provides the following dynamic
function properties.  These functions are not restricted in the types
of arguments they accept, but convert all their arguments to a
primitive number.

<PRE>
    abs:    function (x) &#x0085; ,
    acos:   function (x) &#x0085; ,
    asin:   function (x) &#x0085; ,
    atan:   function (x) &#x0085; ,
    atan2:  function (y,x) &#x0085; ,
    ceil:   function (x) &#x0085; ,
    cos:    function (x) &#x0085; ,
    exp:    function (x) &#x0085; ,
    floor:  function (x) &#x0085; ,
    log:    function (x) &#x0085; ,
    max:    function (...xs) &#x0085; ,
    min:    function (...xs) &#x0085; ,
    pow:    function (x,y) &#x0085; ,
    random: function () &#x0085; ,
    round:  function (x) &#x0085; ,
    sin:    function (x) &#x0085; ,
    sqrt:   function (x) &#x0085; ,
    tan:    function (x) &#x0085;
</PRE>

<P><span class="pcounter"></span> The <code>[[Prototype]]</code> object of the <code>Math</code> object does not contain a
<code>constructor</code> property.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The constraint on <code>constructor</code> is for backward compatibility
and is also necessary to insure that the math object is a singleton
object.  But note that <code>Math.constructor</code> is still defined, it is
accessible through the prototype chain and is <code>Object.constructor</code>.


<h2>Primitive operations on numbers</h2>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #189.) Describe the following helper and informative
functions here: isPositive, isPositiveZero, isNegativeZero,
isOddInteger.


<h2>Intrinsic function properties of the Math object</h2>

<P><span class="pcounter"></span> In the function descriptions below, the symbols NaN, -0, +0, -&#x221E;
and +&#x221E; refer to the number values described in 8.5.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Clean up the cross-reference later.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The behaviour of the functions <code>acos</code>, <code>asin</code>, <code>atan</code>,
<code>atan2</code>, <code>cos</code>, <code>exp</code>, <code>log</code>, <code>pow</code>, <code>sin</code>, and <code>sqrt</code>
is not precisely specified here except to require specific results for
certain argument values that represent boundary cases of interest. For
other argument values, these functions are intended to compute
approximations to the results of familiar mathematical functions, but
some latitude is allowed in the choice of approximation
algorithms. The general intent is that an implementer should be able
to use the same mathematical library for ECMAScript on a given
hardware platform that is available to C programmers on that platform.

<P class="note"> Although the choice of algorithms is left to the
implementation, it is recommended (but not specified by this standard)
that implementations use the approximation algorithms for IEEE 754
arithmetic contained in fdlibm, the freely distributable mathematical
library from Sun Microsystems (<code>fdlibm-comment@sunpro.eng.sun.com</code>).
This specification also requires specific results for certain argument
values that represent boundary cases of interest.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The functions defined in this section preserve the
representation of the argument(s) in the result where this is
reasonable.  All functions map <code>double</code> and <code>decimal</code> arguments to
<code>double</code> and <code>decimal</code> results, respectively.


<h3>intrinsic::abs&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span>The intrinsic <code>abs</code> function computes the absolute value of
the number <i>x</i>, which has the same magnitude as <i>x</i> but has
positive sign.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span>The intrinsic <code>abs</code> function returns the absolute value of
<i>x</i>.  The representation of the result is the same as the
representation of <i>x</i>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span>
<PRE>
intrinsic function abs(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (isNaN(n)) return n;
        if (x == 0) return 0;
        return n &#60; 0 ? -n : n;
    }
    case (n: decimal) {
        if (isNaN(n)) return n;
        if (x == 0m) return 0m;
        return n &#60; 0m ? -n : n;
    }
    }
}
</PRE>


<h3>intrinsic::acos&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>acos</code> function computes an
implementation-dependent approximation to the arc cosine of the number
<i>x</i>.  The result is expressed in radians and ranges from +0 to +&#x03C0;.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>acos</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function acos(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (isNaN(n) || n > 1 || n &#60; -1) return NaN;
        if (n == 1) return 0;
        return <em>acosDouble</em>(n);
    }
    case (n: decimal) {
        if (isNaN(n) || n > 1m || n &#60; 1m) return decimal.NaN;
        if (n == 1m) return 0m;
        return <em>acosDecimal</em>(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>acosDouble</code> and <code>acosDecimal</code>
implement representation-preserving approximate computation of the arc
cosine of their argument.

<PRE>
informative function acosDouble(x: double): double &#x0085
informative function acosDecimal(x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::asin&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>asin</code> function computes an
implementation-dependent approximation to the arc sine of the number
<i>x</i>.  The result is expressed in radians and ranges from -&#x03C0;/2 to
+&#x03C0;/2.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>asin</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function asin(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (isNaN(n) || n > 1 || n &#60; -1) return NaN;
        if (n == 0) return n;
        return <em>asinDouble</em>(n);
    }
    case (n: decimal) {
        if (isNaN(n) || n > 1m || n &#60; 1m) return decimal.NaN;
        if (n == 0m) return n;
        return <em>asinDecimal</em>(n);
    }
    }
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The intrinsic <code>asin</code> function preserves the sign of <i>x</i> if x is 0.

<P><span class="pcounter"></span> The informative functions <code>asinDouble</code> and <code>asinDecimal</code>
implement representation-preserving approximate computation of the arc
sine of their argument.

<PRE>
informative function asinDouble(x: double): double &#x0085
informative function asinDecimal(x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::atan&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>atan</code> function computes an
implementation-dependent approximation to the arc tangent of the
number <i>x</i>.  The result is expressed in radians and ranges from
-&#x03C0;/2 to +&#x03C0;/2.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>atan</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function atan(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (isNaN(n) || n == 0) return n;
        if (!isFinite(n))
            return copysign(double.PI / 2, n);
        return <em>atanDouble</em>(n);
    }
    case (n: decimal) {
        if (isNaN(n) || n == 0m) return n;
        if (!isFinite(n))
            return copysign(decimal.PI / 2m, n);
        return <em>atanDecimal</em>(n);
    }
    }
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; The intrinsic <code>atan</code> function preserves the sign of <i>x</i> if x is 0.

<P><span class="pcounter"></span> The informative functions <code>atanDouble</code> and <code>atanDecimal</code>
implement representation-preserving approximate computation of the arc
tangent of their argument.

<PRE>
informative function atanDouble(x: double): double &#x0085
informative function atanDecimal(x: decimal): decimal &#x0085
</PRE>

<h3>intrinsic::atan2&nbsp;(y,&nbsp;x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>atan2</code> function computes an
implementation-dependent approximation to the arc tangent of the
quotient <i>y/x</i> of the numbers <i>y</i> and <i>x</i>, where the signs of
<i>y</i> and <i>x</i> are used to determine the quadrant of the result.
Note that it is intentional and traditional for the two-argument arc
tangent function that the argument named <i>y</i> be first and the
argument named <i>x</i> be second. The result is expressed in radians and
ranges from -&#x03C0; to +&#x03C0;.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>atan2</code> function returns a floating-point
number.  The result is <code>decimal</code> of <i>y</i> or <i>x</i> is <code>decimal</code>,
otherwise <code>double</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function atan2(y: <em>PrimitiveNumber</em>, x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    if (y is decimal && !(x is decimal))
        x = decimal(x);
    else if (x is decimal && !(y is decimal))
        y = decimal(y);

    let Type = (x is double) ? double : decimal;

    if (isNaN(x) || isNaN(y))
        return Type.NaN;
    if (y > 0 && x == 0)
        return Type.PI/2;
    if (<em>isPositiveZero</em>(y))
        return <em>isPositive</em>(x) ? Type(+0) : Type.PI;
    if (<em>isNegativeZero</em>(y))
        return <em>isPositive</em>(x) ? Type(-0) : -Type.PI;
    if (y &#60; 0 && x == 0)
        return -Type.PI/2;
    if (y != 0 && isFinite(y) && !isFinite(x) && x > 0)
        return Type(copysign(0, y));
    if (y != 0 && isFinite(y) && !isFinite(x) && x &#60; 0)
        return copysign(Type.PI, y);
    if (!isFinite(y) && isFinite(x))
        return copysign(Type.PI/2, y);
    if (!isFinite(y) && !isFinite(x))
        return copysign(x > 0 ? Type.PI/4 : 3*Type.PI/4, y);

    if (Type == double)
        return <em>atan2Double</em>(y, x);
    return <em>atan2Decimal</em>(y, x);
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  An implementation is free to produce approximations for all
computations involving <code>PI</code> in the preceding algorithm.

<P><span class="pcounter"></span> The informative functions <code>atan2Double</code> and <code>atan2Decimal</code>
implement representation-preserving approximate computation of the arc
tangent of the quotient of their arguments.

<PRE>
informative function atan2Double(y: double, x: double): double &#x0085
informative function atan2Decimal(y: decimal, x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::ceil&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>ceil</code> function computes the smallest (closest
to -&#x221E;) number value that is not less than <i>x</i> and is equal to
a mathematical integer. If <i>x</i> is already an integer, the result is
<i>x</i>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>Math.ceil(<i>x</i>)</code> is the same as the value of
<code>-Math.floor(-<i>x</i>)</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>ceil</code> function returns a number in the same
representation as <i>x</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function ceil(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (!isFinite(n) || n == 0) return n;
        if (-1 &#60; n && n &#60; 0) return -0;
        return <em>ceilDouble</em>(n);
    }
    case (n: decimal) {
        if (!isFinite(n) || n == 0m) return n;
        if (-1m &#60; n && n &#60; 0m) return -0m;
        return <em>ceilDecimal</em>(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>ceilDouble</code> and <code>ceilDecimal</code>
implement representation-preserving computation of the ceiling of
their argument.

<PRE>
informative function ceilDouble(x: double): double &#x0085
informative function ceilDecimal(x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::cos&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>cos</code> method computes an
implementation-dependent approximation to the cosine of the number
<i>x</i>.  The argument is expressed in radians.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>cos</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function cos(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (!isFinite(n)) return NaN;
        if (n == 0) return 1;
        return <em>cosDouble</em>(n);
    }
    case (n: decimal) {
        if (!isFinite(n)) return decimal.NaN;
        if (n == 0m) return 1m;
        return <em>cosDecimal</em>(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>cosDouble</code> and <code>cosDecimal</code>
implement representation-preserving approximate computation of the cosine
of their argument.

<PRE>
informative function cosDouble(x: double): double &#x0085
informative function cosDecimal(x: decimal): decimal &#x0085
</PRE>

<h3>intrinsic::exp&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>exp</code> function computes an
implementation-dependent approximation to the exponential function of
the number <i>x</i> (<i>e<SUP>x</SUP></i>, where <i>e</i> is the base of the
natural logarithms).

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>exp</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function exp(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (isNaN(n)) return n;
        if (n == 0) return 1d;
        if (n == Infinity) return Infinity;
        if (n == -Infinity) return 0;
        return <em>expDouble</em>(n);
    }
    case (n: decimal) {
        if (isNaN(n)) return n;
        if (n == 0m) return 1m;
        if (n == decimal.POSITIVE_INFINITY) return decimal.POSITIVE_INFINITY;
        if (n == decimal.NEGATIVE_INFINITY) return 0m;
        return <em>expDecimal</em>(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>expDouble</code> and <code>expDecimal</code>
implement representation-preserving approximate computation of the
exponential function of their argument.

<PRE>
informative function expDouble(x: double): double &#x0085
informative function expDecimal(x: decimal): decimal &#x0085
</PRE>

<h3>intrinsic::floor&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>floor</code> function computes the greatest (closest
to +&#x221E;) number value that is not greater than <i>x</i> and is equal
to a mathematical integer. If <i>x</i> is already an integer, the result
is <i>x</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>floor</code> function returns a number in the same
representation as <i>x</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function floor(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (!isFinite(n) || n == 0) return n;
        if (0 &#60; n && n &#60; 1) return +0;
        return <em>floorDouble</em>(n);
    }
    case (n: decimal) {
        if (!isFinite(n) || n == 0m) return n;
        if (0m &#60; n && n &#60; 1m) return +0m;
        return <em>floorDecimal</em>(n);
    }
    }
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>Math.floor(<i>x</i>)</code> is the same as the value of
<code>-Math.ceil(-<i>x</i>)</code>.

<P><span class="pcounter"></span> The informative functions <code>floorDouble</code> and <code>floorDecimal</code>
implement representation-preserving computation of the floor of their
argument.

<PRE>
informative function floorDouble(x: double): double &#x0085
informative function floorDecimal(x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::log&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>log</code> function computes an
implementation-dependent approximation to the natural logarithm of the
number <i>x</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>log</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function log(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (isNaN(n) || n &#60; 0) return NaN;
        if (n == 0) return -Infinity;
        if (n == 1) return +0;
        if (n == Infinity) return n;
        return <em>logDouble</em>(n);
    }
    case (n: decimal) {
        if (isNaN(n) || n &#60; 0m) return decimal.NaN;
        if (n == 0m) return decimal.NEGATIVE_INFINITY;
        if (n == 1m) return +0m;
        if (n == decimal.POSITIVE_INFINITY) return n;
        return <em>logDecimal</em>(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>logDouble</code> and <code>logDecimal</code>
implement representation-preserving approximate computation of the
natural logarithm of their argument.

<PRE>
informative function logDouble(x: double): double &#x0085
informative function logDecimal(x: decimal): decimal &#x0085
</PRE>


<h3>intrinsic::max&nbsp;(x,&nbsp;y)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>max</code> method selects the numerically largest
(closest to +&#x221E;) value among <i>x</i> and <i>y</i>.  +0 is
considered larger than -0.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>max</code> method returns either <i>x</i> or <i>y</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function max(x: <em>PrimitiveNumber</em>, y: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    if (isNaN(x)) return x;
    if (isNaN(y)) return y;
    if (x > y) return x;
    if (y > x) return y;
    if (x != 0) return x;

    let x_sign = sign(x),
        y_sign = sign(y);
    if (x_sign > y_sign) return x;
    if (y_sign > x_sign) return y;
    return x;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  If <i>x</i> and <i>y</i> are numerically equal (and of the same sign
if they are both 0) then the implementation is free to return either
one of them.

<h3>intrinsic::min&nbsp;(x,&nbsp;y)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>min</code> method selects the numerically smallest
(closest to -&#x221E;) number among <i>x</i> and <i>y</i>.  -0 is
considered smaller than +0.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>min</code> method returns either <i>x</i> or <i>y</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function min(x: <em>PrimitiveNumber</em>, y: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    if (isNaN(x)) return x;
    if (isNaN(y)) return y;
    if (x &#60; y) return x;
    if (y &#60; x) return y;
    if (x != 0) return x;

    let x_sign = sign(x),
        y_sign = sign(y);
    if (x_sign &#60; y_sign) return x;
    if (y_sign &#60; x_sign) return y;
    return x;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  If <i>x</i> and <i>y</i> are numerically equal (and of the same sign
if they are both 0) then the implementation is free to return either
one of them.

<h3>intrinsic::pow&nbsp;(x,&nbsp;y)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>pow</code> function computes an
implementation-dependent approximation to the result of raising <i>x</i>
to the power <i>y</i>.

<P><span class="pcounter"></span> The intrinsic <code>pow</code> function produces a result in the
representation of <i>x</i>.  

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>pow</code> function returns a number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function pow(x: <em>PrimitiveNumber</em>, y: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    if (x is decimal && !(y is decimal))
        y = decimal(y);
    else if (y is decimal && !(x is decimal))
        x = decimal(x);

    let Type = (x is double) ? double : decimal;

    if (isNaN(y)) return Type.NaN;
    if (y == 0) return Type(1);
    if (isNaN(x) && y != 0) return Type.NaN;
    if (abs(x) > 1 && y == Infinity) return Type.POSITIVE_INFINITY;
    if (abs(x) > 1 && y == -Infinity) return Type(+0);
    if (abs(x) == 1 && y == Infinity) return Type.NaN;
    if (abs(x) == 1 && y == -Infinity) return Type.NaN;
    if (abs(x) &#60; 1 && y == Infinity) return Type(+0);
    if (abs(x) &#60; 1 && y == -Infinity) return Type.POSITIVE_INFINITY;
    if (x == Infinity && y > 0) return Type.POSITIVE_INFINITY;
    if (x == Infinity && y &#60; 0) return Type(+0);
    if (x == -Infinity && y > 0 && <em>isOddInteger</em>(y)) return Type.NEGATIVE_INFINITY;
    if (x == -Infinity && y > 0 && !<em>isOddInteger</em>(y)) return Type.POSITIVE_INFINITY;
    if (x == -Infinity && y &#60; 0 && <em>isOddInteger</em>(y)) return Type(-0);
    if (x == -Infinity && y &#60; 0 && !<em>isOddInteger</em>(y)) return Type(+0);
    if (x == 0 && y > 0) return Type(+0);
    if (x == 0 && y &#60; 0) return Type.POSITIVE_INFINITY;
    if (<em>isNegativeZero</em>(x) && y > 0 && <em>isOddInteger</em>(y)) return Type(-0);
    if (<em>isNegativeZero</em>(x) && y > 0 && !<em>isOddInteger</em>(y)) return Type(+0);
    if (<em>isNegativeZero</em>(x) && y &#60; 0 && <em>isOddInteger</em>(y)) return Type.NEGATIVE_INFINITY;
    if (<em>isNegativeZero</em>(x) && y &#60; 0 && !<em>isOddInteger</em>(y)) return Type.POSITIVE_INFINITY;
    if (x &#60; 0 && isFinite(x) && isFinite(y) && !isIntegral(y)) return Type.NaN;

    if (Type == double)
        return <em>powDouble</em>(x, y);
    return <em>powDecimal</em>(x, y);
}
</PRE>


<P><span class="pcounter"></span> The informative functions <code>powDouble</code> and <code>powDecimal</code>
implement representation-dependent computation of the value <i>x<SUP>y</SUP></i>.

<PRE>
informative function powDouble(x: double, y: double): double &#x0085
informative function powDecimal(x: decimal, y: decimal): decimal &#x0085
</PRE>

<h3>intrinsic::random&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>random</code> function computes a <code>double</code> value
with positive sign, greater than or equal to 0 but less than 1, chosen
randomly or pseudo randomly with approximately uniform distribution
over that range, using an implementation-dependent algorithm or
strategy. This function takes no arguments.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>random</code> function returns a <code>double</code>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>random</code> function is implementation-dependent.

<h3>intrinsic::round&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>round</code> function computes the number value that
is closest to <i>x</i> and is equal to a mathematical integer. If two
integer number values are equally close to <i>x</i>, then the result is the
number value that is closer to +&#x221E;. If <i>x</i> is already an integer,
the result is <i>x</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>round</code> function returns a number, the representation
of which is always the same as the representation of the input <i>x</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function round(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (!isFinite(n) || n == 0) return n;
        if (0 &#60; n && n &#60; 0.5) return +0;
        if (-0.5 &#60; n && n &#60; 0) return -0;
        return <em>roundDouble</em>(n);
    }
    case (n: decimal) {
        if (!isFinite(n) || n == 0m) return n;
        if (0m &#60; n && n &#60; 0.5m) return +0m;
        if (-0.5m &#60; n && n &#60; 0m) return -0m;
        return <em>roundDecimal</em>(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>roundDouble</code> and <code>roundDecimal</code>
implement representation-preserving computation of the rounded value
of their argument.

<PRE>
informative function roundDouble(x: double):double &#x0085
informative function roundDecimal(x: decimal):decimal &#x0085
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; 
The intrinsic <code>round</code> function preserves the sign of <i>x</i> if <i>x</i> is 0.

<p class="note"><b>NOTE</b>&nbsp;&nbsp; 
<code>Math.round(3.5)</code> returns 4, but <code>Math.round(-3.5)</code> returns -3.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The value of <code>Math.round(<i>x</i>)</code> is the same as the value of
<code>Math.floor(<i>x</i>+0.5)</code>, except when <i>x</i> is -0 or is less than 0
but greater than or equal to -0.5; for these cases
<code>Math.round(<i>x</i>)</code> returns -0, but <code>Math.floor(<i>x</i>+0.5)</code>
returns +0.


<h3>intrinsic::sin&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>sin</code> function computes an
implementation-dependent approximation to the sine of the number
<i>x</i>.  The argument is expressed in radians.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>sin</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function sin(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (!isFinite(n)) return NaN;
        if (n == 0) return n;
        return <em>sinDouble</em>(n);
    }
    case (n: decimal) {
        if (!isFinite(n)) return decimal.NaN;
        if (n == 0m) return n;
        return <em>sinDecimal</em>(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>sinDouble</code> and <code>sinDecimal</code>
implement representation-preserving approximate computation of the sine
of their argument.

<PRE>
informative function sinDouble(x: double):double &#x0085
informative function sinDecimal(x: decimal):decimal &#x0085
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; 
The intrinsic <code>sin</code> function preserves the sign of <i>x</i> if <i>x</i> is 0.


<h3>intrinsic::sqrt&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>sqrt</code> method computes an
implementation-dependent approximation to the square root of the
number <i>x</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>sqrt</code> method returns a number.  The
representation of the result is the same as the representation of
<i>x</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function sqrt(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (isNaN(n) || n &#60; 0) return NaN;
        if (n == 0 || n == Infinity) return n;
        return <em>sqrtDouble</em>(n);
    }
    case (n: decimal) {
        if (isNaN(n) || n &#60; 0m) return decimal.NaN;
        if (n == 0m || n == decimal.POSITIVE_INFINITY) return n;
        return <em>sqrtDecimal</em>(n);
    }
    }
}
</PRE>


<h3>intrinsic::tan&nbsp;(x)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>tan</code> function computes an
implementation-dependent approximation to the tangent of <i>x</i>.  The
argument is expressed in radians.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>tan</code> function returns a floating-point number.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function sin(x: <em>PrimitiveNumber</em>): <em>PrimitiveNumber</em> {
    switch type (x) {
    case (n: double) {
        if (!isFinite(n)) return NaN;
        if (n == 0) return n;
        return <em>sinDouble</em>(n);
    }
    case (n: decimal) {
        if (!isFinite(n)) return decimal.NaN;
        if (n == 0m) return n;
        return <em>sinDecimal</em>(n);
    }
    }
}
</PRE>

<P><span class="pcounter"></span> The informative functions <code>tanDouble</code> and <code>tanDecimal</code>
implement representation-preserving approximate computation of the tangent
of their argument.

<PRE>
informative function tanDouble(x: double):double &#x0085
informative function tanDecimal(x: decimal):decimal &#x0085
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp; 
The intrinsic <code>tan</code> function preserves the sign of <i>x</i> if <i>x</i> is 0.


<h2>Other function properties of the Math object</h2>

<P><span class="pcounter"></span> Every function listed in this section applies the <code>toPrimitiveNumber</code>
function to each of its arguments (in left-to-right order if there is
more than one) and then performs a computation on the resulting number
value(s) by invoking the corresponding intrinsic method.

<PRE>
Math.public::abs =
    function (x) Math.abs(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::acos =
    function (x) Math.acos(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::asin =
    function (x) Math.asin(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::atan =
    function (x) Math.atan(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::atan2 =
    function (y,x)
        Math.atan2(<em>toPrimitiveNumber</em>(y), <em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::ceil =
    function (x) Math.ceil(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::cos =
    function (x) Math.cos(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::exp =
    function (x) Math.exp(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::floor =
    function (x) Math.floor(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::log =
    function (x) Math.log(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::pow =
    function (x, y)
        Math.pow(<em>toPrimitiveNumber</em>(x), <em>toPrimitiveNumber</em>(y));
</PRE>
<PRE>
Math.public::random =
    function () Math.random();
</PRE>
<PRE>
Math.public::round =
    function (x) Math.round(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::sin =
    function (x) Math.sin(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::sqrt =
    function (x) Math.sqrt(<em>toPrimitiveNumber</em>(x));
</PRE>
<PRE>
Math.public::tan =
    function (x) Math.atan(<em>toPrimitiveNumber</em>(x));
</PRE>

<P><span class="pcounter"></span> The <code>max</code> and <code>min</code> functions are more general than their
corresponding intrinsic methods: they accept zero or more arguments
and apply their corresponding intrinsic methods to the current result
and the next argument, in left-to-right order.

<PRE>
Math.public::max =
    function max(...xs) {
        if (xs.length == 0)
            return -Infinity;
        let result = <em>toPrimitiveNumber</em>(xs[0]);
        for ( let i=1 ; i &#60; xs.length; ++i ) {
            result = Math.max(result, <em>toPrimitiveNumber</em>(xs[i]));
            if (isNaN(result))
                break;
        }
        return result;
    };
</PRE>
<PRE>
Math.public::min =
    function min(...xs) {
        if (xs.length == 0)
            return Infinity;
        let result = <em>toPrimitiveNumber</em>(xs[0]);
        for ( let i=1 ; i &#60; xs.length; ++i ) {
            result = Math.min(result, <em>toPrimitiveNumber</em>(xs[i]));
            if (isNaN(result))
                break;
        }
        return result;
    };
</PRE>





<H1 id="class Date"> The class <code>Date</code> </h1>



<P><span class="pcounter"></span> The <code>Date</code> object serves two purposes: as a record of an instant
in time, and as a simple timer.

<P><span class="pcounter"></span> Time is measured in ECMAScript in milliseconds since 01 January,
1970 UTC (the "epoch"), and a <code>Date</code> object contains a number
indicating a particular instant in time to within a millisecond
relative to the epoch.  The number may also be NaN, indicating that
the Date object does not represent a specific instant of time.

<P><span class="pcounter"></span> A <code>Date</code> object also contains a record of its time of creation
to nanosecond precision, and can be queried for the elapsed time since
its creation to within a nanosecond.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The <code>Date</code> class provides this interface:


<PRE>
dynamic class Date extends Object
{
    function Date(year=NOARG, month=NOARG, date=NOARG, hours=NOARG, minutes=NOARG, seconds=NOARG, ms=NOARG) &#x0085
    static meta function invoke(...args)   // args are ignored. &#x0085

    static intrinsic function parse(s:string, reference:double=0.0) : double &#x0085
    static intrinsic function UTC(year: double, &#x0085
    static function now() : double &#x0085

    static var parse = function parse(str, reference:double=0.0) &#x0085
    static var UTC = &#x0085

    static const length: uint = 7;

    override intrinsic function toString() : string &#x0085
    intrinsic function toDateString() : string &#x0085
    intrinsic function toTimeString():string &#x0085
    override intrinsic function toLocaleString() : string &#x0085
    intrinsic function toLocaleDateString() : string &#x0085
    intrinsic function toLocaleTimeString() : string &#x0085
    intrinsic function toUTCString() : string &#x0085
    intrinsic function toISOString() : string &#x0085
    intrinsic function nanoAge() : double &#x0085
    intrinsic function getTime() : double &#x0085
    intrinsic function getYear() : double &#x0085
    intrinsic function getFullYear() : double &#x0085
    intrinsic function getUTCFullYear() : double &#x0085
    intrinsic function getMonth() : double &#x0085
    intrinsic function getUTCMonth() : double &#x0085
    intrinsic function getDate() : double &#x0085
    intrinsic function getUTCDate() : double &#x0085
    intrinsic function getDay() : double &#x0085
    intrinsic function getUTCDay() : double &#x0085
    intrinsic function getHours() : double &#x0085
    intrinsic function getUTCHours() : double &#x0085
    intrinsic function getMinutes() : double &#x0085
    intrinsic function getUTCMinutes() : double &#x0085
    intrinsic function getSeconds() : double &#x0085
    intrinsic function getUTCSeconds() : double &#x0085
    intrinsic function getMilliseconds() : double &#x0085
    intrinsic function getUTCMilliseconds() : double &#x0085
    intrinsic function getTimezoneOffset() : double &#x0085
</PRE>
<PRE>
    intrinsic function setTime(t:double) : double &#x0085
    intrinsic function setYear(this:Date, year:double) &#x0085
    intrinsic function setFullYear(year:double, &#x0085
    intrinsic function setUTCFullYear(year:double, &#x0085
    intrinsic function setMonth(month:double, date:double = getDate()):double &#x0085
    intrinsic function setUTCMonth(month:double, date:double = getUTCDate()):double &#x0085
    intrinsic function setDate(date: double): double &#x0085
    intrinsic function setUTCDate(date: double): double &#x0085
    intrinsic function setHours(hour: double, &#x0085
    intrinsic function setUTCHours(hour: double, &#x0085
    intrinsic function setMinutes(min:double, &#x0085
    intrinsic function setUTCMinutes(min:double, &#x0085
    intrinsic function setSeconds(sec:double, ms:double = getMilliseconds()) : double &#x0085
    intrinsic function setUTCSeconds(sec:double, ms:double = getUTCMilliseconds()) : double &#x0085
    intrinsic function setMilliseconds(ms:double) : double &#x0085
    intrinsic function setUTCMilliseconds(ms:double) : double &#x0085

    function get time(this:Date) : double &#x0085
    function get year(this:Date) : double &#x0085
    function get fullYear(this:Date) : double &#x0085
    function get UTCFullYear(this:Date) : double &#x0085
    function get month(this:Date) : double &#x0085
    function get UTCMonth(this:Date) : double &#x0085
    function get date(this:Date) : double &#x0085
    function get UTCDate(this:Date) : double &#x0085
    function get day(this:Date) : double &#x0085
    function get UTCDay(this:Date) : double &#x0085
    function get hours(this:Date) : double &#x0085
    function get UTCHours(this:Date) : double &#x0085
    function get minutes(this:Date) : double &#x0085
    function get UTCMinutes(this:Date) : double &#x0085
    function get seconds(this:Date) : double &#x0085
    function get UTCSeconds(this:Date) : double &#x0085
    function get milliseconds(this:Date) : double &#x0085
    function get UTCMilliseconds(this:Date) : double &#x0085
    
    function set time(this:Date, t : double) : double &#x0085
    function set year(this:Date, t: double) : double &#x0085
    function set fullYear(this:Date, t : double) : double &#x0085
    function set UTCFullYear(this:Date, t : double) : double &#x0085
    function set month(this:Date, t : double) : double &#x0085
    function set UTCMonth(this:Date, t : double) : double &#x0085
    function set date(this:Date, t : double) : double &#x0085
    function set UTCDate(this:Date, t : double) : double &#x0085
    function set hours(this:Date, t : double) : double &#x0085
    function set UTCHours(this:Date, t : double) : double &#x0085
    function set minutes(this:Date, t : double) : double &#x0085
    function set UTCMinutes(this:Date, t : double) : double &#x0085
    function set seconds(this:Date, t : double) : double &#x0085
    function set UTCSeconds(this:Date, t : double) : double &#x0085
    function set milliseconds(this:Date, t : double) : double &#x0085
    function set UTCMilliseconds(this:Date, t : double) : double &#x0085

    private var timeval: double = &#x0085;
}
</PRE>

<P><span class="pcounter"></span> The <code>Date</code> prototype object is itself a <code>Date</code> object whose
time value is NaN.  It provides the following direct properties:

<PRE>
    toString:           function () &#x0085; ,
    toDateString:       function () &#x0085; ,
    toTimeString:       function () &#x0085; ,
    toLocaleString:     function () &#x0085; ,
    toLocaleDateString: function () &#x0085; ,
    toLocaleTimeString: function () &#x0085; ,
    toUTCString:        function () &#x0085; ,
    toISOString:        function () &#x0085; ,
    valueOf:            function () &#x0085; ,
    getTime:            function () &#x0085; ,
    getFullYear:        function () &#x0085; ,
    getUTCFullYear:     function () &#x0085; ,
    getMonth:           function () &#x0085; ,
    getUTCMonth:        function () &#x0085; ,
    getDate:            function () &#x0085; ,
    getUTCDate:         function () &#x0085; ,
    getDay:             function () &#x0085; ,
    getUTCDay:          function () &#x0085; ,
    getHours:           function () &#x0085; ,
    getUTCHours:        function () &#x0085; ,
    getMinutes:         function () &#x0085; ,
    getUTCMinutes:      function () &#x0085; ,
    getSeconds:         function () &#x0085; ,
    getUTCSeconds:      function () &#x0085; ,
    getMilliseconds:    function () &#x0085; ,
    getUTCMilliseconds: function () &#x0085; ,
    getTimezoneOffset:  function () &#x0085; ,
    setTime:            function (time) &#x0085; ,
    setMilliseconds:    function (ms) &#x0085; ,
    setUTCMilliseconds: function (ms) &#x0085; ,
    setSeconds:         function (sec, ms=undefined) &#x0085; ,
    setUTCSeconds:      function (sec, ms=undefined) &#x0085; ,
    setMinutes:         function (min, sec=undefined, ms=undefined) &#x0085; ,
    setUTCMinutes:      function (min, sec=undefined, ms=undefined) &#x0085; ,
    setHours:           function (hour, min=undefined, sec=undefined, ms=undefined) &#x0085; ,
    setUTCHours:        function (hour, min=undefined, sec=undefined, ms=undefined) &#x0085; ,
    setDate:            function (date) &#x0085; ,
    setUTCDate:         function (date) &#x0085; ,
    setMonth:           function (month, date=undefined) &#x0085; ,
    setUTCMonth:        function (month, date=undefined) &#x0085; ,
    setFullYear:        function (year, month=undefined, date=undefined) &#x0085; ,
    setUTCFullYear:     function (year, month=undefined, date=undefined) &#x0085; ,
</PRE>


<h2>Overview of Date Objects and Definitions of Helper Functions</h2>

<P><span class="pcounter"></span> A <code>Date</code> object contains a private property <code>timeval</code> that
indicates a particular instant in time to within a millisecond.  The
number may also be <b>NaN</b>, indicating that the <code>Date</code> object does not
represent a specific instant of time.

<P><span class="pcounter"></span> The following sections define a number of helper functions for
operating on time values.  Note that, in every case, if any argument
to such a function is <b>NaN</b>, the result will be <b>NaN</b>.

<P><span class="pcounter"></span> For the sake of succinctness, the <code>helper</code> and <code>informative</code>
namespaces are open in all the definitions that follow.


<h3>Time Range</h3>

<P><span class="pcounter"></span> Time is measured in ECMAScript in milliseconds since 01 January,
1970 UTC. Leap seconds are ignored. It is assumed that there are
exactly 86,400,000 milliseconds per day. ECMAScript <code>double</code> values
can represent all integers from -9,007,199,254,740,991 to
9,007,199,254,740,991; this range suffices to measure times to
millisecond precision for any instant that is within approximately
285,616 years, either forward or backward, from 01 January, 1970 UTC.

<P><span class="pcounter"></span> The actual range of times supported by ECMAScript Date objects is
slightly smaller: exactly -100,000,000 days to 100,000,000 days
measured relative to midnight at the beginning of 01 January, 1970
UTC. This gives a range of 8,640,000,000,000,000 milliseconds to
either side of 01 January, 1970 UTC.

<P><span class="pcounter"></span> The exact moment of midnight at the beginning of 01 January, 1970
UTC is represented by the value +0.

<h3>Constants</h3>

<P><span class="pcounter"></span> The following simple constants are used by the helper functions
defined below.

<PRE>
helper const hoursPerDay = 24;
</PRE>
<PRE>
helper const minutesPerHour = 60;
</PRE>
<PRE>
helper const secondsPerMinute = 60;
</PRE>
<PRE>
helper const daysPerYear = 365.2425;
</PRE>
<PRE>
helper const msPerSecond = 1000;
</PRE>
<PRE>
helper const msPerMinute = <em>msPerSecond</em> * <em>secondsPerMinute</em>;
</PRE>
<PRE>
helper const msPerHour = <em>msPerMinute</em> * <em>minutesPerHour</em>;
</PRE>
<PRE>
helper const msPerDay = <em>msPerHour</em> * <em>hoursPerDay</em>;
</PRE>
<PRE>
helper const msPerYear = <em>msPerDay</em> * <em>daysPerYear</em>;
</PRE>

<P><span class="pcounter"></span> The table <code>monthOffsets</code> contains the day offset within a
non-leap year of the first day of each month:

<PRE>
helper const monthOffsets = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
</PRE>

<h3>Day Number and Time within Day</h3>

<P><span class="pcounter"></span>A given time value <i>t</i> belongs to day number <code>Day(<i>t</i>)</code>:

<PRE>
helper function Day(t : double) : double
    Math.floor(t / <em>msPerDay</em>);
</PRE>

<P><span class="pcounter"></span>The remainder is called the time within the day, <code>TimeWithinDay(<i>t</i>)</code>:

<PRE>
helper function TimeWithinDay(t : double) : double
    t % <em>msPerDay</em>;
helper function HourFromTime(t : double) : double {

    let v = Math.floor(t / <em>msPerHour</em>) % <em>hoursPerDay</em>;
    if (v &#60; 0)
        return v + <em>hoursPerDay</em>;
    return v;
}
</PRE>


<H3 id="year number"> Year Number </h3>

<P><span class="pcounter"></span>ECMAScript uses an extrapolated Gregorian system to map a day
number to a year number and to determine the month and date within
that year.  In this system, leap years are precisely those which are
(divisible by 4) and ((not divisible by 100) or (divisible by
400)). The number of days in year number <i>y</i> is therefore defined by
<code>DaysInYear(<i>y</i>)</code>:

<PRE>
helper function DaysInYear(y : double) : double {
    if (y % 4 !== 0 || y % 100 === 0 && y % 400 !== 0)
        return 365;
    return 366;
}
</PRE>

<P><span class="pcounter"></span>All non-leap years have 365 days with the usual number of days per
month and leap years have an extra day in February.  The day number of
the first day of year <i>y</i> is given by <code>DayFromYear(<i>y</i>)</code>:

<PRE>
helper function DayFromYear(y : double) : double
    365 * (y-1970) + Math.floor((y-1969)/4) - Math.floor((y-1901)/100) + Math.floor((y-1601)/400);
</PRE>

<P><span class="pcounter"></span>The time value of the start of a year <i>y</i> is <code>TimefromYear(<i>y</i>)</code>:

<PRE>
helper function TimeFromYear(y : double) : double
    <em>msPerDay</em> * <em>DayFromYear</em>(y);
</PRE>

<P><span class="pcounter"></span> A time value <i>t</i> determines a year by <code>YearFromTime(<i>t</i>)</code>,
which yields the largest integer <i>y</i> (closest to positive infinity)
such that <code>TimeFromYear(<i>y</i>) &#x2264; <i>t</i></code>.

<P><span class="pcounter"></span> The function <code>YearFromTime</code> is not defined precisely by this Standard.
<PRE>
informative static function YearFromTime(t: double): double &#x0085;
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #190.) Is there any good reason not to define how
<code>YearFromTime</code> should be computed?  The RI uses a non-iterative
algorithm which I believe comes from SpiderMonkey.  I have seen
iterative algorithms elsewhere.

<P><span class="pcounter"></span>The leap-year function <code>InLeapYear</code> is 1 for a time within a leap
year and otherwise is zero:

<PRE>
helper function InLeapYear(t : double) : double
    (<em>DaysInYear</em>(<em>YearFromTime</em>(t)) == 365) ? 0 : 1;
helper function MonthFromTime(t : double) : double {

    let dwy = <em>DayWithinYear</em>(t),
        ily = <em>InLeapYear</em>(t);
    for ( let i=<em>monthOffsets</em>.length-1; i >= 0; i-- ) {
        let firstDayOfMonth = <em>monthOffsets</em>[i];
        if (i >= 2)
            firstDayOfMonth += ily;
        if (dwy >= firstDayOfMonth)
            return i;
    }
}
</PRE>


<H3 id="month number"> Month Number </H3>

<P><span class="pcounter"></span> Months are identified by an integer in the range 0 to 11,
inclusive.  The mapping from a time value <i>t</i> to a month number is
defined by <code>MonthFromTime(<i>t</i>)</code> :

<PRE>
helper function MonthFromTime(t : double) : double {
    let dwy = <em>DayWithinYear</em>(t),
        ily = <em>InLeapYear</em>(t);
    for ( let i=<em>monthOffsets</em>.length-1; i >= 0; i-- ) {
        let firstDayOfMonth = <em>monthOffsets</em>[i];
        if (i >= 2)
            firstDayOfMonth += ily;
        if (dwy >= firstDayOfMonth)
            return i;
    }
}
</PRE>
<PRE>
helper function DayWithinYear(t : double) : double
    <em>Day</em>(t) - <em>DayFromYear</em>(<em>YearFromTime</em>(t));
</PRE>

<P><span class="pcounter"></span> A month value of 0 specifies January; 1 specifies February; 2
specifies March; 3 specifies April; 4 specifies May; 5 specifies June;
6 specifies July; 7 specifies August; 8 specifies September; 9
specifies October; 10 specifies November; and 11 specifies December.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  <code>MonthFromTime(0)=0</code>, corresponding to Thursday, 01&nbsp;January, 1970.


<H3 id="date number"> Date Number </h3>

<P><span class="pcounter"></span> A date number is identified by an integer in the range 1 through
31, inclusive.  The mapping from a time value <i>t</i> to a month number
is defined by <code>DateFromTime(<i>t</i>)</code>:

<PRE>
helper function DateFromTime(t : double) : double {
    let dwy = <em>DayWithinYear</em>(t),
        mft = <em>MonthFromTime</em>(t),
        ily = <em>InLeapYear</em>(t);
    return (dwy+1) - (<em>monthOffsets</em>[mft]) - (mft >= 2 ? ily : 0);
}
</PRE>


<H3 id="week day"> Week Day </h3>

<P><span class="pcounter"></span>The weekday for a particular time value <i>t</i> is defined as <code>WeekDay(<i>t</i>)</code>:

<PRE>
helper function WeekDay(t : double) : double {
    let v = (<em>Day</em>(t) + 4) % 7;
    if (v &#60; 0)
        return v + 7;
    return v;
}
</PRE>

<P><span class="pcounter"></span>A weekday value of 0 specifies Sunday; 1 specifies Monday; 2
specifies Tuesday; 3 specifies Wednesday; 4 specifies Thursday; 5
specifies Friday; and 6 specifies Saturday.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  <code>WeekDay(0)=4</code>, corresponding to Thursday, 01&nbsp;January, 1970.


<H3 id="time zone adjustment"> Local Time Zone Adjustment </H3>

<P><span class="pcounter"></span> An implementation of ECMAScript is expected to determine the local
time zone adjustment.  The local time zone adjustment is a value
<code>LocalTZA</code> measured in milliseconds which when added to UTC
represents the local standard time.  Daylight saving time is not
reflected by <code>LocalTZA</code>.

<PRE>
informative function LocalTZA(): double &#x0085;
</PRE>

<P><span class="pcounter"></span> The value <code>LocalTZA</code> does not vary with time but depends only on
the geographic location.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #129.) This is bogus because it assumes time zone boundaries are
fixed for all eternity.  Yet time zone (standard time) is political;
changing political conditions can lead to adoption of a different
standard time (analogous to the changes in daylight savings time
adjustment).  So the above assertion needs to go, and probably be
replaced by language similar to that we want to adopt for
DaylightSavingsTA, which encourages "best effort for the given time".


<H3 id="dst adjustment"> Daylight Saving Time Adjustment </H3>

<P><span class="pcounter"></span> An implementation of ECMAScript is expected to determine the
daylight saving time algorithm.  The algorithm to determine the
daylight saving time adjustment for a time <i>t</i>, implemented by
<code>DaylightSavingTA(<i>t</i>)</code>, measured in milliseconds, must depend
only on four things:

<OL>
<LI> The time since the beginning of the year: <code><i>t</i> - TimeFromYear(YearFromTime(<i>t</i>))</code>

<LI> Whether t is in a leap year: <code>InLeapYear(<i>t</i>)</code>

<LI> The week day of the beginning of the year: <code>WeekDay(TimeFromYear(YearFromTime(<i>t</i>))</code>

<LI> The geographic location.
</OL>

<P><span class="pcounter"></span> The implementation of ECMAScript should not try to determine
whether the exact time <i>t</i> was subject to daylight saving time, but
just whether daylight saving time would have been in effect if the
current daylight saving time algorithm had been used at the time.
This avoids complications such as taking into account the years that
the locale observed daylight saving time year round.

<P><span class="pcounter"></span> If the host environment provides functionality for determining
daylight saving time, the implementation of ECMAScript is free to map
the year in question to an equivalent year (same leapyear-ness and
same starting week day for the year) for which the host environment
provides daylight saving time information.  The only restriction is
that all equivalent years should produce the same result.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #129.) We've already agreed that the above is bogus; the
implementation needs to make a "best effort" to find the correct
adjustment for the time <i>t</i>, in the year of <i>t</i>.  More to come
here.  Also see note above for <code>LocalTZA</code>.

<h3>Local Time</h3>

<P><span class="pcounter"></span>Conversion from UTC to local time is defined by

<PRE>
helper function LocalTime(t : double) : double
    t + LocalTZA() + DaylightSavingsTA(t);
</PRE>

<P><span class="pcounter"></span>Conversion from local time to UTC is defined by

<PRE>
helper function UTCTime(t : double) : double
    t - LocalTZA() - DaylightSavingsTA(t - LocalTZA());
</PRE>

<P><span class="pcounter"></span>Note that <code>UTCTime(LocalTime(<i>t</i>))</code> is not necessarily always
equal to <i>t</i> because the former expands as
<code><i>t</i>+DaylightSavingsTA(<i>t</i>)-DaylightSavingsTA(<i>t</i>-LocalTZA())</code>.


<H3 id="hours, minutes, seconds, and milliseconds"> Hours, Minutes, Seconds, and Milliseconds </H3>

<P><span class="pcounter"></span>The following functions are useful in decomposing time values:

<PRE>
helper function HourFromTime(t : double) : double {
    let v = Math.floor(t / <em>msPerHour</em>) % <em>hoursPerDay</em>;
    if (v &#60; 0)
        return v + <em>hoursPerDay</em>;
    return v;
}
</PRE>
<PRE>
helper function MinFromTime(t : double) : double {
    let v = Math.floor(t / <em>msPerMinute</em>) % <em>minutesPerHour</em>;
    if (v &#60; 0)
        return v + <em>minutesPerHour</em>;
    return v;
}
</PRE>
<PRE>
helper function SecFromTime(t : double) : double {
    let v = Math.floor(t / <em>msPerSecond</em>) % <em>secondsPerMinute</em>;
    if (v &#60; 0)
        return v + <em>secondsPerMinute</em>;
    return v;
}
</PRE>
<PRE>
helper function msFromTime(t : double) : double
    t % <em>msPerSecond</em>;
helper function DaysInYear(y : double) : double {

    if (y % 4 !== 0 || y % 100 === 0 && y % 400 !== 0)
        return 365;
    return 366;
}
</PRE>


<h3>MakeTime&nbsp;(hour,&nbsp;min,&nbsp;sec,&nbsp;ms)</h3>

<P><span class="pcounter"></span>The operator MakeTime calculates a number of milliseconds from its
four arguments, which must be ECMAScript number values. This operator
functions as follows:

<PRE>
helper function MakeTime(hour:double, min:double, sec:double, ms:double ):double {
    if (!isFinite(hour) || !isFinite(min) || !isFinite(sec) || !isFinite(ms))
        return NaN;

    return (<em>toInteger</em>(hour) * <em>msPerHour</em> +
            <em>toInteger</em>(min) * <em>msPerMinute</em> +
            <em>toInteger</em>(sec) * <em>msPerSecond</em> +
            <em>toInteger</em>(ms));
}
</PRE>

<h3>MakeDay&nbsp;(year,&nbsp;month,&nbsp;date)</h3>

<P><span class="pcounter"></span>The helper function <code>MakeDay</code> calculates a number of days from
its three arguments, which must be ECMAScript <code>double</code> values:

<PRE>
helper function MakeDay(year : double, month : double, date : double) : double {
    if (!isFinite(year) || !isFinite(month) || !isFinite(date))
        return NaN;

    year = <em>toInteger</em>(year);
    month = <em>toInteger</em>(month);
    date = <em>toInteger</em>(date);

    return <em>FindDay</em>(year, month) + date - 1;
}
</PRE>

<h3>MakeDate&nbsp;(day,&nbsp;time)</h3>

<P><span class="pcounter"></span>The helper function <code>MakeDate</code> calculates a number of
milliseconds from its two arguments, which must be ECMAScript
<code>double</code> values:

<PRE>
helper function MakeDate(day : double, time : double) : double {
    if (!isFinite(day) || !isFinite(time))
        return NaN;
    return day * <em>msPerDay</em> + time;
}
</PRE>

<h3>TimeClip&nbsp;(time)</h3>

<P><span class="pcounter"></span>The helper function <code>TimeClip</code> calculates a number of
milliseconds from its argument, which must be an ECMAScript <code>double</code>
value:

<PRE>
helper function TimeClip(t : double) : double
    (!isFinite(t) || Math.abs(t) > 8.64e15) ? NaN : <em>adjustZero</em>(<em>toInteger</em>(t));
</PRE>
<PRE>
informative function adjustZero(t: double): double &#x0085
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The informative function <code>adjustZero(<i>t</i>)</code> can either
return <i>t</i> unchanged or it can add (+0) to it.  The point of this
freedom is that an implementation is permitted a choice of internal
representations of time values, for example as a 64-bit signed integer
or as a 64-bit floating-point value.  Depending on the implementation,
this internal representation may or may not distinguish -0 and +0.


<h2>Date strings</h2>

<P><span class="pcounter"></span> Dates can be converted to string representations for purposes of
human consumption and data transmission in a number of ways, many of
them locale-dependent.

<P><span class="pcounter"></span> Some of the string representations of dates are required to be
lossless, which is to say that converting a time value to a string and
then parsing that string as a Date will always yield the same time
value.  Other string representations are implementation-dependent and
it is not guaranteed that they can be parsed to yield the same time
value (or that they can be parsed at all).

<P><span class="pcounter"></span> This Standard defines numerous methods on <code>Date</code> instances to
generate strings from time values: <code>toString</code>, <code>toDateString</code>,
<code>toTimeString</code>, <code>toLocaleString</code>, <code>toLocaleDateString</code>,
<code>toLocaleTimeString</code>, <code>toUTCString</code>, and <code>toISOString</code>.

<P><span class="pcounter"></span> The <code>toString</code> and <code>toUTCString</code> methods convert time values
to a string losslessly except for fractional seconds, which may not be
represented in the string.  The format of these strings is
implementation-dependent.

<P><span class="pcounter"></span> The <code>toISOString</code> method converts time values to a string
losslessly, and the string conforms to the ISO date grammar defined
below.

<P><span class="pcounter"></span> This Standard defines the static <code>parse</code> method on the <code>Date</code>
class to parse strings and compute time values represented by those
strings.  The <code>parse</code> method is only required to parse all strings
that conform to the ISO date grammar defined below, as well as all
strings produced by the <code>toString</code> and <code>toUTCString</code> methods on
<code>Date</code> instances.

<P><span class="pcounter"></span> The grammar for ISO date strings is defined by the following
regular expression:

<PRE>
helper const isoTimestamp =
    /^                                             \
     (?: (?P&#60;year> - [0-9]+ | [0-9]{4} [0-9]* )    \
      (?: - (?P&#60;month> [0-9]{2} )                  \
       (?: - (?P&#60;day> [0-9]{2} ) )? )? )?          \
     T                                             \
     (?: (?P&#60;hour> [0-9]{2} )                      \
      (?: : (?P&#60;minutes> [0-9]{2} )                \
       (?: : (?P&#60;seconds> [0-9]{2} )               \
        (?: \. (?P&#60;fraction> [0-9]+ ) )? )? )? )?  \
     (?: (?P&#60;zulu> Z )                             \
       | (?P&#60;offs>                                 \
          (?P&#60;tzdir> \+ | - )                      \
          (?P&#60;tzhr> [0-9]{2} )                     \
          (?: : (?P&#60;tzmin> [0-9]{2} ) )? ) )?      \
    $/x;
helper function MakeTime(hour:double, min:double, sec:double, ms:double ):double {

    if (!isFinite(hour) || !isFinite(min) || !isFinite(sec) || !isFinite(ms))
        return NaN;

    return (<em>toInteger</em>(hour) * <em>msPerHour</em> +
            <em>toInteger</em>(min) * <em>msPerMinute</em> +
            <em>toInteger</em>(sec) * <em>msPerSecond</em> +
            <em>toInteger</em>(ms));
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #192.) Replace the regexp by a proper grammar, eventually.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  The <code>T</code> is optional if the time stamp does not have a time part.


<h2>Methods on the Date class</h2>

<h3>new&nbsp;Date&nbsp;(year=&#x0085;,&nbsp;month=&#x0085;,&nbsp;date=&#x0085;,&nbsp;hours=&#x0085;,&nbsp;minutes=&#x0085;,&nbsp;seconds=&#x0085;,&nbsp;ms=&#x0085;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Date</code> constructor is called as part of a <code>new&nbsp;Date</code> expression it initialises 
the newly created object by setting its private <code>timeval</code> property.

<P><span class="pcounter"></span> The <code>Date</code> constructor can be called with zero, one, or two to seven arguments, 
and sets <code>timeval</code> in different ways depending on how it is called.

<P class="implsection"><b>Implementation</b>
<PRE>
function Date(year=NOARG, month=NOARG, date=NOARG, hours=NOARG, minutes=NOARG, seconds=NOARG, ms=NOARG) {
    <em>setupNanoAge</em>();

    switch (NOARG) {
    case year:
        timeval = Date.now();
        return;

    case month: {
        let v = ToPrimitive(year);
        if (v is string)
            return parse(v);

        timeval = <em>TimeClip</em>(double(v));
        return;
    }

    default:
        ms = double(ms);

    case ms:
        seconds = double(seconds);

    case seconds:
        minutes = double(minutes);

    case minutes:
        hours = double(hours);

    case hours:
        date = double(date);

    case date:
        year = double(year);
        month = double(month);

        let intYear : double = <em>toInteger</em>(year);
        if (!isNaN(year) && 0 &#60;= intYear && intYear &#60;= 99)
            intYear += 1900;
        timeval = <em>TimeClip</em>(<em>UTCTime</em>(<em>MakeDate</em>(<em>MakeDay</em>(intYear, month, date),
                                            <em>MakeTime</em>(hours, minutes, seconds, ms))));
    }
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The default value <code>NOARG</code> is an unforgeable private value and is
used to detect the difference between an unsupplied parameter and a
parameter value of <b>undefined</b>.


<h3>Date&nbsp;(...args)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the Date class is called as a function rather than as a
constructor, it converts the current time (as returned by the static
method <code>now</code> on <code>Date</code>) to a string.

<P><span class="pcounter"></span> All arguments are ignored.  A string is created as if by the
expression <code>(new Date()).toString()</code>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The function call <code>Date(&#x0085;)</code> is not equivalent to the
object creation expression <code>new Date(&#x0085;)</code> with the same
arguments.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Date</code> class called as a function returns a <code>string</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(...args)   // args are ignored.
    (new Date()).public::toString();
</PRE>


<h3>intrinsic::parse&nbsp;(s,&nbsp;reference=&#x0085;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static intrinsic <code>parse</code> method applies the <code>string</code>
function to its argument <i>s</i> and interprets the resulting string as
a date.  The string may be interpreted as a local time, a UTC time, or
a time in some other time zone, depending on the contents of the
string.

<P><span class="pcounter"></span> The value <i>reference</i> (defaulting to zero) is a time value that
will provide default values for any fields missing from the string.

<P><span class="pcounter"></span>If <i>x</i> is any Date object whose milliseconds amount is zero
within a particular implementation of ECMAScript, then all of the
following expressions should produce the same numeric value in that
implementation, if all the properties referenced have their initial
values:

<PRE>
x.valueOf()
Date.parse(x.toString())
Date.parse(x.toUTCString())
</PRE>

<P><span class="pcounter"></span>However, the expression <code>Date.parse(x.toLocaleString())</code> is not
required to produce the same number value as the preceding three
expressions and, in general, the value produced by Date.parse is
implementation-dependent when given any string value that could not be
produced in that implementation by the toString or toUTCString method.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>parse</code> method returns a number, the UTC time
value corresponding to the date represented by the string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The static <code>parse</code> method parses a string that conforms to
the ISO grammar as an ISO date string.  Otherwise, the parsing is
implementation-dependent.

<PRE>
static intrinsic function parse(s:string, reference:double=0.0) : double {
    let isoRes = <em>isoTimestamp</em>.exec(s);
    let defaults = new Date(reference);
    if (isoRes) {
        let year = isoRes.year !== undefined ? parseInt(isoRes.year) : defaults.UTCYear;
        let month = isoRes.month !== undefined ? parseInt(isoRes.month)-1 : defaults.UTCMonth;
        let day = isoRes.day !== undefined ? parseInt(isoRes.day) : defaults.UTCDay;
        let hour = isoRes.hour !== undefined ? parseInt(isoRes.hour) : defaults.UTCHours;
        let mins = isoRes.minutes !== undefined ? parseInt(isoRes.minutes) : defaults.UTCMinutes;
        let secs = isoRes.seconds !== undefined ? parseInt(isoRes.seconds) : defaults.UTCSeconds;
        let millisecs = isoRes.fraction !== undefined ?
            fractionToMilliseconds(isoRes.fraction) :
            defaults.UTCMilliseconds;
        let tzo = defaults.timezoneOffset;
        if (isoRes.zulu !== undefined)
            tzo = 0;
        else if (isoRes.offs !== undefined) {
            tzo = parseInt(isoRes.tzhr) * 60;
            if (isoRes.tzmin !== undefined)
                tzo += parseInt(isoRes.tzmin);
            if (isoRes.tzdir === "-")
                tzo = -tzo;
        }
        return new Date.UTC(year, month, day, hour, mins, secs, millisecs) - tzo;
    }
    else
        return <em>fromDateString</em>(s, reference);

    function fractionToMilliseconds(frac: string): double
        Math.floor(1000 * (parseInt(frac) / Math.pow(10, frac.length)));
}
</PRE>


<h3>parse(&nbsp;s,&nbsp;reference=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>parse</code> method applies the <code>string</code> function to
its argument <i>s</i> and the <code>double</code> function to its argument
<i>reference</i> (which defaults to zero), and then calls the intrinsic
<code>parse</code> method on the resulting values.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>parse</code> method returns a number, the UTC time
value corresponding to the date represented by the string.

<P class="implsection"><b>Implementation</b>
<PRE>
static var parse = function parse(str, reference:double=0.0) {
    return Date.parse(string(str), reference);
};
</PRE>


<h3>intrinsic::UTC&nbsp;(year,&nbsp;month,&nbsp;date=&#x0085;,&nbsp;hours=&#x0085;,&nbsp;minutes=&#x0085;,&nbsp;seconds=&#x0085;,&nbsp;ms=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the static intrinsic <code>UTC</code> method is called with two to
seven arguments, it computes the date from <i>year</i>, <i>month</i> and
(optionally) <i>date</i>, <i>hours</i>, <i>minutes</i>, <i>seconds</i> and <i>ms</i>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The <code>UTC</code> method differs from the <code>Date</code> constructor in two
ways: it returns a time value as a number, rather than creating a
<code>Date</code> object, and it interprets the arguments in UTC rather than as
local time.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static intrinsic <code>UTC</code> method returns a time value.

<P class="implsection"><b>Implementation</b>
<PRE>
static intrinsic function UTC(year: double,
                              month: double,
                              date: double=1,
                              hours: double=0,
                              minutes: double=0,
                              seconds: double=0,
                              ms: double=0) : double
{
    let intYear = <em>toInteger</em>(year);
    if (!isNaN(year) && 0 &#60;= intYear && intYear &#60;= 99)
        intYear += 1900;
    return <em>TimeClip</em>(<em>MakeDate</em>(<em>MakeDay</em>(intYear, month, date),
                             <em>MakeTime</em>(hours, minutes, seconds, ms)));
}
</PRE>

<h3>UTC&nbsp;(year,&nbsp;month,&nbsp;date=&#x0085;,&nbsp;hours=&#x0085;,&nbsp;minutes=&#x0085;,&nbsp;seconds=&#x0085;,&nbsp;ms=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the static intrinsic <code>UTC</code> method is called with fewer
than two arguments, the behaviour is implementation dependent.  When
the <code>UTC</code> method is called with two to seven arguments, it computes
the date from <i>year</i>, <i>month</i> and (optionally) <i>date</i>,
<i>hours</i>, <i>minutes</i>, <i>seconds</i> and <i>ms</i> by converting all
arguments to <code>double</code> values and calling the static intrinsic
<code>UTC</code> method.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>UTC</code> method returns a time value.

<P class="implsection"><b>Implementation</b>
<PRE>
static var UTC =
    function UTC(year, month, date=NOARG, hours=NOARG, minutes=NOARG, seconds=NOARG, ms=NOARG) {
        switch (NOARG) {
        case date:    date = 1;
        case hours:   hours = 0;
        case minutes: minutes = 0;
        case seconds: seconds = 0;
        case ms:      ms = 0;
        }

        return Date.UTC(double(year),
                        double(month),
                        double(date),
                        double(hours),
                        double(minutes),
                        double(seconds),
                        double(ms));
    };
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The default value <code>NOARG</code> is an unforgeable private value and is
used to detect the difference between an unsupplied parameter and a
parameter value of <b>undefined</b>.

<h3>now</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The static <code>now</code> method produces the time value at the time
of the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The static <code>now</code> method returns a <code>double</code> representing a
time value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The static <code>now</code> method is implementation-dependent.


<h2>Methods on Date instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts the <code>Date</code> value to
a string.  The contents of the string are intended to represent the
value in the current time zone in a convenient, human-readable
form.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  It is intended that for any <code>Date</code> value <i>d</i>, the result of
<code>Date.parse(<i>d</i>.toString())</code> is equal to <i>d</i>.  (See <span class="xref">Date.parse</span>.)

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method is implementation-dependent.


<h3>intrinsic::toDateString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method converts the "date"
portion of the <code>Date</code> value to a string.  The contents of the string are
intended to represent the value in the current time zone in a
convenient, human-readable form.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toDateString</code> method is implementation-dependent.

<h3>intrinsic::toTimeString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toTimeString</code> method converts the "time"
portion of the <code>Date</code> value to a string.  The contents of the string are
intended to represent the value in the current time zone in a
convenient, human-readable form.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toTimeString</code> method is implementation-dependent.


<h3>intrinsic::toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method converts the <code>Date</code> value
to a string.  The contents of the string are intended to represent the
value in the current time zone in a convenient, human-readable form that
corresponds to the conventions of the host environment's current locale.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method is implementation-dependent.

<h3>intrinsic::toLocaleDateString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleDateString</code> method converts the "date"
portion of the <code>Date</code> value to a string.  The contents of the string are
intended to represent the value in the current time zone in a
convenient, human-readable form that corresponds to the conventions of
the host environment's current locale.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleDateString</code> method is implementation-dependent.


<h3>intrinsic::toLocaleTimeString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleTimeString</code> method converts the "time"
portion of the <code>Date</code> value to a string.  The contents of the string are
intended to represent the value in the current time zone in a
convenient, human-readable form that corresponds to the conventions of
the host environment's current locale.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this function is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleTimeString</code> method is
implementation-dependent.


<h3>intrinsic::toUTCString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toUTCString</code> method converts the <code>Date</code> value to
a string.  The contents of the string are intended to represent the
value in UTC in a convenient, human-readable form.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> value.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toUTCString</code> method is implementation-dependent.


<h3>intrinsic::toISOString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toISOString</code> method converts the <code>Date</code> value to
a string.  The string conforms to the ISO time and date grammar
presented in section <span class="xref">ISO date grammar</span>.  All fields are
present in the string and the shortest possible nonempty string of
digits follows the period in the time part.  The time zone is always
UTC, denoted by a suffix <code>Z</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function toISOString() : string {
    return (<em>formatYears</em>(UTCFullYear) + "-" +
            <em>zeroFill</em>(UTCMonth+1, 2) + "-" +
            <em>zeroFill</em>(UTCDate, 2) +
            "T" +
            <em>zeroFill</em>(UTCHours, 2) + ":" +
            <em>zeroFill</em>(UTCMinutes, 2) + ":" +
            <em>zeroFill</em>(UTCSeconds, 2) + "." +
            <em>removeTrailingZeroes</em>(UTCMilliseconds) +
            "Z");
}
</PRE>
<PRE>
helper function formatYears(n: double): string {
    if (n >= 0 && n &#60;= 9999)
        return <em>zeroFill</em>(n, 4);
    return string(n);
}
</PRE>

<P><span class="pcounter"></span> The helper functions <code>removeTrailingZeroes</code> and <code>zeroFill</code> are
described in section <span class="xref">Minor date helpers</span>.

<h3>intrinsic::nanoAge()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>nanoAge</code> method computes an approximation of
the number of nanoseconds of real time that have elapsed since this
<code>Date</code> object was created.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The approximation is of unspecified quality, and may vary in
both accuracy and precision from platform to platform.  The
approximation will necessarily lose precision as its object ages,
since it is expressed as a double: after approximately 104 days of
real time, its object will have been alive for over 2<SUP>53</SUP>
nanoseconds, so the result of this call will carry more than 2
nanoseconds rounding error after 104 days, and more than 4 nanoseconds
rounding error after 208 days.  Code wishing to measure greater
periods of real time may either construct fresh Date objects after 104
days, or accept the gradual loss of precision.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>double</code> object.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The static <code>nanoAge</code> method is implementation-dependent.


<h3>intrinsic::valueOf&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>valueOf</code> method returns the time value of the
<code>Date</code> object.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>double</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function valueOf() : Object
    getTime();
</PRE>


<h3>intrinsic::getTime&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getTime</code> method retrieves the full time value of the Date object.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> This time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getTime() : double
    timeval;
</PRE>

<h3>intrinisic::getFullYear&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getFullYear</code> method retrieves the year number of the Date object, in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A year number (<span class="xref">year number</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getFullYear() : double
    let (t = timeval)
        isNaN(t) ? t : <em>YearFromTime</em>(<em>LocalTime</em>(t));
</PRE>

<h3>intrinisic::getUTCFullYear&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getUTCFullYear</code> method retrieves the year number of the Date object, in UTC.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Is the phrasing "in UTC" appropriate?  (Ditto for all following functions.)

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A year number (<span class="xref">year number</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getUTCFullYear() : double
    let (t = timeval)
        isNaN(t) ? t : <em>YearFromTime</em>(t);
</PRE>


<h3>intrinisic::getMonth&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getMonth</code> method retrieves the month number of the Date object, in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A month number (<span class="xref">month number</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getMonth() : double
    let (t = timeval)
        isNaN(t) ? t : <em>MonthFromTime</em>(<em>LocalTime</em>(t));
</PRE>

<h3>intrinisic::getUTCMonth&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getUTCMonth</code> method retrieves the month number of the Date object, in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A month number (<span class="xref">month number</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getUTCMonth() : double
    let (t = timeval)
        isNaN(t) ? t : <em>MonthFromTime</em>(t);
</PRE>

<h3>intrinisic::getDate&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getDate</code> method retrieves the date number of the Date object, in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A date number (<span class="xref">date number</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getDate() : double
    let (t = timeval)
        isNaN(t) ? t : <em>DateFromTime</em>(<em>LocalTime</em>(t));
</PRE>

<h3>intrinisic::getUTCDate&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getUTCDate</code> method retrieves the date number of the Date object, in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A date number (<span class="xref">date number</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getUTCDate() : double
    let (t = timeval)
        isNaN(t) ? t : <em>DateFromTime</em>(t);
</PRE>

<h3>intrinisic::getDay&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getDay</code> method retrieves the day number of the Date object, in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A day number (<span class="xref">day number</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getDay() : double
    let (t = timeval)
        isNaN(t) ? t : <em>WeekDay</em>(<em>LocalTime</em>(t));
</PRE>

<h3>intrinisic::getUTCDay&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getUTCDay</code> method retrieves the day number of the Date object, in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A day number (<span class="xref">day number</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getUTCDay() : double
    let (t = timeval)
        isNaN(t) ? t : <em>WeekDay</em>(t);
</PRE>

<h3>intrinisic::getHours&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getHours</code> method retrieves the hours value of the Date object, in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> An hours value (<span class="xref">hours, minutes, seconds, and milliseconds</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getHours() : double
    let (t = timeval)
        isNaN(t) ? t : <em>HourFromTime</em>(<em>LocalTime</em>(t));
</PRE>

<h3>intrinisic::getUTCHours&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getUTCHours</code> method retrieves the hours value of the Date object, in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> An hours value (<span class="xref">hours, minutes, seconds, and milliseconds</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getUTCHours() : double
    let (t = timeval)
        isNaN(t) ? t : <em>HourFromTime</em>(t);
</PRE>

<h3>intrinisic::getMinutes&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getMinutes</code> method retrieves the minutes value of the Date object, in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A minutes value (<span class="xref">hours, minutes, seconds, and milliseconds</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getMinutes() : double
    let (t = timeval)
        isNaN(t) ? t : <em>MinFromTime</em>(<em>LocalTime</em>(t));
</PRE>

<h3>intrinisic::getUTCMinutes&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getUTCMinutes</code> method retrieves the minutes value of the Date object, in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A minutes value (<span class="xref">hours, minutes, seconds, and milliseconds</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getUTCMinutes() : double
    let (t = timeval)
        isNaN(t) ? t : <em>MinFromTime</em>(t);
</PRE>

<h3>intrinisic::getSeconds&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getSeconds</code> method retrieves the seconds value of the Date object, in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A seconds value (<span class="xref">hours, minutes, seconds, and milliseconds</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getSeconds() : double
    let (t = timeval)
        isNaN(t) ? t : <em>SecFromTime</em>(<em>LocalTime</em>(t));
</PRE>

<h3>intrinisic::getUTCSeconds&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getUTCSeconds</code> method retrieves the seconds value of the Date object, in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A seconds value (<span class="xref">hours, minutes, seconds, and milliseconds</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getUTCSeconds() : double
    let (t = timeval)
        isNaN(t) ? t : <em>SecFromTime</em>(t);
</PRE>

<h3>intrinisic::getMilliseconds&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getMilliseconds</code> method retrieves the milliseconds value of the Date object, in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A milliseconds value (<span class="xref">hours, minutes, seconds, and milliseconds</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getMilliseconds() : double
    let (t = timeval)
        isNaN(t) ? t : <em>msFromTime</em>(<em>LocalTime</em>(t));
</PRE>

<h3>intrinisic::getUTCMilliseconds&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>getUTCMilliseconds</code> method retrieves the milliseconds value of the Date object, in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A milliseconds value (<span class="xref">hours, minutes, seconds, and milliseconds</span>).

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getUTCMilliseconds() : double
    let (t = timeval)
        isNaN(t) ? t : <em>msFromTime</em>(t);
</PRE>

<h3>intrinisic::getTimezoneOffset&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> Computes the difference between local time and UTC time.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A possibly non-integer number of minutes.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function getTimezoneOffset() : double
    let (t = timeval)
        isNaN(t) ? t : (t - <em>LocalTime</em>(t)) / <em>msPerMinute</em>;
</PRE>

<h3>intrinisic::setTime&nbsp;(time)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setTime</code> method sets the time value of the Date object.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setTime(t:double) : double
    timeval = <em>TimeClip</em>(t);
</PRE>

<h3>intrinisic::setMilliseconds&nbsp;(ms)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setMilliseconds</code> method sets the milliseconds value of the Date object, taking <i>ms</i> to be
a value in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setMilliseconds(ms:double) : double
    timeval = let (t = <em>LocalTime</em>(timeval))
                  <em>UTCTime</em>(<em>MakeDate</em>(<em>Day</em>(t), <em>MakeTime</em>(<em>HourFromTime</em>(t),
                                                    <em>MinFromTime</em>(t),
                                                    <em>SecFromTime</em>(t),
                                                    ms)));
</PRE>


<h3>intrinisic::setUTCMilliseconds&nbsp;(ms)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setUTCMilliseconds</code> method sets the milliseconds value of the Date object, taking <i>ms</i> to be
a value in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setUTCMilliseconds(ms:double) : double
    timeval = let (t = timeval)
                  <em>MakeDate</em>(<em>Day</em>(t), <em>MakeTime</em>(<em>HourFromTime</em>(t),
                                            <em>MinFromTime</em>(t),
                                            <em>SecFromTime</em>(t),
                                            ms));
</PRE>


<h3>intrinisic::setSeconds&nbsp;(sec,&nbsp;ms=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setSeconds</code> method sets the seconds value (and
optionally the milliseconds value) of the Date object, taking <i>sec</i>
and <i>ms</i> to be values in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setSeconds(sec:double, ms:double = getMilliseconds()) : double
    timeval = let (t = <em>LocalTime</em>(timeval))
                  <em>UTCTime</em>(<em>MakeDate</em>(<em>Day</em>(t), <em>MakeTime</em>(<em>HourFromTime</em>(t),
                                                    <em>MinFromTime</em>(t),
                                                    sec,
                                                    ms)));
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #193.) Default arguments: is this the way we want it?

<P class="fixme"> For this and the following methods the signature has
the following impliciation: if a program subclasses Date and overrides
the intrinsic <code>getMilliseconds()</code> method, the new method <i>will</i> be
invoked if setSeconds is called with one argument.

<P class="fixme"> There are various ways to avoid this, though I don't
think it's really a problem that there is this dependence, except that
it binds implementations in how they represent and handle dates.

<P class="fixme"> 3rd Edition has imprecise language here, it says
that if ms is not provided by the caller then its value will be as if
<i>ms</i> were specified with the value <i>getMilliseconds()</i>.  Whether
that implies that that method is called (and that the user could
override it) or not is not at all clear.


<h3>intrinisic::setUTCSeconds&nbsp;(sec,&nbsp;ms=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setUTCSeconds</code> method sets the seconds value (and optionally the 
milliseconds value) of the Date object,  taking <i>sec</i> and <i>ms</i> to be values in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setUTCSeconds(sec:double, ms:double = getUTCMilliseconds()) : double
    timeval = let (t = timeval)
                  <em>MakeDate</em>(<em>Day</em>(t), <em>MakeTime</em>(<em>HourFromTime</em>(t),
                                            <em>MinFromTime</em>(t),
                                            sec,
                                            ms));
</PRE>

<h3>intrinisic::setMinutes&nbsp;(min,&nbsp;sec=&#x0085;,&nbsp;ms=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setMinutes</code> method sets the minutes value (and optionally the seconds and 
milliseconds values) of the Date object,  taking <i>min</i>, <i>sec</i> and <i>ms</i> to be values in the 
local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setMinutes(min:double,
                              sec:double = getSeconds(),
                              ms:double = getMilliseconds()) : double
    timeval = let (t = <em>LocalTime</em>(timeval))
                  <em>UTCTime</em>(<em>MakeDate</em>(<em>Day</em>(t), <em>MakeTime</em>(<em>HourFromTime</em>(t),
                                                    min,
                                                    sec,
                                                    ms)));
</PRE>

<h3>intrinisic::setUTCMinutes&nbsp;(min,&nbsp;sec=&#x0085;,&nbsp;ms=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setUTCMinutes</code> method sets the minutes value (and optionally the seconds 
and milliseconds values) of the Date object,  taking <i>min</i>, <i>sec</i> and <i>ms</i> to be values in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setUTCMinutes(min:double,
                                 sec:double = getUTCSeconds(),
                                 ms:double = getUTCMilliseconds()) : double
    timeval = let (t = timeval)
                  <em>MakeDate</em>(<em>Day</em>(t), <em>MakeTime</em>(<em>HourFromTime</em>(t),
                                            min,
                                            sec,
                                            ms));
</PRE>

<h3>intrinisic::setHours&nbsp;(hour,&nbsp;min=minutes,&nbsp;sec=&#x0085;,&nbsp;ms=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setHours</code> method sets the hours value (and optionally the minutes, seconds, and 
milliseconds values) of the Date object,  taking <i>hour</i>, <i>min</i>, <i>sec</i> and <i>ms</i> to be values in the 
local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setHours(hour: double,
                            min: double = getMinutes(),
                            sec: double = getSeconds(),
                            ms: double = getMilliseconds()) : double
    timeval = let (t = <em>LocalTime</em>(timeval))
                  <em>UTCTime</em>(<em>MakeDate</em>(<em>Day</em>(t), <em>MakeTime</em>(hour,
                                                    min,
                                                    sec,
                                                    ms)));
</PRE>

<h3>intrinisic::setUTCHours&nbsp;(hour,&nbsp;min=&#x0085;,&nbsp;sec=&#x0085;,&nbsp;ms=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setUTCHours</code> method sets the hours value (and optionally the minutes, seconds, and 
milliseconds values) of the Date object,  taking <i>hour</i>, <i>min</i>, <i>sec</i> and <i>ms</i> to be values in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setUTCHours(hour: double,
                               min: double = getUTCMinutes(),
                               sec: double = getUTCSeconds(),
                               ms: double = getUTCMilliseconds()) : double
    timeval = let (t = timeval)
                  <em>MakeDate</em>(<em>Day</em>(t), <em>MakeTime</em>(hour,
                                            min,
                                            sec,
                                            ms));
</PRE>

<h3>intrinisic::setDate&nbsp;(date)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setDate</code> method sets the date value of the Date object, taking <i>date</i> to be
a value in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setDate(date: double): double
    timeval = let (t = <em>LocalTime</em>(timeval))
                  <em>UTCTime</em>(<em>MakeDate</em>(<em>MakeDay</em>(<em>YearFromTime</em>(t), <em>MonthFromTime</em>(t), date),
                                   <em>TimeWithinDay</em>(t)));
</PRE>

<h3>intrinisic::setUTCDate&nbsp;(date)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setUTCDate</code> method sets the date value of the Date object, taking <i>date</i> to be
a value in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setUTCDate(date: double): double
    timeval = let (t = timeval)
                  <em>MakeDate</em>(<em>MakeDay</em>(<em>YearFromTime</em>(t), <em>MonthFromTime</em>(t), date),
                           <em>TimeWithinDay</em>(t));
</PRE>

<h3>intrinisic::setMonth&nbsp;(month,&nbsp;date=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setMonth</code> method sets the month value (and optionally the date value) of 
the Date object, taking <i>month</i> and <i>date</i> to be values in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setMonth(month:double, date:double = getDate()):double
    timeval = let (t = <em>LocalTime</em>(timeval))
                  <em>UTCTime</em>(<em>MakeDate</em>(<em>MakeDay</em>(<em>YearFromTime</em>(t), month, date),
                                   <em>TimeWithinDay</em>(t)));
</PRE>

<h3>intrinisic::setUTCMonth&nbsp;(month,&nbsp;date=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setUTCMonth</code> method sets the month value (and optionally the date value) of 
the Date object, taking <i>month</i> and <i>date</i> to be values in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setUTCMonth(month:double, date:double = getUTCDate()):double
    timeval = let (t = timeval)
                  <em>MakeDate</em>(<em>MakeDay</em>(<em>YearFromTime</em>(t), month, date),
                           <em>TimeWithinDay</em>(t));
</PRE>

<h3>intrinisic::setFullYear&nbsp;(year,&nbsp;month=&#x0085;,&nbsp;date=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setFullYear</code> method sets the year value (and optionally the month and date 
values) of the Date object, taking <i>year</i>, <i>month</i>, and <i>date</i> to be values in the local time zone.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setFullYear(year:double,
                               month:double = getMonth(),
                               date:double = getDate()) : double
    timeval = let (t = <em>LocalTime</em>(timeval))
                  <em>UTCTime</em>(<em>MakeDate</em>(<em>MakeDay</em>(year, month, date),
                                   <em>TimeWithinDay</em>(t)));
</PRE>

<h3>intrinisic::setUTCFullYear&nbsp;(year,&nbsp;month=&#x0085;,&nbsp;date=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>setFullYear</code> method sets the year value (and optionally the month and date 
values) of the Date object, taking <i>year</i>, <i>month</i>, and <i>date</i> to be values in UTC.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The new time value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function setUTCFullYear(year:double,
                                  month:double = getUTCMonth(),
                                  date:double = getUTCDate()) : double
    timeval = let (t = timeval)
                  <em>MakeDate</em>(<em>MakeDay</em>(year, month, date),
                           <em>TimeWithinDay</em>(t));
</PRE>


<h2>Getters on Date instances</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The Date object provides a number of getters that call the
object's corresponding accessor methods.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The getters all return what their corresponding accessor methods return.

<P class="implsection"><b>Implementation</b>
<PRE>
function get time(this:Date) : double
    getTime();
</PRE>
<PRE>
function get year(this:Date) : double
    getYear();
</PRE>
<PRE>
function get fullYear(this:Date) : double
    getFullYear();
</PRE>
<PRE>
function get UTCFullYear(this:Date) : double
    getUTCFullYear();
</PRE>
<PRE>
function get month(this:Date) : double
    getMonth();
</PRE>
<PRE>
function get UTCMonth(this:Date) : double
    getUTCMonth();
</PRE>
<PRE>
function get date(this:Date) : double
    getDate();
</PRE>
<PRE>
function get UTCDate(this:Date) : double
    getUTCDate();
</PRE>
<PRE>
function get day(this:Date) : double
    getDay();
</PRE>
<PRE>
function get UTCDay(this:Date) : double
    getUTCDay();
</PRE>
<PRE>
function get hours(this:Date) : double
    getHours();
</PRE>
<PRE>
function get UTCHours(this:Date) : double
    getUTCHours();
</PRE>
<PRE>
function get minutes(this:Date) : double
    getMinutes();
</PRE>
<PRE>
function get UTCMinutes(this:Date) : double
    getUTCMinutes();
</PRE>
<PRE>
function get seconds(this:Date) : double
    getSeconds();
</PRE>
<PRE>
function get UTCSeconds(this:Date) : double
    getUTCSeconds();
</PRE>
<PRE>
function get milliseconds(this:Date) : double
    getMilliseconds();
</PRE>
<PRE>
function get UTCMilliseconds(this:Date) : double
    getUTCMilliseconds();
</PRE>

<h2>Setters on Date instances</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The Date object provides a number of setters that call the
object's corresponding updater methods.  Since the setters only accept
a single argument, the updaters will be called with default arguments
for all arguments beyond the first.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The setters all return what their corresponding updater methods return.

<P class="implsection"><b>Implementation</b>
<PRE>
function set time(this:Date, t : double) : double
    setTime(t);
</PRE>
<PRE>
function set year(this:Date, t: double) : double
    setYear(t);
</PRE>
<PRE>
function set fullYear(this:Date, t : double) : double
    setFullYear(t);
</PRE>
<PRE>
function set UTCFullYear(this:Date, t : double) : double
    setUTCFullYear(t);
</PRE>
<PRE>
function set month(this:Date, t : double) : double
    setMonth(t);
</PRE>
<PRE>
function set UTCMonth(this:Date, t : double) : double
    setUTCMonth(t);
</PRE>
<PRE>
function set date(this:Date, t : double) : double
    setDate(t);
</PRE>
<PRE>
function set UTCDate(this:Date, t : double) : double
    setUTCDate(t);
</PRE>
<PRE>
function set hours(this:Date, t : double) : double
    setHours(t);
</PRE>
<PRE>
function set UTCHours(this:Date, t : double) : double
    setUTCHours(t);
</PRE>
<PRE>
function set minutes(this:Date, t : double) : double
    setMinutes(t);
</PRE>
<PRE>
function set UTCMinutes(this:Date, t : double) : double
    setUTCMinutes(t);
</PRE>
<PRE>
function set seconds(this:Date, t : double) : double
    setSeconds(t);
</PRE>
<PRE>
function set UTCSeconds(this:Date, t : double) : double
    setUTCSeconds(t);
</PRE>
<PRE>
function set milliseconds(this:Date, t : double) : double
    setMilliseconds(t);
</PRE>
<PRE>
function set UTCMilliseconds(this:Date, t : double) : double
    setUTCMilliseconds(t);
</PRE>




<h2>Method properties on the <code>Date</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>Date</code> prototype methods are not generic; their <code>this</code>
object must be a <code>Date</code>.  The methods forward the call to the
corresponding intrinsic method in all cases.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Date</code> prototype methods return the values returned by
the intrinsic methods they call.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this:Date)
    this.intrinsic::toString();
</PRE>
<PRE>
prototype function toDateString(this:Date)
    this.toDateString();
</PRE>
<PRE>
prototype function toTimeString(this:Date)
    this.toTimeString();
</PRE>
<PRE>
prototype function toLocaleString(this:Date)
    this.toLocaleString();
</PRE>
<PRE>
prototype function toLocaleDateString(this:Date)
    this.toLocaleDateString();
</PRE>
<PRE>
prototype function toLocaleTimeString(this:Date)
    this.toLocaleTimeString();
</PRE>
<PRE>
prototype function toUTCString(this:Date)
    this.toUTCString();
</PRE>
<PRE>
prototype function toISOString(this:Date)
    this.toISOString();
</PRE>
<PRE>
prototype function valueOf(this:Date)
    this.valueOf();
</PRE>
<PRE>
prototype function getTime(this:Date)
    this.intrinsic::getTime();
</PRE>
<PRE>
prototype function getFullYear(this:Date)
    this.intrinsic::getFullYear();
</PRE>
<PRE>
prototype function getUTCFullYear(this:Date)
    this.intrinsic::getUTCFullYear();
</PRE>
<PRE>
prototype function getMonth(this:Date)
    this.intrinsic::getMonth();
</PRE>
<PRE>
prototype function getUTCMonth(this:Date)
    this.intrinsic::getUTCMonth();
</PRE>
<PRE>
prototype function getDate(this:Date)
    this.intrinsic::getDate();
</PRE>
<PRE>
prototype function getUTCDate(this:Date)
    this.intrinsic::getUTCDate();
</PRE>
<PRE>
prototype function getDay(this:Date)
    this.intrinsic::getDay();
</PRE>
<PRE>
prototype function getUTCDay(this:Date)
    this.intrinsic::getUTCDay();
</PRE>
<PRE>
prototype function getHours(this:Date)
    this.intrinsic::getHours();
</PRE>
<PRE>
prototype function getUTCHours(this:Date)
    this.intrinsic::getUTCHours();
</PRE>
<PRE>
prototype function getMinutes(this:Date)
    this.intrinsic::getMinutes();
</PRE>
<PRE>
prototype function getUTCMinutes(this:Date)
    this.intrinsic::getUTCMinutes();
</PRE>
<PRE>
prototype function getSeconds(this:Date)
    this.intrinsic::getSeconds();
</PRE>
<PRE>
prototype function getUTCSeconds(this:Date)
    this.intrinsic::getUTCSeconds();
</PRE>
<PRE>
prototype function getMilliseconds(this:Date)
    this.intrinsic::getMilliseconds();
</PRE>
<PRE>
prototype function getUTCMilliseconds(this:Date)
    this.intrinsic::getUTCMilliseconds();
</PRE>
<PRE>
prototype function getTimezoneOffset(this:Date)
    this.intrinsic::getTimezoneOffset();
</PRE>
<PRE>
prototype function setTime(this:Date, t)
    this.intrinsic::setTime(double(t));
</PRE>
<PRE>
prototype function setMilliseconds(this:Date, ms)
    this.intrinsic::setMilliseconds(double(ms));
</PRE>
<PRE>
prototype function setUTCMilliseconds(this:Date, ms)
    this.intrinsic::setUTCMilliseconds(double(ms));
</PRE>
<PRE>
prototype function setSeconds(this:Date, sec, ms = this.getMilliseconds())
    this.intrinsic::setSeconds(double(sec), double(ms));
</PRE>
<PRE>
prototype function setUTCSeconds(this:Date, sec, ms = this.getUTCMilliseconds())
    this.intrinsic::setUTCSeconds(double(sec), double(ms));
</PRE>
<PRE>
prototype function setMinutes(this:Date, min, sec = this.getSeconds(), ms = this.getMilliseconds())
    this.intrinsic::setMinutes(double(min), double(sec), double(ms));
</PRE>
<PRE>
prototype function setUTCMinutes(this:Date,
                                 min,
                                 sec = this.getUTCSeconds(),
                                 ms = this.getUTCMilliseconds())
    this.intrinsic::setUTCMinutes(double(min), double(sec), double(ms));
</PRE>
<PRE>
prototype function setHours(this:Date,
                            hour,
                            min=this.getMinutes(),
                            sec=this.getSeconds(),
                            ms=this.getMilliseconds())
    this.intrinsic::setHours(double(hour), double(min), double(sec), double(ms));
</PRE>
<PRE>
prototype function setUTCHours(this:Date,
                               hour,
                               min=this.getUTCMinutes(),
                               sec=this.getUTCSeconds(),
                               ms=this.getUTCMilliseconds())
    this.intrinsic::setUTCHours(double(hour), double(min), double(sec), double(ms));
</PRE>
<PRE>
prototype function setDate(this:Date, date)
    this.intrinsic::setDate(double(date));
</PRE>
<PRE>
prototype function setUTCDate(this:Date, date)
    this.intrinsic::setUTCDate(double(date));
</PRE>
<PRE>
prototype function setMonth(this:Date, month, date=this.getDate())
    this.intrinsic::setMonth(double(month), double(date));
</PRE>
<PRE>
prototype function setUTCMonth(this:Date, month, date=this.getUTCDate())
    this.intrinsic::setUTCMonth(double(month), double(date));
</PRE>
<PRE>
prototype function setFullYear(this:Date, year, month=this.getMonth(), date=this.getDate())
    this.intrinsic::setFullYear(double(year), double(month), double(date));
</PRE>
<PRE>
prototype function setUTCFullYear(this:Date, year, month=this.getUTCMonth(), date=this.getUTCDate())
    this.intrinsic::setUTCFullYear(double(year), double(month), double(date));
</PRE>



<H1 id="class RegExp"> The class <code>RegExp</code> </H1>

<PRE>
FILE:                       spec/library/RegExp.html
DRAFT STATUS:               DRAFT 1 - ROUGH - 2008-06-25
REVIEWED AGAINST ES3:       NO
REVIEWED AGAINST ERRATA:    NO
REVIEWED AGAINST BASE DOC:  NO
REVIEWED AGAINST PROPOSALS: NO
REVIEWED AGAINST CODE:      NO
</PRE>


<P><span class="pcounter"></span> The class <code>RegExp</code> is a dynamic, nullable, non-final, direct
subclass of <code>Object</code>.

<P><span class="pcounter"></span> A RegExp object contains a regular expression <i>pattern</i> and the
associated <i>flags</i>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The form and functionality of regular expressions is modelled
after the regular expression facility in the Perl 5 programming
language.

<P><span class="pcounter"></span> A regular expression is transformed ("compiled") into a
<i>matcher</i> function that can be used to <i>match</i> an <i>input
string</i>: to test whether the input string has a certain form or
contains substrings of a certain form, where the form is defined by
the regular expression.

<P><span class="pcounter"></span> The intrinsic <code>exec</code> method on a <code>RegExp</code> object drives the
matching by invoking the matcher on a string and an offset within the
string to determine whether the pattern would match starting at
exactly that offset within the string, and, if it does match, what the
values of the capturing parentheses would be.

<P><span class="pcounter"></span> Regular expression patterns are written down using a compact and
rich source syntax that is separate from the syntax of the surrounding
language.  A grammar for this syntax is presented below (<span class="xref">RegExp grammar</span>).

<P><span class="pcounter"></span> The regular expression flags modify the meaning of the pattern in
various ways, for example by specifying case-insensitivity, the
meaning of white space, or how to perform the matching.

<P><span class="pcounter"></span> This Standard defines the meaning of regular expressions in two
stages: declaratively as a mapping from surface syntax to abstract
syntax trees, and then operationally (in ECMAScript itself) as an
interpreter that performs matching of input strings by interpreting
those abstract syntax trees.

<P><span class="pcounter"></span> Compiling a pattern may throw a <code>SyntaxError</code> exception; on the
other hand, once the pattern is successfully compiled, applying the
compiled pattern to find a match in a string cannot throw an exception
(except for any host-defined exceptions that can occur anywhere such
as out-of-memory).

<P><span class="pcounter"></span> The abstract syntax trees for regular expressions are represented
as trees of ECMAScript objects.  These objects are all instances of
specific ECMAScript classes, which are presented below (<span class="xref">RegExp ASTs</span>).

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>RegExp</code> provides the following interface:

<PRE>
dynamic class RegExp
{
    function RegExp( pattern, flags ) &#x0085
    static meta function invoke( pattern, flags ) &#x0085

    static const length: uint = 2

    override intrinsic function toString() : string &#x0085

    intrinsic function exec(s : string) : Array &#x0085
    intrinsic function test(s : string) : boolean &#x0085

    meta function invoke(s : string) : Array &#x0085

    const source: string = &#x0085; 
    const global: boolean = &#x0085;
    const ignoreCase: boolean = &#x0085;
    const multiline: boolean = &#x0085;
    const extended: boolean = &#x0085;
    const sticky: boolean = &#x0085;

    final function get lastIndex() &#x0085
    final function set lastIndex(x) &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>RegExp</code> prototype object provides the following direct
dynamic properties:

<PRE>
    exec:     function (s) &#x0085; ,
    test:     function (s) &#x0085; ,
    toString: function () &#x0085;
</PRE>

<h2>Surface syntax and mapping to abstract syntax trees</h2>

<h3 id="RegExp grammar"> Grammar </h3>

<P><span class="pcounter"></span> The <code>RegExp</code> constructor applies the following grammar to the
pattern string.  A <b>SyntaxError</b> exception is thrown if the
grammar cannot recognize the string as an expansion of the nonterminal
<i>Pattern</i>.

<P><span class="pcounter"></span> The grammar acts as a transformer from segments of the pattern
string into abstract syntax (sub)trees.  A transformation computation
of one of the following types is associated with each production in
the grammar.

<UL>

  <LI> The construction of an abstract syntax tree node.  Construction
  appears as the call to a factory function for the node, denoted by
  an identifier in boldface with an initial capital letter.  The
  factory functions map directly to the constructors for the
  respective abstract syntax tree classes, described in section <span class="xref">RegExp.matching</span>.

  <LI> The computation of a value, which may be a string, a number, or
  an abstract syntax tree node.  Computation appears as the call to a
  helper function, denoted by an identifier in boldface with an
  initial lower-case letter.

  <LI> The construction or destructuring of value tuples that carry
  multiple values from a production to a surrounding production.
  Tuple construction and destructuring use the ECMAScript syntax for
  constructing and destructuring Array values.
  
  <LI> The extraction of a token value from the production.
  Extraction appears as the use of the name of the token in the
  computation.

</UL>

<P><span class="pcounter"></span> The definition language also has side computations, side
conditions, and error conditions.  These are suffixed to a
transformation computation.

<UL>

  <LI> Side computations bind temporary names to values and are
  introduced by <code>where</code> clauses.

  <LI> Side conditions test the applicability of a production and are
  introduced by <code>provided</code> clauses.

  <LI> Error conditions throw a <b>SyntaxError</b> exception if they do
  not hold and are introduced by <code>requires</code> clauses.

</UL>

<PRE style="font-style: italic; page-break-inside: avoid">
Pattern ::
    Disjunction                  => <b>RegExpMatcher</b>( Disjunction )
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
Disjunction ::
    Alternative                  => Alternative
    Alternative <span class="literal">|</span> Disjunction    => <b>Disjunct</b>( Alternative, Disjunction )
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
Alternative ::
    [empty]                      => <b>Empty</b>()
    Alternative Term             => <b>Conjunct</b>( Alternative, Term )
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
Term ::
    Assertion                    => Assertion
    Atom                         => Atom
    Atom Quantifier              => <b>Quantified</b>(parenIndex,
                                               parenCount,
                                               atom,
                                               min,
                                               max,
                                               greedy)
                                    where [min, max, greedy] = Quantifier
                                    requires min &#x2264; max
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
Assertion ::
    <span class="literal">^</span>                            => <b>AssertStartOfInput</b>()
    <span class="literal">$</span>                            => <b>AssertEndOfInput</b>()
    <span class="literal">\</span> <span class="literal">b</span>                          => <b>AssertWordBoundary</b>()
    <span class="literal">\</span> <span class="literal">B</span>                          => <b>AssertNotWordBounary</b>()
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
Quantifier ::
    QuantifierPrefix             => [min, max, <b>true</b>] where [min, max] = QuantifierPrefix
    QuantifierPrefix <span class="literal">?</span>           => [min, max, <b>false</b>] where [min, max] = QuantifierPrefix
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
QuantifierPrefix ::
    <span class="literal">*</span>                            => [0, &#x221E;]
    <span class="literal">+</span>                            => [1, &#x221E;]
    <span class="literal">?</span>                            => [0, 1]
    <span class="literal">{</span> DecimalDigits <span class="literal">}</span>            => [DecimalDigits, DecimalDigits]
    <span class="literal">{</span> DecimalDigits <span class="literal">,</span> <span class="literal">}</span>          => [DecimalDigits, &#x221E;]
    <span class="literal">{</span> DecimalDigits<sub>1</sub> <span class="literal">,</span> DecimalDigits<sub>2</sub> <span class="literal">}</span>
                                 => [DecimalDigits<sub>1</sub>, DecimalDigits<sub>2</sub>]
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
Atom ::
    PatternCharacter             => <b>CharacterSet</b>( <b>CharsetAdhoc</b>( PatternCharacter ) )
    <span class="literal">.</span>                            => <b>CharacterSet</b>( <b>CharsetComplement</b>( charset_linebreak ) )
    <span class="literal">\</span> DecimalEscape              => <b>Backref</b>( DecimalEscape )
                                    requires that the regular expression as a whole has
                                             at least DecimalEscape capturing parentheses
    <span class="literal">\</span> CharacterEscape            => <b>CharacterSet</b>( <b>CharsetAdhoc</b>( CharacterEscape ) ) )
    <span class="literal">\</span> CharacterClassEscape       => <b>CharacterSet</b>( CharacterClassEscape )
    CharacterClass               => <b>CharacterSet</b>( CharacterClass )
    <span class="literal">(</span> Disjunction <span class="literal">)</span>              => <b>Capturing</b>( Disjunction, parenIndex+1 )
    <span class="literal">(</span> <span class="literal">?</span> <span class="literal">:</span> Disjunction <span class="literal">)</span>          => Disjunction
    <span class="literal">(</span> <span class="literal">?</span> <span class="literal">=</span> Disjunction <span class="literal">)</span>          => <b>PositiveLookahead</b>( Disjunction )
    <span class="literal">(</span> <span class="literal">?</span> <span class="literal">!</span> Disjunction <span class="literal">)</span>          => <b>NegativeLookahead</b>( Disjunction )
    <span class="literal">(</span> <span class="literal">?</span> <span class="literal">#</span> <span style="font-size: smaller; font-style: normal">[sequence matching [^)]*]</span> <span class="literal">)</span> => <b>Empty</b>()
    <span class="literal">(</span> <span class="literal">?</span> <span class="literal">P</span> <span class="literal"><</span> Identifier <span class="literal">></span> Disjunction <span class="literal">)</span>
                                 => <b>Capturing</b>( Disjunction, <b>capno</b>( Identifier ) )
                                    where <b>capno</B>( Identifier ) is defined as parenIndex+1
    <span class="literal">(</span> <span class="literal">?</span> <span class="literal">P</span> <span class="literal">=</span> Identifier <span class="literal">)</span>         => <b>Backref</b>( <b>capno</b>( Identifier ) )
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
PatternCharacter ::
    SourceCharacter <span class="literal">but not any of ^ $ \ . * + ? ( ) [ ] { } |</span>
                                 => SourceCharacter
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
CharacterEscape ::
    ControlEscape                => ControlEscape
    <span class="literal">c</span> ControlLetter              => <b>chr</b>(<b>ord</b>( ControlLetter ) / 32)
    HexEscapeSequence            => HexEscapeSequence
    UnicodeEscapeSequence        => UnicodeEscapeSequence
    IdentityEscape               => IdentityEscape
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
ControlEscape ::
    <span class="literal">f</span>                            => <span class="literal">'\u000C'</span>
    <span class="literal">n</span>                            => <span class="literal">'\u000A'</span>
    <span class="literal">r</span>                            => <span class="literal">'\u000D'</span>
    <span class="literal">t</span>                            => <span class="literal">'\u0009'</span>
    <span class="literal">v</span>                            => <span class="literal">'\u000B'</span>
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
ControlLetter :: <span class="literal">one of</span>
    <span class="literal">a b c d e f g h i j k l m n o p q r s t u v w x y z</span>
    <span class="literal">A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</span>
                                 => ControlLetter
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
IdentityEscape ::
    SourceCharacter <span class="literal">but not</span> IdentifierPart
                                 => SourceCharacter
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
DecimalEscape ::
    DecimalIntegerLiteral <span style="font-size: smaller; font-style: normal">[lookahead not in DecimalDigit]</span>
                                 => <b>dec</b>( DecimalIntegerLiteral )
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
CharacterClassEscape ::
    <span class="literal">d</span>                           => charset_digit
    <span class="literal">D</span>                           => <b>CharsetComplement</b>( charset_digit )
    <span class="literal">s</span>                           => charset_space
    <span class="literal">S</span>                           => <b>CharsetComplement</b>( charset_space )
    <span class="literal">w</span>                           => charset_word
    <span class="literal">W</span>                           => <b>CharsetComplement</b>( charset_word )
    <span class="literal">p</span> <span class="literal">{</span> UnicodeClass <span class="literal">}</span>          => <b>unicodeClass</b>( UnicodeClass )
    <span class="literal">P</span> <span class="literal">{</span> UnicodeClass <span class="literal">}</span>          => <b>CharsetComplement</b>( <b>unicodeClass</b>( UnicodeClass ) )
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
CharacterClass ::
    <span class="literal">[</span> CharacterClassBody <span class="literal">]</span>      => <b>merge</b>( U, I )
                                   where [U, I] = CharacterClassBody
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
CharacterClassBody ::
    <span style="font-size: smaller; font-style: normal">[lookahead not in {^}]</span> ClassRanges
                                => ClassRanges
    <span class="literal">^</span> ClassRanges               => [[ <b>CharsetComplement</b>( merge( U, I ) ) ], []]
                                   where [U, I] = ClassRanges
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
ClassRanges ::
    [empty]                     => [[ <b>CharsetEmpty</b>() ], []]
    NonemptyClassranges         => NonemptyClassRanges
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
NonemptyClassRanges ::
    ClassRange                  => ClassRange
    ClassRange NonemptyClassRanges
                                => [[union<sub>1</sub>, union<sub>2</sub>&#x0085;], [intersection<sub>1</sub>, intersection<sub>2</sub>&#x0085;]]
                                   where [union<sub>1</sub>, intersection<sub>1</sub>] = ClassRange
                                     and [union<sub>2</sub>&#x0085;, intersection<sub>2</sub>&#x0085;] = NonemptyClassRanges
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
ClassRange ::
    ClassAtom                   => [[ClassAtom],[]]
                                   provided the next production does not apply
    ClassAtom<sub>1</sub> <span class="literal">-</span> ClassAtom<sub>2</sub>      => [[<b>CharsetRange</b>(ClassAtom<sub>1</sub>, ClassAtom<sub>2</sub>)],[]]
                                    requires that ClassAtom<sub>1</sub> and ClassAtom<sub>2</sub>
                                             have one element each and that
                                             the code point value of ClassAtom<sub>1</sub>
                                             is &#x2264; the code point value of ClassAtom<sub>2</sub>
    <span class="literal">&</span> <span class="literal">&</span> <span class="literal">[</span> CharacterClassBody <span class="literal">]</span>  => [[], [ <b>merge</b>( U, I ) ]]
                                    where [U, I] = CharacterClassBody
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
ClassAtom ::
    <span class="literal">-</span>                            => <b>CharsetAdhoc</b>(<span class="literal">'-'</span>)
    <span class="literal">\</span> DecimalEscape              => <b>CharsetAdhoc</b>( <b>chr</b>( DecimalEscape ) )
    <span class="literal">\</span> <span class="literal">b</span>                          => <b>CharsetAdhoc</b>( <span class="literal">'\u0008'</span> )
    <span class="literal">\</span> CharacterEscape            => <b>CharsetAdhoc</b>( CharacterEscape )
    <span class="literal">\</span> CharacterClassEscape       => CharacterClassEscape
    SourceCharacter <span class="literal">but not one of \ ] -</span>
                                 => <b>CharsetAdhoc</b>( SourceCharacter )
</PRE>
<PRE style="font-style: italic; page-break-inside: avoid">
UnicodeClass ::
    Identifier                   => Identifier
                                    provided Identifier spells one of these names:
                                    <span class="literal">C Cc Cf Cn Co Cs L Ll Lm Lo Lt Lu M Mc Me Mn N Nd Nl No</span>
                                    <span class="literal">P Pc Pd Pe Pf Pi Po Ps S Sc Sk Sm So Z Zl Zp Zs</span>
</PRE>

<P><span class="pcounter"></span> <i>SourceCharacter</i>, <i>HexEscapeSequence</i>, <i>UnicodeEscapeSequence</i>, and
<i>IdentityEscape</i> are defined as part of the general ECMAScript
grammar (<span class="xref">language.grammar</span>) and all produce one-character
strings.

<P><span class="pcounter"></span> To every expansion of a production there belongs two variables,
<i>parenIndex</i> and <i>parenCount</i>.  <i>ParenIndex</i> represents the
number of left capturing parentheses in the entire regular expression
that occur to the left of the production expansion's initial token.
<i>ParenCount</i> represents the number of left capturing parentheses in
the expansion of the production.

<P><span class="pcounter"></span> Character set unions and intersections are represented explicitly
as data structures that reference the subsets that are the operands of
the union or intersection operator, respectively; sets are not
flattened.

<P><span class="pcounter"></span> There are four predefined character sets:
<UL>
  <LI> <i>charset_linebreak</i> contains the Unicode line terminator characters &lt;LF>, &lt;CR>, &lt;LS>, and &lt;PS>.
  <LI> <i>charset_digit</i> contains the decimal digit characters <code>0</code> through <code>9</code>
  <LI> <i>charset_space</i> contains all the Unicode <i>WhiteSpace</i> (<span class="xref">Unicode.whitespace</span>)
  and <i>LineTerminator</i> (<span class="xref">Unicode.lineterminator</span>) characters
  <LI> <i>charset_word</i> contains the upper-case letters <code>A</code> through <code>Z</code>,
       the lower-case letters <code>a</code> through <code>z</code>, the decimal digit characters <code>0</code> through <code>9</code>, and the underscore <code>_</code>.
</UL>

<P><span class="pcounter"></span> The helper function <code>chr</code> converts a Unicode code point value into the
corresponding Unicode character (a one-character string).

<P><span class="pcounter"></span> The helper function <code>ord</code> converts a one-character string into a
Unicode code point value.

<P><span class="pcounter"></span> The helper function <code>dec</code> converts the textual representation of
a nonnegative decimal integer into its integer value.

<P><span class="pcounter"></span> The helper function <code>merge</code> creates a single character set from
two collections of sets <i>U</i> and <i>I</i>, where the result set is the
union of the sets of <i>U</i>, intersected with the intersection of the
sets of <i>I</i> unless <i>I</i> is empty.

<P><span class="pcounter"></span> The helper function <code>capno</code> maps identifiers to capture numbers.

<P><span class="pcounter"></span> The helper function <code>unicodeClass</code> maps a one or two character
Unicode class name to a character set containing the characters in
that Unicode class.

<P><span class="pcounter"></span> Even if the pattern ignores case, the case of the two ends of a
range is significant in determining which characters belong to the
range. Thus, for example, the pattern <code>/[E-F]/i</code> matches only the
letters <code>E</code>, <code>F</code>, <code>e</code>, and <code>f</code>, while the pattern <code>/[E-f]/i</code>
matches all upper and lower-case ASCII letters as well as the symbols
<code>[</code>, <code>\</code>, <code>]</code>, <code>^</code>, <code>_</code>, and <code>`</code>.

<P><span class="pcounter"></span> A <i>ClassAtom</i> can use any of the escape sequences that are
allowed in the rest of the regular expression except for <code>\b</code>,
<code>\B</code>, and backreferences.  Inside a CharacterClass, <code>\b</code> means the
backspace character, while <code>\B</code> and backreferences raise errors.
Using a backreference inside a <i>ClassAtom</i> causes an error.

<P><span class="pcounter"></span> <i>ClassRanges</i> can expand into single <i>ClassAtoms</i> and/or
ranges of two <i>ClassAtoms</i> separated by dashes.  In the latter case
the <i>ClassRanges</i> includes all characters between the first
ClassAtom and the second <i>ClassAtom</i>, inclusive; an error occurs if
either <i>ClassAtom</i> does not represent a single character (for
example, if one is <code>\w</code>) or if the first <i>ClassAtom</i>'s code point
value is greater than the second <i>ClassAtom</i>'s code point value.

<P><span class="pcounter"></span> A <code>-</code> character can be treated literally or it can denote a
range.  It is treated literally if it is the first or last character
of <i>ClassRanges</i>, the beginning or end limit of a range
specification, or immediately follows a range specification.


<h3>White space and line comments</h3>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  It has been agreed that comment syntax (both forms) is to be
removed from the spec and that newlines in regex literals must be
escaped by a backslash.  Both decisions make it possible to retain the
ES3 split between surface lexing and regex parsing, and probably also
helps preserve programmers' sanity.

<P><span class="pcounter"></span> The grammar takes on one of two meanings depending on whether the
<code>x</code> flag was supplied to the regular expression constructor.

<P><span class="pcounter"></span> If the <code>x</code> flag was not supplied then all white space is treated
as literal characters (typically <i>SourceCharacter</i>) and the <code>#</code>
character, outside the context of the <code>(?#</code> character sequence, does
not mean anything special -- it is just another <i>SourceCharacter</i>.

<P><span class="pcounter"></span> If the <code>x</code> flag was supplied then white space is ignored in a
number of contexts and the <code>#</code> character, outside the context of the
<code>(?#</code> character sequence, starts a comment that ends when a line
terminator character is seen (the line terminator is not part of the
comment).  White space and line comments act as token separators but
are otherwise completely ignored.  The multi-character tokens of the
regular expression grammar inside which white space and line comments
break the token are:

<UL>
  <LI> the character sequences <code>(?:</code>, <code>(?=</code>, <code>(?!</code>, <code>(?#</code>, <code>(?P=</code>, <code>(?P<</code>, and <code>&&[</code>
  <LI> the character sequences starting with a backslash (<code>\</code>), except that white space and line
  comments are allowed immediately following the backslash
  <LI> <i>DecimalDigits</i> and <i>Identifier</i>
</UL>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #194.) The definition on where whitespace is ignored /
not ignored needs to be stronger, particularly around backspace.  Eg,
<NOBR><code>\p{N}</code></NOBR> is the same as <NOBR><code>\p{ N }</code></NOBR> but not
the same as <NOBR><code>\p {N}</code></NOBR>.  We could go fascist and say that
the middle of those three is not allowed, but that seems unnatural.


<h2>Abstract syntax trees</h2>

<P><span class="pcounter"></span> The abstract syntax trees for regular expressions are represented
as trees of instances of the ECMAScript classes <code>Disjunct</code>,
<code>Conjunct</code>, <code>AssertStartOfInput</code>, <code>AssertEndOfInput</code>,
<code>AssertWordBoundary</code>, <code>AssertNotWordBoundary</code>, <code>Quantified</code>,
<code>Capturing</code>, <code>Backref</code>, <code>PositiveLookahead</code>,
<code>NegativeLookahead</code>, <code>CharacterSet</code>, and <code>Empty</code>.

<P><span class="pcounter"></span> These abstract syntax tree classes all implement the <code>Matcher</code>
interface, which requires them to provide a <code>match</code> method that
takes a matching context, a matching state, and a continuation, and
returns a result:

<PRE>
interface Matcher {
    function match(ctx: Context, x: State, c: Continuation): MatchResult
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The types <code>Context</code>, <code>State</code>, <code>Continuation</code>, and
<code>MatchResult</code> are described later, along with the matching
algorithm.

<P><span class="pcounter"></span> An additional set of classes, comprised of <code>CharsetEmpty</code>,
<code>CharsetUnion</code>, <code>CharsetIntersection</code>, <code>CharsetComplement</code>,
<code>CharsetRange</code>, and <code>CharsetAdhoc</code>, represents character sets and
unions, intersections, and complements of characters sets.  Each of
these implements the <code>CharsetMatcher</code> interface, which takes a
matching context and a single-character string and returns a truth
value:

<PRE>
interface CharsetMatcher {
    function match(ctx: Context, s: string): boolean;
}
</PRE>

<P><span class="pcounter"></span> All abstract syntax tree classes are described in detail below.


<h2>Matching</h2>

<P><span class="pcounter"></span> The <code>match</code> method of the object that implements the <code>Matcher</code>
interface attempts to match a middle subpattern (determined by the
type of matcher and its internal settings) of the pattern against the
input string, starting at the intermediate state given by its
<code>State</code> argument.  The <code>Continuation</code> argument is a closure that
matches the rest of the pattern.  After matching the subpattern of a
pattern to obtain a new <code>State</code>, the matcher then calls
<code>Continuation</code> on the new state to test if the rest of the pattern can
match as well.  If it can, the matcher returns the state returned by
the continuation; if not, the matcher may try different choices at its
choice points, repeatedly calling the continuation until it either
succeeds or all possibilities have been exhausted.

<P><span class="pcounter"></span> The interface to this machinery is the class <code>RegExpMatcher</code>,
which takes as arguments an input, a start position, and some flags,
and which constructs a matcher context, an internal state, and a final
continuation and then invokes its internal matcher on these values,
returning the result returned by the matcher.

<P><span class="pcounter"></span> A <code>Context</code> object describes constant values used by all the
matchers during the matching.

<PRE>
class Context
{
    const input       : string,
          inputLength : uint,
          ignoreCase  : boolean,
          multiline   : boolean
}
</PRE>

<P><span class="pcounter"></span> <code>input</code> is the string being matched by the regular
expression pattern; <code>inputLength</code> is the number of characters in
<code>input</code>; <code>ignoreCase</code> is <b>true</b> if the matching is
case-insensitive; and <code>multiline</code> is <b>true</b> if the matching allows
the <code>^</code> assertion to match at the beginning of a line and the <code>$</code>
assertion to match at the end of a line (and not just at the beginning
and end of the input, respectively).

<P><span class="pcounter"></span> A <code>State</code> object represents partial match states in the regular
expression matching algorithms.

<PRE>
class State
{
   const endIndex: uint,
         captures: CapArray
}

type CapArray = [(string,undefined)]
</PRE>


<P><span class="pcounter"></span> The <code>endIndex</code> is one plus the index of the last input character
matched so far by the pattern, while <code>captures</code> holds the results of
capturing parentheses. <code>Captures</code> is an array whose length is the
number of left capturing parentheses in the <i>pattern</i>.  The <i>n</i>th
element of <code>captures</code> is either a string that represents the value
obtained by the <i>n</i>th set of capturing parentheses or <b>undefined</b>
if the <i>n</i>th set of capturing parentheses hasn't been reached yet.
Due to backtracking, many states may be in use at any time during the
matching process.

<P><span class="pcounter"></span> A <code>MatchResult</code> is either a <code>State</code> or the special token
<b>failure</b> that indicates that the match failed:

<PRE>
type MatchResult = (State, &#x0085;)
const failure = &#x0085;
</PRE>
  
<P><span class="pcounter"></span> A Continuation function is a closure that takes a <code>Context</code> and
a <code>State</code> and returns a <code>MatchResult</code>:

<PRE>
type Continuation = function(Context, State): MatchResult;
</PRE>

<P><span class="pcounter"></span> The continuation attempts to match the remaining portion
(specified by the closure's already-bound arguments) of the pattern
against the input string, starting at the intermediate state given by
its <code>State</code> argument.  If the match succeeds, the continuation
returns the final <code>State</code> that it reached; if the match fails, the
continuation returns <b>failure</b>.


<h3>RegExpMatcher</h3>

<P><span class="pcounter"></span> The class <code>RegExpMatcher</code> drives the matching.  When its <code>match</code> method is invoked
it creates a <code>Context</code>, a <code>State</code>, a <code>Continuation</code>, and then it invokes its matcher
object---the result of compiling the <i>pattern</i>---on these values, returning the result
returned by the matcher.

<PRE>
function RegExpMatcher(matcher, nCapturingParens)
    : matcher = matcher
    , nCapturingParens = nCapturingParens
{
}

const matcher:          Matcher,
      nCapturingParens: uint
</PRE>
<PRE>
function match( input: string, endIndex: double, multiline: boolean, ignoreCase: boolean )
    : MatchResult
    {
        return matcher.match(new Context(input, multiline, ignoreCase),
                             new State(endIndex, makeCapArray(nCapturingParens+1)),
                             function (ctx: Context, x: State): State? { return x } );
    }
</PRE>

<P><span class="pcounter"></span> Capture arrays are created by <code>makeCapArray</code> and copied and
partly cleared by <code>copyCapArray</code>:

<PRE>
function makeCapArray(len: double): CapArray {
    let a = []: CapArray;
    for ( let i = 0 ; i &#60; len ; i++ )
        a[i] = undefined;
    return a;
}
</PRE>
<PRE>
function copyCapArray(a: CapArray, parenIndex: double, parenCount: double): CapArray {
    let b = makeCapArray(a.length);
    for ( let i = 0 ; i &#60; a.length ; i++ )
        b[i] = a[i];

    for ( let k = parenIndex+1 ; k &#60;= parenIndex+parenCount ; k++ )
        b[k] = undefined;
    return b;
}
</PRE>

<h3>Disjunct</h3>

<P><span class="pcounter"></span> The class <code>Disjunct</code> represents a matcher that allows two alternatives:
<PRE>
function Disjunct(m1, m2) : m1=m1, m2=m2 {}

const m1: Matcher,
      m2: Matcher
</PRE>
<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    let r = m1.match(ctx, x, c);
    if (r != failure)
        return r;
    return m2.match(ctx, x, c);
}
</PRE>

<P><span class="pcounter"></span> A <code>Disjunct</code> first tries to match the left alternative <i>m1</i>
(followed by the sequel of the regular expression); if it fails, it
tries to match the right alternative <i>m2</i> (followed by the sequel of
the regular expression). If <i>m1</i>, <i>m2</i>, and the sequel all have
choice points, all choices in the sequel are tried before moving on to
the next choice in <i>m1</i>. If choices in <i>m1</i> are exhausted, <i>m2</i>
is tried instead of <i>m1</i>.  Any capturing parentheses inside a
portion of the pattern skipped by <code>|</code> produce undefined values
instead of strings.  Thus, for example,

<PRE>
    /a|ab/.exec("abc")
</PRE>

returns the result "a" and not "ab". Moreover,

<PRE>
    /((a)|(ab))((c)|(bc))/.exec("abc")
</PRE>

returns the array

<PRE>
    ["abc", "a", "a", undefined, "bc", undefined, "bc"]
</PRE>

and not

<PRE>
    ["abc", "ab", undefined, "ab", "c", "c", undefined]
</PRE>


<h3>Conjunct</h3>

<P><span class="pcounter"></span> The class <code>Conjunct</code> represents a matcher that requires the
matching of two consecutive terms:

<PRE>
function Conjunct(m1, m2) : m1=m1, m2=m2 {}

const m1: Matcher,
      m2: Matcher
</PRE>
<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    return m1.match(ctx,
                    x,
                    (function (ctx: Context, y: State): MatchResult
                     m2.match(ctx, y, c)) );
}
</PRE>

<P><span class="pcounter"></span> A <code>Conjunct</code> tries simultaneoulsly to match the terms <i>m1</i> and
<i>m2</i> on consecutive portions of the input string.  If <i>m1</i>,
<i>m2</i>, and the sequel of the regular expression all have choice
points, all choices in the sequel are tried before moving on to the
next choice in <i>m2</i>, and all choices in <i>m2</i> are tried before
moving on to the next choice in <i>m1</i>.

<h4>AssertStartOfInput</h4>

<P><span class="pcounter"></span> The Start-of-Input assertion succeeds without consuming input if
the current input position is at the start of the input or if the
match is multiline and the current position is at the start of a line.

<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    let e = x.endIndex;
    if (e == 0 || ctx.multiline && isTerminator(ctx.input[e-1]))
        return c(ctx, x);
    return failure;
}
</PRE>

<P><span class="pcounter"></span> The helper function <code>isTerminator</code> takes a character <i>c</i> and
returns <b>true</b> if <i>c</i> is one of the Unicode line terminator
characters &lt;LF>, &lt;CR>, &lt;LS>, and &lt;PS>.

<h4>AssertEndOfInput</h4>

<P><span class="pcounter"></span> The End-of-Input assertion succeeds without consuming input if the
current input position is at the end of the input or if the match is
multiline and the current position is at the end of a line.

<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    let e = x.endIndex;
    if (e == ctx.inputLength || ctx.multiline && isTerminator(ctx.input[e]))
        return c(ctx, x);
    return failure;
}
</PRE>

<h4>AssertWordBoundary</h4>

<P><span class="pcounter"></span> The Word-Boundary assertion succeeds without consuming input if
the current input position is inside a word and the previous position
is outside a word, or vice versa.

<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    let e = x.endIndex;
    if (isREWordChar(ctx, e-1) != isREWordChar(ctx, e))
        return c(ctx, x);
    return failure;
}
</PRE>

<P><span class="pcounter"></span> The test for word character also takes boundary conditions into consideration:

<PRE>
function isREWordChar(ctx: Context, e: double): boolean {
    if (e == -1 || e == ctx.inputLength)
        return false;
    let c = ctx.input[e];
    return isWordChar(ctx.input[e]);
}
</PRE>

<P><span class="pcounter"></span> The helper function <code>isWordChar</code> takes a character <i>c</i> and
returns <b>true</b> if <i>c</i> is one of the upper-case ASCII letters <code>A</code>
through <code>Z</code>, one of the lower-case ASCII letters <code>a</code> through
<code>z</code>, one of the ASCII decimal digits <code>0</code> through <code>9</code>, or the
ASCII underbar <code>_</code>.

<h4>AssertNotWordBoundary</h4>

<P><span class="pcounter"></span> The Not-Word-Boundary assertion succeeds without consuming input
if neither the current input position is inside a word and the
previous position is outside a word, nor vice versa.

<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    let e = x.endIndex;
    if (isREWordChar(ctx, e-1) == isREWordChar(ctx, e))
        return c(ctx, x);
    return failure;
}
</PRE>


<h3>Quantified</h3>

<P><span class="pcounter"></span> The class <code>Quantified</code> represents a matcher that succeeds if its
submatch <i>m</i> matches the input a certain number of times.

<PRE>
function Quantified(parenIndex, parenCount, m, min, max, greedy)
    : parenIndex=parenIndex
    , parenCount=parenCount
    , m=m
    , min=min
    , max=max
    , greedy=greedy

const parenIndex: uint,
      parenCount: uint,
      m: Matcher,
      min: double,
      max: double,
      greedy: boolean
</PRE>
<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {

    function RepeatMatcher(min: double, max: double, x: State): MatchResult {
        function d(ctx: Context, y: State): MatchResult {
            if (min == 0 && y.endIndex == x.endIndex)
                return failure;
            else
                return RepeatMatcher(Math.max(0, min-1), max-1, y);
        }

        if (max == 0)
            return c(ctx, x);

        let xr = new State(x.endIndex, copyCapArray(x.captures, parenIndex, parenCount));

        if (min != 0)
            return m.match(ctx, xr, d);

        if (!greedy) {
            let z = c(ctx, x);
            if (z != failure)
                return z;
            return m.match(ctx, xr, d);
        }
        else {
            let z = m.match(ctx, xr, d);
            if (z != failure)
                return z;
            return c(ctx, x);
        }
    }

    return RepeatMatcher(min, max, x);
}
</PRE>

<P><span class="pcounter"></span> A pattern term <i>m</i> followed by a quantifier is repeated the
number of times specified by the quantifier.  A quantifier can be
non-greedy, in which case <i>m</i> is repeated as few times as possible
while still matching the sequel, or it can be greedy, in which case
<i>m</i> is repeated as many times as possible while still matching the
sequel.  <i>M</i> is repeated rather than the input string that it
matches, so different repetitions of <i>m</i> can match different input
substrings.

<P><span class="pcounter"></span> If <i>m</i> and the sequel of the regular expression all have choice
points, <i>m</i> is first matched as many (or as few, if non-greedy)
times as possible.  All choices in the sequel are tried before moving
on to the next choice in the last repetition of <i>m</i>.  All choices in
the last (nth) repetition of <i>m</i> are tried before moving on to the
next choice in the next-to-last (n-1)st repetition of <i>m</i>; at which
point it may turn out that more or fewer repetitions of <i>m</i> are now
possible; these are exhausted (again, starting with either as few or
as many as possible) before moving on to the next choice in the
(n-1)st repetition of Atom and so on.

<P><span class="pcounter"></span>Compare
<PRE>
    /a[a-z]{2,4}/.exec("abcdefghi")
</PRE>

which returns <code>"abcde"</code> with

<PRE>
    /a[a-z]{2,4}?/.exec("abcdefghi")
</PRE>

which returns <code>"abc"</code>.

<P><span class="pcounter"></span> Consider also

<PRE>
    /(aa|aabaac|ba|b|c)*/.exec("aabaac")
</PRE>

which, by the choice point ordering above, returns the array

<PRE>
    ["aaba", "ba"]
</PRE>

and not any of:

<PRE>
    ["aabaac", "aabaac"]
    ["aabaac", "c"]
</PRE>

<P><span class="pcounter"></span> The above ordering of choice points can be used to write a regular
expression that calculates the greatest common divisor of two numbers
(represented in unary notation). The following example calculates the
<i>gcd</i> of 10 and 15:

<PRE>
    "aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/,"$1")
</PRE>

which returns the <i>gcd</i> in unary notation <code>"aaaaa"</code>.

<P><span class="pcounter"></span> The helper function <code>copyCapArray</code> clears the portion of the
captures array between <i>parenIndex+1</i> and <i>parenIndex+parenCount</i>
inclusive each time <i>m</i> is repeated.  We can see its behaviour in the
regular expression

<PRE>
    /(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")
</PRE>

which returns the array

<PRE>
   ["zaacbbbcac", "z", "ac", "a", undefined, "c"]
</PRE>

and not

<PRE>
   ["zaacbbbcac", "z", "ac", "a", "bbb", "c"]
</PRE>

because each iteration of the outermost <code>*</code> clears all captured
strings contained in <i>m</i>, which in this case includes capture
strings numbered 2, 3, and 4.

<P><span class="pcounter"></span> The initial test of <code>RepeatMatcher</code>'s closure <code>d</code> states that,
once the minimum number of repetitions has been satisfied, any more
expansions of <i>m</i> that match the empty string are not considered for
further repetitions.  This prevents the regular expression engine from
falling into an infinite loop on patterns such as:

<PRE>
   /(a*)*/.exec("b")
</PRE>

or the slightly more complicated:

<PRE>
   /(a*)b\1+/.exec("baaaac")
</PRE>

which returns the array

<PRE>
   ["b", ""]
</PRE>

<h3>PositiveLookahead</h3>

<P><span class="pcounter"></span> The positive lookahead matcher succeeds without consuming input if
its contained matcher can match the input at the current location:

<PRE>
function PositiveLookahead(m) : m=m {}

const m: Matcher
</PRE>
<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    let r = m.match(ctx,
                    x,
                    (function (ctx, y: State): MatchResult
                     y) );
    if (r == failure)
        return failure;
    return c(ctx, new State(x.endIndex, r.captures));
}
</PRE>

<P><span class="pcounter"></span> If <i>m</i> can match at the current position in several ways, only
the first one is tried.  Unlike other regular expression operators,
there is no backtracking into a <code>(?=</code> form (this unusual behaviour
is inherited from Perl).  This only matters when the <i>m</i>
contains capturing parentheses and the sequel of the pattern contains
backreferences to those captures.  For example,

<PRE>
    /(?=(a+))/.exec("baaabac")
</PRE>

matches the empty string immediately after the first <code>b</code> and therefore
returns the array:

<PRE>
    ["", "aaa"]
</PRE>

<P><span class="pcounter"></span> To illustrate the lack of backtracking into the lookahead, consider:

<PRE>
    /(?=(a+))a*b\1/.exec("baaabac")
</PRE>

This expression returns

<PRE>
    ["aba", "a"]
</PRE>

and not:

<PRE>
    ["aaaba", "a"]
</PRE>


<h3>NegativeLookahead</h3>

<P><span class="pcounter"></span> The negative lookahead matcher succeeds without consuming input if
its contained matcher fails to match the input at the current
location:

<PRE>
function NegativeLookahead(m) : m=m {}

const m: Matcher
</PRE>
<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    let r = m.match(ctx,
                    x,
                    (function (ctx, y: State): MatchResult
                     y) );
    if (r != failure)
        return failure;
    return c(ctx, x);
}
</PRE>

<P><span class="pcounter"></span> <i>M</i> can contain capturing parentheses, but backreferences to
them only make sense from within <i>m</i> itself.  Backreferences to
these capturing parentheses from elsewhere in the pattern always
return <b>undefined</b> because the negative lookahead must fail for the
pattern to succeed.  For example,

<PRE>
    /(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")
</PRE>

looks for an <code>a</code> not immediately followed by some positive number
<i>n</i> of <code>a</code>'s, a <code>b</code>, another <i>n</i> <code>a</code>'s (specified by the
first <code>\2</code>) and a <code>c</code>. The second <code>\2</code> is outside the negative
lookahead, so it matches against undefined and therefore always
succeeds.  The whole expression returns the array:

<PRE>
    ["baaabaac", "ba", undefined, "abaac"]
</PRE>


<h3>CharacterSet</h3>

<P><span class="pcounter"></span> A <code>CharacterSet</code> matches the input at the current location if
the canonical representation of the character at the current location
is a member of the character set.

<PRE>
function CharacterSet(cs)
    : cs=cs {}

const cs: CharsetMatcher;
</PRE>
<PRE>
public function match(ctx: Context, x: State, c: Continuation) /*: MatchResult */ {
    let e = x.endIndex;
    let cap = x.captures;
    if (e == ctx.inputLength)
        return failure;
    let cc = Canonicalize(ctx, ctx.input[e]);
    let res = cs.match(ctx, cc);
    if (!res)
        return failure;
    return c(ctx, new State(e+1, cap));
}
</PRE>

<P><span class="pcounter"></span> The helper function <code>Canonicalize</code> converts a character to its
canonical form.  In case-significant matches the canonical form is the
character itself.  In case-insignificant matches all characters are
converted to upper case immediately before they are compared.

<PRE>
function Canonicalize(ctx, ch) {
    if (!ctx.ignoreCase)
        return ch;
    let u = ch.toUpperCase();
    if (u.length != 1)
        return ch;
    if (ch.charCodeAt(0) >= 128 && u.charCodeAt(0) &#60; 128)
        return ch;
    return u;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  If converting a character to upper case would expand that
character into more than one character (such as converting "&#x00df;"
(\u00DF) into "SS"), then the character is left as-is instead.  The
character is also left as-is if it is not an ASCII character but
converting it to upper case would make it into an ASCII character.
This prevents Unicode characters such as \u0131 and \u017F from
matching regular expressions such as <code>/[a-z]/i</code>, which are only
intended to match ASCII letters.  Furthermore, if these conversions
were allowed, then <code>/[^\W]/i</code> would match each of <code>a</code>, <code>b</code>,
&#x0085;, <code>h</code>, but not <code>i</code> or <code>s</code>.


<h4>Character sets</h4>

<P><span class="pcounter"></span> A character set as passed to the <code>CharacterSet</code> constructor is a
mathematical set of characters.  However, in this Standard the sets
are provided with a concrete representation in order to present their
semantics operationally.

<P><span class="pcounter"></span> A character set is represented as a tree of objects that represent
unions, intersections, complements, ranges, and primitive sets
containing some number of single characters.  These data types are
presented in the following sections.

<h4>CharsetEmpty</h4>

<P><span class="pcounter"></span> The empty character set contains no characters, so matching always
fails.

<PRE>
public function match(ctx: Context, c: string): boolean {
    return false;
}
</PRE>

<h4>CharsetUnion</h4>

<P><span class="pcounter"></span> The union of two sets contains a character if either set contains it.

<PRE>
function CharsetUnion(m1,m2) : m1=m1, m2=m2 {}

const m1: Charset,
      m2: Charset
</PRE>
<PRE>
public function match(ctx: Context, c: string): boolean {
    return m1.match(ctx, c) || m2.match(ctx, c);
}
</PRE>

<h4>CharsetIntersection</h4>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  It has been agreed that character set intersection (which is
used to represent set intersection and difference on the source level)
be removed.

<P><span class="pcounter"></span> The intersection of two sets contains a character if both sets contain it.

<PRE>
function CharsetIntersection(m1,m2) : m1=m1, m2=m2 {}

const m1: Charset,
      m2: Charset
</PRE>
<PRE>
public function match(ctx: Context, c: string): boolean {
    return m1.match(ctx, c) && m2.match(ctx, c);
}
</PRE>

<h4>CharsetComplement</h4>

<P><span class="pcounter"></span> A complemented character set contains a character if the contained set does
not contain the character.

<PRE>
function CharsetComplement(m) : m=m {}

const m: Charset
</PRE>
<PRE>
public function match(ctx: Context, c: string): boolean {
    return !m.match(ctx, c);
}
</PRE>

<h4>CharsetRange</h4>

<P><span class="pcounter"></span> A set representing a range contains a character if the character
matches the canonicalized value of one of the characters in the range.

<PRE>
function CharsetRange(lo,hi) : lo=lo, hi=hi {}

const lo: string,
      hi: string
</PRE>
<PRE>
public function match(ctx: Context, c: string): boolean {
    let lo_code = lo.charCodeAt(0);
    let hi_code = hi.charCodeAt(0);
    for ( let i=lo_code ; i &#60;= hi_code ; i++ )
        if (Canonicalize(ctx, string.intrinsic::fromCharCode(i)) == c)
            return true;
    return false;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The strings <code>lo</code> and <code>hi</code> both contain a single character.

<h4>CharsetAdhoc</h4>

<P><span class="pcounter"></span> An ad-hoc character set contains a character <i>c</i> if the <i>c</i> is
equal to the canonicalized value of one of the characters in the set.

<PRE>
function CharsetAdhoc(cs) : cs=explodeString(cs) {}

const cs: [string]
</PRE>
<PRE>
public function match(ctx: Context, c: string): boolean {
    for ( let i=0 ; i &#60; cs.length ; i++ ) {
        if (Canonicalize(ctx, cs[i]) == c)
            return true;
    }
    return false;
}
</PRE>

<P><span class="pcounter"></span> The helper function <code>explodeString</code> converts a string into an
array containing the individual characters in the string, each
represented as a one-character string.

<PRE>
function explodeString(s : string) : [string] {
    let cs = [] : [string];
    for ( let i=0 ; i &#60; s.length ; i++ )
        cs[i] = s[i];
    return cs;
}
</PRE>

<h3>Capturing</h3>

<P><span class="pcounter"></span> A capturing matcher succeeds if its contained matcher <i>m</i>
matches the input at the current location.  The string that is matched
by the contained matcher is saved in the captures array at index
<i>parenIndex</i>.

<PRE>
function Capturing(m, parenIndex) : m=m, parenIndex=parenIndex {}

const m: Matcher,
      parenIndex: uint
</PRE>
<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {

    let function d( ctx: Context, y: State ): MatchResult {
        let cap = copyCapArray( y.captures, 0, 0 );
        let xe = x.endIndex;
        let ye = y.endIndex;
        cap[parenIndex+1] = ctx.input.substring(xe, ye);
        return c(ctx, new State(ye, cap));
    }

    return m.match(ctx, x, d);
}
</PRE>


<h3>Backref</h3>

<P><span class="pcounter"></span> A back-referencing matcher succeeds if the input at the current location
exactly matches the value in the captures array at index <i>capno</i>.

<PRE>
function Backref(capno) : capno=capno {}

const capno: uint
</PRE>
<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    let cap = x.captures;
    let s = cap[capno];
    if (s == null)
        return c(ctx, x);
    let e = x.endIndex;
    let len = s.length;
    let f = e+len;
    if (f > ctx.inputLength)
        return failure;
    for ( let i=0 ; i &#60; len ; i++ )
        if (Canonicalize(ctx, s[i]) != Canonicalize(ctx, ctx.input[e+i]))
            return failure;
    return c(ctx, new State(f, cap));
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  An escape sequence of the form <code>\</code> followed by a nonzero
decimal number <i>n</i> matches the result of the <i>n</i>th set of
capturing parentheses (see 15.10.2.11).  If the <i>n</i>th entry in the
captures array is undefined because it hasn't captured anything, then
the backreference always succeeds.


<h3>Empty</h3>

<P><span class="pcounter"></span> An empty match succeeds without consuming input.

<PRE>
public function match(ctx: Context, x: State, c: Continuation): MatchResult {
    return c(ctx, x);
}
</PRE>


<h2>Methods on the class <code>RegExp</code></h2>

<h3>new&nbsp;RegExp(pattern,&nbsp;flags)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>RegExp</code> constructor creates a new regular expression.
<i>Pattern</i> can be an existing regular expression, in which case the
source and flags for the new object is taken from <i>pattern</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
function RegExp( pattern, flags )
    : { matcher: matcher,
        names: names,
        source: source,
        multiline: multiline,
        ignoreCase: ignoreCase,
        global: global,
        extended: extended,
        sticky: sticky } = analyzePatternAndFlags(pattern, flags)
    , private::lastIndex = 0
{
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  If the characters of <i>src</i> do not have the form <i>Pattern</i>,
then a <b>SyntaxError</b> exception will be thrown.

<P><span class="pcounter"></span> The class <code>RegExp</code> has two internal properties <code>matcher</code> and
and <code>names</code>:

<PRE>
private const matcher: Matcher,
              names:   [string?]
</PRE>

<P><span class="pcounter"></span> The <code>matcher</code> property holds the regular expression matcher
object (the result of compiling the regular expression).  The
<code>names</code> property holds a string in position <i>i</i> if capturing
submatch <i>i</i> in the pattern string was given a name; the string
is that name.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  If pattern is a <i>StringLiteral</i>, the usual escape sequence
substitutions are performed before the string is processed by
<code>RegExp</code>. If <i>pattern</i> must contain an escape sequence to be
recognised by <code>RegExp</code>, the <code>"\"</code> character must be escaped within
the <i>StringLiteral</i> to prevent its being removed when the contents
of the <i>StringLiteral</i> are formed.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The <code>source</code> property of the newly constructed object is set
to an implementation-defined string value in the form of a <i>Pattern</i>
based on <i>src</i>.


<h3>RegExp(pattern,&nbsp;flags)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>RegExp</code> class object invoked as a function converts
<i>pattern</i> to <code>RegExp</code>.

<P><span class="pcounter"></span> If <i>pattern</i> is a <code>RegExp</code> object and <i>flags</i> is undefined,
then return <i>pattern</i> unchanged.  Otherwise construct a new regular
expression from <i>pattern</i> and <i>flags</i> and return that.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>RegExp</code> function returns a <code>RegExp</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke( pattern, flags ) {
    if (pattern is RegExp && flags === undefined)
        return pattern;
    else
        return new RegExp(pattern, flags);
}
</PRE>


<h2>Methods on <code>RegExp</code> instances</h2>


<h3>intrinsic::exec&nbsp;(&nbsp;s&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>exec</code> method performs a regular expression
match of the string <i>s</i> against the regular expression.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>exec</code> method returns an <code>Array</code> object
containing the results of the match, or <b>null</b> if the string did not
match.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function exec(s : string) : Array {
    let length = s.length;
    let i = lastIndex;
    if (!global)
        i = 0;
    let res = failure;
    while (true) {
        if (i &#60; 0 || i > length) {
            lastIndex = 0;
            return null;
        }
        res = matcher.match(s, i, multiline, ignoreCase);
        if (res !== failure)
            break;
        ++i;
    }
    if (global)
        lastIndex = res.endIndex;
    let a = new Array(res.captures.length);
    a.index = i;
    a.input = s;
    a.length = res.captures.length;
    a[0] = s.substring(i,res.endIndex);
    for ( let j=1 ; j &#60; res.captures.length ; j++ )
        a[j] = res.captures[j];
    for ( let j=1 ; j &#60; names.length ; j++ )
        if (names[j] !== null)
            a[names[j]] = res.captures[j];
    return a;
}
</PRE>

<h3>intrinsic::test&nbsp;(&nbsp;s&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>test</code> method tests whether the string <i>s</i>
can be successfully matched against the regular expression.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>test</code> method returns <b>true</b> if the string
can be matched, and otherwise <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function test(s : string) : boolean
    exec(s) !== null;
</PRE>


<h3>intrinsic::toString()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts the regular
expression to a string.

<P><span class="pcounter"></span> Let <i>src</i> be a string in the form of a <i>Pattern</i> representing
the current regular expression.  <i>src</i> may or may not be identical
to the <code>source</code> property or to the source code supplied to the
<code>RegExp</code> constructor; however, if <i>src</i> were supplied to the
<code>RegExp</code> constructor along with the current regular expression's
flags, the resulting regular expression must behave identically to the
current regular expression.

<P><span class="pcounter"></span> The intrinsic <code>toString</code> method produces a string value formed
by concatenating the strings "/", <i>src</i>, and "/"; plus "g" if the
<code>global</code> property is true, "i" if the <code>ignoreCase</code> property is
true, "m" if the <code>multiline</code> property is true, "x" if the
<code>extended</code> property is true, and "y" if the <code>sticky</code> property is
true.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  An implementation may choose to take advantage of <i>src</i> being
allowed to be different from the source passed to the <code>RegExp</code>
constructor to escape special characters in <i>src</i>.  For example, in
the regular expression obtained from <code>new RegExp("/")</code>, <i>src</i> could
be, among other possibilities, "/" or "\/". The latter would permit
the entire result ("/\//") of the <code>toString</code> call to have the form
<i>RegularExpressionLiteral</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method returns a string.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method is implementation-defined.

<h3>meta::invoke&nbsp;(&nbsp;s&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> When a <code>RegExp</code> object is called as a function, it invokes
the <code>exec</code> method on its argument and returns what <code>exec</code> returns.

<P class="implsection"><b>Implementation</b>
<PRE>
meta function invoke(s : string) : Array
    exec(s);
</PRE>

<h2>Value properties on <code>RegExp</code> instances</h2>

<h3>source</h3>

<P><span class="pcounter"></span> The value of the <code>source</code> property is <code>string</code> in the form of a
Pattern representing the current regular expression.

<h3>global</h3>

<P><span class="pcounter"></span> The value of the <code>global</code> property is a <code>boolean</code> value
indicating whether the flags contained the character <code>"g"</code>.

<h3>ignoreCase</h3>

<P><span class="pcounter"></span>The value of the <code>ignoreCase</code> property is a <code>boolean</code> value
indicating whether the flags contained the character <code>"i"</code>.

<h3>multiline</h3>

<P><span class="pcounter"></span> The value of the <code>multiline</code> property is a <code>boolean</code> value
indicating whether the flags contained the character <code>"m"</code>.

<h3>extended</h3>

<P><span class="pcounter"></span> The value of the <code>extended</code> property is a <code>boolean</code> value
indicating whether the flags contained the character <code>"x"</code>.

<h3>sticky</h3>

<P><span class="pcounter"></span> The value of the <code>sticky</code> property is a <code>boolean</code> value
indicating whether the flags contained the character "y".

<h3>lastIndex</h3>

<P><span class="pcounter"></span> The value of the <code>lastIndex</code> property is an integer that
specifies the string position at which to start the next match.

<P><span class="pcounter"></span> The value is converted to integer on setting.

<P class="implsection"><b>Implementation</b>
final function get lastIndex() &#x0085
final function set lastIndex(x) &#x0085


<h2>Methods on the <code>RegExp</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods on the <code>RegExp</code> prototype object call their
intrinsic counterparts.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The methods on the <code>RegExp</code> prototype object return what
their intrinsic counterparts return.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function exec(this:RegExp, s)
    this.exec(string(s));
</PRE>
<PRE>
prototype function test(this:RegExp, s)
    this.test(string(s));
</PRE>
<PRE>
prototype function toString(this:RegExp)
    this.intrinsic::toString();
</PRE>




<H1 id="class Vector"> The class <code>Vector</code> </H1>



<P><span class="pcounter"></span> The class <code>Vector</code> is a parameterized, dynamic, direct subclass
of <code>Object</code>.  It represents dense, typed, 0-based, one-dimensional
arrays with bounds checking and optionally fixed length.

<P><span class="pcounter"></span> The class <code>Vector</code> provides two benefits.  One is optimization:
the restrictions placed on the class---denseness and a predefined
iteration order---make it possible for ECMAScript implementations to
implement it particularly efficiently.  The other is error checking:
<code>Vector</code> provides stronger type checking and bounds checking than
<code>Array</code>.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The class <code>Vector</code> is new in the 4th Edition of this
Standard.

<P><span class="pcounter"></span> The class <code>Vector</code> provides a method suite that is largely
compatible with the class <code>Array</code>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  It is likely that many current uses of <code>Array</code> can be
switched over to <code>Vector</code> without much work, and programs that can
be switched will receive the benefits of stronger type and bounds
checking.

<P><span class="pcounter"></span> The type parameter of the <code>Vector</code> is called its <i>base type</i>.

<P><span class="pcounter"></span> As the <code>Vector</code> class is dynamic, new properties can be added to
its instances but any property whose name is a number (an instance of
any class in the union type <code>AnyNumber</code>) is handled specially.
These properties are called <i>indexed properties</i>.

<P><span class="pcounter"></span> Only indexed properties named by nonnegative integers less than
the value of the property <code>length</code> are defined, and only indexed
properties named by nonnegative integers less than 2<SUP>32</SUP>-1
can be defined.

<P><span class="pcounter"></span> Any attempt to read an undefined indexed property results in a
<b>RangeError</b> exception being thrown.

<P><span class="pcounter"></span> Any attempt to write an undefined indexed property results in a
<b>RangeError</b> being thrown unless the index is equal to the current
value of <code>length</code>, the current value of <code>length</code> is not
2<SUP>32</SUP>-1, and the value of the property <code>fixed</code> is not
<b>true</b>.

<P><span class="pcounter"></span> The property <code>fixed</code> is a flag that determines whether the
vector has fixed length or not.  Any attempt to update the value of
<code>length</code> fails if the <code>fixed</code> property has the value <b>true</b>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  If <code>v</code> is a <code>Vector</code> then reading and writing <code>v[3.14]</code>
or <code>v[-3]</code> will always fail, though reading and writing
<code>v["3.14"]</code> or <code>v["-3"]</code> will succeed.  

<P class="note"> This behavior deviates from the 3rd Edition, where
strings and numbers are interchangeable as property names.  But that's
no longer quite true in 4th Edition anyway, which has have namespaces
and <code>Name</code> objects.

<P class="note">Most attempts to set or get properties that are named
by numbers that are not valid array indices are probably errors,
especially if the object is an Array.  Most attempts to read beyond
the end of an Array are probably errors.  And in a number of cases,
attempts to write beyond the end of an Array are probably errors too.
The <code>Vector</code> class makes it possible to discover these errors.

<P><span class="pcounter"></span> All indexed properties named by nonnegative integers less than
<code>length</code> are always defined.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  As a consequence, a <code>Vector</code> does not have "holes" in its
index range in the way an <code>Array</code> does.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Vector</code> provides the following interface:

<PRE>
__ES4__ dynamic class Vector.&#60;T> extends Object
{
    public function Vector(length: double=0, fixed: boolean=false) &#x0085

    static const length = 2;

    override intrinsic function toString() &#x0085
    override intrinsic function toLocaleString() &#x0085
    intrinsic function concat(...items): Vector.&#60;T> &#x0085
    intrinsic function every(checker: Checker, thisObj: Object=null): boolean &#x0085
    intrinsic function filter(checker: Checker, thisObj: Object=null): Vector.&#60;T> &#x0085
    intrinsic function forEach(eacher: Eacher, thisObj: Object=null): void &#x0085
    intrinsic function indexOf(value: T, from: AnyNumber=0): AnyNumber &#x0085
    intrinsic function join(separator: string=","): string &#x0085
    intrinsic function lastIndexOf(value: T, from: AnyNumber=Infinity): AnyNumber &#x0085
    intrinsic function map(mapper:Mapper, thisObj:Object=null) &#x0085
    intrinsic function pop(): T &#x0085
    intrinsic function push(...items): double &#x0085
    intrinsic function reduce(reducer/*: function*/, initialValue:(T|None)=NONE ): T &#x0085
    intrinsic function reduceRight(reducer/*: function*/, initialValue:(T|None)=NONE ): T &#x0085
    intrinsic function reverse(): Vector.&#60;T> &#x0085
    intrinsic function shift(): T &#x0085
    intrinsic function slice(start: AnyNumber=0, end: AnyNumber=Infinity, step: AnyNumber=1): Vector.&#60;T> &#x0085
    intrinsic function some(checker: Checker, thisObj: Object=null): boolean &#x0085
    intrinsic function sort(comparefn: function(T, T): AnyNumber): Vector.&#60;T> &#x0085
    intrinsic function splice(start: AnyNumber, deleteCount: AnyNumber, ...items): Vector.&#60;T> &#x0085
    intrinsic function unshift(...items): double &#x0085

    iterator function get(deep: boolean = false) : iterator::Iterator.&#60;double> &#x0085
    iterator function getKeys(deep: boolean = false) : iterator::Iterator.&#60;double> &#x0085
    iterator function getValues(deep: boolean = false) : iterator::Iterator.&#60;T> &#x0085
    iterator function getItems(deep: boolean = false) : iterator::Iterator.&#60;[double,T]> &#x0085

    public var fixed: boolean &#x0085

    public final function get length() &#x0085
    public final function set length(len: AnyNumber) &#x0085

    meta final function get(name): T &#x0085
    meta final function set(name, v): void &#x0085
    meta final function has(name) &#x0085
    meta final function delete(name) &#x0085
}
</PRE>

<P><span class="pcounter"></span> The types <code>Checker</code>, <code>Eacher</code>, and <code>Mapper</code> are as for the <code>Array</code> class
(see <span class="xref">class Array</span>).

<P><span class="pcounter"></span> The <code>Vector</code> prototype object provides these direct properties:

<PRE>
    toString:       function () &#x0085;
    toLocaleString: function () &#x0085;
    concat:         function (...items) &#x0085;
    every:          function (checker, thisObj) &#x0085;
    filter:         function (checker, thisObj) &#x0085;
    forEach:        function (eacher, thisObj) &#x0085;
    indexOf:        function (value, from) &#x0085;
    join:           function (separator) &#x0085;
    lastIndexOf:    function (value, from) &#x0085;
    map:            function (mapper, thisObj) &#x0085;
    pop:            function () &#x0085;
    push:           function (...items) &#x0085;
    reduce:         function (callback, initialValue) &#x0085;
    reduceRight:    function (callback, initialValue) &#x0085;
    reverse:        function () &#x0085;
    shift:          function () &#x0085;
    slice:          function (start, end) &#x0085;
    some:           function (checker, thisObj) &#x0085;
    sort:           function (comparefn) &#x0085;
    splice:         function (start, deleteCount, ...items) &#x0085;
    unshift:        function (...items) &#x0085;
</PRE>


<h2>Methods on the <code>Vector</code> class object</h2>

<h3>new&nbsp;Vector.&lt;T&gt;&nbsp;(&nbsp;length=&#x0085;,&nbsp;fixed=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>Vector</code> constructor initializes a new <code>Vector</code> object.

<P><span class="pcounter"></span> <i>Length</i> is the inital value of the <code>length</code> property.  Its
default value is zero.  Every indexed element of the new vector below
<i>length</i> is initialized to a default value that is appropriate to
the base type <code>T</code>.

<P><span class="pcounter"></span> <i>Fixed</i> is the initial value of the <code>fixed</code> property.  Its
default value is <b>false</b>.





<h2>Methods on <code>Vector</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts the vector to a <code>string</code>.
It has the same effect as if the <code>join</code> method were invoked for this
object with no argument.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>toString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString()
    intrinsic::join();
</PRE>

<h3>intrinsic::toLocaleString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toLocaleString</code> method converts the <code>Vector</code>
to a string in the following manner.

<P><span class="pcounter"></span>Elements of this <code>Vector</code> are converted to strings using their
public <code>toLocaleString</code> methods, and these strings are then
concatenated, separated by occurrences of a separator string that has
been derived in an implementation-defined locale-specific way.  The
result of calling this function is intended to be analogous to the
result of <code>toString</code>, except that the result of this function is
intended to be locale-specific.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>toLocaleString</code> method returns a <code>string</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toLocaleString() {
    let limit = length;
    let separator = <em>localeSpecificSeparatorString</em>();
    let s = "";
    let i = 0;

    while (true) {
        let x = this[i];
        if (x !== undefined && x !== null)
            s += x.toLocaleString();
        if (++i == limit)
            break;
        s += separator;
    }
    return s;
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The first parameter to this method is likely to be used in a
future version of this standard; it is recommended that
implementations do not use this parameter position for anything else.

<h3>intrinsic::concat&nbsp;(&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>concat</code> method collects the vector elements
from <code>this</code> followed by the vector elements from the additional
<i>items</i>, in order, into a new <code>Vector</code> object.  All the <i>items</i>
must be <code>Vector</code> instances whose base types are subtypes of the base
type of <code>this</code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>concat</code> method returns a new <code>Vector</code> object with the
same base type as <code>this</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function concat(...items): Vector.&#60;T>
    <em>concat</em>(items);
</PRE>
<PRE>
helper function concat(items) {
    let v = new Vector.&#60;T>;
    let k = 0;

    for ( let i=0, limit=length ; i &#60; limit ; i++ )
        v[k++] = this[i];

    for ( let j=0 ; j &#60; items.length ; j++ ) {
        let item = items[j];
        for ( let i=0, limit=item.length ; i &#60; limit ; i++ )
            v[k++] = item[i];
    }

    return v;
}
</PRE>

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Need to check a detail of the type system, namely whether
<code>Vector.&lt;T&gt;</code> is a subtype of Vector.&lt;U&gt; if T is a
subtype of U and U is not <code>*</code>.

<h3>intrinsic::every&nbsp;(&nbsp;checker,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>every</code> method calls <i>checker</i> on every
vector element of <code>this</code> in increasing index order, stopping as soon
as any call returns <b>false</b>.

<P><span class="pcounter"></span><i>Checker</i> is called with three arguments: the vector element
value, the vector element index, and <code>this</code>.  <i>ThisObj</i> is used as
the <code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>every</code> method returns <b>true</b> if all the calls to
<i>checker</i> returned true values, otherwise it returns <b>false</b>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function every(checker: Checker, thisObj: Object=null): boolean {
    for ( let i=0, limit=length ; i &#60; limit ; i++ )
        if (!checker.call(thisObj, this[i], i, this))
            return false;
    return true;
}
</PRE>

<h3>intrinsic::filter&nbsp;(&nbsp;checker,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>filter</code> method calls <i>checker</i> on every
vector element of <code>this</code> in increasing index order, collecting all
the vector elements for which checker returns a true value.

<P><span class="pcounter"></span> <i>Checker</i> is called with three arguments: the vector element
value, the vector element index, and <code>this</code>.  <i>ThisObj</i> is used as
the <code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>filter</code> method returns a new <code>Vector</code> object with the
same base type as <code>this</code>, containing the elements that were
collected, in the order they were collected.  The length of the new
<code>Vector</code> is equal to the number of values that were collected.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function filter(checker: Checker, thisObj: Object=null): Vector.&#60;T> {
    var result = new Vector.&#60;T>;
    for ( let i=0, limit=length ; i &#60; limit ; i++ ) {
        let item = this[i];
        if (checker.call(thisObj, item, i, this))
            result[result.length] = item;
    }
    return result;
}
</PRE>

<h3>intrinsic::forEach&nbsp;(&nbsp;eacher,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>forEach</code> method calls <i>eacher</i> on every
vector element of <code>this</code> in increasing index order, discarding any
return value of <i>eacher</i>.

<P><span class="pcounter"></span> <i>Eacher</i> is called with three arguments: the vector element
value, the vector element index, and <code>this</code>.  <i>ThisObj</i> is used as
the <code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>forEach</code> method does not return a value.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function forEach(eacher: Eacher, thisObj: Object=null): void {
    for ( let i=0, limit=length ; i &#60; limit ; i++ )
        eacher.call(thisObj, this[i], i, this);
}
</PRE>

<h3>intrinsic::indexOf&nbsp;(&nbsp;value,&nbsp;from=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>indexOf</code> method compares <i>value</i> with every
vector element of <code>this</code> in increasing index order, starting at the
index <i>from</i>, stopping when a vector element is equal to <i>value</i>
by the <code>===</code> operator.

<P><span class="pcounter"></span> If <i>from</i> is negative, it is treated as
<code>this.length+<i>from</i></code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>indexOf</code> method returns the vector index the first
time <i>value</i> is equal to an element, or -1 if no such element is
found.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function indexOf(value: T, from: AnyNumber=0): AnyNumber {
    let start = <em>clamp</em>( from, length );
    for ( let i=start, limit=length ; i &#60; limit ; i++ ) {
        let item = this[i];
        if (item === value)
            return i;
    }
    return -1;
}
</PRE>

<P><span class="pcounter"></span> The helper function <code>clamp</code> performs clamping of <code>from</code> to the
length of this <code>Vector</code>.

<PRE>
helper function clamp(val: AnyNumber, len: double): double {
    val = <em>toInteger</em>(val);
    if (val &#60; 0)
        val += len;
    return intrinsic::toUint( Math.min( Math.max( val, 0 ), len ) );
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The helper function <code>toInteger</code>, used by <code>clamp</code>, is
described elsewhere; it performs the <code>ToInteger</code> operation of the
3rd Edition.

<h3>intrinsic::join&nbsp;(&nbsp;separator=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>join</code> method concatenates the string
representations of the vector elements of <code>this</code> in increasing index
order, separating the individual strings by occurrences of
<i>separator</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>join</code> method returns the concatenated string.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function join(separator: string=","): string {
    let limit = length;
    let s = "";
    let i = 0;

    for (let i = 0; i &#60; limit; i++) {
        let item = this[i];
        if (i != 0)
            s += separator;
        if (item is Object)
            s += string(x);
    }
    return s;
}
</PRE>

<h3>intrinsic::lastIndexOf&nbsp;(&nbsp;value,&nbsp;from=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>lastIndexOf</code> method compares <i>value</i> with every
vector element of <code>this</code> in decreasing numerical index order,
starting at the index <i>from</i>, stopping when a vector element is
equal to <i>value</i> by the <code>===</code> operator.

<P><span class="pcounter"></span> If <i>from</i> is negative, it is treated as
<code>this.length+<i>from</i></code>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>lastIndexOf</code> method returns the vector index the first
time <i>value</i> is equal to an element, or -1 if no such element is
found.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function lastIndexOf(value: T, from: AnyNumber=Infinity): AnyNumber {
    let start = <em>clamp</em>( from, length );
    for ( let i=start ; i >= 0 ; i-- ) {
        let item = this[i];
        if (item === value)
            return i;
    }
    return -1;
}
</PRE>

<h3>intrinsic::map&nbsp;(&nbsp;mapper,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>map</code> method calls <i>mapper</i> on each vector
element of <code>this</code> in increasing numerical index order, collecting
the return values from <i>mapper</i>.

<P><span class="pcounter"></span><i>Mapper</i> is called with three arguments: the vector element
value, the vector element index, and <code>this</code>.  <i>ThisObj</i> is used as
the <code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>map</code> method returns a new <code>Vector</code> object of the same
base type and length as this <code>Vector</code>.  The element at index <i>i</i>
in the new vector is the value collected from the call to <i>mapper</i>
on <code>this[</code><i>i</i><code>]</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function map(mapper:Mapper, thisObj:Object=null) {
    var result = new Vector.&#60;T>(length);
    for ( let i=0, limit=length ; i &#60; limit ; i++ ) {
        let item = this[i];
        result[i] = mapper.call(thisObj, item, i, this);
    }
    return result;
}
</PRE>

<h3>intrinsic::pop&nbsp;()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>pop</code> method extracts the last vector element
from <code>this</code> and removes it by decreasing the value of the <code>length</code>
property of <code>this</code> by 1.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>pop</code> method returns the removed element, or the
appropriate default value for the base type of <code>this</code> if there are
no elements.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function pop(): T {
    if (length == 0)
        return undefined;

    let v = this[length-1];
    length--;
    return v;
}
</PRE>

<h3>intrinsic::push&nbsp;(&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>push</code> method appends the values in <i>items</i>
to this <code>Vector</code>, in the order in which they appear in <i>items</i>.
The <code>length</code> property of this <code>Vector</code> will be incremented by the
length of <i>items</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>push</code> method returns the new value of the <code>length</code>
property of this <code>Vector</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function push(...items): double
    <em>push</em>(items);
</PRE>
<PRE>
helper function push(items) {
    for ( let i=0, limit=items.length ; i &#60; limit ; i++ )
        this[length] = items[i];
    return length;
}
</PRE>


<h3>intrinsic::reverse&nbsp;()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>reverse</code> method rearranges the vector elements of
<code>this</code> so as to reverse their order.  The <code>length</code> property of
<code>this</code> remains unchanged.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>reverse</code> method returns <code>this</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function reverse(): Vector.&#60;T> {
    for ( let i=0, j=length-1 ; i &#60; j ; i++, j-- )
        [this[i], this[j]] = [this[j], this[i]];
    return this;
}
</PRE>

<h3>intrinsic::shift&nbsp;()</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>shift</code> method removes the element called <code>0</code> in
<code>this</code>, moves the element at index <i>i+1</i> to index <i>i</i>, and
decrements the <code>length</code> property of <code>this</code> by 1.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>shift</code> method returns the element that was removed.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function shift(): T {
    if (length == 0)
        return undefined;
    let v = this[0];
    for ( let i=1, limit=length ; i &#60; limit ; i++ )
        this[i-1] = this[i];
    length--;
    return v;
}
</PRE>

<h3>intrinsic::slice&nbsp;(&nbsp;start=&#x0085;,&nbsp;end=&#x0085;,&nbsp;step=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>slice</code> method extracts the subrange of array
elements from <code>this</code> between <i>start</i> (inclusive) and <i>end</i>
(exclusive) into a new Array.  Each <i>step</i> element is taken.

<P><span class="pcounter"></span> The default value of <i>start</i> is 0.  If it is negative, it is
treated as <code><i>object</i>.length+<i>start</i></code>.

<P><span class="pcounter"></span> The default value of <i>end</i> is Infinity.  If it is negative, it
is treated as <code><i>object</i>.length+<i>end</i></code>.

<P><span class="pcounter"></span> The default value of <i>step</i> is 1.  If it is 0, it is set to 1.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>slice</code> method returns a new <code>Vector</code> object with the
same base type as <code>this</code>, containing the extracted vector elements.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function slice(start: AnyNumber=0, end: AnyNumber=Infinity, step: AnyNumber=1): Vector.&#60;T> {
    step = <em>toInteger</em>(step);
    if (step == 0)
        step = 1;

    start = <em>clamp</em>(start, length);
    end = <em>clamp</em>(end, length);

    let result = new Vector.&#60;T>;
    if (step > 0)
        for (let i=start; i &#60; end ; i += step)
            result[result.length] = this[i];
    else
        for (let i=start; i > end ; i += step)
            result[result.length] = this[i];

    return result;
}
</PRE>

<h3>intrinsic::some&nbsp;(&nbsp;checker,&nbsp;thisObj=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>some</code> method calls <i>checker</i> on every vector
element in <code>this</code> in increasing index order, stopping as soon as
<i>checker</i> returns a true value.

<P><span class="pcounter"></span><i>Checker</i> is called with three arguments: the vector element
value, the vector element index, and <code>this</code>.  <i>ThisObj</i> is used as
the <code>this</code> object in the call.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>some</code> method returns <b>true</b> when <i>checker</i> returns a
true value, otherwise returns <b>false</b> if all the calls to
<i>checker</i> return false values.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function some(checker: Checker, thisObj: Object=null): boolean {
    for ( let i=0, limit=length ; i &#60; limit ; i++ ) {
        let item = this[i];
        if (checker.call(thisObj, item, i, this))
            return true;
    }
    return false;
}
</PRE>

<h3>intrinsic::sort&nbsp;(&nbsp;comparefn&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic::<code>sort</code> method sorts the vector elements of
<code>this</code> according to the ordering defined by <code>comparefn</code>.

<P><span class="pcounter"></span> The sort is not necessarily stable (that is, elements that compare
equal do not necessarily remain in their original order).
<i>Comparefn</i> must be a consistent (see <span class="xref">sorting-logic</span>)
function that accepts two arguments <i>x</i> and <i>y</i> of the base type
of <code>this</code> and returns a negative value if <i>x < y</i>, zero if <i>x
= y</i>, or a positive value if <i>x > y</i>.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  Unlike the case for <code>Array</code>, the <i>comparefn</i> is a required argument.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #197.) Should we provide a default comparator?

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>sort</code> method returns <code>this</code>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span>
The <code>sort</code> method calls on the generic sorting engine, passing a
function to compare elements of <i>this</i>.

<PRE>
intrinsic function sort(comparefn: function(T, T): AnyNumber): Vector.&#60;T> {
    let object = this;
    return <em>sortEngine</em>(object,
                                   0,
                                   length-1,
                                   (function (j, k) comparefn(object[j], object[k])));
}
</PRE>

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  For a description of the informative <code>sortEngine</code> method, see
<span class="xref">sorting-logic</span>.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  The signature of <code>comparefn</code> is probably too constraining,
it will require the client to pass a strongly-typed function.

<h3>intrinsic::splice&nbsp;(&nbsp;start,&nbsp;deleteCount,&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>splice</code> method replaces the <i>deleteCount</i> vector
elements of <code>this</code> starting at index <i>start</i> with values
from the <i>items</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>splice</code> method returns a new <code>Vector</code> object of the
same base type as <code>this</code>, containing the vector elements that were
removed from <code>this</code>, in order.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function splice(start: AnyNumber, deleteCount: AnyNumber, ...items): Vector.&#60;T>
    <em>splice</em>(start, deleteCount, items);
</PRE>
<PRE>
helper function splice(start, deleteCount, items) {
    let out = new Vector.&#60;T>;
    let len = intrinsic::toUint(length);

    start = <em>clamp</em>( start, len );
    deleteCount = <em>clamp</em>( deleteCount, len - start );

    let end = start + deleteCount;

    for (let i = 0; i &#60; deleteCount; i++)
        out.push(this[i + start]);

    let insertCount = items.length;
    let shiftAmount = insertCount - deleteCount;

    if (shiftAmount &#60; 0) {
        shiftAmount = -shiftAmount;

        for (let i = end; i &#60; len; i++)
            this[i - shiftAmount] = this[i];
    }
    else {
        for (let i = len; i > end; ) {
            --i;
            this[i + shiftAmount] = this[i];
        }
    }

    for (let i = 0; i &#60; insertCount; i++)
        this[start+i] = items[i];

    length = len + shiftAmount;
    return out;
}
</PRE>

<h3>intrinsic::unshift&nbsp;(&nbsp;...items&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The instrinsic <code>unshift</code> method inserts the values in
<i>items</i> as new vector elements at the start of <code>this</code>, such that
their order within the vector elements of <code>this</code> is the same as the
order in which they appear in <i>items</i>.  Existing vector elements in
<code>this</code> are shifted upward in the index range, and the <code>length</code>
property of <code>this</code> is updated.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>unshift</code> method returns the new value of the
<code>length</code> property of <code>this</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function unshift(...items): double
    <em>unshift</em>(items);
</PRE>
<PRE>
helper function unshift(items) {
    let numitems = items.length;
    let oldlimit = length;
    let newlimit = oldlimit + numitems;

    length = newlimit;
    for ( let i=0 ; i &#60; length ; i++ )
        this[newlimit-i] = this[oldlimit-i];
    for ( let i=0 ; i &#60; numitems ; i++ )
        this[i] = items[i];
    return newlimit;
}
</PRE>


<h2>Iteration protocol on <code>Vector</code> instances</h2>

<P><span class="pcounter"></span> Iterators are defined on the <code>Vector</code> such that <code>for</code>-<code>in</code>
and <code>for each</code>-<code>in</code> loops always iterate across the vector from
low indices toward high indices.  Only indexed properties defined 
directly on the vector object are visited.

<P class="implsection"><b>Implementation</b>
<PRE>
iterator function get(deep: boolean = false) : iterator::Iterator.&#60;double>
    getKeys(deep);
</PRE>
<PRE>
iterator function getKeys(deep: boolean = false) : iterator::Iterator.&#60;double> {
    let i = 0;
    let a = this;
    return {
        const next:
            function () : double {
                if (i &#60; a.length)
                    return i++;
                throw iterator::StopIteration;
            }
    } : iterator::Iterator.&#60;double>;
}
</PRE>
<PRE>
iterator function getValues(deep: boolean = false) : iterator::Iterator.&#60;T> {
    let i = 0;
    let a = this;
    return {
        const next:
            function () : T {
                if (i &#60; a.length)
                    return a[i++];
                throw iterator::StopIteration;
        }
    } : iterator::Iterator.&#60;T>;
}
</PRE>
<PRE>
iterator function getItems(deep: boolean = false) : iterator::Iterator.&#60;[double,T]> {
    let i = 0;
    let a = this;
    return {
        const next:
        function () : T {
            if (i === a.length)
                return [i,a[i++]];
            throw iterator::StopIteration;
        }
    } : iterator::Iterator.&#60;[double,T]>;
}
</PRE>


<h2>Value properties of <code>Vector</code> instances</h2>

<h3>length</h3>

<P><span class="pcounter"></span> The property <code>length</code> determines the range of valid indices into
the <code>Vector</code>.  Indices up to but not including <code>length</code> are always
defined.

<P><span class="pcounter"></span> When <code>length</code> is given a new value that is smaller than its old
value then the elements in the vector at the new length and beyond are
removed from the vector.

<P><span class="pcounter"></span> When <code>length</code> is given a new value that is greater than its old
value then the elements in the vector at the old length and beyond are
given a default value that is appropriate to the base type <code>T</code>.

<P><span class="pcounter"></span> If an attempt is made to set <code>length</code> when the <code>fixed</code> property
is <b>true</b> then a <b>RangeError</b> is thrown.

<P><span class="pcounter"></span> If an attempt is made to set <code>length</code> to any value that is not a
nonnegative integer less than 2<SUP>32</SUP> then a <b>RangeError</b> is
thrown.


<h3>fixed</h3>

<P><span class="pcounter"></span> The boolean property <code>fixed</code> determines whether the <code>Vector</code>
has fixed length.

<P><span class="pcounter"></span> If <code>fixed</code> has the value <b>true</b> then any attempt to change
<code>length</code> will result in in a <b>RangeError</b> being thrown.

<P><span class="pcounter"></span> The value of <code>fixed</code> is not constant, so vectors can be of fixed
length and variable length at different times.


<h3>Numerically named properties</h3>

<P><span class="pcounter"></span> A <code>Vector</code> contains all properties whose names are nonnegative
integers below the value of the <code>Vector</code>'s <code>length</code> property.

<P><span class="pcounter"></span> If an attempt is made to read a property whose name is a number that
is not a nonnegative integer below <code>length</code> then a <b>RangeError</b> is thrown.

<P><span class="pcounter"></span> If an attempt is made to write a property whose name is a number that is not
a nonnegative integer below <code>length</code> then one of two things happen:
<UL>
  <LI> If the <code>fixed</code> property has the value <code>true</code>, or if the
  number is not a nonnegative integer, or if the number is nonnegative but
  not the same value as the value of <code>length</code>, or if <code>length</code> is 
  already 2<SUP>32</SUP>-1, then a <b>RangeError</b> is thrown.

  <LI> Otherwise, the property is defined on the vector and 
  the <code>length</code> property is incremented by 1.
</UL>

<h2>Methods on the <code>Vector</code> prototype object</h2>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The methods on the <code>Vector</code> prototype object perform a small
amount of type conversion and delegate to the corresponding intrinsic
methods.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The methods on the <code>Vector</code> prototype object return what their
corresponding intrinsic methods return.

<P class="implsection"><b>Implementation</b>
<PRE>
prototype function toString(this:Vector.&#60;*>)
    this.intrinsic::toString();
</PRE>
<PRE>
prototype function toLocaleString(this:Vector.&#60;*>)
    this.intrinsic::toLocaleString();
</PRE>
<PRE>
prototype function concat(this:Vector.&#60;*>, ...items)
    this.<em>concat</em>(items);
</PRE>
<PRE>
prototype function every(this:Vector.&#60;*>, checker, thisObj=undefined)
    this.intrinsic::every(checker, thisObj is Object ? thisObj : null);
</PRE>
<PRE>
prototype function filter(this:Vector.&#60;*>, checker, thisObj=undefined)
    this.intrinsic::filter(checker, thisObj is Object ? thisObj : null);
</PRE>
<PRE>
prototype function forEach(this:Vector.&#60;*>, eacher, thisObj=undefined)
    this.intrinsic::forEach(checker, thisObj is Object ? thisObj : null);
</PRE>
<PRE>
prototype function indexOf(this:Vector.&#60;*>, value, from=undefined)
    this.intrinsic::indexOf(value, Number(from));
</PRE>
<PRE>
prototype function join(this:Vector.&#60;*>, separator=undefined)
    this.intrinsic::join(separator == undefined ? "," : string(separator));
</PRE>
<PRE>
prototype function lastIndexOf(this:Vector.&#60;*>, value, from=undefined)
    this.intrinsic::indexOf(value, from == undefined ? Infinity : Number(from));
</PRE>
<PRE>
prototype function map(this:Vector.&#60;*>, mapper, thisObj=undefined)
    this.intrinsic::map(mapper, thisObj is Object ? thisObj : null);
</PRE>
<PRE>
prototype function pop(this:Vector.&#60;*>)
    this.intrinsic::pop();
</PRE>
<PRE>
prototype function push(this:Vector.&#60;*>, ...items)
    this.<em>push</em>(items);
</PRE>
<PRE>
prototype function reverse(this:Vector.&#60;*>)
    this.intrinsic::reverse();
</PRE>
<PRE>
prototype function shift(this:Vector.&#60;*>)
    this.intrinsic::shift();
</PRE>
<PRE>
prototype function slice(this:Vector.&#60;*>, start, end, step)
    this.intrinsic::slice(Number(start), Number(end), Number(step));
</PRE>
<PRE>
prototype function some(this:Vector.&#60;*>, checker, thisObj=undefined)
    this.intrinsic::some(checker, thisObj is Object ? thisObj : null);
</PRE>
<PRE>
prototype function sort(this:Vector.&#60;*>, comparefn)
    this.intrinsic::sort(comparefn);
</PRE>
<PRE>
prototype function splice(this:Vector.&#60;*>, start, deleteCount, ...items)
    this.<em>splice</em>(Number(start), Number(deleteCount), items);
</PRE>
<PRE>
prototype function unshift(this:Vector.&#60;*>, ...items)
    this.<em>unshift</em>(items);
</PRE>





<H1 id="class Map"> The class <code>Map</code> </H1>



<P><span class="pcounter"></span> The class <code>Map</code> is a parameterized, dynamic, non-final, direct
subclass of <code>Object</code> that provides a reliable, efficient, mutable,
and iterable map from keys to values.  Keys and values may be of
arbitrary types.

<p class="note"><b>COMPATIBILITY NOTE</b>&nbsp;&nbsp;  The class <code>Map</code> is new in the 4th Edition of this Standard.

<P><span class="pcounter"></span> A <code>Map</code> is realized as a hash table.  When the <code>Map</code> is
constructed the caller may provide specialized functions that compare
keys and compute hash values for keys.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Map</code> provides the following interface:

<PRE>
__ES4__ dynamic class Map.&#60;K,V> extends Object
{
    function Map(equals:   Callable = (function(a,b) a === b),
                 hashcode: Callable = intrinsic::hashcode) &#x0085;

    static const length = 2;

    intrinsic function size() : double &#x0085
    intrinsic function get(key: K, notfound: (V|undefined)=undefined) : (V|undefined) &#x0085
    intrinsic function put(key: K, value: V, notfound: (V|undefined)=undefined) : (V|undefined) &#x0085
    intrinsic function has(key:K) : boolean &#x0085
    intrinsic function remove(key:K) : boolean &#x0085
    intrinsic function clear() : void &#x0085

    iterator function get(deep: boolean = false) : iterator::Iterator.&#60;K> &#x0085
    iterator function getKeys(deep: boolean = false) : iterator::Iterator.&#60;K> &#x0085
    iterator function getValues(deep: boolean = false) : iterator::Iterator.&#60;V> &#x0085
    iterator function getItems(deep: boolean = false) : iterator::Iterator.&#60;[K,V]> &#x0085

    private const equals   : Callable = &#x0085;
    private const hashcode : Callable = &#x0085;
    private var population : uint = &#x0085;
}
</PRE>

<P><span class="pcounter"></span> The <code>Map</code> prototype object provides these direct properties:

<PRE>
    size:   function () &#x0085;
    get:    function (key, notfound) &#x0085;
    put:    function (key, value, notfound) &#x0085;
    has:    function (key) &#x0085;
    remove: function (key) &#x0085;
    clear:  function () &#x0085;
</PRE>


<h2>Methods on the <code>Map</code> class object</h2>

<h3>new&nbsp;Map.&lt;K,V&gt;(&nbsp;equals=&#x0085;,&nbsp;hashcode=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>Map</code> constructor creates a new map for key type <i>K</i>
and value type <i>V</i>.

<P><span class="pcounter"></span> The optional <i>equals</i> argument is a function that compares two
keys and returns <b>true</b> if they are equal and <b>false</b> if they are
not.  This function must implement a reflexive, transitive, and
symmetric relation, and <i>equals(k1,k2)</i> must be constant for any two
actual keys <i>k1</i> and <i>k2</i>.  The default value for <i>equals</i> is a
function that compares the two keys using the <code>===</code> operator.

<P><span class="pcounter"></span> The optional <i>hashcode</i> argument is a function that takes a key
and returns a numeric value for it; this key is converted to a <code>uint</code>
<i>hash value</i> for the key.  The hash value may be used to find
associations more quickly in the map.  Two calls to <i>hashcode</i> on
the same key value must always result in the same hash value, and a
call to <i>hashcode</i> must always result in the same hash value for two
key values that compare equal by the <i>equals</i> function.  The default
value for <i>hashcode</i> is the intrinsic global function <code>hashcode</code>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The constraint that <i>equals</i> and <i>hashcode</i> return
constant values does not apply to key values that are not in a <code>Map</code>
nor referenced from an activation of any method on <code>Map</code>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  There is no requirement that the values returned from
<i>hashcode</i> for two unequal keys must be different.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The operator <code>==</code> is not a valid comparator for the global
intrinsic function <code>hashcode</code> because <code>==</code> will consider some
values to be equal for which <code>hashcode</code> returns different hash
values.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The <code>Map</code> constructor initializes the <code>Map</code> object by
saving its parameters in private storage and initializing the count of
the number of associations in the table to zero.

<PRE>
function Map(equals   : Callable = (function (x,y) x === y),
ashcode : Callable = intrinsic::hashcode)
quals = equals
ashcode = function (k) intrinsic::toUint(hashcode(k) cast AnyNumber)
opulation = 0
    {
    }
</PRE>




<h2>Methods on <code>Map</code> instances</h2>

<h3>intrinsic::size&nbsp;(&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic method <code>size</code> returns the number of associations in the map.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function size() : double
ulation;
</PRE>

<h3>intrinsic::get&nbsp;(&nbsp;key,&nbsp;notfound=&#x0085;&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic method <code>get</code> returns the value associated with
<i>key</i>, or <i>notfound</i> if there is no such association.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function get(key: K, notfound: (V|undefined)=undefined) : (V|undefined) {
 probe = <em>find</em>(key);
urn probe ? probe.value : notfound;
}
</PRE>

<P><span class="pcounter"></span> The informative function <code>find</code> searches for <i>key</i> in the
<code>Map</code> and returns an object containing at least the properties
<code>key</code> and <code>value</code> if the association was found, or otherwise
<b>null</b>.  (The returned object is part of the <code>Map</code> data structure,
and writing to it updates the association in the <code>Map</code>.)

<PRE>
informative function find(key: K): like { key: K, value: V } &#x0085;
</PRE>

<h3>intrinsic::put&nbsp;(&nbsp;key,&nbsp;value,&nbsp;notfound=&#x0085;&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic method <code>put</code> creates an association between
<i>key</i> and <i>value</i>, or overwrites an existing association if there
is one.  

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>put</code> method returns the old value of the association if
there was one, otherwise it returns <i>notfound</i>.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function put(key: K, value: V, notfound: (V|undefined)=undefined) : (V|undefined) {
 oldvalue = notfound;
 probe = <em>find</em>(key);
(probe) {
 oldvalue = probe.value;
 probe.value = value;

e {
 ++population;
 <em>insert</em>(key, value);

urn oldvalue;
}
</PRE>

<P><span class="pcounter"></span> The informative function <code>insert</code> adds a new association between
<i>key</i> and <i>value</i> to the <code>Map</code>.

<PRE>
informative function insert(key: K, value: V): void &#x0085;
</PRE>

<h3>intrinsic::has&nbsp;(&nbsp;key&nbsp;)</h3>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The intrinsic method <code>has</code> returns <b>true</b> if there exists
an association for <i>key</i>, or <b>false</b> otherwise.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function has(key:K) : boolean {
 probe = <em>find</em>(key);
urn probe ? true : false;
}
</PRE>

<h3>intrinsic::remove&nbsp;(&nbsp;key&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic method <code>remove</code> removes any association for <i>key</i>.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>remove</code> method returns <b>true</b> if there was an association for <i>key</i>,
or <b>false</b> otherwise.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function remove(key:K) : boolean {
 probe = <em>find</em>(key);
(probe) {
 --population;
 <em>eject</em>(probe);
 return true;

urn false;
}
</PRE>

<P><span class="pcounter"></span> The informative function <code>eject</code> removes the association for
<i>key</i> from the <code>Map</code>.

<PRE>
informative function eject(box: like { key: K, value: V }): void &#x0085;
</PRE>

<h3>intrinsic::clear&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic method <code>clear</code> removes all associations from the map.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>clear</code> method returns nothing.

<P class="implsection"><b>Implementation</b>
<PRE>
intrinsic function clear() : void {
 (let k in this)
 intrinsic::remove(k);
}
</PRE>

<h2>Iteration protocol on <code>Map</code> instances</h2>

<P><span class="pcounter"></span> The iterator protocol makes use of a helper method <code>iterate</code>
which first collects the values that will be returned by the iterator
methods and then returns an object that provides the correct <code>next</code>
method:

<PRE>
helper function iterate.&#60;T>(f) {
 a = [];
ormative::allItems(function (k,v) { f(a,k,v) });
urn {
 const next:
t (i=0, limit=a.length)
  function () : T {
      if (i &#60; limit)
   return a[i++];
hrow iterator::StopIteration;
         }
 iterator::Iterator.&#60;T>;
}
</PRE>

<P><span class="pcounter"></span> The informative function <code>allItems</code> calls its function
argument on every key/value pair in the <code>Map</code>:

<PRE>
informative function allItems(fn: function): void &#x0085;
</PRE>

<P><span class="pcounter"></span> The iterator methods <code>getKeys</code>, <code>getValues</code>, and <code>getItems</code>
return iterator objects that iterate over keys, values, and key/value
pairs, respectively.  The iterator method <code>get</code> iterates over keys
(like <code>getKeys</code>).

<P class="implsection"><b>Implementation</b>
<PRE>
iterator function getKeys(deep: boolean = false) : iterator::Iterator.&#60;K>
per::iterate.&#60;K>(function (a,k,v) { a.push(k) });
</PRE>
<PRE>
iterator function getValues(deep: boolean = false) : iterator::Iterator.&#60;V>
per::iterate.&#60;V>(function (a,k,v) { a.push(v) });
</PRE>
<PRE>
iterator function getItems(deep: boolean = false) : iterator::Iterator.&#60;[K,V]>
per::iterate.&#60;[K,V]>(function (a,k,v) { a.push([k,v]) });
</PRE>
<PRE>
iterator function get(deep: boolean = false) : iterator::Iterator.&#60;K>
rator::getKeys(deep);
</PRE>

<h2>Methods on the <code>Map</code> prototype object</h2>

<P><span class="pcounter"></span> The methods on the <code>Map</code> prototype object are constrained to
being called on instances of <code>Map</code>.  They all delegate to the
corresponding intrinsic method on their <code>this</code> object.

<PRE>
prototype function size(this: Map.&#60;*,*>)
s.intrinsic::size();
</PRE>
<PRE>
prototype function get(this: Map.&#60;*,*>, key, notfound)
s.intrinsic::get(key, notfound);
</PRE>
<PRE>
prototype function put(this: Map.&#60;*,*>, key, value, notfound)
s.intrinsic::put(key, value, notfound);
</PRE>
<PRE>
prototype function has(this: Map.&#60;*,*>, key)
s.intrinsic::has(key);
</PRE>
<PRE>
prototype function remove(this: Map.&#60;*,*>, key)
s.intrinsic::remove(key);
</PRE>
<PRE>
prototype function clear(this: Map.&#60;*,*>)
s.intrinsic::clear();
</PRE>



<h1 id="meta-objects"> The meta-object classes </h1>



<P><span class="pcounter"></span> The intrinsic meta-object interfaces <code>Type</code>, <code>NominalType</code>,
<code>ClassType</code>, <code>InterfaceType</code>, <code>AnyType</code>, <code>UndefinedType</code>,
<code>NullType</code>, <code>UnionType</code>, <code>RecordType</code>, <code>ArrayType</code>,
<code>FunctionType</code>, <code>Field</code>, and <code>FieldValue</code>, along with the
intrinsic helper types <code>FieldIterator</code>, <code>NominalTypeIterator</code>,
<code>TypeIterator</code>, <code>ValueIterator</code>, and <code>FieldValueIterator</code>,
provide a simple reflection capability.

<P><span class="pcounter"></span> The standard meta-objects described by the interface types may be
immutable.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #199.) Right now the class <code>Class</code> is not defined in
ES4.  (Nor is there an <code>Interface</code>, nor are there described classes
for other type objects.)  If these are defined, then we must decide
whether they implement the meta-object interfaces or not.  Otherwise
we have problems of nonportability due to name shadowing in some
systems but not in others, or subclassability in some systems but not
in others.

<P><span class="pcounter"></span> ECMAScript implementations may choose to provide extensions to
these interfaces, in order to provide richer reflective capabilities.
Clients wishing to use extended meta-object interfaces can perform
runtime downcasts on the meta-objects described by this Standard.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #200.)  The meta-objects system does not currently deal with
parameterized types.  It will almost certainly need to.  First,
classes can contain type definitions and those definitions can be
public, and it would be strange if they could not be iterated by the
<code>publicMembers</code> and <code>publicStaticMembes</code> methods of
<code>NominalType</code>.  But type definitions can bind type parameters, so
there would need to be a representation of that.  Second, method
definitions can bind type parameters (this facility is used in eg the
<code>Map</code> class for internal helper methods), so even if type
definitions were not iterated we'd have to deal with the problem for
methods.

<P class="fixme"> There is also the question of what the meaning of
<code>typeOf(Map)</code> means, when <code>Map</code> is a paremeterized type.
Presumably that too needs to reveal parameterization in some way.

<P class="fixme"> The original meta-objects proposal had some
facilities for parameterization in the context of instantiation: the
<code>construct</code> methods would take a type iterator that would provide
values for type parameters.  But that's not good enough, and the
following spec does not provide for these.  Something like that will
come back in, though.

<P class="fixme"> There will probably be a new interface
<code>ParemeterizedType</code> that acts as a binder for type parameters:

<PRE class="fixme">
interface ParameterizedType
{
    function numberOfParameters()
    function construct(typeVals: TypeIterator): Type
}
</PRE>

<P class="fixme"> We must decide whether only instantiated types can
be manipulated or not.  If so, then we could then arrange for a "dummy
type" factory to allow easy instantiation for inspection purposes:

<PRE class="fixme">
intrinsic function dummyTypes(t: Type): TypeIterator
</PRE>

<P class="fixme"> That may or may not run afoul of type checking, if
any type checking happens at instantiation time.  The alternative
would be to provide an interface for <code>TypeParameter</code>, and for
<code>ParameterizedType</code> to allow inspection of its contained type
without instantiation, with the proviso that <code>TypeParameter</code> values
will pop up during inspection and will have to be handled.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  In the following sections all interfaces, types, and methods
are implicitly defined in the <code>intrinsic</code> namespace.  The methods
defined on the interfaces are not defined on the prototypes of the
classes that implement those interfaces.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  Type annotations that denote nullable types are revealed as a
union of <code>NullType</code> and another type.

<h2>Retrieving the type of an object</h2>

<h3>typeOf&nbsp;(&nbsp;v&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The global intrinsic function <code>typeOf</code> delivers the run-time
type of its argument <i>v</i>, which may be a value of any type.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The function <code>typeOf</code> returns an object that implements
<code>Type</code> and possibly one of the interfaces extending <code>Type</code>.

<P class="implsection"><b>Implementation</b> <P><span class="pcounter"></span> The function <code>typeOf</code> is implementation-dependent.


<h2>The interface <code>Type</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>Type</code> describes a type in the system in
basic terms.

<h3>Synopsis</h3>

<PRE>
interface Type 
{
    function canConvertTo(t: Type): boolean
    function isSubtypeOf(t: Type): boolean
}
</PRE>

<h3>Methods</h3>

<h4>canConvertTo&nbsp;(&nbsp;t&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>canConvertTo</code> method returns <b>true</b> if this type can
be converted to the type <i>t</i>, otherwise it returns <b>false</b>.

<h4>isSubtypeOf&nbsp;(&nbsp;t&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>isSubtypeOf</code> method returns <b>true</b> if this type is a
subtype of the type <i>t</i>, otherwise it returns <b>false</b>.


<h2>The interface <code>Field</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>Field</code> describes a field (property) of
a class, record, or array type by the field name and field type.

<h3>Synopsis</h3>

<PRE>
interface Field
{
    function name(): Name
    function type(): Type
}
</PRE>

<h3>Methods</h3>

<h4>name&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>name</code> method returns the field name as a <code>Name</code> object.

<h4>type&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>type</code> method returns the field type as an object that
implements <code>Type</code> or one of the interfaces extending <code>Type</code>.


<h2>The interface <code>FieldValue</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>FieldValue</code> describes a field
(property) of a record or array by the field name and field value.  It
is used for constructing new record and array instances.

<h3>Synopsis</h3>

<PRE>
interface FieldValue
{
    function name(): Name
    function value(): *
}
</PRE>


<h3>Methods</h3>

<h4>name&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>name</code> method returns the field name as a <code>Name</code>
object.

<h4>value&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>value</code> method returns the actual field value as an
ECMAScript value.


<h2>The interface <code>NominalType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>NominalType</code> is a base interface for
<code>InterfaceType</code> and <code>ClassType</code>.  It provides accessors for
aspects common to those two types.

<h3>Synopsis</h3>

<PRE>
interface NominalType extends Type
{
    function name(): Name
    function superTypes(): NominalTypeIterator
    function publicMembers(): FieldIterator
    function publicStaticMembers(): FieldIterator
}
</PRE>

<h3>Methods</h3>

<h4>name&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>name</code> method returns the name of the nominal type as a
<code>Name</code> object.

<h4>superTypes&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>superTypes</code> method returns an iterator that iterates
over the superclasses and implemented interfaces of this nominal type.

<h4>publicMembers&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>publicMembers</code> method returns an iterator that iterates
over the field definitions of all public instance fields (both method
properties and value properties).

<h4>publicStaticMembers&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>publicMembers</code> method returns an iterator that iterates
over the field definitions of all public class fields (both method
properties and value properties).

<P><span class="pcounter"></span> The constructor method is included in the set of static members,
provided that it is public.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  (Ticket #200.) Likely, this will also iterate type definitions (see comment
at the start of this chapter).


<h2>The interface <code>InterfaceType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>InterfaceType</code> describes an interface.

<h3>Synopsis</h3>

<PRE>
interface InterfaceType extends NominalType
{
    function implementedBy(): ClassTypeIterator
}
</PRE>

<h3>Methods</h3>

<h4>implementedBy&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>implementedBy</code> method returns an interator that iterates
over all the class types that implement this interface.


<h2>The interface <code>ClassType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>ClassType</code> describes a class and
provides a means of creating new instances of the class.

<h3>Synopsis</h3>

<PRE>
interface ClassType extends NominalType
{
    function construct(valArgs: ValueIterator): Object
}
</PRE>

<h3>Methods</h3>

<h4>construct&nbsp;(&nbsp;valArgs&nbsp;)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>construct</code> method creates a new instance of the class
represented by this <code>ClassType</code>, provided the class's constructor is
public.

<P><span class="pcounter"></span> The iterator <i>valArgs</i> provides any value arguments required by
the constructor.  Only as many values as necessary for calling the
constructor will be consumed from the iterator.  If the constructor
takes no arguments then <i>valArgs</i> may be null.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>construct</code> method returns a new object of the type
represented by this <code>ClassType</code>.

<h2>The interface <code>AnyType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>AnyType</code> describes the type <code>*</code>.

<h3>Synopsis</h3>

<PRE>
interface AnyType extends Type
{
}
</PRE>

<h2>The interface <code>NullType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>NullType</code> describes the type <code>null</code>.

<h3>Synopsis</h3>

<PRE>
interface NullType extends Type
{
}
</PRE>


<h2>The interface <code>UndefinedType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>UndefinedType</code> describes the type <code>undefined</code>.

<h3>Synopsis</h3>

<PRE>
interface UndefinedType extends Type
{
}
</PRE>

<h2>The interface <code>UnionType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>UnionType</code> describes a union of other
types.  No object has a union type for its manifest type.  Union types
are only used for annotating parameters or fields, and cannot be instantiated.

<h3>Synopsis</h3>

<PRE>
interface UnionType extends Type
{
    function members(): TypeIterator
}
</PRE>

<h3>Methods</h3>

<h4>members&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>members</code> method returns an iterator that iterates over the
member types of the union.


<h2>The interface <code>RecordType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>RecordType</code> describes a structural
object type.

<h3>Synopsis</h3>

<PRE>
interface RecordType extends Type
{
    function fields(): FieldIterator
    function construct(valArgs: FieldValueIterator): Object
}
</PRE>

<h3>Methods</h3>

<h4>fields&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>fields</code> method returns an iterator that iterates over
the fields of the record type.

<h4>construct&nbsp;(&nbsp;valArgs&nbsp;)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>construct</code> method creates a new instance of the
structural object type represented by this <code>RecordType</code>.

<P><span class="pcounter"></span> The iterator <i>valArgs</i> provides any field names and values
required to initialize the object.  All values will be consumed from
the iterator; the iterator may provide more field names and values
than are required by the type.  If the iterator does not provide a
value for a field required by the type, the field will be initialized
to <b>undefined</b> cast to the type of the field; this may cause a
<b>TypeError</b> exception to be thrown at run-time.

<P><span class="pcounter"></span> <i>ValArgs</i> may not be null.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>construct</code> method returns a new object of the type
represented by this <code>RecordType</code>.

<h2>The interface <code>ArrayType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>ArrayType</code> describes a structural array
type.

<h3>Synopsis</h3>

<PRE>
interface ArrayType extends Type
{
    function fields(): FieldIterator
    function construct(length: uint, valArgs: FieldValueIterator): Object
}
</PRE>

<h3>Methods</h3>

<h4>fields&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>fields</code> method returns an iterator that iterates over
the fields of the array type.  The fields are iterated from low to
high indices, and only fields that are present are iterated.  The name
of the field provides the field index as the <code>identifier</code>.

<h4>construct&nbsp;(&nbsp;length,&nbsp;valArgs&nbsp;)</h4>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The <code>construct</code> method creates a new instance of the
structural array type represented by this <code>ArrayType</code>.

<P><span class="pcounter"></span> The value <i>length</i> provides the value for the length of the
array; it is set after all fields have been initialized.

<P><span class="pcounter"></span> The iterator <i>valArgs</i> provides any field names and values
required to initialize the object.  All values will be consumed from
the iterator; the iterator may provide more field names and values
than are required by the type.  The field name must encode the correct
array index of the field in the <code>identifier</code>.  If the iterator does
not provide a value for a field required by the type, the field will
be initialized to <b>undefined</b> cast to the type of the field; this
may cause a <b>TypeError</b> exception to be thrown at run-time.

<P><span class="pcounter"></span> <i>ValArgs</i> may not be null.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>construct</code> method returns a new object of the type
represented by this <code>ArrayType</code>.

<h2>The interface <code>FunctionType</code></h2>

<P><span class="pcounter"></span> The intrinsic interface <code>FunctionType</code> describes a structural
function type.  Function types cannot be instantiated.

<h3>Synopsis</h3>

<PRE>
interface FunctionType extends Type
{
    function boundThis(): Type
    function parameterTypes(): TypeIterator
    function defaultValues(): ValueIterator
    function hasRestType(): boolean
    function returnType(): Type
}
</PRE>

<h3>Methods</h3>

<h4>boundThis&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>boundThis</code> method returns a type if the function has a
bound <code>this</code> value, otherwise it returns an <code>AnyType</code> object.

<h4>parameterTypes&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>parameterTypes</code> method returns an iterator that iterates over
the types of the formal parameters of the function, starting with the
first argument and iterating in order, including all optional and rest
arguments.

<P><span class="pcounter"></span> Arguments that do not have annotations will be revealed as type
<code>AnyType</code>.

<h4>defaultValues&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>defaultValues</code> method returns an iterator that iterates
over the default values of the optional arguments, starting with the
first default value and iterating in order.

<h4>hasRestTypes()</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>hasRestTypes</code> method returns <b>true</b> if the function
has a rest argument, <b>false</b> otherwise.

<h4>returnType&nbsp;(&nbsp;)</h4>

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>returnType</code> method returns the return type annotation
for this function, or an <code>AnyType</code> object if there was no type
annotation.


<h2>Iterator types</h2>

<P><span class="pcounter"></span> The following iterator type definitions are used as annotations on
parameters and methods in the interface hierarchy described
previously.

<PRE>
type FieldIterator = iterator::IteratorType.&#60;Field>
type ClassTypeIterator = iterator::IteratorType.&#60;ClassType>
type NominalTypeIterator = iterator::IteratorType.&#60;NominalType>
type TypeIterator = iterator::IteratorType.&#60;Type>
type FieldValueIterator = iterator::IteratorType.&#60;FieldValue>
type ValueIterator = iterator::IteratorType.&#60;*>
</PRE>





<h1>Error classes</h1>



<P><span class="pcounter"></span> ECMAScript provides a hierarchy of standard pre-defined error classes
rooted at the class <code>Error</code> (see <span class="xref">class Error</span>).

<P><span class="pcounter"></span> The ECMAScript implementation throws a new instance of one of
the pre-defined error classes when it detects certain run-time errors.  The
conditions under which run-time errors are detected are explained
throughout this Standard.  The description of each of the pre-defined error
classes contains a summary of the conditions under which an instance
of that particular error class is thrown.

<P><span class="pcounter"></span> The class <code>Error</code> serves as the base class for all the classes
describing standard errors thrown by the ECMAScript implementation:
<code>EvalError</code>, <code>RangeError</code>, <code>ReferenceError</code>, <code>SyntaxError</code>,
<code>TypeError</code>, and <code>URIError</code>.
(See <span class="xref">class EvalError</span>, <span class="xref">class RangeError</span>,
<span class="xref">class ReferenceError</span>, <span class="xref">class SyntaxError</span>,
<span class="xref">class TypeError</span>, <span class="xref">class URIError</span>.)

<P><span class="pcounter"></span> The class <code>Error</code> as well as all its pre-defined subclasses are
non-final and dynamic and may be subclassed by user-defined exception
classes.

<P><span class="pcounter"></span> All the pre-defined subclasses of <code>Error</code> share the same structure.


<H1 id="class Error"> The class <code>Error</code> </h1>

<P><span class="pcounter"></span> The class <code>Error</code> is a dynamic, non-final subclass of <code>Object</code>.
Instances of <code>Error</code> are not thrown by the implementation; rather,
<code>Error</code> is intended to serve as a base class for other error classes
whose instances represent specific classes of run-time errors.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The class <code>Error</code> provides the following interface:

<PRE>
dynamic class Error extends Object 
{
    public function Error(message) &#x0085
    static meta function invoke(message) &#x0085
    
    static public const length = 1
    
    override intrinsic function toString() &#x0085
    override helper function getClassName() &#x0085
}
</PRE>

<P><span class="pcounter"></span> The <code>Error</code> prototype object provides these direct properties:

<PRE>
    toString: function () &#x0085;
    name:     "Error"
    message:  &#x0085;
</PRE>

<h2>Methods on the <code>Error</code> class</h2>

<h3>new&nbsp;Error&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Error</code> constructor is called as part of a
<code>new&nbsp;Error</code> expression it initialises the newly created object:
If <i>message</i> is not <b>undefined</b>, the dynamic <code>message</code> property
of the newly constructed <code>Error</code> object is set to <code>string(<i>message</i>)</code>.

<P class="implsection"><b>Implementation</b>
<PRE>
public function Error(message) {
    if (message !== undefined)
        this.message = string(message);
}
</PRE>

<h3>Error&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>Error</code> class object is called as a function, it
creates and initialises a new <code>Error</code> object by invoking the
<code>Error</code> constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>Error</code> class object called as a function returns a new
<code>Error</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(message)
    new Error(message);
</PRE>


<h2>Methods on <code>Error</code> instances</h2>

<h3>intrinsic::toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The intrinsic <code>toString</code> method converts the <code>Error</code> object
to an implementation-defined string.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> A <code>string</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
override intrinsic function toString()
    private::toString();
</PRE>

<P><span class="pcounter"></span> The private function <code>toString</code> is implementation-defined.

<h3>helper::getClassName&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The helper method <code>getClassName</code> overrides the method defined
in <code>Object</code> and makes the pre-defined subclasses of <code>Error</code> appear
to have the <code>[[Class]]</code> value <code>"Error"</code>.

<p class="note"><b>NOTE</b>&nbsp;&nbsp;  The helper method <code>getClassName</code> is a specification artifact.
The protocol it defines for overriding <code>[[Class]]</code> is not available to
user code.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The helper method <code>getClassName</code> returns a string.

<P class="implsection"><b>Implementation</b>
<PRE>
override helper function getClassName() {
    if (<em>isExactlyType</em>(this, EvalError) ||
        <em>isExactlyType</em>(this, RangeError) ||
        <em>isExactlyType</em>(this, ReferenceError) ||
        <em>isExactlyType</em>(this, SyntaxError) ||
        <em>isExactlyType</em>(this, TypeError) ||
        <em>isExactlyType</em>(this, URIError))
        return "Error";
    return super.<em>getClassName</em>();
}
</PRE>
<PRE>
helper function isExactlyType(obj, cls)
    let (objtype = reflect::typeOf(obj))
        cls.reflect::isSubtypeOf(objtype) && objtype.reflect::isSubtypeOf(cls);
</PRE>


<h2>Methods on the <code>Error</code> prototype object</h2>

<h3>toString&nbsp;(&nbsp;)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> The prototype <code>toString</code> method calls the private <code>toString</code> method.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The prototype <code>toString</code> method returns a <code>string</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
public prototype function toString()
    this.private::toString();
</PRE>

<h2>Value properties on the <code>Error</code> prototype object</h2>

<h3>name</h3>

<P><span class="pcounter"></span> The initial value of the <code>name</code> prototype property is the string
"<code>Error</code>".

<h3>message</h3>

<P><span class="pcounter"></span> The initial value of the <code>message</code> prototype property is an
implementation-defined string.




<H1 id="class EvalError"> The class <code>EvalError</code> </H1>

<P><span class="pcounter"></span> The implementation throws a new <code>EvalError</code> instance when it
detects that the global function <code>eval</code> was used in a way that is
incompatible with its definition.  See sections XXX.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Clean up the section references when we reach final draft.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The <code>EvalError</code> class provides this interface:

<PRE>
dynamic class EvalError extends Error
{
    public function EvalError(message) &#x0085
    static meta function invoke(message) &#x0085
    
    static public const length = 1
}
</PRE>

<P><span class="pcounter"></span> The <code>EvalError</code> prototype object provides these direct properties:
<PRE>
    name:    "EvalError"
    message: &#x0085;
</PRE>

<h2>Methods on the <code>EvalError</code> class</h2>

<h3>new&nbsp;EvalError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>EvalError</code> constructor is called as part of a
<code>new&nbsp;EvalError</code> expression it initialises the newly created
object by delegating to the <code>Error</code> constructor.

<P class="implsection"><b>Implementation</b>
<PRE>
public function EvalError(message)
    : super(message)
{
}
</PRE>


<h3>EvalError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>EvalError</code> class object is called as a function, it
creates and initialises a new <code>EvalError</code> object by invoking the
<code>EvalError</code> constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>EvalError</code> class object called as a function returns a
new <code>EvalError</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(message)
    new EvalError(message);
</PRE>


<h2>Value properties on the <code>EvalError</code> prototype object</h2>

<h3>name</h3>

<P><span class="pcounter"></span> The initial value of the <code>name</code> prototype property is the string "<code>EvalError</code>".

<h3>message</h3>

<P><span class="pcounter"></span> The initial value of the <code>message</code> prototype property is an implementation-defined string.




<H1 id="class RangeError"> The class <code>RangeError</code> </H1>

<P><span class="pcounter"></span> The implementation throws a new <code>RangeError</code> instance when it
detects that a numeric value has exceeded the allowable range.  See
sections XXX.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Clean up the section references when we reach final draft.

<h2>Synopsis</h2>

<P><span class="pcounter"></span> The <code>RangeError</code> class provides this interface:

<PRE>
dynamic class RangeError extends Error
{
    public function RangeError(message) &#x0085
    static meta function invoke(message) &#x0085
    
    static public const length = 1
}
</PRE>

<P><span class="pcounter"></span> The <code>RangeError</code> prototype object provides these direct properties:
<PRE>
    name:    "RangeError"
    message: &#x0085;
</PRE>

<h2>Methods on the <code>RangeError</code> class</h2>

<h3>new&nbsp;RangeError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>RangeError</code> constructor is called as part of a
<code>new&nbsp;RangeError</code> expression it initialises the newly created
object by delegating to the <code>Error</code> constructor.

<P class="implsection"><b>Implementation</b>
<PRE>
public function RangeError(message)
    : super(message)
{
}
</PRE>


<h3>RangeError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>RangeError</code> class object is called as a function, it
creates and initialises a new <code>RangeError</code> object by invoking the
<code>RangeError</code> constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>RangeError</code> class object called as a function returns a
new <code>RangeError</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(message)
    new RangeError(message);
</PRE>


<h2>Value properties on the <code>RangeError</code> prototype object</h2>

<h3>name</h3>

<P><span class="pcounter"></span> The initial value of the <code>name</code> prototype property is the string "<code>RangeError</code>".

<h3>message</h3>

<P><span class="pcounter"></span> The initial value of the <code>message</code> prototype property is an implementation-defined string.




<H1 id="class ReferenceError"> The class <code>ReferenceError</code> </H1>

<P><span class="pcounter"></span> The implementation throws a new <code>ReferenceError</code> instance when it
detects an invalid reference value. See sections XXX.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Clean up the section references when we reach final draft.

<h2>Synopsis</h2>

<PRE>
dynamic class ReferenceError extends Error
{
    public function ReferenceError(message) &#x0085
    static meta function invoke(message) &#x0085
    
    static public const length = 1
}
</PRE>

<P><span class="pcounter"></span> The <code>ReferenceError</code> prototype object provides these direct properties:
<PRE>
    name:    "ReferenceError"
    message: &#x0085;
</PRE>

<h2>Methods on the <code>ReferenceError</code> class</h2>

<h3>new&nbsp;ReferenceError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>ReferenceError</code> constructor is called as part of a
<code>new&nbsp;ReferenceError</code> expression it initialises the newly created
object by delegating to the <code>Error</code> constructor.

<P class="implsection"><b>Implementation</b>
<PRE>
public function ReferenceError(message)
    : super(message)
{
}
</PRE>


<h3>ReferenceError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>ReferenceError</code> class object is called as a function, it
creates and initialises a new <code>ReferenceError</code> object by invoking the
<code>ReferenceError</code> constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>ReferenceError</code> class object called as a function returns a
new <code>ReferenceError</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(message)
    new ReferenceError(message);
</PRE>


<h2>Value properties on the <code>ReferenceError</code> prototype object</h2>

<h3>name</h3>

<P><span class="pcounter"></span> The initial value of the <code>name</code> prototype property is the string "<code>ReferenceError</code>".

<h3>message</h3>

<P><span class="pcounter"></span> The initial value of the <code>message</code> prototype property is an implementation-defined string.




<H1 id="class SyntaxError"> The class <code>SyntaxError</code> </H1>

<P><span class="pcounter"></span> The implementation throws a new <code>SyntaxError</code> instance when a
parsing error has occurred. See sections XXX.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Clean up the section references when we reach final draft.

<h2>Synopsis</h2>

<PRE>
dynamic class SyntaxError extends Error
{
    public function SyntaxError(message) &#x0085
    static meta function invoke(message) &#x0085
    
    static public const length = 1
}
</PRE>

<P><span class="pcounter"></span> The <code>SyntaxError</code> prototype object provides these direct properties:
<PRE>
    name:    "SyntaxError"
    message: &#x0085;
</PRE>

<h2>Methods on the <code>SyntaxError</code> class</h2>

<h3>new&nbsp;SyntaxError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>SyntaxError</code> constructor is called as part of a
<code>new&nbsp;SyntaxError</code> expression it initialises the newly created
object by delegating to the <code>Error</code> constructor.

<P class="implsection"><b>Implementation</b>
<PRE>
public function SyntaxError(message)
    : super(message)
{
}
</PRE>


<h3>SyntaxError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>SyntaxError</code> class object is called as a function, it
creates and initialises a new <code>SyntaxError</code> object by invoking the
<code>SyntaxError</code> constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>SyntaxError</code> class object called as a function returns a
new <code>SyntaxError</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(message)
    new SyntaxError(message);
</PRE>


<h2>Value properties on the <code>SyntaxError</code> prototype object</h2>

<h3>name</h3>

<P><span class="pcounter"></span> The initial value of the <code>name</code> prototype property is the string "<code>SyntaxError</code>".

<h3>message</h3>

<P><span class="pcounter"></span> The initial value of the <code>message</code> prototype property is an implementation-defined string.




<h1 id="class TypeError"> The class <code>TypeError</code> </H1>

<P><span class="pcounter"></span> The implementation throws a new <code>TypeError</code> instance when it has
detected that the actual type of an operand is different than the
expected type. See sections XXX.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Clean up the section references when we reach final draft.

<h2>Synopsis</h2>

<PRE>
dynamic class TypeError extends Error
{
    public function TypeError(message) &#x0085
    static meta function invoke(message) &#x0085
    
    static public const length = 1
}
</PRE>

<P><span class="pcounter"></span> The <code>TypeError</code> prototype object provides these direct properties:
<PRE>
    name:    "TypeError"
    message: &#x0085;
</PRE>

<h2>Methods on the <code>TypeError</code> class</h2>

<h3>new&nbsp;TypeError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>TypeError</code> constructor is called as part of a
<code>new&nbsp;TypeError</code> expression it initialises the newly created
object by delegating to the <code>Error</code> constructor.

<P class="implsection"><b>Implementation</b>
<PRE>
public function TypeError(message)
    : super(message)
{
}
</PRE>


<h3>TypeError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>TypeError</code> class object is called as a function, it
creates and initialises a new <code>TypeError</code> object by invoking the
<code>TypeError</code> constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>TypeError</code> class object called as a function returns a
new <code>TypeError</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(message)
    new TypeError(message);
</PRE>


<h2>Value properties on the <code>TypeError</code> prototype object</h2>

<h3>name</h3>

<P><span class="pcounter"></span> The initial value of the <code>name</code> prototype property is the string "<code>TypeError</code>".

<h3>message</h3>

<P><span class="pcounter"></span> The initial value of the <code>message</code> prototype property is an implementation-defined string.




<H1 id="class URIError"> The class <code>URIError</code> </H1>

<P><span class="pcounter"></span> The implementation throws a new <code>URIError</code> when one of the global
URI handling functions was used in a way that is incompatible with its
definition. See sections XXX.

<p class="fixme"><b>FIXME</b>&nbsp;&nbsp;  Clean up the section references when we reach final draft.

<h2>Synopsis</h2>

<PRE>
dynamic class URIError extends Error
{
    public function URIError(message) &#x0085
    static meta function invoke(message) &#x0085
    
    static public const length = 1
}
</PRE>

<P><span class="pcounter"></span> The <code>URIError</code> prototype object provides these direct properties:
<PRE>
    name:    "URIError"
    message: &#x0085;
</PRE>

<h2>Methods on the <code>URIError</code> class</h2>

<h3>new&nbsp;URIError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>URIError</code> constructor is called as part of a
<code>new&nbsp;URIError</code> expression it initialises the newly created
object by delegating to the <code>Error</code> constructor.

<P class="implsection"><b>Implementation</b>
<PRE>
public function URIError(message)
    : super(message)
{
}
</PRE>


<h3>URIError&nbsp;(message)</h3>

<P class="section"><b>Description</b> <P><span class="pcounter"></span> When the <code>URIError</code> class object is called as a function, it
creates and initialises a new <code>URIError</code> object by invoking the
<code>URIError</code> constructor.

<P class="section"><b>Returns</b> <P><span class="pcounter"></span> The <code>URIError</code> class object called as a function returns a
new <code>URIError</code> object.

<P class="implsection"><b>Implementation</b>
<PRE>
static meta function invoke(message)
    new URIError(message);
</PRE>


<h2>Value properties on the <code>URIError</code> prototype object</h2>

<h3>name</h3>

<P><span class="pcounter"></span> The initial value of the <code>name</code> prototype property is the string "<code>URIError</code>".

<h3>message</h3>

<P><span class="pcounter"></span> The initial value of the <code>message</code> prototype property is an implementation-defined string.




</body>
</html>
