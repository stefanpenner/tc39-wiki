====== Proposal ======
The Khronos group want to add Typed Array methods for setting a range of elements in a Typed Array Elements and for internally copying a range of elements to a new position within the array.

ES6 is trying to better integrate Typed Array into ECMAScript including making most Array.prototype methods available on TypedArrays. In that spirit, rather than adding these new methods solely for TypedArrays it makes more sense to define them as Array.prototype methods.

====== Array.prototype.fill Method ======


===== Informal Spec  =====

<code>
Array.prototype.fill = function fill(value, start=0, end=this.length) {
  /*
    Every element of array from start up to but not including end is assigned value.
    start and end are coerced to Number and truncated to integer values.
    Negative start and end values are converted to positive indices relative to the length of the array:

       if (start < 0) start = this.length-start

    Reference to start and count below assume that conversion has already been applied
           
    If end <= start no elements are modified.
    If end > this.length and this.length is read-only a Range error is thrown and no elements are modified.
    If end > this.length and this.length is not read-only, this.length is set to end
    Array elements are set sequentially starting with the start index.
    If an element is encountered that cannot be assigned, a TypeError is thrown.
    Element values are assigned using [[Set]]

    The array is returned as the value of this method
  */
}
</code>




===== Examples =====
<code>
 aFloatArray.fill(Infinity);  // Fill all elements with Infinity
 aFloatArray.fill(-1, 6);     // Fill all elements starting at index 6 with -1
 aFloatArray(1.5, 0, 5);      // Fill the first five elements with 1.5
 aUint8Array(0xff, -2);       // Place 0xff in the last two elements
 [ ].fill("abc", 0, 12)
    .fill("xyz", 12, 24);     // Create a regular array, fill its first dozen
                              // elements with "abc", and its 2nd dozen elements
                              // with "xyz"
</code>


===== Design Rationale =====

  * Placing the fill value first means no indices need to be specified when filling all elements of an array.
  * Works with both fixed-sized (eg, Typed Arrays) and variable sized (eg, Array and "Array-like") object
  * The start/end argument pattern is consistent with  Array splice and allows both start and end to be specified relative to the end of the array.


====== Array.prototype.copySlice Method ======

===== Informal Spec  =====

<code>
Array.prototype.copySlice = function copySlice(target = 0,start = 0, end = this.length ) {
/*
  The sequence of array elements from start index up to but not including end index are copied within 
  the array to the span of elements starting at the target index. 

    target, start, and end are coerced to Number and truncated to integer values.
    Negative indices are converted to positive indices relative to the length of the array.
    If end <= start no elements are modified.
    If end > this.length a Range error is thrown and no elements are modified.
    If target + (end-start) > this.length and this.length is read-only a Range error is thrown and no elements are modified.
    If target + (end-start) > this.length and this.length is not read-only, this.length is set to target+(end-start).
 
   The transfers takes into account the possibility that the source and target ranges overlap. Array elements are
   sequentially transferred in a manner appropriate to avoid overlap conflicts. If target <= start a left to right
   transfer is performed.  If target>start a right to left transfer is performed.
 
   If a target element is encountered that cannot be assigned, a type error is thrown and no additional elements are modified.
   Sparse array "holes" are transferred just like for other array functions.

   The array is returned as the value of this method
*/
}
</code>


===== Examples =====
<code>
 [0,1,2,3,4].copySlice(0,2);    //[2,3,4,3,4]
 [0,1,2,3,4].copySlice(2,0,2);  //[0,1,0,1,4]
 [0,1,2].copySlice(1);          // [0,0,1,2]
 Int8Array.from([0,1,2]).copySlice(1);      //RangeError
 Int8Array.from([0,1,2]).copySlice(1,0,2);  //   Int8Array 0,0,1
 Int8Array.from([0,1,2]).copySlice(0,1,2);  //   Int8Array 1,2,2
</code>

===== Design Rationale =====

  * Other names considered include "copy", "move",  "transfer", "copyElements" and "copyRange". copySlice was the consensus choice of an esdiscuss thread.
  * "copyElements" and "copyRange" were also suggested as possible names.
  * I considered a final optional "fill" parameter which would provide a value to put into each source element after it was copied (and taking overlap into account).  This would make it more like a true "move" operation.  However, I couldn't convince myself that there was enough utility in the embellishment to justify the added complexity.







====== Discussion ======

Q: Does anyone know of a rationale for why (start, end) might be a better design pattern than (start, count) for such operation?

A: Array.prototype.slice uses (start, end) where end is a fencepost to facilitate looping over half-open ranges within a larger range. Spec'ing count requires subtracting next_start - end, gratuitously. Also, consistency with slice and range APIs matters. This should be considered carefully in the design.

Furthermore, as Tab Atkins reminds on es-discuss, (start, end) supports negative indexes for both arguments (measured from length).

 --- //[[brendan@mozilla.org|Brendan Eich]] 2013/06/24 01:38//