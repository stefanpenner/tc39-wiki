<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=harmony:proxies_spec&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="http://wiki.ecmascript.org/feed.php?mode=list&amp;ns=harmony" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#direct_proxies_spec" class="toc">Direct Proxies Spec</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#direct_proxies" class="toc">Direct Proxies</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#internal_properties" class="toc">Internal properties</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#proxy_constructor_function" class="toc">Proxy constructor function</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#revocable_proxy_factory_method" class="toc">Revocable Proxy factory method</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#proxy_internal_methods" class="toc">Proxy internal methods</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#internal_methods_inherited_from_object" class="toc">Internal methods inherited from Object</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#internal_methods_overridden_from_object" class="toc">Internal methods overridden from Object</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#deprecated_internal_methods_from_object" class="toc">Deprecated internal methods from Object</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#internal_function_methods" class="toc">Internal Function methods</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#updated_object_internal_methods" class="toc">Updated Object internal methods</a></span></li>
</ul>
</li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#changes_to_es5_built-in_functions" class="toc">Changes to ES5 built-in functions</a></span></li>
<li class="level2"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#iteration_and_enumeration" class="toc">Iteration and Enumeration</a></span></li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#reflect_module" class="toc">@reflect Module</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#virtual_object_handler" class="toc">Virtual Object handler</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#auxiliary_functions" class="toc">Auxiliary Functions</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=harmony:proxies_spec&amp;do=export_html.html#references" class="toc">References</a></span></li>
</ul>
</div>
</div>

<a name="direct_proxies_spec"></a><h1>Direct Proxies Spec</h1>
<div class="level1">

<p>
 <strong>This proposal has progressed to the Draft ECMAScript 6 Specification (Sections 8.5 and 15.18), which is available for review here: <a href="doku.php%3Fid=harmony:specification_drafts.html" class="wikilink1" title="harmony:specification_drafts" onclick="return svchk()" onkeypress="return svchk()">specification_drafts</a>. Any new issues relating to them should be filed as bugs at <a href="http://bugs.ecmascript.org" class="urlextern" target="_blank" title="http://bugs.ecmascript.org" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">http://bugs.ecmascript.org</a>. The content on this page is for historic record only and may no longer reflect the current state of the feature described within.</strong>
</p>

<p>
About this draft spec:
</p>
<ul>
<li class="level1"><div class="li"> Specs <a href="doku.php%3Fid=harmony:direct_proxies.html" class="wikilink1" title="harmony:direct_proxies" onclick="return svchk()" onkeypress="return svchk()">direct proxies</a>, <a href="doku.php%3Fid=harmony:proto_climbing_refactoring.html" class="wikilink1" title="harmony:proto_climbing_refactoring" onclick="return svchk()" onkeypress="return svchk()">proto climbing refactoring</a>, <a href="doku.php%3Fid=harmony:reflect_api.html" class="wikilink1" title="harmony:reflect_api" onclick="return svchk()" onkeypress="return svchk()">reflect api</a>, <a href="doku.php%3Fid=harmony:virtual_object_api.html" class="wikilink1" title="harmony:virtual_object_api" onclick="return svchk()" onkeypress="return svchk()">virtual object api</a> and <a href="doku.php%3Fid=strawman:revokable_proxies.html" class="wikilink1" title="strawman:revokable_proxies" onclick="return svchk()" onkeypress="return svchk()">revokable_proxies</a>.</div>
</li>
<li class="level1"><div class="li"> Does not yet cover <a href="doku.php%3Fid=strawman:proxies_names.html" class="wikilink1" title="strawman:proxies_names" onclick="return svchk()" onkeypress="return svchk()">proxies_names</a>.</div>
</li>
<li class="level1"><div class="li"> This draft spec builds on the ES5 spec layout, and highlights changes mostly w.r.t. the ES5 spec.</div>
</li>
<li class="level1"><div class="li"> Proxies are introduced as a new kind of ECMAScript Object (like Array or Function). They inherit some of the built-in properties from Object, but override some others.</div>
</li>
<li class="level1"><div class="li"> In the below code, where a TypeError is thrown when an invariant violation is detected, the algorithm describes (<em>in parentheses and italics</em>) the reason for the error. This description is non-normative and intended mainly to distinguish the different error cases.</div>
</li>
</ul>

<p>
 <em>&ndash; Tom Van Cutsem</em>
</p>

</div>
<!-- SECTION [1-1240] -->
<a name="direct_proxies"></a><h1>Direct Proxies</h1>
<div class="level1">

<p>
 A Direct Proxy is a special type of <code>Object</code> with different implementations for the Object internal methods. Direct proxies have the following internal properties in addition to those of regular Objects: 
</p>
<ul>
<li class="level1"><div class="li"> [[Handler]]: a reference to the Proxy handler object. Type([[Handler]]) is Object.</div>
</li>
<li class="level1"><div class="li"> [[Target]]: a reference to the target object wrapped by this proxy. Type([[Target]]) is Object.</div>
</li>
</ul>

<p>
 For proxies constructed using the <code>Proxy</code> constructor, these references are guaranteed to be non-null and immutable. For proxies constructed using the <code>Proxy.revocable</code> function, these references are mutated on revocation, but thereafter remain immutable.
</p>

</div>
<!-- SECTION [1241-1942] -->
<a name="internal_properties"></a><h2>Internal properties</h2>
<div class="level2">

<p>
 <strong>[[NativeBrand]] (previously [[Class]])</strong>
</p>

<p>
A direct proxy acquires the value of the [[NativeBrand]] internal property from its [[Target]]. This influences the <code>toString</code> behavior.
</p>

<p>
<strong>[[PrimitiveValue]]</strong>
</p>

<p>
If a direct proxy&rsquo;s target has a [[PrimitiveValue]], the direct proxy acquires the same internal property with the same primitive value.
</p>

<p>
A direct proxy has no usual [[Prototype]] or [[Extensible]] internal properties. Instead, these properties can be thought of as &ldquo;internal accessors&rdquo; that when accessed, lead to the execution of the following code:
</p>

<p>
<strong>[[Prototype]]</strong>
</p>

<p>
When the [[Prototype]] internal accessor is called on a Proxy P:
</p>
<ol>
<li class="level1"><div class="li"> Let handler be the value of the [[Handler]] internal property of P.</div>
</li>
<li class="level1"><div class="li"> Let target be the value of the [[Target]] internal property of P.</div>
</li>
<li class="level1"><div class="li"> Let trap be the result of calling GetTrap(handler, &ldquo;getPrototypeOf&rdquo;).</div>
</li>
<li class="level1"><div class="li"> If trap is undefined,</div>
<ul>
<li class="level2"><div class="li"> a. Return the result of calling the built-in function Reflect.getPrototypeOf(target).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Let trapResult be the result of calling the [[Call]] internal method of trap providing handler as the this value, with target as the first argument.</div>
</li>
<li class="level1"><div class="li"> Let targetProto be the result of calling the built-in Reflect.getPrototypeOf(target)</div>
</li>
<li class="level1"><div class="li"> If SameValue(targetProto, trapResult) is false,</div>
<ul>
<li class="level2"><div class="li"> a. Throw a TypeError <em>(cannot report a prototype value that is inconsistent with target prototype value)</em></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Return targetProto</div>
</li>
</ol>

<p>
 <strong>[[Extensible]]</strong>
</p>

<p>
When the [[Extensible]] internal accessor is called on a Proxy P: 
</p>
<ol>
<li class="level1"><div class="li"> Let handler be the value of the [[Handler]] internal property of P.</div>
</li>
<li class="level1"><div class="li"> Let target be the value of the [[Target]] internal property of P.</div>
</li>
<li class="level1"><div class="li"> Let trap be the result of calling GetTrap(handler, &ldquo;isExtensible&rdquo;).</div>
</li>
<li class="level1"><div class="li"> If trap is undefined,</div>
<ul>
<li class="level2"><div class="li"> a. Return the result of calling the built-in function Reflect.isExtensible(target).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Let trapResult be the result of calling the [[Call]] internal method of trap providing handler as the this value, with target as the first argument.</div>
</li>
<li class="level1"><div class="li"> Let proxyIsExtensible be ToBoolean(trapResult)</div>
</li>
<li class="level1"><div class="li"> Let targetIsExtensible be the result of calling the built-in Object.isExtensible(target)</div>
</li>
<li class="level1"><div class="li"> If proxyIsExtensible and targetIsExtensible are not the same,</div>
<ul>
<li class="level2"><div class="li"> a. Throw a TypeError <em>(cannot report a non-extensible object as extensible or vice versa)</em></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Return targetIsExtensible</div>
</li>
</ol>

<p>
 The <code>typeof</code> operator, when applied to a proxy, returns the result of applying the operator to the proxy&rsquo;s [[Target]]. If [[Target]] is null (i.e. the proxy is revoked), <code>typeof</code> continues to return the same result as it would have before the proxy was revoked.
</p>

<p>
Note: proxies do not affect the <code>instanceof</code> and <code>===</code> operators. A proxy has its own object identity, distinct from its [[Target]].
</p>

<p>
<strong>9.11 IsCallable</strong>
</p>

<p>
ES5 Table 16 should be extended with: 
</p>
<table class="inline">
	<tr>
		<th>Argument Type</th><th>Result</th>
	</tr>
	<tr>
		<td>Proxy</td><td>If the [[Target]] internal property of the proxy is not null and [[Target]] has a [[Call]] method, then return true, otherwise return false.</td>
	</tr>
</table>
<br />

</div>
<!-- SECTION [1943-5030] -->
<a name="proxy_constructor_function"></a><h2>Proxy constructor function</h2>
<div class="level2">

<p>
 When a proxy is created, if the target is callable, the proxy has all the internal methods of a Function object. If the target is not callable, the proxy does not have these internal methods. This influences the outcome of the <code>typeof</code> operator and <code>IsCallable</code> abstract operation, and affects whether or not a proxy can be called, constructed, or used as the right-hand-side of the <code>instanceof</code> operator.
</p>

<p>
<strong> Proxy (T, H) </strong>
</p>

<p>
When the <code>Proxy</code> function is called with target T and handler H, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> If Type(T) is not Object, throw a TypeError exception</div>
</li>
<li class="level1"><div class="li"> If Type(H) is not Object, throw a TypeError exception</div>
</li>
<li class="level1"><div class="li"> Let p be a new Proxy Object with custom internal Object methods as specified in the following Section</div>
</li>
<li class="level1"><div class="li"> If IsCallable(T), set the [[Call]], [[Construct]] and [[HasInstance]] internal methods to those specified in the following Section</div>
</li>
<li class="level1"><div class="li"> Set the [[Handler]] internal property of p to H</div>
</li>
<li class="level1"><div class="li"> Set the [[Target]] internal property of p to T</div>
</li>
<li class="level1"><div class="li"> Return p</div>
</li>
</ol>

</div>
<!-- SECTION [5031-6097] -->
<a name="revocable_proxy_factory_method"></a><h2>Revocable Proxy factory method</h2>
<div class="level2">

<p>
 <strong>Proxy.revocable(T, H)</strong> 
</p>
<ol>
<li class="level1"><div class="li"> If Type(T) is not Object, throw a TypeError exception</div>
</li>
<li class="level1"><div class="li"> If Type(H) is not Object, throw a TypeError exception</div>
</li>
<li class="level1"><div class="li"> Let p be a new Proxy Object with custom internal Object methods as specified in the following Section</div>
</li>
<li class="level1"><div class="li"> If IsCallable(T), set the [[Call]], [[Construct]] and [[HasInstance]] internal methods to those specified in the following Section</div>
</li>
<li class="level1"><div class="li"> Set the [[Handler]] internal property of p to H</div>
</li>
<li class="level1"><div class="li"> Set the [[Target]] internal property of p to T</div>
</li>
<li class="level1"><div class="li"> Let r be a new Function with the [[Call]] behavior as specified below</div>
</li>
<li class="level1"><div class="li"> Set the [[Proxy]] internal property of r to p</div>
</li>
<li class="level1"><div class="li"> Let pair be a new ECMAScript Object</div>
</li>
<li class="level1"><div class="li"> Call pair.[[DefineOwnProperty]](&rdquo;proxy&rdquo;,{value:p,writable:true,enumerable:true,configurable:true},true)</div>
</li>
<li class="level1"><div class="li"> Call pair.[[DefineOwnProperty]](&rdquo;revoke&rdquo;,{value:r,writable:true,enumerable:true,configurable:true},true)</div>
</li>
<li class="level1"><div class="li"> Return pair</div>
</li>
</ol>

<p>
 <strong>Revoke function [[Call]]</strong>
</p>

<p>
When the [[Call]] method of a revoke function F is called: 
</p>
<ol>
<li class="level1"><div class="li"> Let proxy be the value of the [[Proxy]] internal property of F</div>
</li>
<li class="level1"><div class="li"> Set the [[Target]] internal property of proxy to null</div>
</li>
<li class="level1"><div class="li"> Set the [[Handler]] internal property of proxy to RevokedHandler</div>
</li>
<li class="level1"><div class="li"> Return undefined</div>
</li>
</ol>

<p>
 <strong>RevokedHandler</strong>
</p>

<p>
The <strong>RevokedHandler</strong> is an Object whose [[Get]] method is specified as follows: 
</p>
<ol>
<li class="level1"><div class="li"> throw TypeError <em>(proxy is revoked)</em></div>
</li>
</ol>

</div>
<!-- SECTION [6098-7539] -->
<a name="proxy_internal_methods"></a><h2>Proxy internal methods</h2>
<div class="level2">

</div>
<!-- SECTION [7540-7575] -->
<a name="internal_methods_inherited_from_object"></a><h3>Internal methods inherited from Object</h3>
<div class="level3">

<p>
 <strong>[[DefaultValue]] (hint) </strong>
</p>

<p>
<strong>[[Get]] (P) </strong>
</p>

<p>
<strong>[[Put]] (P, V, Throw) </strong>
</p>

<p>
See below for updated implementations of [[Get]] and [[Put]] on regular Objects.
</p>

</div>
<!-- SECTION [7576-7803] -->
<a name="internal_methods_overridden_from_object"></a><h3>Internal methods overridden from Object</h3>
<div class="level3">

<p>
 <strong>[[GetOwnProperty]] (P) </strong>
</p>

<p>
When the [[GetOwnProperty]] internal method of a proxy O is called with property name P, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Let descObj be the result of calling TrapGetOwnProperty(O, P)</div>
</li>
<li class="level1"><div class="li"> If descObj is undefined, return undefined</div>
</li>
<li class="level1"><div class="li"> Let desc be ToCompletePropertyDescriptor(descObj)</div>
</li>
<li class="level1"><div class="li"> Return desc</div>
</li>
</ol>

<p>
 <strong> TrapGetOwnProperty(O, P) </strong> 
</p>
<ol>
<li class="level1"><div class="li"> Let handler be the value of the [[Handler]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let target be the value of the [[Target]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let trap be the result of calling GetTrap(handler, &ldquo;getOwnPropertyDescriptor&rdquo;).</div>
</li>
<li class="level1"><div class="li"> If trap is undefined,</div>
<ul>
<li class="level2"><div class="li"> a. Return the result of calling the built-in function Reflect.getOwnPropertyDescriptor(target, P).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Let trapResult be the result of calling the [[Call]] internal method of trap providing handler as the this value, target as the first argument and P as the second argument.</div>
</li>
<li class="level1"><div class="li"> Let targetDesc be the result of calling target.[[GetOwnProperty]](P)</div>
</li>
<li class="level1"><div class="li"> If trapResult is undefined,</div>
<ul>
<li class="level2"><div class="li"> a. If targetDesc is not undefined, and targetDesc.[[Configurable]] is false, throw a TypeError <em>(cannot report a non-configurable property as non-existent)</em></div>
</li>
<li class="level2"><div class="li"> b. If targetDesc is not undefined, and the [[Extensible]] attribute of target is false, throw a TypeError <em>(cannot report existing own property as non-existent on a non-extensible object)</em></div>
</li>
<li class="level2"><div class="li"> c. Return undefined</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> If Type(trapResult) is not Object throw a TypeError exception.</div>
</li>
<li class="level1"><div class="li"> Let normalizedDesc be the result of calling ToCompletePropertyDescriptor(trapResult)</div>
</li>
<li class="level1"><div class="li"> Let extensible be the value of the [[Extensible]] internal property of target</div>
</li>
<li class="level1"><div class="li"> If extensible is false, and targetDesc is undefined then,</div>
<ul>
<li class="level2"><div class="li"> a. Throw a TypeError <em>(cannot report a new own property on a non-extensible object)</em></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> If targetDesc is not undefined and IsCompatibleDescriptor(extensible, targetDesc, normalizedDesc) is false, throw a TypeError <em>(cannot report incompatible property descriptor)</em></div>
</li>
<li class="level1"><div class="li"> If normalizedDesc.[[Configurable]] is false,</div>
<ul>
<li class="level2"><div class="li"> a. If targetDesc is undefined or targetDesc.[[Configurable]] is true, throw a TypeError <em>(cannot report a non-configurable descriptor for a non-existent or configurable property)</em></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Let normalizedDescObj be the result of calling FromPropertyDescriptor(normalizedDesc)</div>
</li>
<li class="level1"><div class="li"> Call CopyAttributes(trapResult, normalizedDescObj)</div>
</li>
<li class="level1"><div class="li"> Return normalizedDescObj</div>
</li>
</ol>

<p>
 <strong>[[HasProperty]] (P) </strong>
</p>

<p>
When the [[HasProperty]] internal method of a proxy O is called with property name P the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Let handler be the value of the [[Handler]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let target be the value of the [[Target]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let trap be the result of calling GetTrap(handler, &ldquo;has&rdquo;).</div>
</li>
<li class="level1"><div class="li"> If trap is undefined,</div>
<ul>
<li class="level2"><div class="li"> a. Return the result of calling the built-in function Reflect.has(target, P).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Let trapResult be the result of calling the [[Call]] internal method of trap providing handler as the this value, target as the first argument and P as the second argument.</div>
</li>
<li class="level1"><div class="li"> Let success be ToBoolean(result)</div>
</li>
<li class="level1"><div class="li"> If success is false,</div>
<ul>
<li class="level2"><div class="li"> a. Let targetDesc be the result of calling target.[[GetOwnProperty]](P)</div>
</li>
<li class="level2"><div class="li"> b. If desc is not undefined and targetDesc.[[Configurable]] is false, throw a TypeError <em>(cannot report existing non-configurable own property as non-existent)</em></div>
</li>
<li class="level2"><div class="li"> c. If the [[Extensible]] attribute of target is false, and targetDesc is not undefined, throw a TypeError <em>(cannot report existing own property as non-existent on a non-extensible object)</em></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Return success</div>
</li>
</ol>

<p>
 <strong>[[Delete]] (P, Throw) </strong>
</p>

<p>
When the [[Delete]] internal method of a trapping proxy O is called with property name P and the Boolean flag Throw the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Let handler be the value of the [[Handler]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let target be the value of the [[Target]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let trap be the result of calling GetTrap(handler, &ldquo;deleteProperty&rdquo;).</div>
</li>
<li class="level1"><div class="li"> If trap is undefined,</div>
<ul>
<li class="level2"><div class="li"> a. Return the result of calling the built-in function Reflect.deleteProperty(target, P).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Let trapResult be the result of calling the [[Call]] internal method of trap providing handler as the this value, target as the first argument and P as the second argument.</div>
</li>
<li class="level1"><div class="li"> Let success be ToBoolean(trapResult)</div>
</li>
<li class="level1"><div class="li"> If success is true,</div>
<ul>
<li class="level2"><div class="li"> a. Let targetDesc be the result of calling target.[[GetOwnProperty]](P)</div>
</li>
<li class="level2"><div class="li"> b. If targetDesc is not undefined, and targetDesc.[[Configurable]] is false, throw a TypeError <em>(property is non-configurable and cannot be deleted)</em></div>
</li>
<li class="level2"><div class="li"> c. Return true.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Else, success must be false</div>
<ul>
<li class="level2"><div class="li"> a. If Throw then throw a TypeError exception, else return false.</div>
</li>
</ul>
</li>
</ol>

<p>
 <strong>[[DefineOwnProperty]] (P, Desc, Throw)</strong>
</p>

<p>
When the [[DefineOwnProperty]] internal method of a proxy O is called with property name P, property descriptor Desc and Boolean flag Throw, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Let descObj be FromGenericPropertyDescriptor(Desc)</div>
</li>
<li class="level1"><div class="li"> Return the result of calling TrapDefineOwnProperty(O, P, descObj, Throw)</div>
</li>
</ol>

<p>
 <strong>TrapDefineOwnProperty (O, P, DescObj, Throw)</strong>
</p>

<p>
When the abstract operation TrapDefineOwnProperty is called with a proxy O, a property name P, an Object DescObj and a Boolean flag Throw, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Let handler be the value of the [[Handler]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let target be the value of the [[Target]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let trap be the result of calling GetTrap(handler, &ldquo;defineProperty&rdquo;).</div>
</li>
<li class="level1"><div class="li"> If trap is undefined,</div>
<ul>
<li class="level2"><div class="li"> a. Return the result of calling the built-in function Reflect.defineProperty(target, P, DescObj).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Let normalizedDesc be the result of calling ToPropertyDescriptor(DescObj)</div>
</li>
<li class="level1"><div class="li"> Let normalizedDescObj be the result of calling FromGenericPropertyDescriptor(normalizedDesc)</div>
</li>
<li class="level1"><div class="li"> Call CopyAttributes(DescObj, normalizedDescObj)</div>
</li>
<li class="level1"><div class="li"> Let trapResult be the result of calling the [[Call]] internal method of trap providing handler as the this value, target as the first argument, P as the second argument and normalizedDescObj as the third argument.</div>
</li>
<li class="level1"><div class="li"> Let success be ToBoolean(trapResult)</div>
</li>
<li class="level1"><div class="li"> If success is true,</div>
<ul>
<li class="level2"><div class="li"> a. Let targetDesc be the result of calling target.[[GetOwnProperty]](P)</div>
</li>
<li class="level2"><div class="li"> b. Let extensible be the value of the [[Extensible]] internal property of target</div>
</li>
<li class="level2"><div class="li"> c. If extensible is false and targetDesc is undefined, throw a TypeError (<em>cannot successfully add a new property to a non-extensible object</em>)</div>
</li>
<li class="level2"><div class="li"> d. If targetDesc is not undefined and IsCompatibleDescriptor(extensible, targetDesc, normalizedDesc) is false, throw a TypeError (<em>cannot define incompatible property descriptor for existing property</em>)</div>
</li>
<li class="level2"><div class="li"> e. If normalizedDesc.[[Configurable]] is false,</div>
<ul>
<li class="level3"><div class="li"> i. If targetDesc is undefined or targetDesc.[[Configurable]] is true, throw a TypeError <em>(cannot define a non-configurable property that is non-existent or configurable on target)</em></div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> f. Return true</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Else, success must be false,</div>
<ul>
<li class="level2"><div class="li"> a. If Throw then throw a TypeError, else return false</div>
</li>
</ul>
</li>
</ol>

<p>
 <strong>[[GetP]] (P, Receiver) </strong>
</p>

<p>
When the [[GetP]] internal method of a proxy O is called with property name P and object Receiver, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Let handler be the value of the [[Handler]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let target be the value of the [[Target]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let trap be the result of calling GetTrap(handler, &ldquo;get&rdquo;).</div>
</li>
<li class="level1"><div class="li"> If trap is undefined,</div>
<ul>
<li class="level2"><div class="li"> a. Return the result of calling the built-in function Reflect.get(target, P, Receiver).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Let trapResult be the result of calling the [[Call]] internal method of trap providing handler as the this value, target as the first argument, P as the second argument and Receiver as the third argument.</div>
</li>
<li class="level1"><div class="li"> Let desc be the result of calling target.[[GetOwnProperty]](P)</div>
</li>
<li class="level1"><div class="li"> If desc is not undefined,</div>
<ul>
<li class="level2"><div class="li"> a. If IsDataDescriptor(desc) and desc.[[Configurable]] is false and desc.[[Writable]] is false,</div>
<ul>
<li class="level3"><div class="li"> i. If SameValue(trapResult, desc.[[Value]]) is false, throw a TypeError <em>(cannot report inconsistent value for non-writable, non-configurable property)</em></div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> b. If IsAccessorDescriptor(desc) and desc.[[Configurable]] is false and desc.[[Get]] is undefined,</div>
<ul>
<li class="level3"><div class="li"> i. If trapResult is not undefined, throw a TypeError <em>(must report undefined for non-configurable accessor property without a getter)</em> </div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Return trapResult</div>
</li>
</ol>

<p>
 <strong>[[SetP]] (P, V, Receiver)</strong>
</p>

<p>
When the [[SetP]] internal method of a proxy O is called with property name P, value V and object Receiver the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Let handler be the value of the [[Handler]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let target be the value of the [[Target]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let trap be the result of calling GetTrap(handler, &ldquo;set&rdquo;).</div>
</li>
<li class="level1"><div class="li"> If trap is undefined,</div>
<ul>
<li class="level2"><div class="li"> a. Return the result of calling the built-in function Reflect.set(target, P, V, Receiver).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Let trapResult be the result of calling the [[Call]] internal method of trap providing handler as the this value, target as the first argument, P as the second argument, V as the third argument and Receiver as the fourth argument.</div>
</li>
<li class="level1"><div class="li"> Let success be ToBoolean(trapResult)</div>
</li>
<li class="level1"><div class="li"> If success is true,</div>
<ul>
<li class="level2"><div class="li"> a. Let desc be the result of calling target.[[GetOwnProperty]](P)</div>
</li>
<li class="level2"><div class="li"> b. If desc is not undefined,</div>
<ul>
<li class="level3"><div class="li"> i. If IsDataDescriptor(desc) and desc.[[Configurable]] is false and desc.[[Writable]] is false,</div>
<ul>
<li class="level4"><div class="li"> 1. If SameValue(V, desc.[[Value]]) is false, throw a TypeError (<em>cannot successfully assign to a non-writable, non-configurable property</em>)</div>
</li>
</ul>
</li>
<li class="level3"><div class="li"> ii. If IsAccessorDescriptor(desc) and desc.[[Configurable]] is false,</div>
<ul>
<li class="level4"><div class="li"> 1. If desc.[[Set]] is undefined, throw a TypeError (<em>cannot successfully set a property that has only a getter</em>)</div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Return success</div>
</li>
</ol>

<p>
 <strong>[[HasOwnProperty]] (P) </strong>
</p>

<p>
When the [[HasOwnProperty]] internal method of a proxy O is called with property name P the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Let handler be the value of the [[Handler]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let target be the value of the [[Target]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let trap be the result of calling GetTrap(handler, &ldquo;hasOwn&rdquo;).</div>
</li>
<li class="level1"><div class="li"> If trap is undefined,</div>
<ul>
<li class="level2"><div class="li"> a. Return the result of calling the built-in function Reflect.hasOwn(target, P).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Let trapResult be the result of calling the [[Call]] internal method of trap providing handler as the this value, target as the first argument and P as the second argument.</div>
</li>
<li class="level1"><div class="li"> Let success be ToBoolean(result)</div>
</li>
<li class="level1"><div class="li"> If success is false,</div>
<ul>
<li class="level2"><div class="li"> Let targetDesc be the result of calling target.[[GetOwnProperty]](P)</div>
</li>
<li class="level2"><div class="li"> If targetDesc is not undefined, and targetDesc.[[Configurable]] is false, throw a TypeError <em>(cannot report existing non-configurable own property as non-existent)</em></div>
</li>
<li class="level2"><div class="li"> b. If the [[Extensible]] attribute of target is false, and targetDesc is not undefined, throw a TypeError <em>(cannot report existing own property as non-existent on a non-extensible object)</em></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Else, success must be true</div>
<ul>
<li class="level2"><div class="li"> a. If the [[Extensible]] attribute of target is false, and targetDesc is undefined, throw a TypeError <em>(cannot report a new own property on a non-extensible object)</em></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Return success</div>
</li>
</ol>

</div>
<!-- SECTION [7804-19181] -->
<a name="deprecated_internal_methods_from_object"></a><h3>Deprecated internal methods from Object</h3>
<div class="level3">

<p>
 See <a href="doku.php%3Fid=harmony:proto_climbing_refactoring.html" class="wikilink1" title="harmony:proto_climbing_refactoring" onclick="return svchk()" onkeypress="return svchk()">proto climbing refactoring</a>.
</p>

<p>
<strong>[[GetProperty]] (P) </strong>
</p>

<p>
<strong>[[CanPut]] (P) </strong>
</p>

</div>
<!-- SECTION [19182-19332] -->
<a name="internal_function_methods"></a><h3>Internal Function methods</h3>
<div class="level3">

<p>
 Note: these methods are only defined on a Proxy object P if <code>IsCallable(P.[[Target]])</code> is true. See the <code>Proxy</code> constructor above.
</p>

<p>
<strong>[[Call]] (thisValue, listOfArguments)</strong>
</p>

<p>
When the [[Call]] internal method of a proxy O is called with a this value and a list of arguments, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Let handler be the value of the [[Handler]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let target be the value of the [[Target]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let argArray be listOfArguments converted into an Array.</div>
</li>
<li class="level1"><div class="li"> Let trap be the result of calling GetTrap(handler, &ldquo;apply&rdquo;).</div>
</li>
<li class="level1"><div class="li"> If trap is undefined,</div>
<ul>
<li class="level2"><div class="li"> a. Return the result of calling the built-in function Reflect.apply(target, thisValue, argArray).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Return the result of calling the [[Call]] internal method of trap providing handler as the this value, target as the first argument, thisValue as the second argument and argArray as the third argument.</div>
</li>
</ol>

<p>
 <strong>[[Construct]] (listOfArguments)</strong>
</p>

<p>
When the [[Construct]] internal method of a proxy O is called with a list of arguments the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Let handler be the value of the [[Handler]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let target be the value of the [[Target]] internal property of O.</div>
</li>
<li class="level1"><div class="li"> Let argArray be listOfArguments converted into an Array.</div>
</li>
<li class="level1"><div class="li"> Let trap be the result of calling GetTrap(handler, &ldquo;construct&rdquo;).</div>
</li>
<li class="level1"><div class="li"> If trap is undefined,</div>
<ul>
<li class="level2"><div class="li"> a. Return the result of calling the built-in function Reflect.construct(target, argArray).</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Return the result of calling the [[Call]] internal method of trap providing handler as the this value, target as the first argument and argArray as the second argument.</div>
</li>
</ol>

<p>
 <strong>[[HasInstance]]</strong>
</p>

<p>
Same semantics as Function [[HasInstance]] (ES5 15.3.5.3)
</p>

</div>
<!-- SECTION [19333-21144] -->
<a name="updated_object_internal_methods"></a><h3>Updated Object internal methods</h3>
<div class="level3">

<p>
 The following are revised and additional implementations of the internal methods for regular (non-proxy) Objects.
</p>

<p>
<strong> 8.12.3 [[Get]] (P)</strong>
</p>

<p>
When the [[Get]] internal method of O is called with property name P, the following steps are taken:
</p>
<ol>
<li class="level1"><div class="li"> Return the result of calling the [[GetP]] internal method of O providing P as the first argument and O as the second argument.</div>
</li>
</ol>

<p>
 <strong> [[GetP]] (P, Receiver)</strong>
</p>

<p>
When the [[GetP]] internal method of O is called with property name P and object Receiver, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Let desc be the result of calling the [[GetOwnProperty]] internal method of O with property name P.</div>
</li>
<li class="level1"><div class="li"> If desc is undefined,</div>
<ul>
<li class="level2"><div class="li"> a. Let proto be the value of the [[Prototype]] internal property of O</div>
</li>
<li class="level2"><div class="li"> b. If proto is null, return undefined</div>
</li>
<li class="level2"><div class="li"> c. Return the result of calling the [[GetP]] internal method of proto with arguments Receiver and P.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> If IsDataDescriptor(desc) is true, return desc.[[Value]].</div>
</li>
<li class="level1"><div class="li"> Otherwise, IsAccessorDescriptor(desc) must be true so, let getter be desc.[[Get]].</div>
</li>
<li class="level1"><div class="li"> If getter is undefined, return undefined.</div>
</li>
<li class="level1"><div class="li"> Return the result calling the [[Call]] internal method of getter providing Receiver as the this value and providing no arguments.</div>
</li>
</ol>

<p>
 <strong> 8.12.5 [[Put]] (P, V, Throw)</strong>
</p>

<p>
When the [[Put]] internal method of O is called with property P, value V, and Boolean flag Throw, the following steps are taken:
</p>
<ol>
<li class="level1"><div class="li"> Let success be the result of calling the [[SetP]] internal method of proto, passing O as the first argument, P as the second argument and V as the third argument.</div>
</li>
<li class="level1"><div class="li"> If success is false and Throw is true, then throw a TypeError exception.</div>
</li>
<li class="level1"><div class="li"> Return.</div>
</li>
</ol>

<p>
 <strong> [[SetP]] (P, V, Receiver) </strong>
</p>

<p>
When the [[SetP]] internal method of O is called with property name P, value V and object Receiver, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> Let ownDesc be the result of calling the [[GetOwnProperty]] internal method of O with argument P.</div>
</li>
<li class="level1"><div class="li"> If IsDataDescriptor(ownDesc) is true, then</div>
<ul>
<li class="level2"><div class="li"> a. If ownDesc.[[Writable]] is false, return false.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> If IsAccessorDescriptor(ownDesc) is true, then</div>
<ul>
<li class="level2"><div class="li"> a. Let setter be ownDesc.[[Set]]</div>
</li>
<li class="level2"><div class="li"> b. If setter is undefined, return false.</div>
</li>
<li class="level2"><div class="li"> c. Call the [[Call]] internal method of setter providing Receiver as the this value and providing V as the sole argument.</div>
</li>
<li class="level2"><div class="li"> d. Return true.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Let proto be the value of the [[Prototype]] internal property of O</div>
</li>
<li class="level1"><div class="li"> If proto is null, we have not found a non-writable data property in the prototype chain, add the property to the Receiver as follows:</div>
<ul>
<li class="level2"><div class="li"> a. Let receiverDesc be the result of calling the [[GetOwnProperty]] internal method of Receiver with argument P.</div>
</li>
<li class="level2"><div class="li"> b. If IsDataDescriptor(receiverDesc) is true, then</div>
<ul>
<li class="level3"><div class="li"> i. If receiverDesc.[[Writable]] is false, return false.</div>
</li>
<li class="level3"><div class="li"> ii. Let valueDesc be the Property Descriptor {[[Value]]: V}.</div>
</li>
<li class="level3"><div class="li"> iii. Return the result of calling the [[DefineOwnProperty]] internal method of Receiver passing P, valueDesc, and false as arguments</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> c. If IsAccessorDescriptor(receiverDesc) is true, then</div>
<ul>
<li class="level3"><div class="li"> i. Let setter be receiverDesc.[[Set]]</div>
</li>
<li class="level3"><div class="li"> ii. If setter is undefined, return false.</div>
</li>
<li class="level3"><div class="li"> iii. Call the [[Call]] internal method of setter providing Receiver as the this value and providing V as the sole argument.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> d. Otherwise, receiverDesc must be undefined, add a new named data property named P on Receiver:</div>
<ul>
<li class="level3"><div class="li"> i. If the [[Extensible]] internal property of Receiver is false, return false.</div>
</li>
<li class="level3"><div class="li"> ii. Let newDesc be the Property Descriptor {[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}.</div>
</li>
<li class="level3"><div class="li"> iii. Return the result of calling the [[DefineOwnProperty]] internal method of Receiver passing P, newDesc, and false as arguments</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Return the result of calling the [[SetP]] internal method of proto with arguments Receiver, P and V.</div>
</li>
</ol>

<p>
 <strong> 8.12.6 [[HasProperty]] (P) </strong>
</p>
<pre class="file">
  - Let hasOwn be the result of calling the %%[[HasOwnProperty]]%% internal method of O with property name P.
  - If hasOwn is true return true.
  - Let proto be the %%[[Prototype]]%% internal property of O.
  - If proto is null, return false
  - Return the result of calling the %%[[HasProperty]]%% internal method of proto with argument P.
</pre>

<p>
<strong>[[HasOwnProperty]] (P) </strong>
</p>

<p>
When the [[HasOwnProperty]] internal method of O is called with property name P the following steps are taken:
</p>
<ol>
<li class="level1"><div class="li"> Let desc be the result of calling the [[GetOwnProperty]] internal method of O, passing P as the sole argument.</div>
</li>
<li class="level1"><div class="li"> If desc is undefined, return false</div>
</li>
<li class="level1"><div class="li"> Return true</div>
</li>
</ol>

</div>
<!-- SECTION [21145-25852] -->
<a name="changes_to_es5_built-in_functions"></a><h2>Changes to ES5 built-in functions</h2>
<div class="level2">

<p>
 <strong> 15.2.3.2 Object.getPrototypeOf ( O )</strong>
</p>

<p>
When the getPrototypeOf function is called with argument O, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> If Type(O) is not Object throw a TypeError exception.</div>
</li>
<li class="level1"><div class="li"> If O is a proxy, return the result of calling the [[Prototype]] internal accessor of O.</div>
</li>
<li class="level1"><div class="li"> Return the value of the [[Prototype]] internal property of O.</div>
</li>
</ol>

<p>
 <strong> 15.2.3.3 Object.getOwnPropertyDescriptor ( O, P ) </strong>
</p>

<p>
When the getOwnPropertyDescriptor function is called, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> If Type(O) is not Object throw a TypeError exception.</div>
</li>
<li class="level1"><div class="li"> Let name be ToString(P)</div>
</li>
<li class="level1"><div class="li"> If O is a proxy</div>
<ul>
<li class="level2"><div class="li"> Return the result of calling TrapGetOwnProperty(O, name)</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Let desc be the result of calling the [[GetOwnProperty]] internal method of O with argument name.</div>
</li>
<li class="level1"><div class="li"> Return the result of calling FromPropertyDescriptor(desc) (8.10.4).</div>
</li>
</ol>

<p>
 <strong> 15.2.3.4 Object.getOwnPropertyNames ( O ) </strong>
</p>

<p>
When the <strong>getOwnPropertyNames</strong> function is called, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> If Type(O) is not Object throw a TypeError exception.</div>
</li>
<li class="level1"><div class="li"> If O is a proxy</div>
<ul>
<li class="level2"><div class="li"> a. Let handler be the value of the [[Handler]] internal property of O.</div>
</li>
<li class="level2"><div class="li"> b. Let target be the value of the [[Target]] internal property of O.</div>
</li>
<li class="level2"><div class="li"> c. Let trap be the result of calling GetTrap(handler, &ldquo;getOwnPropertyNames&rdquo;).</div>
</li>
<li class="level2"><div class="li"> d. If trap is undefined,</div>
<ul>
<li class="level3"><div class="li"> i. Return the result of calling the built-in function Reflect.getOwnPropertyNames(target).</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> e. Let trapResult be the result of calling the [[Call]] internal method of trap providing handler as the this value, with target as the first argument.</div>
</li>
<li class="level2"><div class="li"> f. If Type(trapResult) is not Object, throw a TypeError exception</div>
</li>
<li class="level2"><div class="li"> g. Let len be the result of calling the [[Get]] internal method of trapResult with argument &ldquo;length&rdquo;</div>
</li>
<li class="level2"><div class="li"> h. Let n be ToUint32(len)</div>
</li>
<li class="level2"><div class="li"> i. Let array be the result of creating a new Object as if by the expression new Array(n) where Array is the standard built-in constructor with that name.</div>
</li>
<li class="level2"><div class="li"> j. Let index be 0.</div>
</li>
<li class="level2"><div class="li"> k. Repeat, while index &lt; n</div>
<ul>
<li class="level3"><div class="li"> i. Let nextElement be the result of calling the [[Get]] internal method of trapResult with argument ToString(index).</div>
</li>
<li class="level3"><div class="li"> ii. Let s be ToString(nextElement)</div>
</li>
<li class="level3"><div class="li"> iii. If s is the same as any previous s obtained in this loop, throw a TypeError exception.</div>
</li>
<li class="level3"><div class="li"> iv. Let isFixed be the result of calling target.[[HasOwnProperty]](s)</div>
</li>
<li class="level3"><div class="li"> iv. If the [[Extensible]] internal property of target is false and isFixed is false,</div>
<ol>
<li class="level4"><div class="li"> throw a TypeError <em>(cannot list a new property on a non-extensible object)</em></div>
</li>
</ol>
</li>
<li class="level3"><div class="li"> v. Call the [[DefineOwnProperty]] internal method of array with arguments ToString(index), the PropertyDescriptor {[[Value]]: s, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and true.</div>
</li>
<li class="level3"><div class="li"> vi. Increment index by 1.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> l. Let ownProps be the result of calling the built-in Object.getOwnPropertyNames(target), an Array of Strings</div>
</li>
<li class="level2"><div class="li"> m. For each element string P in ownProps not present in array,</div>
<ul>
<li class="level3"><div class="li"> i. Let targetDesc be the result of calling target.[[GetOwnProperty]](P)</div>
</li>
<li class="level3"><div class="li"> ii. If targetDesc is not undefined, and targetDesc.[[Configurable]] is false, throw a TypeError <em>(cannot skip non-configurable property)</em></div>
</li>
<li class="level3"><div class="li"> iii. If the [[Extensible]] internal property of target is false, and targetDesc is not undefined, throw a TypeError <em>(cannot report existing own property as non-existent on a non-extensible object)</em></div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> n. Return array.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Else, perform the regular Object.getOwnPropertyNames steps according to 15.2.3.4, starting from step 2.</div>
</li>
</ol>

<p>
 <strong>15.2.3.6 Object.defineProperty ( O, P, Attributes )</strong>
</p>

<p>
When the defineProperty function is called, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> If Type(O) is not Object throw a TypeError exception.</div>
</li>
<li class="level1"><div class="li"> Let name be ToString(P).</div>
</li>
<li class="level1"><div class="li"> If O is a proxy</div>
<ul>
<li class="level2"><div class="li"> a. If Type(Attributes) is not Object, throw a TypeError exception.</div>
</li>
<li class="level2"><div class="li"> b. Call TrapDefineOwnProperty(O, name, Attributes, true)</div>
</li>
<li class="level2"><div class="li"> c. Return O.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Let desc be the result of ToPropertyDescriptor(Attributes)</div>
</li>
<li class="level1"><div class="li"> Call the [[DefineOwnProperty]] internal method of O with arguments name, desc, and true.</div>
</li>
<li class="level1"><div class="li"> Return O.</div>
</li>
</ol>

<p>
 <strong>15.2.3.7 Object.defineProperties ( O, Properties )</strong>
</p>

<p>
Replace step 6.c. by:
</p>
<ul>
<li class="level1"><div class="li"> 6.c. Call Object.defineProperty(O, P, desc), using the above definition of Object.defineProperty</div>
</li>
</ul>

<p>
 Notes:
</p>
<ul>
<li class="level1"><div class="li"> This change is necessary so that calling <code>Object.defineProperties</code> on a proxy will correctly pass on non-standard property descriptor attributes.</div>
</li>
</ul>

<p>
 <strong> 15.2.3.8 Object.seal ( O ) </strong>
</p>

<p>
When the <strong>seal</strong> function is called with argument O, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> If Type(O) is not Object throw a TypeError exception.</div>
</li>
<li class="level1"><div class="li"> If O is a Proxy,</div>
<ul>
<li class="level2"><div class="li"> a. Let handler be the value of the [[Handler]] internal property of O.</div>
</li>
<li class="level2"><div class="li"> b. Let target be the value of the [[Target]] internal property of O.</div>
</li>
<li class="level2"><div class="li"> c. Let trap be the result of calling GetTrap(handler, &ldquo;seal&rdquo;).</div>
</li>
<li class="level2"><div class="li"> d. If trap is undefined,</div>
<ul>
<li class="level3"><div class="li"> i. Return the result of calling the built-in function Reflect.seal(target).</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> e. Let trapResult be the result of calling the [[Call]] internal method of trap providing handler as the this value, with target as the first argument.</div>
</li>
<li class="level2"><div class="li"> f. Let success be ToBoolean(trapResult)</div>
</li>
<li class="level2"><div class="li"> g. If success is true and the built-in Object.isSealed(target) returns false,</div>
<ul>
<li class="level3"><div class="li"> i. throw a TypeError <em>(cannot report non-sealed object as sealed)</em></div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> h. If success is false, throw a TypeError <em>(object rejected to be sealed)</em></div>
</li>
</ul>
</li>
</ol>

<p>
    i. Return O.
</p>
<ol>
<li class="level1"><div class="li"> Else, perform the regular Object.seal steps according to 15.2.3.8, starting from step 2.</div>
</li>
</ol>

<p>
 <strong> 15.2.3.9 Object.freeze ( O ) </strong>
</p>

<p>
When the <strong>freeze</strong> function is called with argument O, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> If Type(O) is not Object throw a TypeError exception.</div>
</li>
<li class="level1"><div class="li"> If O is a Proxy,</div>
<ul>
<li class="level2"><div class="li"> a. Let handler be the value of the [[Handler]] internal property of O.</div>
</li>
<li class="level2"><div class="li"> b. Let target be the value of the [[Target]] internal property of O.</div>
</li>
<li class="level2"><div class="li"> c. Let trap be the result of calling GetTrap(handler, &ldquo;freeze&rdquo;).</div>
</li>
<li class="level2"><div class="li"> d. If trap is undefined,</div>
<ul>
<li class="level3"><div class="li"> i. Return the result of calling the built-in function Reflect.freeze(target).</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> e. Let trapResult be the result of calling the [[Call]] internal method of trap providing handler as the this value, with target as the first argument.</div>
</li>
<li class="level2"><div class="li"> f. Let success be ToBoolean(trapResult)</div>
</li>
<li class="level2"><div class="li"> g. If success is true and the built-in Object.isFrozen(target) returns false,</div>
<ul>
<li class="level3"><div class="li"> i. throw a TypeError <em>(cannot report non-frozen object as frozen)</em></div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> h. If success is false, throw a TypeError <em>(object rejected to be frozen)</em></div>
</li>
</ul>
</li>
</ol>

<p>
    i. Return O.
</p>
<ol>
<li class="level1"><div class="li"> Else, perform the regular Object.freeze steps according to 15.2.3.9, starting from step 2.</div>
</li>
</ol>

<p>
 <strong> 15.2.3.10 Object.preventExtensions ( O ) </strong>
</p>

<p>
When the <strong>preventExtensions</strong> function is called with argument O, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> If Type(O) is not Object throw a TypeError exception.</div>
</li>
<li class="level1"><div class="li"> If O is a Proxy,</div>
<ul>
<li class="level2"><div class="li"> a. Let handler be the value of the [[Handler]] internal property of O.</div>
</li>
<li class="level2"><div class="li"> b. Let target be the value of the [[Target]] internal property of O.</div>
</li>
<li class="level2"><div class="li"> c. Let trap be the result of calling GetTrap(handler, &ldquo;preventExtensions&rdquo;).</div>
</li>
<li class="level2"><div class="li"> d. If trap is undefined,</div>
<ul>
<li class="level3"><div class="li"> i. Return the result of calling the built-in function Reflect.preventExtensions(target).</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> e. Let trapResult be the result of calling the [[Call]] internal method of trap providing handler as the this value, with target as the first argument.</div>
</li>
<li class="level2"><div class="li"> f. Let success be ToBoolean(trapResult)</div>
</li>
<li class="level2"><div class="li"> g. If success is true and the [[Extensible]] internal property of target is true,</div>
<ul>
<li class="level3"><div class="li"> i. throw a TypeError <em>(cannot report extensible object as non-extensible)</em></div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> h. If success is false, throw a TypeError <em>(object rejected to be made non-extensible)</em></div>
</li>
<li class="level2"><div class="li"> i. Return O.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Else, set the [[Extensible]] internal property of O to false.</div>
</li>
<li class="level1"><div class="li"> Return O.</div>
</li>
</ol>

<p>
 <strong> 15.2.3.11 Object.isSealed ( O ) </strong>
</p>

<p>
When the <strong>isSealed</strong> function is called with argument O, the following steps are taken:
</p>
<pre class="file">
  1. If Type(O) is not Object throw a TypeError exception.
  2. If O is a proxy,
    * a. Let handler be the value of the %%[[Handler]]%% internal property of O.
    * b. Let target be the value of the %%[[Target]]%% internal property of O.
    * c. Let trap be the result of calling GetTrap(handler, &quot;isSealed&quot;).
    * d. If trap is undefined,
      * i. Return the result of calling the built-in function Reflect.isSealed(target).
    * e. Let trapResult be the result of calling the %%[[Call]]%% internal method of trap providing handler as the this value, with target as the first argument.
    * f. Let proxyIsSealed be ToBoolean(trapResult)
    * g. Let targetIsSealed be the result of calling the built-in Object.isSealed(target)
    * h. If proxyIsSealed and targetIsSealed are not the same,
      * i. Throw a TypeError //(cannot report a non-sealed object as sealed or vice versa)//
    * i. Return targetIsSealed
  3. Else, perform the regular Object.isSealed steps according to 15.2.3.11, starting from step 2.
</pre>

<p>
<strong> 15.2.3.12 Object.isFrozen ( O ) </strong>
</p>

<p>
When the <strong>isFrozen</strong> function is called with argument O, the following steps are taken:
</p>
<pre class="file">
  1. If Type(O) is not Object throw a TypeError exception.
  2. If O is a proxy,
    * a. Let handler be the value of the %%[[Handler]]%% internal property of O.
    * b. Let target be the value of the %%[[Target]]%% internal property of O.
    * c. Let trap be the result of calling GetTrap(handler, &quot;isFrozen&quot;).
    * d. If trap is undefined,
      * i. Return the result of calling the built-in function Reflect.isFrozen(target).
    * e. Let trapResult be the result of calling the %%[[Call]]%% internal method of trap providing handler as the this value, with target as the first argument.
    * f. Let proxyIsFrozen be ToBoolean(trapResult)
    * g. Let targetIsFrozen be the result of calling the built-in Object.isFrozen(target)
    * h. If proxyIsFrozen and targetIsFrozen are not the same,
      * i. Throw a TypeError //(cannot report a non-frozen object as frozen or vice versa)//
    * i. Return targetIsFrozen
  3. Else, perform the regular Object.isFrozen steps according to 15.2.3.12, starting from step 2.
</pre>

<p>
<strong> 15.2.3.13 Object.isExtensible ( O ) </strong>
</p>

<p>
When the <strong>isExtensible</strong> function is called with argument O, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> If Type(O) is not Object throw a TypeError exception.</div>
</li>
<li class="level1"><div class="li"> If O is a proxy,</div>
<ul>
<li class="level2"><div class="li"> a. Return the result of calling the [[Extensible]] internal accessor of O.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Else, return the Boolean value of the [[Extensible]] internal property of O.</div>
</li>
</ol>

<p>
 <strong> 15.2.3.14 Object.keys ( O ) </strong>
</p>

<p>
When the <strong>keys</strong> function is called with argument O, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> If Type(O) is not Object throw a TypeError exception.</div>
</li>
<li class="level1"><div class="li"> If O is a proxy</div>
<ul>
<li class="level2"><div class="li"> a. Let handler be the value of the [[Handler]] internal property of O.</div>
</li>
<li class="level2"><div class="li"> b. Let target be the value of the [[Target]] internal property of O.</div>
</li>
<li class="level2"><div class="li"> c. Let trap be the result of calling GetTrap(handler, &ldquo;keys&rdquo;).</div>
</li>
<li class="level2"><div class="li"> d. If trap is undefined,</div>
<ul>
<li class="level3"><div class="li"> i. Return the result of calling the built-in function Reflect.keys(target).</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> e. Let trapResult be the result of calling the [[Call]] internal method of trap providing handler as the this value, with target as the first argument.</div>
</li>
<li class="level2"><div class="li"> f. If Type(trapResult) is not Object, throw a TypeError exception</div>
</li>
<li class="level2"><div class="li"> g. Let len be the result of calling the [[Get]] internal method of trapResult with argument &ldquo;length&rdquo;</div>
</li>
<li class="level2"><div class="li"> h. Let n be ToUint32(len)</div>
</li>
<li class="level2"><div class="li"> i. Let array be the result of creating a new Object as if by the expression new Array(n) where Array is the standard built-in constructor with that name.</div>
</li>
<li class="level2"><div class="li"> j. Let index be 0.</div>
</li>
<li class="level2"><div class="li"> k. Repeat, while index &lt; n</div>
<ul>
<li class="level3"><div class="li"> i. Let nextElement be the result of calling the [[Get]] internal method of trapResult with argument ToString(index).</div>
</li>
<li class="level3"><div class="li"> ii. Let s be ToString(nextElement)</div>
</li>
<li class="level3"><div class="li"> iii. If s is the same as any previous s obtained in this loop, throw a TypeError exception.</div>
</li>
<li class="level3"><div class="li"> iv. Let isFixed be the result of calling target.[[HasOwnProperty]](s)</div>
</li>
<li class="level3"><div class="li"> iv. If the [[Extensible]] internal property of target is false and isFixed is false,</div>
<ol>
<li class="level4"><div class="li"> throw a TypeError <em>(cannot list a new property on a non-extensible object)</em></div>
</li>
</ol>
</li>
<li class="level3"><div class="li"> v. Call the [[DefineOwnProperty]] internal method of array with arguments ToString(index), the PropertyDescriptor {[[Value]]: s, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and true.</div>
</li>
<li class="level3"><div class="li"> vi. Increment index by 1.</div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> l. Let ownProps be the result of calling the built-in Object.getOwnPropertyDescriptor(target), an Array of Strings</div>
</li>
<li class="level2"><div class="li"> m. For each element string P in ownProps not present in array,</div>
<ul>
<li class="level3"><div class="li"> i. Let targetDesc be the result of calling target.[[GetOwnProperty]](P)</div>
</li>
<li class="level3"><div class="li"> ii. If targetDesc is not undefined, and targetDesc.[[Configurable]] is false, throw a TypeError <em>(cannot skip non-configurable enumerable property)</em></div>
</li>
<li class="level3"><div class="li"> iii. If the [[Extensible]] internal property of target is false, and targetDesc is not undefined, throw a TypeError <em>(cannot report existing own property as non-existent on a non-extensible object)</em></div>
</li>
</ul>
</li>
<li class="level2"><div class="li"> n. Return array.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Else, perform the regular Object.keys steps according to 15.2.3.14, starting from step 2.</div>
</li>
</ol>

<p>
 <strong> 15.2.4.4 Object.prototype.valueOf ( ) </strong> 
</p>
<ol>
<li class="level1"><div class="li"> Let O be the result of calling ToObject passing the this value as the argument.</div>
</li>
<li class="level1"><div class="li"> If O is a proxy,</div>
<ul>
<li class="level2"><div class="li"> a. Let target be the [[Target]] internal property of O</div>
</li>
<li class="level2"><div class="li"> b. Return the result of calling Object.prototype.valueOf passing target as the this value.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> If O is the result of calling the Object constructor with a host object (15.2.2.1), then</div>
<ul>
<li class="level2"><div class="li"> a. Return either O or another value such as the host object originally passed to the constructor. The specific result that is returned is implementation-defined.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Return O.</div>
</li>
</ol>

<p>
 <strong> 15.2.4.5 Object.prototype.hasOwnProperty ( V ) </strong>
</p>

<p>
When the hasOwnProperty method is called with argument V, the following steps are taken:
</p>
<ol>
<li class="level1"><div class="li"> Let P be ToString(V).</div>
</li>
<li class="level1"><div class="li"> Let O be the result of calling ToObject passing the this value as the argument.</div>
</li>
<li class="level1"><div class="li"> Return the result of calling the [[HasOwnProperty]] internal method of O passing P as the argument.</div>
</li>
</ol>

<p>
 <strong> 15.3.4.2 Function.prototype.toString ( O ) </strong>
</p>

<p>
When called on a Proxy that is callable (i.e. whose target has a [[Call]] internal method), returns the result of applying the built-in Function.prototype.toString on the Proxy&rsquo;s [[Target]]. Otherwise, throw the same TypeError that would be thrown if this function is applied to a non-function object.
</p>

<p>
For a revoked proxy, IsCallable is false so this operation throws a TypeError.
</p>

</div>
<!-- SECTION [25853-40646] -->
<a name="iteration_and_enumeration"></a><h2>Iteration and Enumeration</h2>
<div class="level2">

<p>
 <strong>[[Enumerate]](includePrototype, onlyEnumerable)</strong>
</p>

<p>
(when <code>includePrototype</code> is false and <code>onlyEnumerable</code> is true, should trigger <code>keys</code> trap. when <code>includePrototype</code> is false and <code>onlyEnumerable</code> is false, should trigger <code>getOwnPropertyNames</code> trap.)
</p>

<p>
This method is called on a proxy P when enumerated via a <code>for-in</code> loop. In this case, <code>includePrototype</code> and <code>onlyEnumerable</code> should both be true: 
</p>
<ol>
<li class="level1"><div class="li"> Let target be the value of the [[Target]] internal property of P.</div>
</li>
<li class="level1"><div class="li"> Let handler be the value of the [[Handler]] internal property of P.</div>
</li>
<li class="level1"><div class="li"> Let trap be the result of calling GetTrap(handler, &ldquo;enumerate&rdquo;)</div>
</li>
<li class="level1"><div class="li"> If trap is undefined</div>
<ul>
<li class="level2"><div class="li"> a. Let trapResult be the result of calling the built-in Reflect.enumerate(target)</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Else,</div>
<ul>
<li class="level2"><div class="li"> a. Let trapResult be the result of calling the [[Call]] internal method of trap passing handler as the this value and target as the sole argument.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> If Type(trapResult) is not Object, throw a TypeError</div>
</li>
<li class="level1"><div class="li"> Return a new Iterator(target, trapResult) object whose &ldquo;next&rdquo; method is specified below</div>
</li>
</ol>

<p>
 The &ldquo;next&rdquo; method of the returned Iterator, wrapping a target object T and an iterator I is as follows:
</p>

<p>
<strong>Iterator(T, I).next()</strong>: 
</p>
<ol>
<li class="level1"><div class="li"> Let nextI be the result of calling I.[[Get]](&quot;next&quot;)</div>
</li>
<li class="level1"><div class="li"> If not IsCallable(nextI), throw a TypeError</div>
</li>
<li class="level1"><div class="li"> Let v be the result of calling the [[Call]] internal method of nextI, passing I as the this-binding and no arguments.</div>
</li>
<li class="level1"><div class="li"> If the above call terminates abnormally due to a <code>StopIteration</code> exception,</div>
<ul>
<li class="level2"><div class="li"> a. Let targetKeys be the result of calling the built-in Reflect.keys(target), an Array of Strings</div>
</li>
<li class="level2"><div class="li"> b. For each property name P previously enumerated by I that is not present in targetKeys,</div>
<ul>
<li class="level3"><div class="li"> i. Let targetDesc be the result of calling target.[[GetOwnProperty]](P)</div>
</li>
<li class="level3"><div class="li"> ii. If targetDesc is not undefined, and targetDesc.[[Configurable]] is false, throw a TypeError <em>(cannot skip non-configurable enumerable property)</em></div>
</li>
<li class="level3"><div class="li"> iii. If the [[Extensible]] internal property of target is false, and targetDesc is not undefined, throw a TypeError <em>(cannot report existing own property as non-existent on a non-extensible object)</em></div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Else, return ToString(v)</div>
</li>
</ol>

<p>
 Notes:
</p>
<ul>
<li class="level1"><div class="li"> If <code>for-in</code> visits a non-proxy object <code>obj</code> whose [[Prototype]] is a Proxy object <code>p</code>, then the original for-in algorithm must be modified such that, after all of <code>obj</code>&lsquo;s properties have been enumerated, the &ldquo;enumerate&rdquo; trap of <code>p</code> is invoked, returning an iterator <code>I</code>. The for-in algorithm should then continue enumerating properties based on <code>I</code>. After <code>p</code>&lsquo;s properties have been enumerated in this way, the for-in algorithm should not attempt to enumerate the properties of <code>p</code>&lsquo;s prototype.</div>
</li>
</ul>

<p>
 <strong>[[Iterate]]()</strong>
</p>

<p>
The [[Iterate]] operation on a Proxy P behaves the same as on an Object. It looks up the value of a property with the unique name <code>iterator</code>. For a proxy, this triggers the &ldquo;get&rdquo; trap on the handler.
</p>

</div>
<!-- SECTION [40647-43656] -->
<a name="reflect_module"></a><h1>@reflect Module</h1>
<div class="level1">

<p>
 See the <a href="doku.php%3Fid=harmony:reflect_api.html" class="wikilink1" title="harmony:reflect_api" onclick="return svchk()" onkeypress="return svchk()">@reflect module</a>.
</p>

</div>
<!-- SECTION [43657-43738] -->
<a name="virtual_object_handler"></a><h1>Virtual Object handler</h1>
<div class="level1">

<p>
 See <a href="doku.php%3Fid=harmony:virtual_object_api.html" class="wikilink1" title="harmony:virtual_object_api" onclick="return svchk()" onkeypress="return svchk()">virtual object api</a>
</p>

</div>
<!-- SECTION [43739-43814] -->
<a name="auxiliary_functions"></a><h1>Auxiliary Functions</h1>
<div class="level1">

<p>
 ToCompletePropertyDescriptor creates a fresh, complete, internal property descriptor.
</p>

<p>
<strong> Aux.1 ToCompletePropertyDescriptor ( Obj ) </strong>
</p>
<ol>
<li class="level1"><div class="li"> If Type(Obj) is not Object, throw a TypeError exception</div>
</li>
<li class="level1"><div class="li"> Let desc be the result of calling ToPropertyDescriptor(Obj)</div>
</li>
<li class="level1"><div class="li"> If IsGenericDescriptor(desc) or IsDataDescriptor(desc) is true, then</div>
<ul>
<li class="level2"><div class="li"> a. If the value of an attribute field of desc, considered as a data descriptor, is absent, set it to its default value.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Else if the value of an attribute field of desc, considered as an accessor descriptor, is absent, set it to its default value.</div>
</li>
<li class="level1"><div class="li"> Return desc.</div>
</li>
</ol>

<p>
 FromGenericPropertyDescriptor creates a new ECMAScript Object based on a generic (potentially incomplete) internal property descriptor.
</p>

<p>
<strong> Aux.2 FromGenericPropertyDescriptor ( Desc ) </strong>
</p>
<ol>
<li class="level1"><div class="li"> If Desc is undefined, return undefined</div>
</li>
<li class="level1"><div class="li"> Let obj be the result of creating a new object as if by the expression new Object() where Object is the standard built-in constructor with that name.</div>
</li>
<li class="level1"><div class="li"> If Desc has a [[Value]] field,</div>
<ul>
<li class="level2"><div class="li"> a. Call the [[DefineOwnProperty]] internal method of obj with arguments &ldquo;value&rdquo;, Property Descriptor {[[Value]]: Desc.[[Value]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and true.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> If Desc has a [[Writable]] field,</div>
<ul>
<li class="level2"><div class="li"> a. Call the [[DefineOwnProperty]] internal method of obj with arguments &ldquo;writable&rdquo;, Property Descriptor {[[Value]]: Desc.[[Writable]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and true.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> If Desc has a [[Get]] field,</div>
<ul>
<li class="level2"><div class="li"> a. Call the [[DefineOwnProperty]] internal method of obj with arguments &ldquo;get&rdquo;, Property Descriptor {[[Value]]: Desc.[[Get]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and true.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> If Desc has a [[Set]] field,</div>
<ul>
<li class="level2"><div class="li"> a. Call the [[DefineOwnProperty]] internal method of obj with arguments &ldquo;set&rdquo;, Property Descriptor {[[Value]]: Desc.[[Set]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and true.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> If Desc has a [[Enumerable]] field,</div>
<ul>
<li class="level2"><div class="li"> a. Call the [[DefineOwnProperty]] internal method of obj with arguments &ldquo;enumerable&rdquo;, Property Descriptor {[[Value]]: Desc.[[Enumerable]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and true.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> If Desc has a [[Configurable]] field,</div>
<ul>
<li class="level2"><div class="li"> a. Call the [[DefineOwnProperty]] internal method of obj with arguments &ldquo;configurable&rdquo;, Property Descriptor {[[Value]]: Desc.[[Configurable]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, and true.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Return obj</div>
</li>
</ol>

<p>
 <strong> Aux.3 CopyAttributes ( FromDescObj, ToDescObj ) </strong>
</p>

<p>
When the abstract operation CopyAttributes is called with objects FromDescObj and ToDescObj, the following steps are taken: 
</p>
<ol>
<li class="level1"><div class="li"> For each enumerable property name N in FromDescObj that is not a standard property descriptor attribute name,</div>
<ul>
<li class="level2"><div class="li"> a. Let attr be the result of calling the [[Get]] internal method of FromDescObj with N.</div>
</li>
<li class="level2"><div class="li"> b. Call the [[DefineOwnProperty]] internal method of ToDescObj with arguments N, the Property Descriptor {[[Value]]: attr, [[Writable]]:true, [[Enumerable]]:true, [[Configurable]]:true}, and true.</div>
</li>
</ul>
</li>
</ol>

<p>
 Notes:
</p>
<ul>
<li class="level1"><div class="li"> The standard property descriptor attribute names are <code>&ldquo;value&rdquo;</code>, <code>&ldquo;writable&rdquo;</code>, <code>&ldquo;get&rdquo;</code>, <code>&ldquo;set&rdquo;</code>, <code>&ldquo;enumerable&rdquo;</code> and <code>&ldquo;configurable&rdquo;</code>.</div>
</li>
<li class="level1"><div class="li"> step 1 is determined as if by performing a for-in loop over FromDescObj. If FromDescObj is a Proxy, this will trigger that Proxy&rsquo;s &ldquo;enumerate&rdquo; trap.</div>
</li>
<li class="level1"><div class="li"> Any enumerable own and inherited properties of FromDescObj, whose name is non-standard, are treated as &ldquo;custom&rdquo; attributes. This is consistent with <code>ToPropertyDescriptor</code>&lsquo;s use of [[HasProperty]] and [[Get]] to determine the standard attributes (Section 8.10.5).</div>
</li>
<li class="level1"><div class="li"> Custom attributes are defined as own enumerable, configurable, writable data properties on the new descriptor object. This is consistent with <code>FromPropertyDescriptor</code>&lsquo;s definition of the standard attributes (Section 8.10.4)</div>
</li>
</ul>

<p>
 <strong> Aux.4 IsCompatibleDescriptor(Extensible, OriginalDesc, NewDesc) </strong>
</p>

<p>
When the abstract operation IsCompatibleDescriptor is called with boolean Extensible and internal property descriptors OriginalDesc and NewDesc, the following steps are taken:
</p>
<ol>
<li class="level1"><div class="li"> If OriginalDesc is undefined and Extensible is false, return false.</div>
</li>
<li class="level1"><div class="li"> If OriginalDesc is undefined and Extensible is true, then return true.</div>
</li>
<li class="level1"><div class="li"> Return true, if every field in NewDesc is absent.</div>
</li>
<li class="level1"><div class="li"> Return true, if every field in NewDesc also occurs in current and the value of every field in NewDesc is the same value as the corresponding field in OriginalDesc when compared using the SameValue algorithm (9.12).</div>
</li>
<li class="level1"><div class="li"> If the [[Configurable]] field of OriginalDesc is false then</div>
<ul>
<li class="level2"><div class="li"> a. Return false, if the [[Configurable]] field of NewDesc is true.</div>
</li>
<li class="level2"><div class="li"> b. Return false, if the [[Enumerable]] field of NewDesc is present and the [[Enumerable]] fields of OriginalDesc and NewDesc are the Boolean negation of each other.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> If IsGenericDescriptor(NewDesc) is true, return true.</div>
</li>
<li class="level1"><div class="li"> Else, if IsDataDescriptor(OriginalDesc) and IsDataDescriptor(NewDesc) have different results, then</div>
<ul>
<li class="level2"><div class="li"> a. Return false, if the [[Configurable]] field of OriginalDesc is false.</div>
</li>
<li class="level2"><div class="li"> b. Return true</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Else, if IsDataDescriptor(OriginalDesc) and IsDataDescriptor(NewDesc) are both true,</div>
<ul>
<li class="level2"><div class="li"> a. If the [[Configurable]] field of OriginalDesc is false, then</div>
<ul>
<li class="level3"><div class="li"> i. Return false, if the [[Writable]] field of OriginalDesc is false and the [[Writable]] field of NewDesc is true.</div>
</li>
<li class="level3"><div class="li"> ii. If the [[Writable]] field of OriginalDesc is false, then</div>
<ul>
<li class="level4"><div class="li"> 1. Return false, if the [[Value]] field of NewDesc is present and SameValue(NewDesc.[[Value]], OriginalDesc.[[Value]]) is false.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level2"><div class="li"> b. Else, return true.</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Else, IsAccessorDescriptor(OriginalDesc) and IsAccessorDescriptor(NewDesc) are both true so,</div>
<ul>
<li class="level2"><div class="li"> a. If the [[Configurable]] field of OriginalDesc is false, then</div>
<ul>
<li class="level3"><div class="li"> i. Return false, if the [[Set]] field of NewDesc is present and SameValue(NewDesc.[[Set]], OriginalDesc.[[Set]]) is false.</div>
</li>
<li class="level3"><div class="li"> ii. Return false, if the [[Get]] field of NewDesc is present and SameValue(NewDesc.[[Get]], OriginalDesc.[[Get]]) is false.</div>
</li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Return true.</div>
</li>
</ol>

<p>
 Note: IsCompatibleDescriptor(O.[[Extensible]], O.[[GetOwnProperty]](P), Desc) is equivalent to O.[[DefineOwnProperty]](P,Desc), with all Reject statements in ES5 8.12.9 [[DefineOwnProperty]] changed into returning false, and all success cases simply returning true rather than trying to define a new property.
</p>

<p>
<strong> Aux.5 GetTrap ( H, P ) </strong>
</p>

<p>
When the abstract operation GetTrap is called with a handler object O and a property name P representing a trap name, the following steps are taken:
</p>
<ol>
<li class="level1"><div class="li"> Let trap be the result of calling H.[[Get]](P)</div>
</li>
<li class="level1"><div class="li"> If trap is undefined, return undefined</div>
</li>
<li class="level1"><div class="li"> If IsCallable(trap) is false, throw a TypeError</div>
</li>
<li class="level1"><div class="li"> Return trap</div>
</li>
</ol>

</div>
<!-- SECTION [43815-50925] -->
<a name="references"></a><h1>References</h1>
<div class="level1">
<ul>
<li class="level1"><div class="li"> A <a href="http://code.google.com/p/es-lab/source/browse/trunk/src/proxies/DirectProxies.js" class="urlextern" target="_blank" title="http://code.google.com/p/es-lab/source/browse/trunk/src/proxies/DirectProxies.js" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">prototype implementation</a> that defines <a href="doku.php%3Fid=harmony:direct_proxies.html" class="wikilink1" title="harmony:direct_proxies" onclick="return svchk()" onkeypress="return svchk()">direct proxies</a> in terms of the previous <a href="doku.php%3Fid=harmony:proxies.html" class="wikilink1" title="harmony:proxies" onclick="return svchk()" onkeypress="return svchk()">proxies</a> <acronym title="Application Programming Interface">API</acronym>. Tested on Firefox 8.</div>
</li>
</ul>

</div>
<!-- SECTION [50926-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/5/55eeb164df7c074f330cc333f49cfc41.xhtml used -->
</body>
</html>
