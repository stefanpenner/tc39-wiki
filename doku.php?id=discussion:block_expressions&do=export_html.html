<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=discussion:block_expressions&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=discussion" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=discussion:block_expressions&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=discussion:block_expressions&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=discussion:block_expressions&amp;do=export_html.html#let_ref_as_a_reformed_with" class="toc">&quot;let ref&quot; as a &quot;reformed with&quot;</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=discussion:block_expressions&amp;do=export_html.html#notes" class="toc">Notes</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=discussion:block_expressions&amp;do=export_html.html#older_commentsclarifications_all_addressed_by_the_proposal" class="toc">Older Comments/Clarifications, all addressed by the proposal</a></span><ul class="toc">
<li class="level2"><span class="li"><a href="doku.php%3Fid=discussion:block_expressions&amp;do=export_html.html#possible_extensions_and_alternatives" class="toc">Possible extensions and alternatives</a></span><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:block_expressions&amp;do=export_html.html#comments" class="toc">Comments</a></span></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=discussion:block_expressions&amp;do=export_html.html#old_proposal_discussion" class="toc">Old Proposal &amp; Discussion</a></span><ul class="toc">
<li class="clear"><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:block_expressions&amp;do=export_html.html#proposal" class="toc">Proposal</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:block_expressions&amp;do=export_html.html#comparison_to_standard_idiom" class="toc">Comparison to Standard Idiom</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:block_expressions&amp;do=export_html.html#rationale" class="toc">Rationale</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:block_expressions&amp;do=export_html.html#rejected_alternatives" class="toc">Rejected Alternatives</a></span><ul class="toc">
<li class="clear"><ul class="toc">
<li class="level5"><span class="li"><a href="doku.php%3Fid=discussion:block_expressions&amp;do=export_html.html#point_1" class="toc">Point 1</a></span></li>
<li class="level5"><span class="li"><a href="doku.php%3Fid=discussion:block_expressions&amp;do=export_html.html#point_2" class="toc">Point 2</a></span></li>
<li class="level5"><span class="li"><a href="doku.php%3Fid=discussion:block_expressions&amp;do=export_html.html#point_3" class="toc">Point 3</a></span></li>
</ul>
</li>
</ul>
</li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=discussion:block_expressions&amp;do=export_html.html#counterproposal" class="toc">Counterproposal</a></span></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<p>
This is a discussion page for <a href="doku.php%3Fid=proposals:block_expressions.html" class="wikilink1" title="proposals:block_expressions" onclick="return svchk()" onkeypress="return svchk()">block_expressions</a>.
</p>

<a name="let_ref_as_a_reformed_with"></a><h1>&quot;let ref&quot; as a &quot;reformed with&quot;</h1>
<div class="level1">

<p>
 This is not a proposal, just some musings.  (As noted below, this feature probably does not pay for itself.  &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/05/09 23:37</em>)
</p>

<p>
In Modula-3 the <code>with</code> statement is a <code>let</code> as in ECMAScript except that it can alias lvalues:
</p>
<pre class="code modula-3">    WITH x = obj.f DO
        x := 10         (* assigns to obj.f *)
    END
</pre>
<p>
We can introduce a similar form in ECMAScript in <code>let</code> statements and <code>let</code> expressions:
</p>
<pre class="code javascript">    let <span class="br0">&#40;</span>ref x : int = obj.<span class="me1">f</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
       x = <span class="nu0">10</span>;
    <span class="br0">&#125;</span></pre><pre class="code javascript">    x = let <span class="br0">&#40;</span>ref x : int = obj.<span class="me1">f</span><span class="br0">&#41;</span> x+<span class="nu0">10</span>*x</pre>
<p>
The purpose would be to make it more convenient to write code that does not use <code>with</code> but instead is entirely lexically scoped and can be typed statically.
</p>

<p>
The syntactic keyword <code>ref</code> makes x an alias for the lvalue on the right-hand-side of &ldquo;=&rdquo;; the type designator for x, if present, must match exactly the type of that lvalue.  (It can&rsquo;t be a supertype since assignments to x may then break the type constraint on obj.f; it also can&rsquo;t be a subtype, because obj.f may hold (or be given through direct assignment) a value that is not of that subtype.) 
</p>
<hr noshade="noshade" size="1" />

<p>
Right, since a <code>ref</code> is readable and writable, the type of the referent must be invariant.
</p>

<p>
This leads, I&rsquo;m sure you realize, directly to call by reference. <img src="lib/images/smileys/icon_razz.gif" align="middle" alt=":-P" />
</p>

<p>
I say this is overkill.  It is not the reform of <code>with</code> that I had in mind, which might use new syntax, or at least new features such as type annotations and structural type definitions, to reuse most or all of the familiar <code>with</code> statement syntax, but avoid the dynamic scope pollution.
</p>

<p>
As you noted in last week&rsquo;s meeting, if the object named in the <code>with</code> head has precise type, meaning (I think) a sealed class with a known set of member names, then the dynamic scope pollution is abated.  This is well and good, but will it match common use-cases, or will users demand that the dynamic type of the object cause other names to appear in scope in the body? If so, the answer is to use <code>Object!</code> or wider as the type of the object expression in the <code>with</code> head.
</p>

<p>
But rather than require renaming that expression&rsquo;s value with a loosely typed variable, why not add syntax reminiscent of <a href="doku.php%3Fid=discussion:switch_class.html" class="wikilink1" title="discussion:switch_class" onclick="return svchk()" onkeypress="return svchk()">switch class</a>:
</p>
<pre class="code javascript">  <span class="kw1">with</span> <span class="br0">&#40;</span>obj : T<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    ...
  <span class="br0">&#125;</span></pre>
<p>
where T could be any type expression, including a structural type, and limit the scope pollution to T&rsquo;s members?  This enables <code>with</code> to have a well-typed &ldquo;view&rdquo; of <code>obj</code>, without dynamic scope bugaboos.
</p>

<p>
Perhaps this is obvious and easily agreed to.  It&rsquo;s more what I had in mind in urging reform of <code>with</code>.  It is not <code>ref</code> by a long shot.  I like <code>ref</code> (for parameters too) in a world where everything is free, but in the real world it seems not worth the costs.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/05/09 10:24</em>
</p>

<p>
Interesting issue about call-by-reference; I had imagined that a reference would not be first-class, its value would be taken if it were used in an lvalue context (a la references in C++).
</p>

<p>
But I generally agree with you, I don&rsquo;t think this feature is cost effective, and I think a &ldquo;view&rdquo; like you suggest is probably better.  Though the object must probably match the type exactly in the fields that the type contains, like for &ldquo;let ref&rdquo;, not the usual subtyping rule.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/05/09 12:50</em>
</p>

<p>
I&rsquo;ll write up a <a href="doku.php%3Fid=discussion:reformed_with.html" class="wikilink1" title="discussion:reformed_with" onclick="return svchk()" onkeypress="return svchk()">reformed with</a> proposal, noting the precise type requirement.  Feel free to move all my comments here down, or out <img src="lib/images/smileys/icon_wink.gif" align="middle" alt=";-)" />.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/05/09 16:38</em>
</p>

</div>
<!-- SECTION [65-3703] -->
<a name="notes"></a><h1>Notes</h1>
<div class="level1">

<p>
 I&rsquo;ve implemented the various forms of <code>let</code> in my test compiler.  One slightly absurd/amusing consequence of the rules about <code>let</code> not creating properties like <code>var</code> does is that the following program is legal and evaluates to 30.
</p>
<pre class="code javascript">   <span class="kw2">function</span> f<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="nu0">20</span>; <span class="br0">&#125;</span>
   let <span class="kw2">function</span> f<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="nu0">10</span>; <span class="br0">&#125;</span>
   f<span class="br0">&#40;</span><span class="br0">&#41;</span> + <span class="kw1">this</span>.<span class="me1">f</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;</pre>
<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/04/11 04:48</em>
</p>

<p>
This probably just demonstrates my ignorance about the variable object, but why isn&rsquo;t a <code>let</code> at the top level of a function declaration the same as a <code>var</code>? That is, Jeff says below that a <code>var</code> introduces a name in the innermost enclosing variable object, and a <code>let</code> introduces a name in the innermost block. If the innermost block <em>is</em> the nearest enclosing function body, why isn&rsquo;t that name a part of the variable object?
</p>

<p>
On a separated but not unrelated note, what is the behavior of the following?
</p>
<pre class="code javascript"><span class="br0">&#123;</span>
    <span class="kw1">eval</span><span class="br0">&#40;</span><span class="st0">"let x = 1"</span><span class="br0">&#41;</span>
    <span class="kw3">print</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span>
<span class="br0">&#125;</span></pre>
<p>
 &mdash; <em><a href="mailto:%26%23x64%3B%26%23x68%3B%26%23x65%3B%26%23x72%3B%26%23x6d%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x63%3B%26%23x63%3B%26%23x73%3B%26%23x2e%3B%26%23x6e%3B%26%23x65%3B%26%23x75%3B%26%23x2e%3B%26%23x65%3B%26%23x64%3B%26%23x75%3B" class="mail" title="&#x64;&#x68;&#x65;&#x72;&#x6d;&#x61;&#x6e;&#x40;&#x63;&#x63;&#x73;&#x2e;&#x6e;&#x65;&#x75;&#x2e;&#x65;&#x64;&#x75;">Dave Herman</a> 2006/04/24 08:12</em>
</p>

<p>
In response to your first question: <code>let</code> at the top of a function definition <em>is</em> the same thing as a <code>var</code>.  Note carefully that the example uses the code word <code>program</code>.  The example wouldn&rsquo;t work on the top level of a function, where <code>var</code>, <code>let</code>, and <code>function</code> all operate on the same variable object.
</p>

<p>
The behavior of your second example is that the value of <code>x</code> bound outside that block, if any, is printed.  The reason for this is that <code>eval</code> works on programs and that <code>let</code> in a program defines properties on a temporary variable object created for the program, not on the program&rsquo;s surrounding variable object.
</p>

<p>
&ldquo;Jeff&rsquo;s rule&rdquo; is neat.  Initially I thought it complicated things, and in a way it does.  But it allows initializer code to be written more easily and emasculates eval a little bit, too.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/04/26 04:30</em>
</p>

<p>
Another way to say it is that <code>eval</code>&lsquo;s variable object is dynamically scoped &ndash; it&rsquo;s the same as its caller&rsquo;s variable object &ndash; while <code>let</code> never affects dynamically scoped variable object.  <code>let</code> always addresses a slot in the nearest enclosing block; or in the implicit block around a <code>for</code> loop, if the <code>let</code> is in the head of the loop; or in the implicit block around a program, if at top level outside of any function body.
</p>

<p>
A function body is not a program, and as Lars notes there is no way to distinguish <code>var</code> and <code>let</code> at top level in a function.  The variable object is the activation object, which cannot be accessed (unlike a program&rsquo;s variable object, which has <code>this</code> and probably other names).  Edition 3&rsquo;s semantics attach to productions for the non-terminals <em>Program</em> and <em>FunctionBody</em>; we can use the same distinction.
</p>

<p>
But, is there an advantage to not making this distinction, rather to have an implicit block around function bodies?  Just because the activation object is inaccessible does necessarily mean programmers should have to model <code>var</code> vs. <code>let</code> at &ldquo;top level&rdquo; (in program vs. in function body) differently.  Will programmers be confused by the ability to have
</p>
<pre class="code javascript">  <span class="kw2">var</span> x = <span class="nu0">42</span>; let x = <span class="st0">"moo"</span>
  <span class="kw3">print</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span>      <span class="co1">// &quot;moo&quot;</span>
  <span class="kw3">print</span><span class="br0">&#40;</span><span class="kw1">this</span>.<span class="me1">x</span><span class="br0">&#41;</span> <span class="co1">// 42</span></pre>
<p>
but have <code>&ldquo;moo&rdquo;</code> printed twice if this same global code is wrapped in a function and called?
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/04/26 09:03</em>
</p>

<p>
During today&rsquo;s <a href="doku.php%3Fid=meetings:minutes_apr_26_2006.html" class="wikilink1" title="meetings:minutes_apr_26_2006" onclick="return svchk()" onkeypress="return svchk()">meeting</a>, we agreed to unify program and function body handling, so that both get an implicit block.  Lars pointed out the problem for function body without this implicit block: <code>var</code> and <code>let</code> can&rsquo;t be the same thing for this example:
</p>
<pre class="code javascript">  <span class="kw2">function</span> f<span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    let x = <span class="nu0">42</span>
    arguments<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span> = <span class="nu0">44</span>
    <span class="kw3">print</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span>
  <span class="br0">&#125;</span></pre>
<p>
or we have a nasty aliasing problem via <code>arguments</code> (this follows because <code>var x</code> in a function that has a formal parameter named <code>x</code> does not shadow the formal, rather it refers to the formal, in ECMA-262 Editions 1-3).
</p>

<p>
Therefore top-level <code>let</code> in a function body must shadow any formal parameter of the same name.  So we want that implicit block.  The list of cases that get an implicit block is: 
</p>
<ul>
<li class="level1"><div class="li"> global code</div>
</li>
<li class="level1"><div class="li"> package code</div>
</li>
<li class="level1"><div class="li"> class initialization code</div>
</li>
<li class="level1"><div class="li"> function body</div>
</li>
<li class="level1"><div class="li"> <code>for</code> loop containing <code>let</code> in loop head</div>
</li>
</ul>

<p>
 Anything else?
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/04/26 23:58</em>
</p>

</div>
<!-- SECTION [3704-8162] -->
<a name="older_commentsclarifications_all_addressed_by_the_proposal"></a><h1>Older Comments/Clarifications, all addressed by the proposal</h1>
<div class="level1">
<ul>
<li class="level1"><div class="li"> There are places where a <code>var</code> causes an object property to be created, as in global code and in class definitions. Rather than replace the use of <code>var</code> in those cases (not sure that was being proposed), does it make sense to distinguish the meaning of <code>let</code> from <code>var</code> to include that a <code>let</code> declaration introduces a name to the innermost enclosing block frame, whereas <code>var</code> introduces one to the innermost enclosing variable object  as in E3.</div>
</li>
<li class="level1"><div class="li"> The difference, then, between <code>let</code> and <code>var</code> in global code is then that <code>let</code> decls don&rsquo;t result in slots being created on the variable object. So <code>let</code> declarations that are in scope and not shadowed are visible to lexical references, but not through global <code>this</code> or an alias to global <code>this</code>. Likewise, the use of <code>let</code> inside of a class body would result in a local name in the class initializer, not in an instance variable.</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/03/24 16:28</em>
</p>

<p>
I generally agree with this.  It introduces the notion that code at the global level is running inside an implicit block but I could live with that.  The other alternative is simply to say that <code>let</code> as a &ldquo;better <code>var</code>&rdquo; is not allowed on the global level.  (This does not seem to be much of an issue in the class initializer since there is probably no surprise that there is some sort of implicit block there, but as far as I&rsquo;m concerned we could do the same there.  After all, the let-block statement can be used both places to introduce local bindings.)
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/03/31 03:50</em>
</p>

</div>
<!-- SECTION [8163-9830] -->
<a name="possible_extensions_and_alternatives"></a><h2>Possible extensions and alternatives</h2>
<div class="level2">

<p>
 We could use <code>let function</code> to define a local function and <code>let const</code> to define a local constant:
</p>
<pre class="code">
   let function fib(n) {
     return n &lt; 2 ? n : return fib(n-1) + fib(n-2);
   }
   let const k = 20;
</pre>

<p>
We could also state that <code>var</code> used inside a <code>let</code> block is implicitly interpreted as <code>let</code>.  I did not do this because it introduces a new context-dependent meaning for <code>var</code>; apart from <code>function</code> being illegal in non-top-level contexts, such meaning-change is unprecedented in the language (as far as I can tell).
</p>

</div>
<!-- SECTION [9831-10431] -->
<a name="comments"></a><h3>Comments</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> I agree, context-dependent meanings make code hard to read. We&rsquo;ve been tempted to allow <code>private</code> as an attribute outside of class definitions, but decided against it because it makes the meaning of <code>private</code> context sensitive.</div>
</li>
<li class="level1"><div class="li"> We need something like <code>let const</code>, but then I could live without <code>let function</code> since we would have <code>let const f = function ...</code></div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/03/24 16:54</em> 
</p>
<ul>
<li class="level1"><div class="li"> <code>let const f = function ...</code> includes <code>const</code>, <code>=</code>, and <code>function</code> where only <code>function</code> is strictly necessary.  If <code>let function ...</code> is a special form that makes a lexical binding to a function (and only to that function), there is no need for the semblance of assignment, or for redundant const-ness denotation.</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/03/24 17:31</em> 
</p>
<ul>
<li class="level1"><div class="li"> Fair enough. I won&rsquo;t resist too strongly, but since in E3 function declarations are only allowed at the top level of function and global code, do we want to (need to) introduce them as a special form of general statement in E4?</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/03/24 17:50</em> 
</p>
<ul>
<li class="level1"><div class="li"> Necessity is hard to argue given trade-offs among contingent proposals (only <code>let</code> or something equivalent is &ldquo;necessary&rdquo; if we want block scope), but if we support <code>let const</code>, I want to support <code>let function</code>.  But as I&rsquo;ve said elsewhere, I think syntactic convenience should trump minimalism if there is no cost beyond another production to parse.</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/03/24 18:52</em> 
</p>
<ul>
<li class="level1"><div class="li"> Why do we need <code>let const</code> since there is no compatibility issue with <code>const</code> and edition 3? Let&rsquo;s consider making <code>const</code> scope like <code>let</code>.</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/03/28 18:13</em>  
</p>
<ul>
<li class="level1"><div class="li"> You&rsquo;re right, we could have <code>const</code> be scoped like <code>let</code>, except that <acronym title="JavaScript">JS</acronym> 1.5 and JScript.NET already have <code>const</code> with function/global scope and that probably creates precedent here.  Personally I think that one good reason to have <code>let const</code> is to allow the obvious symmetry to be extended to <code>let function</code>, ie, I think locally scoped functions, constants, and variables are Good, and there should be symmetric syntax for declaring them.  (Although that argument probably calls for <code>let var</code> rather than just plain <code>let</code>.)</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/03/31 04:00</em> 
</p>
<ul>
<li class="level1"><div class="li"> The <code>const</code> horse is out of the barn as Lars noted.  Reforming the language by adding <code>let</code> is great, and suggests symmetry: <code>let const</code>, <code>let function</code>, and <code>let var</code>.  But the last is needlessly verbose and overloads <code>var</code> contextually (but with the preceding token as the only context, so not terribly).  Adding <code>let</code> instead of <code>let var</code> is both shorter and less overload-y.</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/03/31 15:37</em> 
</p>
<ul>
<li class="level1"><div class="li"> Agreed. If <code>let</code> means limit the scope of the thing that comes after to the innermost enclosing block, then it is not hard to read <code>let x = 10</code> to mean what <code>let var x = 10</code> would mean. No matter which one we accept, I&rsquo;d like to make the other a syntax error to avoid confusion.</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/03/31 16:27</em> 
</p>
<ul>
<li class="level1"><div class="li"> Since we wish to promote best practices, we should not require <code>let var</code>.  Therefore <code>let</code> wins and <code>let var</code> is <em>verboten</em>.</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/03/31 22:59</em>
</p>

</div>
<!-- SECTION [10432-13830] -->
<a name="old_proposal_discussion"></a><h1>Old Proposal &amp; Discussion</h1>
<div class="level1">

</div>
<!-- SECTION [13831-13871] -->
<a name="proposal"></a><h3>Proposal</h3>
<div class="level3">

<p>
 The body of a <code>let</code>-expression is considered a target of hoisting, like function bodies and program top-level, and the expression is itself not hoisted.
</p>

<p>
The surface syntax for <code>let</code> expressions might look like this:
</p>
<pre class="code">LetExpression ::= &quot;let&quot; ( &quot;(&quot; VarInit (&quot;,&quot; VarInit)* &quot;)&quot; )? Block
VarInit ::= ID (&quot;:&quot; Type)? (&quot;=&quot; Expression)?</pre>

<p>
The optional preamble contains a list of variables and initializer expressions. The variables are bound to the result of the initializers (or <strong>undefined</strong> for omitted initializers). The preamble variables are not hoisted and are bound only within the body of the expression (in particular, they are <em>not</em> bound in their initialization expressions). That is, they are added to the scope chain of the expression body, but not to the scope chains of the initializers.
</p>

<p>
Note that this allows for (mutually) recursive bindings within the body of a <code>let</code> expression, e.g.:
</p>
<pre class="code javascript">let <span class="br0">&#123;</span>
    <span class="kw2">var</span> fs = <span class="br0">&#123;</span> even: <span class="kw2">function</span><span class="br0">&#40;</span>n<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="br0">&#40;</span>x == <span class="nu0">0</span><span class="br0">&#41;</span> || fs.<span class="me1">odd</span><span class="br0">&#40;</span>n - <span class="nu0">1</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span>,
               odd: <span class="kw2">function</span><span class="br0">&#40;</span>n<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> <span class="br0">&#40;</span>x &gt; <span class="nu0">0</span><span class="br0">&#41;</span> &amp;&amp; fs.<span class="me1">even</span><span class="br0">&#40;</span>n - <span class="nu0">1</span><span class="br0">&#41;</span>; <span class="br0">&#125;</span> <span class="br0">&#125;</span>;
    ...
<span class="br0">&#125;</span></pre>
<p>
But does not allow recursive bindings within the preamble:
</p>
<pre class="code javascript"><span class="kw2">var</span> x = <span class="nu0">3</span>;
let <span class="br0">&#40;</span>x = <span class="nu0">4</span>, y = x<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw3">print</span><span class="br0">&#40;</span>y<span class="br0">&#41;</span>; <span class="co1">// prints 3</span>
<span class="br0">&#125;</span></pre>
<p>
After hoisting, the syntax of a <code>let</code> expression looks like:
</p>
<pre class="code">LetExpression ::= &quot;let&quot; ( &quot;(&quot; VarInit* &quot;)&quot; )? HoistedBlock
HoistedBlock ::= &quot;{&quot;
                     ( &quot;var&quot; ID (&quot;:&quot; Type)? (&quot;,&quot; &quot;var&quot; ID (&quot;:&quot; Type)?)* &quot;;&quot;? )?
                     Statement*
                 &quot;}&quot;</pre>

<p>
The block expression form is not a statement but an expression. Upon normal completion of the expression body, the value of the expression is the completion value, or <strong>undefined</strong> if there is no completion value.
</p>

</div>
<!-- SECTION [13872-15648] -->
<a name="comparison_to_standard_idiom"></a><h3>Comparison to Standard Idiom</h3>
<div class="level3">

<p>
 There is an idiom used by EcmaScript programmers to achieve something akin to this proposal using anonymous inner functions. Programmers appear to use
</p>
<pre class="code javascript"><span class="br0">&#40;</span><span class="kw2">function</span><span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="coMULTI">/* body */</span> <span class="br0">&#125;</span><span class="br0">&#41;</span><span class="br0">&#40;</span><span class="br0">&#41;</span></pre>
<p>
to achieve the same basic effect (see for example <a href="http://dean.edwards.name/my/cssQuery/src/?cssQuery.js" class="urlextern" target="_blank" title="http://dean.edwards.name/my/cssQuery/src/?cssQuery.js" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">http://dean.edwards.name/my/cssQuery/src/?cssQuery.js</a>). Notice that the above code contains several subtle and surprising differences between the body of the inner function and the body of a <code>let</code> expression. First, the meaning of <code>return</code> is changed &ndash; it returns a value for the application expression, but not for the surrounding function. There does not appear to be any way to simulate such a <code>return</code>.
</p>

<p>
Note also that the meaning of <code>arguments</code> is different: to maintain the same meaning, it would be necessary to change the idiom to:
</p>
<pre class="code javascript"><span class="br0">&#40;</span><span class="kw2">function</span> <span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="coMULTI">/* body */</span> <span class="br0">&#125;</span><span class="br0">&#41;</span>.<span class="me1">apply</span><span class="br0">&#40;</span><span class="kw1">this</span>, arguments<span class="br0">&#41;</span></pre>
<p>
Now we guarantee that both <code>this</code> and <code>arguments</code> are unchanged within the body of the function. But if we want to achieve the same behavior as the <code>let</code> expression preamble, where initializers can refer to variables being shadowed, we might try:
</p>
<pre class="code javascript"><span class="br0">&#40;</span><span class="kw2">function</span> <span class="br0">&#40;</span>x1, ..., xn<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="coMULTI">/* body */</span> <span class="br0">&#125;</span><span class="br0">&#41;</span>.<span class="me1">call</span><span class="br0">&#40;</span><span class="kw1">this</span>, e1, ..., en<span class="br0">&#41;</span></pre>
<p>
But then notice that we have once again modified the meaning of <code>arguments</code>.
</p>

<p>
Next we might try several levels of nested functions, but at this point, the idiom has become convoluted enough to defeat its simplicity and convenience. And we have still not achieved the same meaning for <code>return</code>.
</p>

<p>
This proposal attempts to abstract away the details of this implementation in a convenient and well-behaved special form that solves the problem once and for all.
</p>

</div>
<!-- SECTION [15649-17382] -->
<a name="rationale"></a><h3>Rationale</h3>
<div class="level3">

<p>
 The primary motivation for this form is the ability to introduce lexically scoped blocks that are not hoisted to the top level of function bodies.
</p>

<p>
In practice, EcmaScript programmers appear to use the syntactic idiom of immediately applying anonymous function expressions, so it&rsquo;s useful to abstract this out into a special syntactic form in the language. This saves typing and clarifies the code, and prevents several subtle potential bugs that can arise in the idiom.
</p>

<p>
Three possible bugs in the idiom are:
</p>
<ul>
<li class="level1"><div class="li"> incorrect use of <code>this</code></div>
</li>
<li class="level1"><div class="li"> incorrect use of the <code>arguments</code> array</div>
</li>
<li class="level1"><div class="li"> incorrect use of <code>return</code></div>
</li>
</ul>

<p>
 The first case may not be a big deal since the meaning of <code>this</code> stays the same when you call a function without a receiver object. In the second case, the meaning of <code>arguments</code> is different from the code surrounding the expression unless the programmer carefully uses the <code>apply</code> method of the anonymous function object. In the third case, there is no way to make <code>return</code> behave the same as it does outside of the inner expression.
</p>

<p>
Another motivation for this form is the ability to bind variables whose scope does <em>not</em> include their intializer expressions. This allows referring to the previous binding of shadowed variables.
</p>

<p>
Yet another motivation for this form is to future-proof the language for macros: it&rsquo;s important to be able to introduce local bindings in non-trivial macros, and to do this without altering the meaning of the client code at the invocation site of the macro. The <code>let</code> expression is carefully designed so that the body has exactly the same meaning as it does outside of the <code>let</code> expression except for the new bindings.
</p>

<p>
Making <code>let</code> an expression form, rather than a statement form, is useful for programmers who want to write in a functional style by composing expressions, and again would be important for macros as a way of introducing bindings in expression macros.
</p>

<p>
Brendan pointed out in the 2/16 meeting that it would be good to be able to refer to a variable&rsquo;s previous binding within an initializer (i.e., <code>let</code> and not <code>letrec</code> semantics), hence the introduction of the preamble.
</p>

<p>
However, it&rsquo;s still useful to be able to introduce aribtrary statements and declarations within the substatement and not have them hoisted to the top of the enclosing function. This proposal combines both capabilities. When the preamble facility isn&rsquo;t needed it can be omitted entirely:
</p>
<pre class="code javascript">let <span class="br0">&#123;</span>
    <span class="kw2">var</span> x = ...
<span class="br0">&#125;</span></pre>
<p>
and when declarations within the block aren&rsquo;t needed, they too can be omitted:
</p>
<pre class="code javascript">let <span class="br0">&#40;</span>x = <span class="nu0">3</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    x
<span class="br0">&#125;</span></pre>
</div>
<!-- SECTION [17383-20033] -->
<a name="rejected_alternatives"></a><h3>Rejected Alternatives</h3>
<div class="level3">
<ul>
<li class="level1"><div class="li"> Without the preamble, it&rsquo;s possible to allow any arbitrary statement for the body, but this introduces an ambiguity between the preamble and expression statements.</div>
</li>
<li class="level1"><div class="li"> The preamble could begin with the redundant keyword <code>var</code> to indicate that the variables are bound, but this would be pointless typing, and both <code>catch</code> and <code>function</code> are existing binding forms that don&rsquo;t use <code>var</code> to indicate binding, so it&rsquo;s not inconsistent with the language.</div>
</li>
<li class="level1"><div class="li"> The preamble could optionally begin with the <code>var</code> keyword, only binding the variables if the keyword is present, and otherwise assigning to existing variables, but this runs contrary to the whole <em>point</em> of <code>let</code>, which is to introduce bindings. The exact same effect can be achieved (with fewer characters!) by a preamble-less <code>let</code> with assignment statements at the beginning of the body.</div>
</li>
<li class="level1"><div class="li"> Could use the keyword <code>block</code> instead of <code>let</code>, but</div>
<ul>
<li class="level2"><div class="li"> the fewer characters the better</div>
</li>
<li class="level2"><div class="li"> this can serve as a bridge to functional languages</div>
</li>
<li class="level2"><div class="li"> might be confused with Ruby and Smalltalk blocks</div>
</li>
</ul>
</li>
</ul>
<hr noshade="noshade" size="1" />

<p>
Some comments: 
</p>
<ul>
<li class="level1"><div class="li"> I&rsquo;m not sure you mean &ldquo;block expression&rdquo; here, rather than &ldquo;block binding&rdquo; or such. This doesn&rsquo;t seem like an expression type: it contains statements, and doesn&rsquo;t (seem to) evaluate to a value. Am I misreading?</div>
</li>
<li class="level1"><div class="li"> I wonder if you could clarify the rationale further, perhaps provide an example. It seems to me that you can get similar affects by making an inner anonymous function and calling it.</div>
</li>
<li class="level1"><div class="li"> you use the word &ldquo;binding&rdquo; frequently; as far as I know (sadly) there is no such concept in the ecmascript language: all activity related to &ldquo;variables&rdquo; &ndash; evaluating names, introducing new name-to-value mappings, shadowing old ones, etc. &ndash; are modeled as imperative operations on scope objects and their slots. I think it might help clarify your proposal if you wrote it in these terms exclusively, and avoided referring to bindings (even if the goal is to simulate binding).</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x67%3B%26%23x72%3B%26%23x61%3B%26%23x79%3B%26%23x64%3B%26%23x6f%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x67;&#x72;&#x61;&#x79;&#x64;&#x6f;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">graydon</a> 2006/02/22 12:22</em> 
</p>
<hr noshade="noshade" size="1" />

<p>
Thanks for the feedback. Let me respond to each point in turn:
</p>

</div>
<!-- SECTION [20034-22178] -->
<a name="point_1"></a><h5>Point 1</h5>
<div class="level5">

<p>
 I do in fact mean expression: <code>let</code> is an expression form that evaluates to a value; it contains a block statement as its body, but it evaluates to the completion value of that block &ndash; see the last paragraph of the proposal.
</p>

</div>
<!-- SECTION [22179-22422] -->
<a name="point_2"></a><h5>Point 2</h5>
<div class="level5">

<p>
 Great point, thanks. I&rsquo;ve expanded the rationale section and added a section comparing this proposal to the standard idiom of applying an anonymous function.
</p>

<p>
I wrote this proposal as a syntactic abstraction of that idiom; it&rsquo;s a convenient expression form for lexical scoping that saves the writer from having to use a somewhat obscure and verbose idiom, and protects against the pitfalls of the subtle changes it makes to the meaning of the body expression.
</p>

<p>
With a macro system, you might try to define this form as a simple translation to the anonymous function application idiom. But you&rsquo;d find that the meaning of <code>return</code> and possibly <code>arguments</code> is silently and surprisingly changed within the body of the <code>let</code> expression. This is why, even if we did have a macro system, I would still prefer to define this as a special language form.
</p>

<p>
It may sound like splitting hairs to worry about <code>arguments</code> and <code>return</code>, but imagine that <code>let</code> is specified by translation to the standard idiom, rather than as it is in this proposal. Now if you are an EcmaScript programmer and you have some code like:
</p>
<pre class="code javascript">foo<span class="br0">&#40;</span>f<span class="br0">&#40;</span>x<span class="br0">&#41;</span>, f<span class="br0">&#40;</span>x<span class="br0">&#41;</span>, arguments<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="br0">&#41;</span></pre>
<p>
and then you want to abstract out the call to <code>f</code>, and you try:
</p>
<pre class="code javascript">let <span class="br0">&#40;</span>z = f<span class="br0">&#40;</span>x<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> foo<span class="br0">&#40;</span>z, z, arguments<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#125;</span></pre>
<p>
the code will suddenly give <code>foo</code> the same value as <code>z</code> as its third argument &ndash; which will change the behavior of the program, but might not even produce an immediate error. This will be a very hard bug to track down, since the error isn&rsquo;t localized to the part of the code that caused it, and it would be due to a strange corner-case in the specification of <code>let</code> expressions.
</p>

</div>
<!-- SECTION [22423-24129] -->
<a name="point_3"></a><h5>Point 3</h5>
<div class="level5">

<p>
 The existing spec doesn&rsquo;t refer to binding, true. I think that&rsquo;s a flaw in the spec.
</p>

<p>
Now, I am not sure about the current draft, but in edition 3, <acronym title="If I remember correctly">IIRC</acronym>, there is no provision for scope objects (other than those dynamically added to the scope chain via <code>with</code>) to be mutated by the user program. The upshot is that in these frames of the scope chain, slots are written to only once. So they may as well not be defined in imperative terms at all, and they&rsquo;re behaviorally equivalent to environment frames.
</p>

<p>
The terminology of scope chains and &ldquo;objects&rdquo; in the scope chains reads to me like a confusion of specification from implementation. It may be perfectly reasonable for some EcmaScript implementations to use regular JavaScript objects that are not accessible to the programmer as frames in the environment, but it&rsquo;s also perfectly reasonable to use ordinary lexical scope in the implementation language. This is what I do in my JavaScript-to-Scheme compiler. It&rsquo;s complicated to some degree by <code>with</code>, but I&rsquo;d be glad to tell you about my implementation strategy.
</p>

<p>
What&rsquo;s going on here really is the same thing as binding. The only complication is that some environment frames (i.e., those installed by <code>with</code>), do have to be JavaScript objects. But not all of them should have to be, and those that aren&rsquo;t should be specified as binding mechanisms.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x64%3B%26%23x68%3B%26%23x65%3B%26%23x72%3B%26%23x6d%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x63%3B%26%23x63%3B%26%23x73%3B%26%23x2e%3B%26%23x6e%3B%26%23x65%3B%26%23x75%3B%26%23x2e%3B%26%23x65%3B%26%23x64%3B%26%23x75%3B" class="mail" title="&#x64;&#x68;&#x65;&#x72;&#x6d;&#x61;&#x6e;&#x40;&#x63;&#x63;&#x73;&#x2e;&#x6e;&#x65;&#x75;&#x2e;&#x65;&#x64;&#x75;">Dave Herman</a> 2006/02/22 19:44</em> 
</p>
<hr noshade="noshade" size="1" />

<p>
 I agree that the lack of conventional binding specification in ECMA-262 is a bug, reflecting my bugged design of JS1 from 1995.  I hope we can fix this bug.  Beware, however, that slots in scope objects can be added and deleted as follows: 
</p>
<ul>
<li class="level1"><div class="li"> The global object may be extended with properties not declared using function or var.</div>
</li>
<li class="level1"><div class="li"> Variables created by an <code>eval</code> are not given the <code>DontDelete</code> attribute, so may be removed from the variable object via <code>delete</code>.  This applies at top-level and within a function activation.</div>
</li>
<li class="level1"><div class="li"> Fortunately, functions and variables bound outside of eval create <code>DontDelete</code> properties (note that <code>var</code> never re-creates a pre-existing binding).  But these properties are not <code>ReadOnly</code>, so a binding can be changed by assignment as well as by redeclaration.</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/02/22 23:41</em>
</p>

<p>
Interesting. I&rsquo;m certain that&rsquo;ll cause problems for type soundness. Let&rsquo;s talk about this more.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x64%3B%26%23x68%3B%26%23x65%3B%26%23x72%3B%26%23x6d%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x63%3B%26%23x63%3B%26%23x73%3B%26%23x2e%3B%26%23x6e%3B%26%23x65%3B%26%23x75%3B%26%23x2e%3B%26%23x65%3B%26%23x64%3B%26%23x75%3B" class="mail" title="&#x64;&#x68;&#x65;&#x72;&#x6d;&#x61;&#x6e;&#x40;&#x63;&#x63;&#x73;&#x2e;&#x6e;&#x65;&#x75;&#x2e;&#x65;&#x64;&#x75;">Dave Herman</a> 2006/02/23 07:50</em>
</p>

<p>
With <a href="doku.php%3Fid=clarification:drop_traits.html" class="wikilink1" title="clarification:drop_traits" onclick="return svchk()" onkeypress="return svchk()">TypeConstraint</a>, type annotations change the rules incompatibly and may restore soundness.  Type-annotated <code>var</code> and <code>function</code> declarations are <code>DontDelete</code> unconditionally, and assignment cannot rebind if the type of the new value violates the constraint.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/02/23 12:04</em>
</p>
<pre class="code">
for ( i=0 ; i &lt; 2 ; i++ )
  let (x = 10) {
    fn[i] = (function () { return x })
    x = i
  }
</pre>

<p>
What then is the meaning of 
</p>
<pre class="code">fn[0]()
fn[1]()</pre>

<p>
 Probably you want 0, 1, but if x is hoisted then you get 1,1 (classical problem with Common Lisp &ldquo;do&rdquo; loops).
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars Hansen</a> 2006/02/24 </em>
</p>

<p>
We definitely want 0, 1, since Edition 3 closures have the classical (CL &ldquo;do&rdquo;) problem <img src="lib/images/smileys/icon_wink.gif" align="middle" alt=";-)" />.  The lack of any workaround for the classical problem in ES3 is one strong indicator in favor of this proposal.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/02/24 14:22</em>
</p>

</div>
<!-- SECTION [24130-27560] -->
<a name="counterproposal"></a><h3>Counterproposal</h3>
<div class="level3">

<p>
 I want to suggest the following as an alternative (the word &ldquo;counterproposal&rdquo; is a little strong).  I do like the idea of having a <code>let</code>-type expression.  I do not particularly like the current proposal, because it inserts statements into expressions and because it uses the &ldquo;completion value&amp;quot;, which so far has been ignored except at the top level of the program.
</p>

<p>
I propose that <code>let</code> can be used everywhere <code>var</code> can be used in Edition 3, but that unlike <code>var</code> it introduces a variable that is scoped in a block or statement, not in the function or program: 
</p>
<ul>
<li class="level1"><div class="li"> If used as a statement (<code>let x=10;</code>) it introduces a variable scoped within the enclosing block</div>
</li>
<li class="level1"><div class="li"> If used in a <code>for</code> loop it introduces a variable scoped within that statement</div>
</li>
</ul>

<p>
 For example:
</p>
<pre class="code javascript">   <span class="kw2">function</span> f<span class="br0">&#40;</span>x<span class="br0">&#41;</span>
   <span class="br0">&#123;</span>
     <span class="kw2">var</span> i = <span class="nu0">0</span>;
     <span class="kw1">if</span> <span class="br0">&#40;</span>x &gt; <span class="nu0">5</span><span class="br0">&#41;</span>
     <span class="br0">&#123;</span>
       let i = <span class="nu0">3</span>;
       <span class="kw3">print</span><span class="br0">&#40;</span>i<span class="br0">&#41;</span>;
     <span class="br0">&#125;</span>
     <span class="kw3">print</span><span class="br0">&#40;</span>i<span class="br0">&#41;</span>;
   <span class="br0">&#125;</span></pre>
<p>
prints <code>3</code>, then <code>0</code>.  Or:
</p>
<pre class="code javascript">   <span class="kw2">var</span> i = <span class="nu0">0</span>;
   <span class="kw1">for</span> <span class="br0">&#40;</span> let i=<span class="nu0">0</span> ; i &lt; <span class="nu0">10</span> ; i++ <span class="br0">&#41;</span>
     ...;
   <span class="kw3">print</span><span class="br0">&#40;</span>i<span class="br0">&#41;</span>;</pre>
<p>
prints <code>0</code> also.
</p>

<p>
The main disadvantage of the proposal is that we lose the expression form.  This is remedied by introducing a separate expression form, as in the original proposal:
</p>
<pre class="code javascript">   x = <span class="nu0">10</span> + let <span class="br0">&#40;</span>a=<span class="nu0">5</span>, x=x+<span class="nu0">5</span><span class="br0">&#41;</span> x</pre>
<p>
Though the two separate syntaxen for <code>let</code> may seem like adding too much machinery when one form is enough, we do have exactly this situation for <code>function</code>, where we have both binding forms and expression forms.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/03/23 01:42</em>
</p>

<p>
I am strongly in favor of both proposals.  I don&rsquo;t view Lars&rsquo; proposal as an alternative so much as a generous and fitting completion, optimizing for common cases&rsquo; conciseness, of Dave&rsquo;s proposal.
</p>

<p>
The <code>let</code> block-expression form provides missing expression syntax, as well as a way to re-use a name in an inner scope but initialize it (or another variable within the same optional <code>let</code> preamble) to the outer name&rsquo;s value, without <code>var</code>-hoisting causing the initializer to assign undefined (the present value of the inner name).  Dave shows an example above.
</p>

<p>
Allowing <code>let</code> instead of <code>var</code> for enclosing-block or for-loop scope is too convenient to resist, familiar from other C-descended languages, and low-cost in implementations and spec terms.
</p>

<p>
Again, it seems to me that convenience can trump minimalism &ndash; not always, but in several cases near the surface of the language.  Minimizing the language so that there is only one way to say something goes against the grain of scripting languages (<acronym title="Practical Extraction and Report Language">Perl</acronym> overdoes this, but its heart is in the right place).  Over-minimizing the surface may optimize language size at the expense of real-world usability.
</p>

<p>
I took the liberty of adding optional type annotations to the BNF at the top of this page.  I believe we want all such <code>VarList</code> non-terminals (graydon&rsquo;s latest <a href="doku.php%3Fid=discussion:switch_class.html" class="wikilink1" title="discussion:switch_class" onclick="return svchk()" onkeypress="return svchk()">switch class</a> proposal has such a production) to allow types.
</p>

<p>
Questions:
</p>
<ul>
<li class="level1"><div class="li"> Do we want to require a block after the <code>let</code> and any optional preamble?  Lars&rsquo; example does not, but Dave rejected this because it makes the preamble mandatory syntax.</div>
</li>
<li class="level1"><div class="li"> Should we allow <code>with</code> and <code>eval</code> in such blocks?  I think so, but they require more work, analogous to the work required in functions to reify an activation object.</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/03/23 22:58</em>
</p>

<p>
My take on the questions:
</p>
<ul>
<li class="level1"><div class="li"> My proposal does not require a block after the <code>let</code> because it does not allow it, it is exclusively an expression form (does not admit use of the statement language).</div>
</li>
<li class="level1"><div class="li"> You can&rsquo;t not allow <code>with</code> and <code>eval</code> in these blocks; that would be an arbitrary restriction that would be completely maddening.  Anyway you already have to handle <code>with</code> and <code>eval</code> (and function closures) inside <code>catch</code> clauses, which have local binding, and presumably you also want to handle them inside enum cases, so unless you&rsquo;re prepared to prohibit them everywhere ... <img src="lib/images/smileys/icon_smile.gif" align="middle" alt=":-)" /></div>
</li>
</ul>

<p>
 Apart from that I have some comments: 
</p>
<ul>
<li class="level1"><div class="li"> With the heavy emphasis on static checking and programming-in-the-large in ECMAScript 4 it is increasingly difficult to see it as a scripting language, so I&rsquo;m not sure that we should continue to increase the number of &ldquo;scripting&rdquo; features or use that as a justification for design choices.  There are no implementation problems per se (that I&rsquo;m aware of now) with the block-statement form of the <code>let</code> proposal, it&rsquo;s just an aesthetic thing with me, and in addition it resurrects the &ldquo;completion value&rdquo; mechanism that really had been left better for dead.</div>
</li>
<li class="level1"><div class="li"> The <code>var</code> form of destructuring assignments does not allow for type annotations, and won&rsquo;t, if we&rsquo;re going to stick to using construction syntax for destructuring</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x6c%3B%26%23x74%3B%26%23x68%3B%26%23x40%3B%26%23x6f%3B%26%23x70%3B%26%23x65%3B%26%23x72%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6c;&#x74;&#x68;&#x40;&#x6f;&#x70;&#x65;&#x72;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">Lars T Hansen</a> 2006/03/24 01:58</em>
</p>

<p>
Agreed on avoiding arbitrary nesting restrictions &ndash; I had to ask, because extension purity vs. compatibility and composition of old and new features are at war, at least in some of our heads.  You touch on that too, in raising the question of whether Edition 4 is still a &ldquo;scripting language&rdquo;.  My answer is that it certainly is, in these senses: 
</p>
<ul>
<li class="level1"><div class="li"> Dynamic type and minimal boilerplate, for quick code-snippet-based prototyping.</div>
</li>
<li class="level1"><div class="li"> Admits small implementation without too much effort.</div>
</li>
<li class="level1"><div class="li"> Scales over large audience of would-be programmers, as well as professionals.</div>
</li>
</ul>

<p>
 Since we can&rsquo;t throw out the old and make a clean, new and incompatible language, and since we hope to migrate much of the existing code toward the new edition over the next many years, we should avoid viewing the new Edition as a &ldquo;new language&rdquo; and rejecting &ldquo;scripting features&rdquo;.
</p>

<p>
To justify design choices, we should fill gaps and fix bugs compatible.  I think <code>let</code> (both proposals) does that.  It&rsquo;s true that we could defer the <code>let</code> block-expressions, and still fill the &ldquo;lack of block scope&rdquo; gap.  We should reserve syntax if we can.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/03/24 08:21</em> 
</p>

</div>
<!-- SECTION [27561-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/c/c93efd8ef9a53eb61e79c29340dda06b.xhtml used -->
</body>
</html>
