(See also the [[discussion:argument this|discussion page]].)

====== Proposal for "Argument This" ======

For class methods, we really have two design options:
  * "Bound-this": The class method closes over this, and always ignores its first argument (this is the current design).
  * "Argument-this": The class method does not close over this, and instead uses its first argument.

I wonder if its possible at this  stage to re-visit the issue of "bound-this".  
I've been trying to formalize the semantics of a mini-ES4,
and bound-this methods are turning out a bit awkward to fit in.
I understand that "bound-this" has precedent in Actionscript and it guarantees that "this" always has the right type (that is, this class or a subclass), which may facilitate optimization.

Yet there are some technical benefits for "argument-this":
it yields a smaller and more coherent language,
with only one flavor of method (plain vanilla ES3, now with types).
It means that all methods (both from classes and structural objects) take a "this" argument, which is what ES3 programmers might expect, and is perhaps more "Javascripty".

The type system, via self types, can ensure (in both strict and standard mode) that "this" is a subtype of (or compatible with) the underlying class type, which is a somewhat weaker guarantee than "bound-this".

Bound-this does support the nice coding pattern:

     doTenTimes( outputStream.println )

However, this works only if the object outputStream comes from a class, and breaks if outputStream is a structural object. That is, bound-this methods and object methods are just different kinds of entities.
The more robust coding pattern:

     doTenTimes( function() outputStream.println() )

that works for both class methods and object methods will also work under both 
bound-this and argument-this.
It seems that porting code from "bound this" to "argument this" primarily requires introducing these wrappers around method extractions.
I think argument-this supports  all the coding patterns that programmers should use, and in weird corner cases it gives a semantics that is perhaps more consistent with ES3 and structural objects.

"Argument this" also yields a smoother interoperation between classes and objects, from the point-of-view of the type system. For example, the class D 

    class D { var foo:int = 10; function f():int { return this.foo } };

is a subtype of 

    {foo:int; function(this:this):int }

under "argument-this"; under "bound this", D is a subtype of

    {foo:int; function(this:*):int }

where this:* indicates that the "this" argument is discarded, and looks a little strange.

Since classes are new in ES4, this is our only chance to get them right.  It it still possible to revisit this issue at this stage?
Would it significantly hurt compatibility with Actionscript?

 --- //[[cormac@soe.ucsc.edu|Cormac Flanagan]] 2007/05/14 09:10//

There is a third option:

  * "Rejected-this": The class method closes over this, and any attempt to invoke the extracted method with a non-null this object causes a run-time (or compile-time, if you can track it) error.

Under this rule, D is a subtype of 

    {foo:int; function(this:()):int }

or perhaps even

    {foo:int; function(this:D):int }

Don't know what this does for your type system, though.

 --- //[[lth@acm.org|Lars T Hansen]] 2007/05/15 05:39//