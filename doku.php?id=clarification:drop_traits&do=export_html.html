<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=clarification:drop_traits&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=clarification" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=clarification:drop_traits&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=clarification:drop_traits&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>

<a name="dropping_traits_from_the_spec"></a><h1>Dropping traits from the spec</h1>
<div class="level1">

<p>
 The spec defines the behavior of static aspects of the language in terms of <code>traits</code> objects.
</p>

<p>
This proposal suggests that the concept of <code>traits</code> be modeled in terms of property attributes on prototype objects.
</p>

<p>
In particular, this proposal suggests inclusion of a <code>TypeConstraint</code> attribute, which would be included on (and <em>only</em> on) properties declared in classes. This attribute would carry a reference to a type (class). Given a class field <code>F</code> of type <code>C</code>, the associated property <code>P</code> would have the attribute <code>TypeConstraint C</code>. This attribute would cause the following restrictions: 
</p>
<ul>
<li class="level1"><div class="li"> <code>TypeConstraint</code> implies <code>DontDelete</code></div>
</li>
<li class="level1"><div class="li"> <code>TypeConstraint C</code> on property <code>P</code> of object <code>O</code> means that only values of type <code>C</code> or its subclasses can be assigned to <code>O.P</code>, <em>or</em> to any property <code>P</code> in a secondary object <code>S</code> where <code>O</code> is a member of the prototype chain of <code>S</code>. In other words, <code>P</code> is prohibited from:</div>
<ul>
<li class="level2"><div class="li"> type-incompatible rebinding in <code>O</code></div>
</li>
<li class="level2"><div class="li"> type-incompatible shadowing in an object using <code>O</code> as a prototype</div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Reading from a property <code>P</code> with <code>TypeConstraint C</code> would therefore always produce a value of type <code>C</code>.</div>
</li>
</ul>

</div>
<!-- SECTION [1-1230] -->
<a name="mike_s_critiques_regarding_prototype_indirection"></a><h2>Mike's critiques regarding prototype indirection</h2>
<div class="level2">

<p>
 <em>Question:</em> does forbidding type-incompatible shadowing of prototype properties not interact poorly with implementations like SpiderMonkey which permit manipulation of the __proto__ chain after object creation?  Given
</p>

<p>
<code>O = { P: TypeConstraint }; S = { }; S2 = { __proto__: S, P: &ldquo;wibble&rdquo; };
S.__proto__ = O;
</code>
</p>

<p>
it seems that we would need to maintain a reference from S to S2 in order to check it for a newly created shadowing.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x73%3B%26%23x68%3B%26%23x61%3B%26%23x76%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x73;&#x68;&#x61;&#x76;&#x65;&#x72;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Mike Shaver</a> 2006/01/31 07:43</em>
</p>

<p>
<em>Answer:</em> Sorry, yes. In the version of this proposal I initially posted (via email), I included the restriction that the presence of a <code>TypeConstraint</code> attribute on a slot of an object <code>P</code> required that any child object <code>C</code> using <code>P</code> as a prototype have its ES3-intrinsic <code>[[Prototype]]</code> property (JS1.x <code>__proto__</code> property) made read-only. I was told that this was an unnecessary restriction since the prototype chain is immutable according to spec anyways, but I will happily add language noting this requirement, if the proposal is accepted.
</p>

<p>
In your example, you&rsquo;re correct in noting that more is needed to prohibit the post-construction shadowing. Because the shadowing arises from the connection of two legal prototype chains at an &ldquo;uninformed&rdquo; intermediary, this proposal could only be sound with one of two additional modifications: 
</p>
<ol>
<li class="level1"><div class="li"> All prototype chains are read-only, all the time <em>or</em> </div>
</li>
<li class="level1"><div class="li"> Any writable <code>[[Prototype]]</code> property needs to be bi-directional &ndash; each object with a writable prototype must keep a list of its prototype delegators &ndash;  and assignment of a <code>__proto__</code> slot on object <code>O</code> after construction causes a complete traversal and shadowing check of all the chains <code>O</code> is involved in.</div>
</li>
</ol>

<p>
  &mdash; <em><a href="mailto:%26%23x67%3B%26%23x72%3B%26%23x61%3B%26%23x79%3B%26%23x64%3B%26%23x6f%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x67;&#x72;&#x61;&#x79;&#x64;&#x6f;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">graydon</a> 2006/01/31 10:52</em>
</p>

</div>
<!-- SECTION [1231-3126] -->
<a name="jeff_s_edge_cases_regarding_name-binding"></a><h2>Jeff's edge cases regarding name-binding</h2>
<div class="level2">

<p>
 Here are two sharp edges in the object model that need to be addressed with or without triats. 
</p>
<hr noshade="noshade" size="1" />

<p>
Hi,
</p>

<p>
This is an awkward way of editing the wiki, but I&rsquo;m afraid I&rsquo;m quite lost in your descriptions. I do not understand either the problem statements nor the solutions, nor do I know which language (with traits or without) you are phrasing the problem and solution in. Could you extend the examples with some details? I&rsquo;ve made notes above indicating the parts I do not understand. All the notes I&rsquo;ve made in your section are bracketed between horizontal rules (<code>----</code>).
</p>

<p>
Fwiw, I&rsquo;m perfectly willing to accept that traits are a requirement for the name binding rules of the language to make sense. What I lack is a clear understanding of <em>why</em>, which makes me think that the existing language is too complex for users to grasp also.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x67%3B%26%23x72%3B%26%23x61%3B%26%23x79%3B%26%23x64%3B%26%23x6f%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x67;&#x72;&#x61;&#x79;&#x64;&#x6f;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">graydon</a> 2006/03/11 12:30</em>
</p>

<p>
Actually, these aren&rsquo;t intended to be critiques of this proposal, but rather to point out some edge cases that need to be dealt with by any design. I apologize that my meaning was not clear. To make things worse, there were quite a few typos. I&rsquo;ll try to make things clearer by fixing the typos and erasing some of the confusing prose. Hopefully then the answers to your questions will become clear.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/03/14 12:40</em>
</p>

<p>
Thank you, your revisions helped. I have some residual questions though, which I have left in place below.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x67%3B%26%23x72%3B%26%23x61%3B%26%23x79%3B%26%23x64%3B%26%23x6f%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x67;&#x72;&#x61;&#x79;&#x64;&#x6f;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">graydon</a> 2006/03/15 00:30</em> 
</p>
<hr noshade="noshade" size="1" />

<p>
<strong>Lexical lookup at runtime</strong>
</p>
<pre class="code">
var x = 10
class A { function m() { with(â€¦) { print(x) } } }
class B extends A { var x = 20 }
var o = new B()
o.m() // should print 10
</pre>

<p>
The challenge is to represent the lexical scopes at runtime so that <code>x</code> in m binds to the global <code>var x</code>, not the instance <code>var x</code> in <code>B</code>. 
</p>
<hr noshade="noshade" size="1" />

<p>
Graydon&rsquo;s questions for clarification in this section:
</p>
<ul>
<li class="level1"><div class="li"> I agree that this is a challenge; what do you propose as a solution? </div>
</li>
<li class="level1"><div class="li"> Would it work to insert an anonymous object in the scope chain of method <code>A.m</code>, acting as a lexical closure over the variable <code>x</code>?</div>
</li>
<li class="level1"><div class="li"> Would such a solution place undue burden on lightweight compilers wishing to avoid static analysis?</div>
</li>
</ul>
<hr noshade="noshade" size="1" />

<p>
<strong>Early binding</strong>
</p>

<p>
We want to allow smart implementations to bind references at compile time without changing the meaning of programs. For example, in the sample code below an implementation might want to resolve a reference to <code>m</code> through an instance of type <code>A</code> to a virtual table index, or even to a method body, to avoid having to resolve the name at runtime.
</p>
<pre class="code">
class A { function m() {} }
class B extends A { override function m() {} }

var a : A = new B
a.m()  // maybe resolve m to a virtual table index based on current knowledge of A
</pre>

<p>
If we want a language that allows for early binding, then clearly dynamic lookup and early binding must result in the same function being called. 
</p>

<p>
So far this isn&rsquo;t much of a problem because there is only one <code>m</code> in <code>B</code> and it overrides the <code>m</code> in <code>A</code>. But what if there is more than one <code>m</code> in <code>B</code>?
</p>

<p>
In the following example, <code>class A</code> introduces method <code>m</code> into the default namespace. <code>class B</code> overrides <code>A</code>&lsquo;s <code>m</code> and introduces another method <code>m</code> in the <code>namespace N</code>. <code>N</code> is an open namespace at the point of reference of <code>o.m()</code> in <code>f</code> so there at least two possible interpretations of that reference.
</p>
<pre class="code">
class A { function m() { print(&quot;A.m&quot;) } }
namespace N
class B extends A { override function m() { print(&quot;B.m&quot;) }; N function m() { print(&quot;B.N::m&quot;) } } 

var o = new B
f(o)

function f( o ) 
{ 
  use namespace N
  o.m()   // prints B.m, B.N::m, or error?
  var a : A = o
  a.m()   // prints B.m, with early binding
}
</pre>

<p>
The compiler sees only one <code>m</code> in the reference through <code>A</code>, and so has no way of knowing that there will be an alternative binding to <code>m</code> in <code>B</code>. But at runtime <code>m</code> in <code>N</code> will also be seen. So what should the correct interpretation of this program be?
</p>

<p>
Waldemar&rsquo;s solution: At run time, search for <code>m</code> from the root type (Object) down to the instance type (<code>B</code> in this case) until a match for <code>m</code> is found. If a match is found, use its qualified name to search for the ultimate match in the instance. 
</p>
<hr noshade="noshade" size="1" />

<p>
Graydon&rsquo;s questions for clarification in this section:
</p>
<ul>
<li class="level1"><div class="li"> Is the following commentary correct?</div>
<ul>
<li class="level2"><div class="li"> The call <code>a.m()</code> will dispatch to the same method, <code>B.m</code>, in both early binding and late binding interpretations under the current proposal, since the variable type <code>A</code> has no use of namespace <code>N</code> at all.</div>
</li>
<li class="level2"><div class="li"> No early binding of the call <code>o.m()</code> is possible since <code>o</code> is of unconstrained type</div>
</li>
<li class="level2"><div class="li"> We seek a rule for dispatching the call <code>o.m()</code> unambiguously or raising a runtime error</div>
</li>
<li class="level2"><div class="li"> Waldemar&rsquo;s rule would encounter <code>A.m</code>, consider the unqualified name <code>m</code> to refer to the name <code>m</code> in the default namespace, and then dispatch to <code>B.m</code>, not <code>B.N::m</code></div>
</li>
<li class="level2"><div class="li"> An equally possible rule would involve using the normal (compile-time) unqualified name lookup rule at runtime against the discovered instance type <code>B</code> and reporting an ambiguous binding due to the open namespace <code>N</code></div>
</li>
</ul>
</li>
<li class="level1"><div class="li"> Do you have a particular preference about which rule to adopt?</div>
</li>
<li class="level1"><div class="li"> Did Waldemar offer much commentary on his preference?</div>
</li>
<li class="level1"><div class="li"> Do traits help? Not to sound too defeatest, I&rsquo;m just curious; this latter problem doesn&rsquo;t sound (to me) immediately related to whether we&rsquo;re looking things up in prototypes or traits. I imagine we need to be storing qualified <code>(namespace,name)</code> pairs as property keys in all cases.</div>
</li>
</ul>
<hr noshade="noshade" size="1" />

<p>
Quick interjections: 
</p>
<ul>
<li class="level1"><div class="li"> Someone familiar with AS3 please reassure us that namespaces are *not* first-class, so that the compiler can see all uses as well as definitions via the <code>use namespace</code> pragma.  Dave (and Cormac) have raised dynamic namespacing as yet another soundness threat (along with <code>with</code> and <code>eval</code> as constituted in Edition 3).</div>
</li>
</ul>
<ul>
<li class="level1"><div class="li"> Waldemar offered commentary about member lookup rule alternatives and his preference at <a href="http://www.mozilla.org/js/language/js20/rationale/member-lookup.html" class="urlextern" target="_blank" title="http://www.mozilla.org/js/language/js20/rationale/member-lookup.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">http://www.mozilla.org/js/language/js20/rationale/member-lookup.html</a>.</div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/03/15 18:53</em> 
</p>
<hr noshade="noshade" size="1" />

<p>
Arguments to <code>use namespace ...</code> directives must be compile time constant expressions. Namespace attributes must be compile time constant expressions. Name qualifiers may be runtime expressions (as in E4X).
</p>

<p>
So, for example, the following is a valid program:
</p>
<pre class="code javascript"><span class="kw2">namespace</span> N
N <span class="kw2">var</span> x = <span class="nu0">10</span>
<span class="kw2">var</span> q = N
<span class="kw3">print</span><span class="br0">&#40;</span>q::x<span class="br0">&#41;</span> <span class="co1">// prints 10</span>
<span class="kw2">use</span> <span class="kw2">namespace</span> N
<span class="co1">// use namespace q  &lt;- would be an error, q is not a ct constant expression</span>
<span class="kw3">print</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span>    <span class="co1">// also prints 10</span></pre>
<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/03/16 09:06</em> 
</p>
<hr noshade="noshade" size="1" />

<p>
So <code>q::x</code> in general (with data flow that can&rsquo;t be analyzed statically) is a run-time expression.
</p>

<p>
This is like <code>eval(y)</code> where <code>y</code> is constrained not to bind new variables or have other effects.  It is very much like <code>with</code>.  Wait, it&rsquo;s just like computed property names via <code>q[x]</code>.  In fact a namespace <code>q</code> could be modeled as an object mapping string to string, so that evaluating a qualified name <code>q::x</code> could be evaluated via <code>eval(q[x])</code>.  If the reference is not lexical, but in object <code>o</code>, it&rsquo;s like <code>eval(&rdquo;o[&rsquo;&rdquo; + q[x] + &ldquo;&lsquo;]&rdquo;)</code> (provided <code>q[x]</code> doesn&rsquo;t contain any single-quote characters).
</p>

<p>
I know E4X introduced namespaces as values, but the usability experience (as with <acronym title="Extensible Markup Language">XML</acronym> namespaces in general) has been dismal.  Do we really want to build on this, especially if it threatens soundness?
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/03/16 10:22</em> 
</p>
<hr noshade="noshade" size="1" />

<p>
This comment is unrelated to the discussion above, but reflects feelings I&rsquo;ve had during the recent meetings. 
</p>

<p>
I&rsquo;ve really come to dislike this proposal (even though I made it); the more I see the differences between the static and dynamic translation modes, the more I think we&rsquo;d be causing more cost than benefit if we pursue this path. At least with the traits design, we have a proof of existence that it works, and it carries the virtue that you decide <em>early</em> how you&rsquo;re going to treat a name lookup, and then enter distinct code paths thereafter. I&rsquo;ve come to believe that design is in fact better than artificially unifying prototypes and traits. 
</p>

<p>
Does anyone dearly want to keep this proposal alive? I&rsquo;d be happy (really happy, not just &ldquo;quietly resigned&rdquo;) to move it to the &ldquo;withdrawn&rdquo; section.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x67%3B%26%23x72%3B%26%23x61%3B%26%23x79%3B%26%23x64%3B%26%23x6f%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x67;&#x72;&#x61;&#x79;&#x64;&#x6f;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">graydon</a> 2006/04/06 23:17</em>
</p>

<p>
At least we should consider renaming <strong>traits</strong> (possibly to <strong>meta slots</strong>) to avoid confusion with the meaning of traits in other languages.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x6a%3B%26%23x6f%3B%26%23x64%3B%26%23x79%3B%26%23x65%3B%26%23x72%3B%26%23x40%3B%26%23x61%3B%26%23x64%3B%26%23x6f%3B%26%23x62%3B%26%23x65%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x6a;&#x6f;&#x64;&#x79;&#x65;&#x72;&#x40;&#x61;&#x64;&#x6f;&#x62;&#x65;&#x2e;&#x63;&#x6f;&#x6d;">Jeff Dyer</a> 2006/04/07 10:19</em>
</p>

<p>
Links: 
</p>
<ul>
<li class="level1"><div class="li"> <a href="http://www.iam.unibe.ch/~scg/Research/Traits/" class="urlextern" target="_blank" title="http://www.iam.unibe.ch/~scg/Research/Traits/" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Traits for Squeak (Smalltalk)</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://research.sun.com/projects/plrg/fortress0618.pdf" class="urlextern" target="_blank" title="http://research.sun.com/projects/plrg/fortress0618.pdf" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Fortress spec</a></div>
</li>
<li class="level1"><div class="li"> <a href="http://scala.epfl.ch/intro/traits.html" class="urlextern" target="_blank" title="http://scala.epfl.ch/intro/traits.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Scala traits</a></div>
</li>
</ul>

<p>
  &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2006/04/07 12:09</em>
</p>

<p>
Perhaps &ldquo;class metaslots&rdquo; vs. &ldquo;prototype metaslots&rdquo; (though both those terms are a bit verbose).
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x67%3B%26%23x72%3B%26%23x61%3B%26%23x79%3B%26%23x64%3B%26%23x6f%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x63%3B%26%23x6f%3B%26%23x6d%3B" class="mail" title="&#x67;&#x72;&#x61;&#x79;&#x64;&#x6f;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">graydon</a> 2006/04/07 13:51</em> 
</p>

</div>
<!-- SECTION [3127-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/8/89166907a5c6a1a100620e251a591dfd.xhtml used -->
</body>
</html>
