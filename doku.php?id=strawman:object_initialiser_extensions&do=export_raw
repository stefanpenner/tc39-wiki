====== Strawman: Declarative Object and Class Abstractions Based Upon Extended Object Initialisers ======

//This proposal has been supercede by [[strawman:basic_object_literal_extensions|Intergrated Object Literal Extensions]].//

Allen Wirfs-Brock
Original Proposal August 10, 2009 \\
Revised Proposal March 2011

Abstraction creation is a central theme of object-based programming and ECMAScript provides many mechanisms  that support patterns for creating object based abstractions.  However, most of these patterns are constructive in nature using procedural code to create the abstractions.  This approach is  powerful in that it allows a wide variety of different technical mechanism to be  used to construct various abstractions. It also allows for programmer defined abstractions with application specific construction semantics. However, this variety can also be problematic. It creates complexity for both readers and writers of ECMAScript program and making it difficult to ECMAScript implementations to recognize common abstraction patterns so they can be optimized.  Most other programming language solve these issues by providing a straightforward declarative mechanism for defining object abstractions based upon a standardize semantics.

ECMAScript does provided a basic declarative mechanism for defining object-based abstractions.  Object initialisers provide a declarative mechanism for defining objects that in most situations is more concise, readable, and maintainable  than programmatic object creation using constructor functions and dynamic property insertion. The declarative nature of object initialisers  also makes it easier for implementations to perform various object representation optimization. However, existing ECMAScript object initialisers do not provide declarative solutions for a number of abstraction capabilities that are common used with ECMAScript objects.

This strawman proposed ways in which ECMAScript object initialisers  can be extended to make them more useful for building complete object abstractions.  A number of individual candidate extensions are identified. These extensions could be selectively and individually added to the language.  However, the individual extensions in combination turn ECMAScript object initialisers  into a declarative abstraction mechanism that is powerful enough to serve as the primary abstraction mechanism of the language.

The goal of these extensions is not to introduce a new semantics of objects that differs from what is already in ECMAScript. Instead, it attempts to incrementally improve the existing ECMAScript abstraction mechanisms without introducing anything that a typical user might perceive as new fundamental concepts.  The proposal does introduce a more concrete manifestation of "classes", but the semantics they exhibit are exactly those that are already used by the built-in ECMAScript library objects.
















===== Individual Extensions =====
  * [[Concise Object Literal Extensions]] this is an alternative to several of the following proposals

  * [[strawman:Obj_initialiser_meta|Object Initialiser Meta Properties]]
  * [[strawman:Obj_initialiser_methods|Method Properties]]
  * [[strawman:Obj_initialiser_const|Other Object Initialiser Property Attribute Modifiers]]
    * see [[proto operator]] and [[concise object literal extensions]] for an  alternative to the above
  * [[strawman:object initialiser shorthand|Implicit property initialization expressions]]
  * [[Object Initialiser Initialization Blocks]]
  * [[strawman:obj_initialiser_class_abstraction|Class Initialisers]]
    * [[super in Object Initialisers]]
The following describes how the [[Private Names]] extension integrates with extended Object Initialisers.
  * [[Private Names in Object Initialisers]]

[[Instance Variables]] can also be used with extended Object and Class Initialisers.










===== Combined Syntax =====
The following provides an integrated syntax definition for all of the individual extensions combined with the ES5 Object initialiser syntax:

//ObjectLiteral// : \\
**{** //Block//<sub>opt</sub> **}**\\
**{** //MetaProperties// **}**\\
**{** //MetaProperties// **,** //Block//<sub>opt</sub> **}**\\
**{** //MetaProperties// **,** //PrivateNamesList<sub>opt</sub>// //PropertyNameAndValueList// **}**\\
**{** //MetaProperties// **,** //PrivateNamesList<sub>opt</sub>// //PropertyNameAndValueList// **,** //Block//<sub>opt</sub> **}**\\
**{** //PrivateNamesList<sub>opt</sub>// //PropertyNameAndValueList// **}**\\
**{** //PrivateNamesList<sub>opt</sub>// //PropertyNameAndValueList// **,** //Block//<sub>opt</sub> **}**\\


//ArrayLiteral// :\\
**%%[%%** //Ellision<sub>opt</sub>// **]**\\
**%%[%%** //MetaProperties// //Ellision<sub>opt</sub>// **]**\\
**%%[%%** //MetaProperties// **,** //ElementList//  **]**\\
**%%[%%** //MetaProperties// **,** //ElementList// **,**  //Ellision<sub>opt</sub>// **]**\\
**%%[%%** //ElementList//  **]**\\
**%%[%%** //ElementList// **,**  //Ellision<sub>opt</sub>// **]**\\

//MetaProperties// :\\
**%%<%%** MetaPropertyList **%%>%%**\\
\\
//MetaPropertyList// :\\
//MetaProperty//\\
//MetaPropertyList// **,** //MetaProperty//\\
\\
//MetaProperty// :\\
**proto** **:** //MemberExpression//\\
**sealed**\\
**frozen**\\
**closed**

//PrivateNamesList// :\\
//PrivateName// \\
//PrivateNamesList//  //PrivateName//\\

//PrivateName// :\\
**''private''** //identifier// **,**\\
**''private''** //identifier// **'':''** //AssignmentExpression **,**//



//PropertyNameAndValueList// :\\
//PropertyAssignment//\\
//PropertyNameAndValueList// **,** //PropertyAssignment//\\
\\
//PropertyAssignment// :\\
//IdentifierName//\\
**sealed**<sub>opt</sub> //PropertyName// **:** **const**<sub>opt</sub> //AssignmentExpression//\\
**sealed**<sub>opt</sub> **var** //PropertyName// **:** **const**<sub>opt</sub> //AssignmentExpression//\\
**sealed**<sub>opt</sub> **get** //PropertyName// **( ) {** //FunctionBody// **}**\\
**sealed**<sub>opt</sub> **set** //PropertyName// **(** //PropertySetParameterList// **) {** //FunctionBody// **}**\\
**sealed**<sub>opt</sub> **method** //PropertyName// **(** //FormalParameterListopt// **) {** //FunctionBody// **}** \\
\\
//PropertyName// :\\
//IdentifierName//\\
//StringLiteral//\\
//NumericLiteral//\\
\\
//PropertySetParameterList// :\\
//Identifier//

//ClassDeclaration// :\\
**''class''** //Identifier// //ClassBody//

//ClassExpression// :\\
**''class''** //Identifier<sub>opt</sub>// //ClassBody//

//ClassBody//\\
**{ }**\\
**{** //ClassMetaProperties// **}**\\
**{** //ClassMetaProperties// **, }**\\
**{** //ClassMetaProperties// **,**  //PrivateNamesList<sub>opt</sub>//  //ClassPropertyNameAndValueList// **}**\\
**{** //ClassMetaProperties// **,**  //PrivateNamesList<sub>opt</sub>//  //ClassPropertyNameAndValueList// **, }**\\
**{** //PrivateNamesList<sub>opt</sub>// //ClassPropertyNameAndValueList// **}**\\
**{** //PrivateNamesList<sub>opt</sub>// //ClassPropertyNameAndValueList// **, }**\\


//ClassMetaProperties// :\\
**%%<%%** ClassMetaPropertyList **%%>%%**\\

//ClassMetaPropertyList// :\\
//ClassMetaProperty//\\
//ClassMetaPropertyList// **,** //MetaProperty//\\

//ClassMetaProperty// :\\
**''proto''** **:** //AssignmentExpression//\\
**''superclass''** **:** //AssignmentExpression//\\
**''sealed''** \\
**''frozen''** \\
**''closed''** \\

//ClassPropertyNameAndValueList// :\\
//ClassPropertyAssignment//\\
//ClassPropertyNameAndValueList// **,** //ClassPropertyAssignment//\\

//ClassPropertyNameAndValueList// :\\
//ClassPropertyAssignment//\\
//ClassPropertyNameAndValueList// **,** //ClassPropertyAssignment//\\

//ClassPropertyAssignment// : \\
**''class''** //PropertyAssignment// \\
//ConstrutorBody// \\
//PropertyAssignment//

//ConstrutorBody// : \\
**''new''** //ObjectLiteral//  \\
**''new''** **(** //FormalParameterList<sub>opt</sub>// **)** //ObjectLiteral//  \\



