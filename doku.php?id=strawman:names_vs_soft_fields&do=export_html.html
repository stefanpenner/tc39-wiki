<html>
<head>
  <meta name="generator" content="DokuWiki Release 2005-09-22e" />
  <link rel="start" href="index.html" />
  <link rel="contents" href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=index.html" title="" />
  <link rel="alternate" type="application/rss+xml" title="Recent Changes" href="feed.php" />
  <link rel="alternate" type="application/rss+xml" title="Current Namespace" href="feed.php%3Fmode=list&amp;ns=strawman" />
  <link rel="alternate" type="text/html" title="Plain HTML" href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html" />
  <link rel="alternate" type="text/plain" title="Wiki Markup" href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_raw" />
  <link rel="stylesheet" media="screen" type="text/css" href="lib/styles/style.css" />
  <meta name="robots" content="noindex,nofollow" />
  <script language="javascript" type="text/javascript" charset="utf-8">
    var alertText   = 'Please enter the text you want to format.\nIt will be appended to the end of the document.'
    var notSavedYet = 'Unsaved changes will be lost.\nReally continue?'
    var DOKU_BASE   = '/'
  </script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/script.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/tw-sack.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/ajax.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domLib.js"></script>
  <script language="javascript" type="text/javascript" charset="utf-8" src="lib/scripts/domTT.js"></script>
  <link rel="stylesheet" type="text/css" href="lib/plugins/plugin/style.css" />
</head>
<body>
<div class="toc">
<div class="tocheader"> <script type="text/javascript">showTocToggle("+","-")</script>Table of Contents</div>
<div id="tocinside">
<ul class="toc">
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html#overview" class="toc">Overview</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html#the_private_declaration" class="toc">The private declaration</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html#using_private_identifiers" class="toc">Using Private Identifiers</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html#private_identifiers_in_object_literals" class="toc">Private Identifiers in Object Literals</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html#private_declaration_scoping" class="toc">Private Declaration Scoping</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html#private_declarations_expand_to_unique_hidden_variable_names" class="toc">Private Declarations Expand to Unique Hidden Variable Names</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html#accessing_private_identifiers_as_soft_field_values" class="toc">Accessing Private Identifiers as Soft Field Values</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html#conflict-free_object_extension_using_soft_fields" class="toc">Conflict-Free Object Extension Using Soft Fields</a></span><ul class="toc">
<li class="clear"><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html#crucial_difference" class="toc">Crucial difference</a></span></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html#enumeration_and_reflection" class="toc">Enumeration and Reflection</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html#soft_fields_support_encapsulation" class="toc">Soft Fields Support Encapsulation</a></span></li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html#interactions_with_other_harmony_proposals" class="toc">Interactions with other Harmony Proposals</a></span><ul class="toc">
<li class="clear"><ul class="toc">
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html#enhanced_object_literals" class="toc">Enhanced Object Literals</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html#proxies" class="toc">Proxies</a></span></li>
<li class="level3"><span class="li"><a href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html#modules" class="toc">Modules</a></span></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><span class="li"><a href="doku.php%3Fid=strawman:names_vs_soft_fields&amp;do=export_html.html#references" class="toc">References</a></span></li>
</ul>
</div>
</div>

<a name="overview"></a><h1>Overview</h1>
<div class="level1">

<p>
 To better understand the differences between <a href="doku.php%3Fid=strawman:inherited_explicit_soft_fields.html" class="wikilink1" title="strawman:inherited_explicit_soft_fields" onclick="return svchk()" onkeypress="return svchk()">soft fields</a> and <a href="doku.php%3Fid=strawman:private_names.html" class="wikilink1" title="strawman:private_names" onclick="return svchk()" onkeypress="return svchk()">private names</a>, this page goes through all the examples from the latter (as of this writing) and explores how they&rsquo;d look as translated to use soft fields instead. This translation does not imply endorsement of all elements of the names proposal as translated to soft fields, such as the proposed syntactic extensions. However, these translations do establish that these syntactic choices are orthogonal to the semantic controversy and so can be argued about separately.
</p>

<p>
Identifiers ending with triple underbar below signify unique identifiers generated by expansion that are known not to conflict with any identifiers that appear elsewhere.
</p>

</div>
<!-- SECTION [1-793] -->
<a name="the_private_declaration"></a><h1>The private declaration</h1>
<div class="level1">

<p>
 Adapted from <a href="doku.php%3Fid=strawman:private_names.html#the_private_declaration" class="wikilink1" title="strawman:private_names" onclick="return svchk()" onkeypress="return svchk()">the private declaration</a>
</p>
<pre class="code javascript"><span class="kw2">private</span> secret;  <span class="co1">//create a new soft field that is bound to the private identifier ''secret''.</span>
<span class="kw2">private</span> _x,_y;   <span class="co1">//create two soft fields bound to two private identifiers</span>
... <span class="me1">foo</span>.<span class="me1">secret</span> ...
<span class="me1">foo</span>.<span class="me1">secret</span> = val;
<span class="kw2">const</span> obj = <span class="br0">&#123;</span>secret: val, ...<span class="br0">&#125;</span>;
#.<span class="me1">secret</span></pre>
<p>
expands to
</p>
<pre class="code javascript"><span class="kw2">const</span> secret___ = SoftField<span class="br0">&#40;</span><span class="br0">&#41;</span>;
<span class="kw2">const</span> _x___ = SoftField<span class="br0">&#40;</span><span class="br0">&#41;</span>, _y___ = SoftField<span class="br0">&#40;</span><span class="br0">&#41;</span>;
... <span class="me1">secret___</span>.<span class="me1">get</span><span class="br0">&#40;</span>foo<span class="br0">&#41;</span> ...
<span class="me1">secret___</span>.<span class="me1">set</span><span class="br0">&#40;</span>foo, val<span class="br0">&#41;</span>;
<span class="kw2">const</span> obj = <span class="br0">&#123;</span>...<span class="br0">&#125;</span>; secret___.<span class="me1">set</span><span class="br0">&#40;</span>obj, val<span class="br0">&#41;</span>;
secret___</pre>
</div>
<!-- SECTION [794-1397] -->
<a name="using_private_identifiers"></a><h1>Using Private Identifiers</h1>
<div class="level1">

<p>
 Adapted from <a href="doku.php%3Fid=strawman:private_names.html#using_private_identifiers" class="wikilink1" title="strawman:private_names" onclick="return svchk()" onkeypress="return svchk()">using private identifiers</a>
</p>
<pre class="code javascript"><span class="kw2">function</span> makeObj<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
   <span class="kw2">private</span> secret;
   <span class="kw2">var</span> obj = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
   obj.<span class="me1">secret</span> = <span class="nu0">42</span>;  <span class="co1">//obj has a soft field</span>
   <span class="kw3">print</span><span class="br0">&#40;</span>obj.<span class="me1">secret</span><span class="br0">&#41;</span>;<span class="co1">//42 -- accesses the soft field's value</span>
   <span class="kw3">print</span><span class="br0">&#40;</span>obj<span class="br0">&#91;</span><span class="st0">"secret"</span><span class="br0">&#93;</span><span class="br0">&#41;</span>; <span class="co1">//undefined -- a soft field is not a property</span>
   <span class="kw1">return</span> obj;
<span class="br0">&#125;</span>
<span class="kw2">var</span> obj=makeObj<span class="br0">&#40;</span><span class="br0">&#41;</span>;
<span class="kw3">print</span><span class="br0">&#40;</span>obj<span class="br0">&#91;</span><span class="st0">"secret"</span><span class="br0">&#93;</span><span class="br0">&#41;</span>; <span class="co1">//undefined -- a soft field is still not a property</span>
<span class="kw3">print</span><span class="br0">&#40;</span>obj.<span class="me1">secret</span><span class="br0">&#41;</span>;    <span class="co1">//undefined -- this statement is not in the scope of the private declaration so the</span>
                      <span class="co1">//string value &quot;secret&quot; is used to look up the property.  It is not a soft field.</span></pre>
<p>
This technique can be used to define &ldquo;instance-private&rdquo; properties:
</p>
<pre class="code javascript"><span class="kw2">function</span> Thing<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">private</span> key;   <span class="co1">// each invocation will use a new soft field</span>
    <span class="kw1">this</span>.<span class="me1">key</span> = <span class="st0">"instance private value"</span>;
    <span class="kw1">this</span>.<span class="me1">hasKey</span> = <span class="kw2">function</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> x.<span class="me1">key</span> === <span class="kw1">this</span>.<span class="me1">key</span>;  <span class="co1">//x.key should be undefined if x!==this</span>
    <span class="br0">&#125;</span>;
    <span class="kw1">this</span>.<span class="me1">getThingKey</span> = <span class="kw2">function</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> x.<span class="me1">key</span>;
    <span class="br0">&#125;</span>;
<span class="br0">&#125;</span></pre>
<p>
Instance-private instance state is better done by lexical capture
</p>
<pre class="code javascript"><span class="kw2">function</span> Thing<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">const</span> key = <span class="st0">"instance private value"</span>;
    <span class="kw1">this</span>.<span class="me1">hasKey</span> = <span class="kw2">function</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> x === <span class="kw1">this</span>;
    <span class="br0">&#125;</span>;
    <span class="kw1">this</span>.<span class="me1">getThingKey</span> = <span class="kw2">function</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>x === <span class="kw1">this</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> key; <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>;
<span class="br0">&#125;</span></pre>
<p>
Either technique produces the same external effect:
</p>
<pre class="code javascript"><span class="kw2">var</span> thing1 = <span class="kw2">new</span> Thing;
<span class="kw2">var</span> thing2 = <span class="kw2">new</span> Thing;
&nbsp;
<span class="kw3">print</span><span class="br0">&#40;</span><span class="st0">"key"</span> <span class="kw1">in</span> thing1<span class="br0">&#41;</span>;       <span class="co1">// false</span>
<span class="kw3">print</span><span class="br0">&#40;</span>thing2.<span class="me1">key</span><span class="br0">&#41;</span>;            <span class="co1">//undefined</span>
<span class="kw3">print</span><span class="br0">&#40;</span>thing1.<span class="me1">hasKey</span><span class="br0">&#40;</span>thing1<span class="br0">&#41;</span><span class="br0">&#41;</span>; <span class="co1">// true</span>
<span class="kw3">print</span><span class="br0">&#40;</span>thing1.<span class="me1">hasKey</span><span class="br0">&#40;</span>thing2<span class="br0">&#41;</span><span class="br0">&#41;</span>; <span class="co1">// false</span></pre>
<p>
By changing the scope of the private declaration a similar technique can be used to define &ldquo;class-private&rdquo; properties:
</p>
<pre class="code javascript"><span class="kw2">private</span> key;  <span class="co1">//the a soft field shared by all instances of Thing.</span>
<span class="kw2">function</span> Thing<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">this</span>.<span class="me1">key</span> = <span class="st0">"class private value"</span>;
    <span class="kw1">this</span>.<span class="me1">hasKey</span> = <span class="kw2">function</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> x.<span class="me1">key</span> === <span class="kw1">this</span>.<span class="me1">key</span>;
    <span class="br0">&#125;</span>;
    <span class="kw1">this</span>.<span class="me1">getThingKey</span> = <span class="kw2">function</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> x.<span class="me1">key</span>;
    <span class="br0">&#125;</span>;
<span class="br0">&#125;</span>
&nbsp;
<span class="kw2">var</span> thing1 = <span class="kw2">new</span> Thing;
<span class="kw2">var</span> thing2 = <span class="kw2">new</span> Thing;
&nbsp;
<span class="kw3">print</span><span class="br0">&#40;</span><span class="st0">"key"</span> <span class="kw1">in</span> thing1<span class="br0">&#41;</span>;       <span class="co1">// false</span>
<span class="kw3">print</span><span class="br0">&#40;</span>thing1.<span class="me1">hasKey</span><span class="br0">&#40;</span>thing1<span class="br0">&#41;</span><span class="br0">&#41;</span>; <span class="co1">// true</span>
<span class="kw3">print</span><span class="br0">&#40;</span>thing1.<span class="me1">hasKey</span><span class="br0">&#40;</span>thing2<span class="br0">&#41;</span><span class="br0">&#41;</span>; <span class="co1">// true</span></pre>
</div>
<!-- SECTION [1398-3661] -->
<a name="private_identifiers_in_object_literals"></a><h1>Private Identifiers in Object Literals</h1>
<div class="level1">

<p>
 Adapted from <a href="doku.php%3Fid=strawman:private_names.html#private_identifiers_in_object_literals" class="wikilink1" title="strawman:private_names" onclick="return svchk()" onkeypress="return svchk()">private identifiers in object literals</a>
</p>
<pre class="code javascript"><span class="kw2">function</span> makeObj<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
   <span class="kw2">private</span> secret;
   <span class="kw2">var</span> obj = <span class="br0">&#123;</span>secret: <span class="nu0">42</span><span class="br0">&#125;</span>;
   <span class="kw3">print</span><span class="br0">&#40;</span>obj.<span class="me1">secret</span><span class="br0">&#41;</span>;<span class="co1">//42 -- access the soft field's value</span>
   <span class="kw3">print</span><span class="br0">&#40;</span>obj<span class="br0">&#91;</span><span class="st0">"secret"</span><span class="br0">&#93;</span><span class="br0">&#41;</span>; <span class="co1">//undefined -- a soft field is not a property</span>
   <span class="kw1">return</span> obj;
<span class="br0">&#125;</span></pre><pre class="code javascript"><span class="kw2">function</span> Thing<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">private</span> key;
    <span class="kw1">return</span> <span class="br0">&#123;</span>
       key : <span class="st0">"instance private value"</span>,
       hasKey : <span class="kw2">function</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="br0">&#123;</span>
          <span class="kw1">return</span> x.<span class="me1">key</span> === <span class="kw1">this</span>.<span class="me1">key</span>;  <span class="co1">//x.key should be undefined if x!==this</span>
       <span class="br0">&#125;</span>,
       getThingKey : <span class="kw2">function</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="br0">&#123;</span>
          <span class="kw1">return</span> x.<span class="me1">key</span>;
       <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>;
<span class="br0">&#125;</span></pre>
<p>
or, preserving the same external behavior:
</p>
<pre class="code javascript"><span class="kw2">function</span> Thing<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw2">const</span> key = <span class="st0">"instance private value"</span>;
    <span class="kw1">return</span> <span class="br0">&#123;</span>
       hasKey : <span class="kw2">function</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="br0">&#123;</span>
          <span class="kw1">return</span> x === <span class="kw1">this</span>;
       <span class="br0">&#125;</span>,
       getThingKey : <span class="kw2">function</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="br0">&#123;</span>
          <span class="kw1">if</span> <span class="br0">&#40;</span>x === <span class="kw1">this</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> key; <span class="br0">&#125;</span>
       <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>;
<span class="br0">&#125;</span></pre><pre class="code javascript"><span class="kw2">private</span> key;
<span class="kw2">function</span> Thing<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">return</span> <span class="br0">&#123;</span>
       key : <span class="st0">"class private value"</span>,
       hasKey : <span class="kw2">function</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="br0">&#123;</span>
          <span class="kw1">return</span> x.<span class="me1">key</span> === <span class="kw1">this</span>.<span class="me1">key</span>;  <span class="co1">//x.key should be undefined if x!==this</span>
       <span class="br0">&#125;</span>,
       getThingKey : <span class="kw2">function</span><span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="br0">&#123;</span>
          <span class="kw1">return</span> x.<span class="me1">key</span>;
       <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>;
<span class="br0">&#125;</span></pre>
</div>
<!-- SECTION [3662-4960] -->
<a name="private_declaration_scoping"></a><h1>Private Declaration Scoping</h1>
<div class="level1">

<p>
 Adapted from <a href="doku.php%3Fid=strawman:private_names.html#private_declaration_scoping" class="wikilink1" title="strawman:private_names" onclick="return svchk()" onkeypress="return svchk()">private declaration scoping</a>
</p>
<pre class="code javascript"><span class="kw2">function</span> outer<span class="br0">&#40;</span>obj<span class="br0">&#41;</span> <span class="br0">&#123;</span>
   <span class="kw2">private</span> <span class="kw3">name</span>;
   <span class="kw2">function</span> inner<span class="br0">&#40;</span>obj<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      <span class="kw2">private</span> <span class="kw3">name</span>;
      obj.<span class="kw3">name</span> = <span class="st0">"inner name"</span>;
      <span class="kw3">print</span><span class="br0">&#40;</span>obj.<span class="kw3">name</span><span class="br0">&#41;</span>;   <span class="co1">//&quot;inner name&quot; because outer name declaration is shadowed</span>
   <span class="br0">&#125;</span>
   obj.<span class="kw3">name</span> = <span class="st0">"outer name"</span>;
   inner<span class="br0">&#40;</span>obj<span class="br0">&#41;</span>
   <span class="kw3">print</span><span class="br0">&#40;</span>obj.<span class="kw3">name</span><span class="br0">&#41;</span>;      <span class="co1">//&quot;outer name&quot;</span>
<span class="br0">&#125;</span>
<span class="kw2">var</span> obj = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
obj.<span class="kw3">name</span> = <span class="st0">"public name"</span>;
outer<span class="br0">&#40;</span>obj<span class="br0">&#41;</span>;
<span class="kw3">print</span><span class="br0">&#40;</span>obj.<span class="kw3">name</span><span class="br0">&#41;</span>;            <span class="co1">//&quot;public name&quot;</span></pre>
<p>
After executing the above code, the object that was created will have one property and two associated soft fields:
</p>
<table class="inline">
	<tr>
		<th>Property or Fields </th><th> Value </th>
	</tr>
	<tr>
		<td>&ldquo;name&rdquo;</td><td>&ldquo;public name&rdquo;</td>
	</tr>
	<tr>
		<td>private name<sub>outer</sub></td><td>&ldquo;outer name&rdquo;</td>
	</tr>
	<tr>
		<td>private name<sub>inner</sub></td><td>&ldquo;inner name&rdquo;</td>
	</tr>
</table>
<br />

</div>
<!-- SECTION [4961-5749] -->
<a name="private_declarations_expand_to_unique_hidden_variable_names"></a><h1>Private Declarations Expand to Unique Hidden Variable Names</h1>
<div class="level1">

<p>
 Adapted from <a href="doku.php%3Fid=strawman:private_names.html#private_declarations_exist_in_a_parallel_environment" class="wikilink1" title="strawman:private_names" onclick="return svchk()" onkeypress="return svchk()">private declarations exist in a parallel environment</a>
</p>

<p>
Consider the following very common idiom used in a constructor declaration: 
</p>
<pre class="code javascript"><span class="kw2">function</span> Point<span class="br0">&#40;</span>x,y<span class="br0">&#41;</span> <span class="br0">&#123;</span>
   <span class="kw1">this</span>.<span class="me1">x</span> = x;
   <span class="kw1">this</span>.<span class="me1">y</span> = y;
   <span class="co1">//... methods that use x and y properties</span>
<span class="br0">&#125;</span>
<span class="kw2">var</span> pt = <span class="kw2">new</span> Point<span class="br0">&#40;</span><span class="nu0">1</span>,<span class="nu0">2</span><span class="br0">&#41;</span>;</pre><pre class="code javascript"><span class="kw2">function</span> Point<span class="br0">&#40;</span>x,y<span class="br0">&#41;</span> <span class="br0">&#123;</span>
   <span class="kw2">private</span> x, y;
   <span class="kw1">this</span>.<span class="me1">x</span> = x;
   <span class="kw1">this</span>.<span class="me1">y</span> = y;
   <span class="co1">//... methods that use private x and y properties</span>
<span class="br0">&#125;</span>
<span class="kw2">var</span> pt = <span class="kw2">new</span> Point<span class="br0">&#40;</span><span class="nu0">1</span>,<span class="nu0">2</span><span class="br0">&#41;</span>;</pre><pre class="code javascript"><span class="kw2">function</span> Point<span class="br0">&#40;</span>x,y<span class="br0">&#41;</span> <span class="br0">&#123;</span>
   <span class="kw2">const</span> x___ = SoftField<span class="br0">&#40;</span><span class="br0">&#41;</span>, y___ = SoftField<span class="br0">&#40;</span><span class="br0">&#41;</span>;
   x___.<span class="me1">set</span><span class="br0">&#40;</span><span class="kw1">this</span>, x<span class="br0">&#41;</span>;
   y___.<span class="me1">set</span><span class="br0">&#40;</span><span class="kw1">this</span>, y<span class="br0">&#41;</span>;
   <span class="co1">//... methods that use private x and y properties</span>
<span class="br0">&#125;</span>
<span class="kw2">var</span> pt = <span class="kw2">new</span> Point<span class="br0">&#40;</span><span class="nu0">1</span>,<span class="nu0">2</span><span class="br0">&#41;</span>;</pre>
</div>
<!-- SECTION [5750-6547] -->
<a name="accessing_private_identifiers_as_soft_field_values"></a><h1>Accessing Private Identifiers as Soft Field Values</h1>
<div class="level1">

<p>
 Adapted from <a href="doku.php%3Fid=strawman:private_names.html#accessing_private_names_as_values" class="wikilink1" title="strawman:private_names" onclick="return svchk()" onkeypress="return svchk()">accessing private names as values</a>
</p>

<p>
The <code>private</code> declaration normally both creates a new soft field and introduces a identifier binding that can be used only in &ldquo;property name&rdquo; syntactic contexts to access the new soft field by the lexically bound identifier.
</p>

<p>
However, in some circumstances it is necessary to access the actual soft field as an expression value, not as an apparent property name on the right of <code>.</code> or the left of <code>:</code> in an object initialiser. This requires a special form than can be used in an expression to access the soft field binding of a private identifier.  The syntactic form is <code><strong>#.</strong></code> <em>IdentifierName</em>.  This may be used as a <em>PrimaryExpression</em> and yields the soft field of the <em>IdentifierName</em>.  This may be either a soft field or a string value, depending upon whether the expression is within the scope of a <code>private</code> declaration for that <em>IdentifierName</em>;
</p>
<pre class="code javascript"><span class="kw2">function</span> addPrivateProperty<span class="br0">&#40;</span>obj, init<span class="br0">&#41;</span> <span class="br0">&#123;</span>
   <span class="kw2">private</span> pname;     <span class="co1">//create a new soft field</span>
   obj.<span class="me1">pname</span> = init;  <span class="co1">//set this soft field</span>
   <span class="kw1">return</span> #.<span class="me1">pname</span>;    <span class="co1">//return the soft field</span>
<span class="br0">&#125;</span></pre><pre class="code javascript"><span class="kw2">function</span> addPrivateProperty<span class="br0">&#40;</span>obj, init<span class="br0">&#41;</span> <span class="br0">&#123;</span>
   <span class="kw2">const</span> pname___ = SoftField<span class="br0">&#40;</span><span class="br0">&#41;</span>;
   pname___.<span class="me1">set</span><span class="br0">&#40;</span>obj, init<span class="br0">&#41;</span>;
   <span class="kw1">return</span> pname___;
<span class="br0">&#125;</span></pre><pre class="code javascript"><span class="kw2">var</span> myObj = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
<span class="kw2">var</span> answerKey = addPrivateProperty<span class="br0">&#40;</span>myObj, <span class="nu0">42</span><span class="br0">&#41;</span>;
<span class="kw3">print</span><span class="br0">&#40;</span>answerKey.<span class="me1">get</span><span class="br0">&#40;</span>myObj<span class="br0">&#41;</span><span class="br0">&#41;</span>;  <span class="co1">// AFAICT, this is the *only* claimed advantage of Names over SoftFields. </span>
<span class="co1">//myObj can now be made globally available but answerKey can be selectively passed to privileged code</span></pre>
<p>
Note that simply assigning a soft field to a variable does not make that variable a private identifier. For example, in the above example, the print statement could not validly be replaced with:
</p>
<pre class="code javascript"><span class="kw3">print</span><span class="br0">&#40;</span>myObj.<span class="me1">answerKey</span><span class="br0">&#41;</span>;</pre>
<p>
This would produce <code>&ldquo;undefined&rdquo;</code> because it would access the non-existent property whose string valued property name would be <code>&ldquo;answerKey&rdquo;</code>.  Only identifiers that have been explicitly declared using <code>private</code> are private identifiers.
</p>

<p>
&ldquo;<a href="doku.php%3Fid=strawman:inherited_explicit_soft_fields.html#can_we_subsume_private_names" class="wikilink1" title="strawman:inherited_explicit_soft_fields" onclick="return svchk()" onkeypress="return svchk()">can we subsume private names</a>&rdquo; explains how soft fields as value proxies could support a property-like usage of [], so this code could indeed be written as
</p>
<pre class="code javascript"><span class="kw3">print</span><span class="br0">&#40;</span>myObj<span class="br0">&#91;</span>answerKey<span class="br0">&#93;</span><span class="br0">&#41;</span>;</pre>
<p>
 If <code><strong>#.</strong></code> is not within the scope of a <code>private</code> declaration for its <em>IdentifierName</em> then the value produced is the string value of the <em>IdentifierName</em>.
</p>

<p>
As an expressive convenience, <code>private</code> declarations can be used to associate a private identifier with an already existing soft field.  This is done by using a <code>private</code> declaration of the form:
</p>

<p>
 <strong><code>private</code></strong> <em>Identifier</em> <strong><code>=</code></strong> <em>Initialiser</em> <strong><code>;</code></strong> <br/>
 
</p>

<p>
The Names proposal asks: &ldquo;If <em>Initialiser</em> does not evaluate to a soft field, a TypeError exception is thrown. (<sup><img src="lib/images/smileys/icon_question.gif" align="middle" alt=":?:" /></sup>  <em>for uniformity, should string values be allowed?  In that case, local private name bindings could be string valued.</em>)&rdquo;
</p>

<p>
If the answer is true, the one supposed advantage of Names over soft fields goes away. Our contentious bit of code becomes:
</p>
<pre class="code javascript"><span class="kw2">private</span> ak = answerKey; <span class="co1">// soft field or string</span>
<span class="kw3">print</span><span class="br0">&#40;</span>obj.<span class="me1">ak</span><span class="br0">&#41;</span>; <span class="co1">// works either way</span></pre><pre class="code javascript"><span class="kw2">private</span> name1;   <span class="co1">//value is a new soft field</span>
<span class="kw2">private</span> name2 = #.<span class="me1">name1</span>  <span class="co1">//name2 can be used to access the same soft field as name1</span></pre><table class="inline">
	<tr>
		<td>Other possible syntactic forms for converting a private identifier to an expression value include: </td>
	</tr>
	<tr>
		<td><code><strong>private</strong> </code><em>IdentifierName</em></td>
	</tr>
	<tr>
		<td><code><strong>(private</strong> </code><em>IdentifierName</em><strong><code>)</code></strong></td>
	</tr>
	<tr>
		<td><strong><code>.</code></strong><em>IdentifierName</em></td>
	</tr>
	<tr>
		<td><strong><code>`</code></strong><em>IdentifierName</em></td>
	</tr>
	<tr>
		<td><strong><code>#`</code></strong><em>IdentifierName</em></td>
	</tr>
	<tr>
		<td><code><strong>#&rsquo;</strong></code><em>IdentifierName</em></td>
	</tr>
</table>
<br />

</div>
<!-- SECTION [6548-10378] -->
<a name="conflict-free_object_extension_using_soft_fields"></a><h1>Conflict-Free Object Extension Using Soft Fields</h1>
<div class="level1">

<p>
 Adapted from <a href="doku.php%3Fid=strawman:private_names.html#conflict-free_object_extension_using_private_names" class="wikilink1" title="strawman:private_names" onclick="return svchk()" onkeypress="return svchk()">conflict-free object extension using private names</a>
</p>
<pre class="code javascript"><span class="kw2">function</span> installCloneLibrary<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
   <span class="kw2">private</span> clone;   <span class="co1">// the soft field for clone methods</span>
&nbsp;
   <span class="co1">// Install clone methods in key built-in prototypes:</span>
   Object.<span class="me1">prototype</span>.<span class="me1">clone</span> = <span class="kw2">function</span> <span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> ... <span class="br0">&#125;</span>;
   Array.<span class="me1">prototype</span>.<span class="me1">clone</span> = <span class="kw2">function</span> <span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
       ...
       <span class="me1">target</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span> = <span class="kw1">this</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span>.<span class="me1">clone</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;  <span class="co1">// recur on clone method</span>
       ...
   <span class="br0">&#125;</span>
   String.<span class="me1">prototype</span>.<span class="me1">clone</span> = <span class="kw2">function</span> <span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>...<span class="br0">&#125;</span>
   ...
   <span class="kw1">return</span> #.<span class="me1">clone</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="co1">// Example usage of CloneLibrary:</span>
<span class="kw2">private</span> clone = installCloneLibrary<span class="br0">&#40;</span><span class="br0">&#41;</span>;
installAnotherLibrary<span class="br0">&#40;</span><span class="br0">&#41;</span>;
<span class="kw2">var</span> twin = <span class="br0">&#91;</span><span class="br0">&#123;</span>a:<span class="nu0">0</span><span class="br0">&#125;</span>, <span class="br0">&#123;</span>b:<span class="nu0">1</span><span class="br0">&#125;</span><span class="br0">&#93;</span>.<span class="me1">clone</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;</pre>
<p>
Similarities: The above client of the <code>CloneLibrary</code> will work even if the other library also defines a method named <code>clone</code> on <code>Object.prototype</code>.  The second library would not have visibility of the soft field used for <code>clone</code> so it would either use a string property name or a different soft field for the method.  In either case there would be no conflict with the method defined by <code>CloneLibrary</code>. 
</p>

</div>
<!-- SECTION [10379-11517] -->
<a name="crucial_difference"></a><h3>Crucial difference</h3>
<div class="level3">

<p>
  For defensive programming, best practice in many environments will be to freeze the primordials early, as the dual of the existing best practice that one should not mutate the primordials. <a href="http://crpit.com/confpapers/CRPITV91Holkner.pdf" class="urlextern" target="_blank" title="http://crpit.com/confpapers/CRPITV91Holkner.pdf" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Evaluating the dynamic behaviour of Python applications</a> (See also <a href="http://gnuu.org/2010/12/13/too-lazy-to-type/" class="urlextern" target="_blank" title="http://gnuu.org/2010/12/13/too-lazy-to-type/" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">http://gnuu.org/2010/12/13/too-lazy-to-type/</a>) provides evidence that this will be compatible with much existing content. We should expect these best practices to grow during the time when people feel they can target ES5 but not yet ES6.
</p>

<p>
Consider if Object.prototype or Array.prototype were already frozen, as they should be, before the code above executes. Using soft fields, this extension works. Using private names, it is rejected. Allen argues at <a href="https://mail.mozilla.org/pipermail/es-discuss/2010-December/012330.html" class="urlextern" target="_blank" title="https://mail.mozilla.org/pipermail/es-discuss/2010-December/012330.html" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Private names use cases</a> that 
</p>
<pre class="code">    Allow third-party property extensions to built-in 
    objects or third-party frameworks that are guaranteed 
    to not have naming conflicts with unrelated extensions 
    to the same objects.</pre>

<p>
 is the more important use case. Soft fields provide for this use case. Private names do not. 
</p>
<hr noshade="noshade" size="1" />

<p>
Who knows whether frozen primordials will catch on? Many <acronym title="JavaScript">JS</acronym> hackers are vehemently opposed. PrototypeJS still extends built-in prototypes and its maintainers say that won&rsquo;t change. Allen clearly was talking about extending non-frozen shared objects in his &ldquo;Private names use cases&rdquo; message &ndash; he did not assume what you assume here. We need to agree on our assumptions before putting forth conclusions that we hope will be shared. I don&rsquo;t think everyone shares the belief that &ldquo;We should expect these best practices to grow during [any foreseeable future].&rdquo;
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2010/12/22 01:37</em>
</p>

<p>
Are we still confusing &ldquo;any&rdquo; and &ldquo;all&rdquo;? The original quote claims only that these best practices will grow in some environments. Regarding your &ldquo;any foreseeable future&rdquo;, this future is already long past. <a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Modifying_prototypes_of_builtin_objects#Modifying_prototypes_of_builtin_objects" class="urlextern" target="_blank" title="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml?showone=Modifying_prototypes_of_builtin_objects#Modifying_prototypes_of_builtin_objects" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">Google JavaScript Style Guide: Modifying prototypes of builtin objects</a> has long stated: 
</p>
<pre class="code">  Modifying prototypes of builtin objects
  [Recommendation:] No
  Modifying builtins like Object.prototype and Array.prototype 
  are strictly forbidden. Modifying other builtins like 
  Function.prototype is less dangerous but still leads to hard 
  to debug issues in production and should be avoided.</pre>

<p>
 I&rsquo;m sure other such quotes about JavaScript best practice can be found.
</p>

<p>
Also, of course, The last initialization step of <a href="http://code.google.com/p/es-lab/source/browse/trunk/src/ses/initSES.js" class="urlextern" target="_blank" title="http://code.google.com/p/es-lab/source/browse/trunk/src/ses/initSES.js" onclick="return svchk()" onkeypress="return svchk()" rel="nofollow">initSES</a> is to freeze the primordials  of its frame. Only code that does not mutate their primordials will be directly compatible with SES without resort to sandboxing. 
</p>
<hr noshade="noshade" size="1" />

<p>
Mark, the original quote from you is visible above, and it asserts &ldquo;many&rdquo;, not &ldquo;any&rdquo;. That is a bold claim. Not only Prototype, but SproutCore and Moo (and probably others), extend standard objects. SproutCore adds a <code>w</code> method to <code>String.prototype</code>, along with many other methods inspired by Ruby.
</p>

<p>
It&rsquo;s nice that Google has recommendations, which it can indeed enforce as mandates on employees, but the Web at large is under no such authority. The Web is the relevant context for quantifying &ldquo;many&rdquo;, not some number of secure subset languages used in far smaller domains. On the Web, it&rsquo;s hard to rule out maintainers and reusers mixing your code with SproutCore, e.g.
</p>

<p>
SES is a different language from Harmony, not standardized by Harmony in full. Goal 5 at <a href="doku.php%3Fid=harmony:harmony.html" class="wikilink1" title="harmony:harmony" onclick="return svchk()" onkeypress="return svchk()">harmony</a> is about supporting SES, not subsuming it.
</p>

<p>
I believe we should avoid trying to run social experiments, building up pedagogical regimes, or making predictions about the future, anywhere in the text of future ECMA-262 editions.
</p>

<p>
 &mdash; <em><a href="mailto:%26%23x62%3B%26%23x72%3B%26%23x65%3B%26%23x6e%3B%26%23x64%3B%26%23x61%3B%26%23x6e%3B%26%23x40%3B%26%23x6d%3B%26%23x6f%3B%26%23x7a%3B%26%23x69%3B%26%23x6c%3B%26%23x6c%3B%26%23x61%3B%26%23x2e%3B%26%23x6f%3B%26%23x72%3B%26%23x67%3B" class="mail" title="&#x62;&#x72;&#x65;&#x6e;&#x64;&#x61;&#x6e;&#x40;&#x6d;&#x6f;&#x7a;&#x69;&#x6c;&#x6c;&#x61;&#x2e;&#x6f;&#x72;&#x67;">Brendan Eich</a> 2011/01/12 02:12</em>
</p>

</div>
<!-- SECTION [11518-15570] -->
<a name="enumeration_and_reflection"></a><h1>Enumeration and Reflection</h1>
<div class="level1">

<p>
 <a href="doku.php%3Fid=strawman:private_names.html#enumeration_and_reflection" class="wikilink1" title="strawman:private_names" onclick="return svchk()" onkeypress="return svchk()">enumeration and reflection</a>
</p>

<p>
Even though soft fields are typically implemented as state within the object they extends, because soft fields are semantically not properties of the object but are rather side tables, they do not show up in reflective operations performed on the object itself.
</p>

<p>
For example: 
</p>
<pre class="code javascript"><span class="kw2">private</span> b;
<span class="kw2">var</span> obj = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
obj.<span class="me1">a</span> = <span class="nu0">1</span>;
obj.<span class="me1">b</span> = <span class="nu0">2</span>;
obj.<span class="me1">c</span> = <span class="nu0">3</span>;
&nbsp;
<span class="kw2">var</span> names = <span class="br0">&#91;</span><span class="br0">&#93;</span>;
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> p <span class="kw1">in</span> obj<span class="br0">&#41;</span> names.<span class="me1">push</span><span class="br0">&#40;</span>obj<span class="br0">&#91;</span>p<span class="br0">&#93;</span><span class="br0">&#41;</span>;
<span class="kw3">print</span><span class="br0">&#40;</span>names.<span class="me1">toString</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;    <span class="co1">// &quot;1,3&quot; -- soft field &quot;b&quot; was not enumerated</span></pre>
<p>
Soft fields created using object literals also not part of the object itself.  So <code>obj</code> could have been created to produce the same result by saying:
</p>
<pre class="code javascript"><span class="kw2">private</span> b;
<span class="kw2">var</span> obj = <span class="br0">&#123;</span>
   a: <span class="nu0">1</span>,
   b: <span class="nu0">2</span>,
   c: <span class="nu0">3</span>
<span class="br0">&#125;</span></pre>
<p>
Beyond the syntactic expansions explained above, no other change to the definition of object literals is needed.
</p>

<p>
Creating a soft field that is enumerable makes no sense. Reflective operations that take property names as arguments, such as Object.defineProperty below, if given a non-string argument including a soft field, would coerce it to string and (uselessly) use that as a property name.
</p>
<pre class="code javascript"><span class="kw2">private</span> b;
<span class="kw2">var</span> obj = <span class="br0">&#123;</span><span class="br0">&#125;</span>;
obj.<span class="me1">a</span> = <span class="nu0">1</span>;
obj.<span class="me1">b</span> = <span class="nu0">2</span>;
Object.<span class="me1">defineProperty</span><span class="br0">&#40;</span>obj, #.<span class="me1">b</span>, <span class="br0">&#123;</span>enumerable: <span class="kw2">true</span><span class="br0">&#125;</span><span class="br0">&#41;</span>;
obj.<span class="me1">c</span> = <span class="nu0">3</span>;
&nbsp;
<span class="kw2">var</span> names = <span class="br0">&#91;</span><span class="br0">&#93;</span>;
<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> p <span class="kw1">in</span> obj<span class="br0">&#41;</span> names.<span class="me1">push</span><span class="br0">&#40;</span>obj<span class="br0">&#91;</span>p<span class="br0">&#93;</span><span class="br0">&#41;</span>;
<span class="kw3">print</span><span class="br0">&#40;</span>names.<span class="me1">toString</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;    <span class="co1">// &quot;1,2,3&quot; -- property &quot;[object Object]&quot; is now enumerated</span></pre>
<p>
<code>Object.prototype.hasOwnProperty</code> (ES5 15.2.4.5), <code>Object.prototype.propertyIsEnumerable</code> (ES5 15.2.4.7) and the <code>in</code> operator (ES5 11.8.7) do not see soft fields, again, because they are not part of the object.
</p>

<p>
The <code>JSON.stringify</code> algorithm (ES5 15.12.3) needs no change in order to ignore soft fields, since again they are not part of the object.
</p>

<p>
All the Object reflection functions defined in ES5 section 15.2.3 remain unchanged, since they need not be aware of soft fields. 
</p>
<table class="inline">
	<tr>
		
	</tr>
	<tr>
		
	</tr>
</table>
<br />

<p>
 An important use case for reflection using soft fields is algorithms that need to perform meta-level processing of all properties of any object.  For example, a &ldquo;universal&rdquo; object copy function might be coded as:
</p>
<pre class="code javascript"><span class="kw2">function</span> copyObject<span class="br0">&#40;</span>obj<span class="br0">&#41;</span> <span class="br0">&#123;</span>
   <span class="co1">// This doesn't deal with other special [[Class]] objects:</span>
   <span class="kw2">var</span> copy = Object.<span class="me1">isArray</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span> ? <span class="br0">&#91;</span><span class="br0">&#93;</span> : Object.<span class="me1">create</span><span class="br0">&#40;</span>Object.<span class="me1">getPrototypeOf</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span><span class="br0">&#41;</span>;
   <span class="kw2">var</span> props = Object.<span class="me1">getOwnPropertyNames</span><span class="br0">&#40;</span>obj<span class="br0">&#41;</span>;
   <span class="kw2">var</span> pname;
   <span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw2">var</span> i = <span class="nu0">0</span>; i &lt; props.<span class="me1">length</span>; i++<span class="br0">&#41;</span> <span class="br0">&#123;</span>
      pname = props<span class="br0">&#91;</span>i<span class="br0">&#93;</span>;
      Object.<span class="me1">defineProperty</span><span class="br0">&#40;</span>copy, pname, Object.<span class="me1">getOwnPropertyDescriptor</span><span class="br0">&#40;</span>obj,pname<span class="br0">&#41;</span><span class="br0">&#41;</span>;
   <span class="br0">&#125;</span>
   <span class="kw1">return</span> obj;
<span class="br0">&#125;</span></pre>
<p>
This function will duplicate all properties but not any soft fields, preserving encapsulation, since neither the definer nor the caller of copyObject knows these soft fields. Of course, a more complex copyObject function could be defined that would also copy and re-index those soft fields it was told of.
</p>

</div>
<!-- SECTION [15571-18979] -->
<a name="soft_fields_support_encapsulation"></a><h1>Soft Fields Support Encapsulation</h1>
<div class="level1">

<p>
 Adapted from <a href="doku.php%3Fid=strawman:private_names.html#private_name_properties_support_only_weak_encapsulation" class="wikilink1" title="strawman:private_names" onclick="return svchk()" onkeypress="return svchk()">private name properties support only weak encapsulation</a>
</p>

<p>
No qualifiers needed.
</p>

<p>
Should so-called &ldquo;weak encapsulation&rdquo; actually be desired, &ldquo;<a href="doku.php%3Fid=strawman:inherited_explicit_soft_fields.html#can_we_subsume_private_names" class="wikilink1" title="strawman:inherited_explicit_soft_fields" onclick="return svchk()" onkeypress="return svchk()">can we subsume private names</a>&rdquo; explains how to provide <em>weakly encapsulating soft fields</em> (or &ldquo;wesf&rdquo;) polymorphically with soft fields.
</p>

</div>
<!-- SECTION [18980-19390] -->
<a name="interactions_with_other_harmony_proposals"></a><h1>Interactions with other Harmony Proposals</h1>
<div class="level1">

</div>
<!-- SECTION [19391-19448] -->
<a name="enhanced_object_literals"></a><h3>Enhanced Object Literals</h3>
<div class="level3">

<p>
 Adapted from <a href="doku.php%3Fid=strawman:private_names.html#enhanced_object_literals" class="wikilink1" title="strawman:private_names" onclick="return svchk()" onkeypress="return svchk()">enhanced object literals</a>
</p>

<p>
<code>private</code> might be supported as either a property modifier keyword that makes the property name a soft field whose private identifier is scoped to the object literal:
</p>
<pre class="code javascript"><span class="kw2">var</span> obj=<span class="br0">&#123;</span>
   <span class="kw2">private</span> _x: <span class="nu0">0</span>;
   get x<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="kw1">this</span>._x<span class="br0">&#125;</span>,
   set x<span class="br0">&#40;</span>val<span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">this</span>._x=val<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
This might simplify the declarative creation of objects with instance private soft fields. However, there are internal scoping and hoisting issues that would need to be considered and resolved.
</p>

<p>
Another alternative is to use meta property syntax to declare object literal local soft field declarations:
</p>
<pre class="code javascript"><span class="kw2">var</span> obj=<span class="br0">&#123;</span>
   &lt;prototype: myProto; <span class="kw2">private</span> _x&gt;
   _x: <span class="nu0">0</span>;
   get x<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> <span class="kw1">this</span>._x<span class="br0">&#125;</span>,
   set x<span class="br0">&#40;</span>val<span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">this</span>._x=val<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
<p>
While the above proposals are perfectly consistent with soft fields, again, for instance-private instance state, using lexical capture seems strictly superior:
</p>
<pre class="code javascript">let x = <span class="nu0">0</span>;
<span class="kw2">var</span> obj=<span class="br0">&#123;</span>
   get x<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="kw1">return</span> x<span class="br0">&#125;</span>,
   set x<span class="br0">&#40;</span>val<span class="br0">&#41;</span> <span class="br0">&#123;</span>x=val<span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>
</div>
<!-- SECTION [19449-20538] -->
<a name="proxies"></a><h3>Proxies</h3>
<div class="level3">

<p>
 Adapted from <a href="doku.php%3Fid=strawman:private_names.html#proxies" class="wikilink1" title="strawman:private_names" onclick="return svchk()" onkeypress="return svchk()">proxies</a>
</p>

<p>
None of the uses of string valued property names in proxy handlers would need to be extended to accept/produce soft fields in addition to string values.
</p>

<p>
As covered above, ECMAScript reflection capabilities provides no means to break the encapsulation of an object&rsquo;s soft fields.
</p>

</div>
<!-- SECTION [20539-20889] -->
<a name="modules"></a><h3>Modules</h3>
<div class="level3">

<p>
 Adapted from <a href="doku.php%3Fid=strawman:private_names.html#modules" class="wikilink1" title="strawman:private_names" onclick="return svchk()" onkeypress="return svchk()">modules</a>
</p>

<p>
It is reasonable to expect that modules will want to define and export soft fields. For example, a module might want to add methods to a built-in prototype object using soft fields and then make those soft fields available to other modules.  Within the present definition of the simple module system that might be done as follows:
</p>
<pre class="code javascript">&lt;script type=<span class="st0">"harmony"</span>&gt;
module ExtendedObject <span class="br0">&#123;</span>
   <span class="kw2">import</span> Builtins.<span class="me1">Object</span>;       <span class="co1">// however access to Object is obtained.</span>
   <span class="kw2">private</span> clone;                <span class="co1">// the soft field for clone methods</span>
   <span class="kw2">export</span> <span class="kw2">const</span> clone = #.<span class="me1">clone</span>; <span class="co1">// export a constant with the soft field;</span>
&nbsp;
   Object.<span class="me1">prototype</span>.<span class="me1">clone</span> = <span class="kw2">function</span> <span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> ... <span class="br0">&#125;</span>;
<span class="br0">&#125;</span>
&lt;/script&gt;</pre>
<p>
A consumer of this module might look like:
</p>
<pre class="code javascript">&lt;script type=<span class="st0">"harmony"</span>&gt;
<span class="kw2">import</span> ExtendedObject.<span class="me1">clone</span>;
<span class="kw2">private</span> clone = clone;
<span class="kw2">var</span> anotherObj = someObj.<span class="me1">clone</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
&lt;/script&gt;</pre>
<p>
The above formulation would work without any additional extensions to the simple module proposal. However, it would be even more convenient if the module system was extended to understand private declarations.  In that case this example might be written as:
</p>
<pre class="code javascript">&lt;script type=<span class="st0">"harmony"</span>&gt;
module ExtendedObject <span class="br0">&#123;</span>
   <span class="kw2">import</span> Builtins.<span class="me1">Object</span>;     <span class="co1">// however access to Object is obtained.</span>
   <span class="kw2">export</span> <span class="kw2">private</span> clone;       <span class="co1">// export soft field for clone methods</span>
&nbsp;
   Object.<span class="me1">prototype</span>.<span class="me1">clone</span> = <span class="kw2">function</span> <span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> ... <span class="br0">&#125;</span>;
<span class="br0">&#125;</span>
&lt;/script&gt;</pre><pre class="code javascript">&lt;script type=<span class="st0">"harmony"</span>&gt;
<span class="kw2">import</span> <span class="kw2">private</span> ExtendedObject.<span class="me1">clone</span>;
<span class="kw2">var</span> anotherObj = someObj.<span class="me1">clone</span><span class="br0">&#40;</span><span class="br0">&#41;</span>;
&lt;/script&gt;</pre>
<p>
I don&rsquo;t get the point about &ldquo;dynamic access to the exported property name environment of first-class module instances&rdquo;, so at this time I offer no comparison of this last example.
</p>

</div>
<!-- SECTION [20890-22689] -->
<a name="references"></a><h1>References</h1>
<div class="level1">

<p>
 Adapted from <a href="doku.php%3Fid=strawman:private_names.html#references" class="wikilink1" title="strawman:private_names" onclick="return svchk()" onkeypress="return svchk()">references</a>
</p>

<p>
Any unforgeable reference to a tamper-proof encapsulated object is analogous to a capability in object-capability languages. In this degenerate sense, both Names and Soft Fields are also so analogous. I see no further way in which Names are analogous. In addition, Soft Fields encourage encapsulation friendly patterns, whereas Names encourage unsafe (or &ldquo;weakly encapsulated&rdquo;) patterns.
</p>

</div>
<!-- SECTION [22690-] -->
<!-- cachefile /usr/local/www/es-lang.org/wiki/data/cache/7/7dc43bcc4f408b9e589a71772313d9cd.xhtml used -->
</body>
</html>
